/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.tz;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;import java.util.Set;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeZone;/** * This class is a JUnit test for UTCProvider. * * @author Stephen Colebourne */public class TestUTCProvider extends TestCase {    private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestUTCProvider.class);    }    public TestUTCProvider(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testClass() throws Exception {        Class cls = UTCProvider.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isPublic(con.getModifiers()));    }    //-----------------------------------------------------------------------    public void testGetAvailableIDs() throws Exception {        Provider p = new UTCProvider();        Set set = p.getAvailableIDs();        assertEquals(1, set.size());        assertEquals("UTC", set.iterator().next());    }    //-----------------------------------------------------------------------    public void testGetZone_String() throws Exception {        Provider p = new UTCProvider();        assertSame(DateTimeZone.UTC, p.getZone("UTC"));        assertEquals(null, p.getZone(null));        assertEquals(null, p.getZone("Europe/London"));        assertEquals(null, p.getZone("Blah"));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.tz;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestUTCProvider.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.ReadablePeriod;import org.joda.time.Period;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadablePeriodConverter. * * @author Stephen Colebourne */public class TestReadablePeriodConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadablePeriodConverter.class);    }    public TestReadablePeriodConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadablePeriodConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadablePeriod.class, ReadablePeriodConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetPeriodMillis_Object() throws Exception {        assertEquals(123L, ReadablePeriodConverter.INSTANCE.getDurationMillis(new Period(123L)));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.getAllType(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L), false));        assertEquals(PeriodType.getPreciseAllType(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L), true));        assertEquals(PeriodType.getPreciseAllType(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.getAllType()), true));        assertEquals(PeriodType.getPreciseYearDayType(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.getPreciseYearDayType()), true));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());        ReadablePeriodConverter.INSTANCE.setInto(m, new Period(0, 0, 0, 3, 0, 4, 0, 5));        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(0, m.getHours());        assertEquals(4, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(5, m.getMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadablePeriod]", ReadablePeriodConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.Interval;import org.joda.time.MutablePeriod;import org.joda.time.MutableInterval;import org.joda.time.ReadableInterval;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a JUnit test for ReadableIntervalConverter. * * @author Stephen Colebourne */public class TestReadableIntervalConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableIntervalConverter.class);    }    public TestReadableIntervalConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableIntervalConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableInterval.class, ReadableIntervalConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        Interval i = new Interval(100L, 223L);        assertEquals(123L, ReadableIntervalConverter.INSTANCE.getDurationMillis(i));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        Interval i = new Interval(100L, 223L);        assertEquals(PeriodType.getAllType(),            ReadableIntervalConverter.INSTANCE.getPeriodType(i, false));        assertEquals(PeriodType.getPreciseAllType(),            ReadableIntervalConverter.INSTANCE.getPeriodType(i, true));    }    public void testSetIntoPeriod_Object() throws Exception {        Interval i = new Interval(100L, 223L);        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());        ReadableIntervalConverter.INSTANCE.setInto(m, i);        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(0, m.getDays());        assertEquals(0, m.getHours());        assertEquals(0, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(123, m.getMillis());    }    //-----------------------------------------------------------------------    public void testGetIntervalMillis_Object() throws Exception {        Interval i = new Interval(1234L, 5678L);        long[] data = ReadableIntervalConverter.INSTANCE.getIntervalMillis(i);        assertEquals(1234L, data[0]);        assertEquals(5678L, data[1]);    }    public void testSetIntoInterval_Object() throws Exception {        Interval i = new Interval(0L, 123L);        MutableInterval m = new MutableInterval(-1000L, 1000L);        ReadableIntervalConverter.INSTANCE.setInto(m, i);        assertEquals(0L, m.getStartMillis());        assertEquals(123L, m.getEndMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableInterval]", ReadableIntervalConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeZone;import org.joda.time.Duration;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.ReadableDuration;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadableDurationConverter. * * @author Stephen Colebourne */public class TestReadableDurationConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableDurationConverter.class);    }    public TestReadableDurationConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableDurationConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableDuration.class, ReadableDurationConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(123L)));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.getPreciseAllType(),            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L), false));        assertEquals(PeriodType.getPreciseAllType(),            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L), true));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());        ReadableDurationConverter.INSTANCE.setInto(m, new Duration(            3L * DateTimeConstants.MILLIS_PER_DAY +            4L * DateTimeConstants.MILLIS_PER_MINUTE + 5L        ));        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(0, m.getDays());        assertEquals(3 * 24, m.getHours());        assertEquals(4, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(5, m.getMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableDuration]", ReadableDurationConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for NullConverter. * * @author Stephen Colebourne */public class TestNullConverter extends TestCase {    private long TEST_TIME_NOW =            20 * DateTimeConstants.MILLIS_PER_DAY            + 10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestNullConverter.class);    }    public TestNullConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = NullConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(null, NullConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, PARIS));        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, JULIAN));        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, NullConverter.INSTANCE.getChronology(null, PARIS));        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, NullConverter.INSTANCE.getChronology(null, JULIAN));        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(0L, NullConverter.INSTANCE.getDurationMillis(null));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.getAllType(),            NullConverter.INSTANCE.getPeriodType(null, false));        assertEquals(PeriodType.getPreciseAllType(),            NullConverter.INSTANCE.getPeriodType(null, true));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());        NullConverter.INSTANCE.setInto(m, null);        assertEquals(0L, m.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[null]", NullConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for CalendarConverter. * * @author Stephen Colebourne */public class TestCalendarConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone MOSCOW = DateTimeZone.getInstance("Europe/Moscow");    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO = ISOChronology.getInstance();        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestCalendarConverter.class);    }    public TestCalendarConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = CalendarConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Calendar.class, CalendarConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(123L));        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(123L));        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, PARIS));        assertEquals(123L, cal.getTime().getTime());        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (DateTimeZone) null));        assertEquals(123L, cal.getTime().getTime());    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(123L));        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN));        assertEquals(123L, cal.getTime().getTime());        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (Chronology) null));        assertEquals(123L, cal.getTime().getTime());    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(GJChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(0L));        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MAX_VALUE));        assertEquals(JulianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MIN_VALUE));        assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(new MockUnknownTimeZone());        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal));                Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc));                try {            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            assertEquals(BuddhistChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(bc));        } catch (ClassNotFoundException ex) {            // ignore        }    }    public void testGetChronology_Object_Zone() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(GJChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (DateTimeZone) null));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(0L));        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MAX_VALUE));        assertEquals(JulianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MIN_VALUE));        assertEquals(GregorianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));                Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(ISOChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(uc, PARIS));                try {            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            assertEquals(BuddhistChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(bc, PARIS));        } catch (ClassNotFoundException ex) {            // ignore        }    }    public void testGetChronology_Object_Chronology() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(JULIAN, CalendarConverter.INSTANCE.getChronology(cal, JULIAN));        assertEquals(ISO, CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.util.Calendar]", CalendarConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.Instant;import org.joda.time.ReadableInstant;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadableInstantConverter. * * @author Stephen Colebourne */public class TestReadableInstantConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableInstantConverter.class);    }    public TestReadableInstantConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableInstantConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableInstant.class, ReadableInstantConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L)));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L)));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), PARIS));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), PARIS));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (DateTimeZone) null));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), JULIAN));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), JULIAN));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (Chronology) null));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L)));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L)));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), PARIS));        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (DateTimeZone) null));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (DateTimeZone) null));                assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L, new MockBadChronology()), PARIS));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), JULIAN));        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), JULIAN));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (Chronology) null));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableInstant]", ReadableInstantConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestConverterManager.suite());        suite.addTest(TestConverterSet.suite());                suite.addTest(TestCalendarConverter.suite());        suite.addTest(TestDateConverter.suite());        suite.addTest(TestLongConverter.suite());        suite.addTest(TestNullConverter.suite());        suite.addTest(TestReadableDurationConverter.suite());        suite.addTest(TestReadableIntervalConverter.suite());        suite.addTest(TestReadableInstantConverter.suite());        suite.addTest(TestReadablePeriodConverter.suite());        suite.addTest(TestStringConverter.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.MutableInterval;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for StringConverter. * * @author Stephen Colebourne */public class TestStringConverter extends TestCase {    private static final DateTimeZone ONE_HOUR = DateTimeZone.getInstance("+01:00");    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestStringConverter.class);    }    public TestStringConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = StringConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(String.class, StringConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00"));                dt = new DateTime(2004, 1, 1, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004T+01:00"));                dt = new DateTime(2004, 6, 1, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06T+01:00"));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T+01:00"));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-161T+01:00"));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24-3T+01:00"));                dt = new DateTime(2004, 6, 7, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24T+01:00"));                dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48+01:00"));                dt = new DateTime(2004, 6, 9, 12, 30, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12.5+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 30, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24.5+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.5+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501"));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+02:00", PARIS));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", (DateTimeZone) null));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", PARIS));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, JulianChronology.getInstance(LONDON));        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", JULIAN));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, ISOChronology.getInstance(LONDON));        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", (Chronology) null));    }    public void testGetInstantMillisInvalid() {        try {            StringConverter.INSTANCE.getInstantMillis("");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getInstantMillis("X");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00"));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501"));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", PARIS));        assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", PARIS));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (DateTimeZone) null));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", JULIAN));        assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", JULIAN));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (Chronology) null));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetDateTime() throws Exception {        DateTime base = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        DateTime test = new DateTime(base.toString(), PARIS);        assertEquals(base, test);    }    public void testGetDateTime1() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+01:00");        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(LONDON, test.getZone());    }    public void testGetDateTime2() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501");        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(LONDON, test.getZone());    }    public void testGetDateTime3() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", PARIS);        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime4() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501", PARIS);        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime5() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", JulianChronology.getInstance(PARIS));        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime6() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501", JulianChronology.getInstance(PARIS));        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        long millis = StringConverter.INSTANCE.getDurationMillis("P2Y6M9D");        long len = (2L * 365L + 6L * 30L + 9L) * DateTimeConstants.MILLIS_PER_DAY;        assertEquals(len, millis);    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.getAllType(),            StringConverter.INSTANCE.getPeriodType("P2Y6M9D", false));        assertEquals(PeriodType.getPreciseAllType(),            StringConverter.INSTANCE.getPeriodType("P2Y6M9D", true));    }    public void testSetIntoPeriod_Object1() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());        StringConverter.INSTANCE.setInto(m, "P2Y6M9DT12H24M48S");        assertEquals(2, m.getYears());        assertEquals(6, m.getMonths());        assertEquals(9, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(48, m.getSeconds());        assertEquals(0, m.getMillis());    }    public void testSetIntoPeriod_Object2() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.getYearWeekType());        StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48S");        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(48, m.getSeconds());        assertEquals(0, m.getMillis());    }            public void testSetIntoPeriod_Object3() throws Exception {        MutablePeriod m = new MutablePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.getYearWeekType());        StringConverter.INSTANCE.setInto(m, "P2Y4W3D");        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(0, m.getHours());        assertEquals(0, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(0, m.getMillis());    }            public void testSetIntoPeriod_Object4() throws Exception {        MutablePeriod m = new MutablePeriod();        try {            StringConverter.INSTANCE.setInto(m, "");            fail();        } catch (IllegalArgumentException ex) {}                try {            StringConverter.INSTANCE.setInto(m, "PXY");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetIntervalMillis_Object() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        long[] data = StringConverter.INSTANCE.getIntervalMillis("2004-06-09/P1Y2M");        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).getMillis(), data[0]);        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0).getMillis(), data[1]);    }    public void testSetIntoInterval_Object1() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2004-06-09/P1Y2M");        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());    }    public void testSetIntoInterval_Object2() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "P1Y2M/2004-06-09");        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());    }    public void testSetIntoInterval_Object3() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2003-08-09/2004-06-09");        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());    }    public void testSetIntoIntervalEx_Object1() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object2() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "/");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object3() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "P1Y/");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object4() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "/P1Y");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object5() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "P1Y/P2Y");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.lang.String]", StringConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.Duration;import org.joda.time.ReadablePeriod;import org.joda.time.Period;import org.joda.time.PeriodType;import org.joda.time.Interval;import org.joda.time.JodaTimePermission;import org.joda.time.ReadWritablePeriod;import org.joda.time.ReadWritableInterval;import org.joda.time.ReadableDateTime;import org.joda.time.ReadableDuration;import org.joda.time.ReadableInstant;import org.joda.time.ReadableInterval;/** * This class is a JUnit test for ConverterManager. * * @author Stephen Colebourne */public class TestConverterManager extends TestCase {    private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestConverterManager.class);    }    public TestConverterManager(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ConverterManager.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(true, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testGetInstantConverter() {        InstantConverter c = ConverterManager.getInstance().getInstantConverter(new Long(0L));        assertEquals(Long.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new DateTime());        assertEquals(ReadableInstant.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new Date());        assertEquals(Date.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new GregorianCalendar());        assertEquals(Calendar.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getInstantConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetInstantConverterRemovedNull() {        try {            ConverterManager.getInstance().removeInstantConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getInstantConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addInstantConverter(NullConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testGetInstantConverterOKMultipleMatches() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return ReadableDateTime.class;}        };        try {            ConverterManager.getInstance().addInstantConverter(c);            InstantConverter ok = ConverterManager.getInstance().getInstantConverter(new DateTime());            // ReadableDateTime and ReadableInstant both match, but RI discarded as less specific            assertEquals(ReadableDateTime.class, ok.getSupportedType());        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testGetInstantConverterBadMultipleMatches() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Serializable.class;}        };        try {            ConverterManager.getInstance().addInstantConverter(c);            try {                ConverterManager.getInstance().getInstantConverter(new DateTime());                fail();            } catch (IllegalStateException ex) {                // Serializable and ReadableInstant both match, so cannot pick            }        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    public void testGetInstantConverters() {        InstantConverter[] array = ConverterManager.getInstance().getInstantConverters();        assertEquals(6, array.length);    }    //-----------------------------------------------------------------------    public void testAddInstantConverter1() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        try {            InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getInstantConverter(Boolean.TRUE).getSupportedType());            assertEquals(7, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter2() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return String.class;}        };        try {            InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getInstantConverter("").getSupportedType());            assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter3() {        InstantConverter removed = ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter4() {        InstantConverter removed = ConverterManager.getInstance().addInstantConverter(null);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveInstantConverter1() {        try {            InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(5, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverter2() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(c);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverter3() {        InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(null);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int DURATION_SIZE = 6;        public void testGetDurationConverter() {        DurationConverter c = ConverterManager.getInstance().getDurationConverter(new Long(0L));        assertEquals(Long.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(new Duration(123L));        assertEquals(ReadableDuration.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8));        assertEquals(ReadablePeriod.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getDurationConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetDurationConverterRemovedNull() {        try {            ConverterManager.getInstance().removeDurationConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getDurationConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addDurationConverter(NullConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    public void testGetDurationConverters() {        DurationConverter[] array = ConverterManager.getInstance().getDurationConverters();        assertEquals(DURATION_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddDurationConverter1() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return Boolean.class;}        };        try {            DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getDurationConverter(Boolean.TRUE).getSupportedType());            assertEquals(DURATION_SIZE + 1, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().removeDurationConverter(c);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverter2() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return String.class;}        };        try {            DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getDurationConverter("").getSupportedType());            assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverter3() {        DurationConverter removed = ConverterManager.getInstance().addDurationConverter(null);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveDurationConverter1() {        try {            DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(DURATION_SIZE - 1, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverter2() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return Boolean.class;}        };        DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(c);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverter3() {        DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(null);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int PERIOD_SIZE = 5;        public void testGetPeriodConverter() {        PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8));        assertEquals(ReadablePeriod.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(new Duration(123L));        assertEquals(ReadableDuration.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetPeriodConverterRemovedNull() {        try {            ConverterManager.getInstance().removePeriodConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getPeriodConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addPeriodConverter(NullConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    public void testGetPeriodConverters() {        PeriodConverter[] array = ConverterManager.getInstance().getPeriodConverters();        assertEquals(PERIOD_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddPeriodConverter1() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object) {}            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        try {            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE).getSupportedType());            assertEquals(PERIOD_SIZE + 1, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().removePeriodConverter(c);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverter2() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object) {}            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}            public Class getSupportedType() {return String.class;}        };        try {            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getPeriodConverter("").getSupportedType());            assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverter3() {        PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(null);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    public void testRemovePeriodConverter1() {        try {            PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(PERIOD_SIZE - 1, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverter2() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object) {}            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(c);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverter3() {        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(null);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void testGetIntervalConverter() {        IntervalConverter c = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getIntervalConverter("");        assertEquals(String.class, c.getSupportedType());                try {            ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}        try {            ConverterManager.getInstance().getIntervalConverter(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetIntervalConverters() {        IntervalConverter[] array = ConverterManager.getInstance().getIntervalConverters();        assertEquals(2, array.length);    }    //-----------------------------------------------------------------------    public void testAddIntervalConverter1() {        IntervalConverter c = new IntervalConverter() {            public long[] getIntervalMillis(Object object) {return null;}            public void setInto(ReadWritableInterval interval, Object object) {}            public Class getSupportedType() {return Boolean.class;}        };        try {            IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE).getSupportedType());            assertEquals(3, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().removeIntervalConverter(c);        }        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverter2() {        IntervalConverter c = new IntervalConverter() {            public long[] getIntervalMillis(Object object) {return null;}            public void setInto(ReadWritableInterval interval, Object object) {}            public Class getSupportedType() {return String.class;}        };        try {            IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getIntervalConverter("").getSupportedType());            assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);        }        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverter3() {        IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(null);        assertEquals(null, removed);        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveIntervalConverter1() {        try {            IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(1, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);        }        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverter2() {        IntervalConverter c = new IntervalConverter() {            public long[] getIntervalMillis(Object object) {return null;}            public void setInto(ReadWritableInterval interval, Object object) {}            public Class getSupportedType() {return Boolean.class;}        };        IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(c);        assertEquals(null, removed);        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverter3() {        IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(null);        assertEquals(null, removed);        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(2, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("ConverterManager[6 instant,6 duration,5 period,2 interval]", ConverterManager.getInstance().toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;import java.util.Calendar;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateMidnight;import org.joda.time.DateTime;import org.joda.time.ReadWritableDateTime;import org.joda.time.ReadWritableInstant;import org.joda.time.ReadableDateTime;import org.joda.time.ReadableInstant;/** * This class is a JUnit test for ConverterSet. * Mostly for coverage. * * @author Stephen Colebourne */public class TestConverterSet extends TestCase {    private static final Converter c1 = new Converter() {        public Class getSupportedType() {return Boolean.class;}    };    private static final Converter c2 = new Converter() {        public Class getSupportedType() {return Character.class;}    };    private static final Converter c3 = new Converter() {        public Class getSupportedType() {return Byte.class;}    };    private static final Converter c4 = new Converter() {        public Class getSupportedType() {return Short.class;}    };    private static final Converter c4a = new Converter() {        public Class getSupportedType() {return Short.class;}    };    private static final Converter c5 = new Converter() {        public Class getSupportedType() {return Integer.class;}    };        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestConverterSet.class);    }    public TestConverterSet(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testClass() throws Exception {        Class cls = ConverterSet.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                assertEquals(1, cls.getDeclaredConstructors().length);        Constructor con = cls.getDeclaredConstructors()[0];        assertEquals(false, Modifier.isPublic(con.getModifiers()));        assertEquals(false, Modifier.isProtected(con.getModifiers()));        assertEquals(false, Modifier.isPrivate(con.getModifiers()));    }    //-----------------------------------------------------------------------    public void testBigHashtable() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        set.select(Boolean.class);        set.select(Character.class);        set.select(Byte.class);        set.select(Short.class);        set.select(Integer.class);        set.select(Long.class);        set.select(Float.class);        set.select(Double.class);        set.select(null);        set.select(Calendar.class);        set.select(GregorianCalendar.class);        set.select(DateTime.class);        set.select(DateMidnight.class);        set.select(ReadableInstant.class);        set.select(ReadableDateTime.class);        set.select(ReadWritableInstant.class);  // 16        set.select(ReadWritableDateTime.class);        set.select(DateTime.class);        assertEquals(4, set.size());    }    //-----------------------------------------------------------------------    public void testAddNullRemoved1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c5, null);        assertEquals(4, set.size());        assertEquals(5, result.size());    }    public void testAddNullRemoved2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c4, null);        assertSame(set, result);    }    public void testAddNullRemoved3() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c4a, null);        assertTrue(set != result);        assertEquals(4, set.size());        assertEquals(4, result.size());    }    //-----------------------------------------------------------------------    public void testRemoveNullRemoved1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.remove(c3, null);        assertEquals(4, set.size());        assertEquals(3, result.size());    }    public void testRemoveNullRemoved2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.remove(c5, null);        assertSame(set, result);    }    //-----------------------------------------------------------------------    public void testRemoveBadIndex1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        try {            set.remove(200, null);            fail();        } catch (IndexOutOfBoundsException ex) {}        assertEquals(4, set.size());    }    public void testRemoveBadIndex2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        try {            set.remove(-1, null);            fail();        } catch (IndexOutOfBoundsException ex) {}        assertEquals(4, set.size());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Date;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for DateConverter. * * @author Stephen Colebourne */public class TestDateConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateConverter.class);    }    public TestDateConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = DateConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Date.class, DateConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L)));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), PARIS));        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), JULIAN));        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L)));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, DateConverter.INSTANCE.getChronology(new Date(123L), PARIS));        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, DateConverter.INSTANCE.getChronology(new Date(123L), JULIAN));        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.util.Date]", DateConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for LongConverter. * * @author Stephen Colebourne */public class TestLongConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestLongConverter.class);    }    public TestLongConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = LongConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Long.class, LongConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L)));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), PARIS));        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), JULIAN));        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L)));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, LongConverter.INSTANCE.getChronology(new Long(123L), PARIS));        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, LongConverter.INSTANCE.getChronology(new Long(123L), JULIAN));        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getDurationMillis(new Long(123L)));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.getAllType(),            LongConverter.INSTANCE.getPeriodType(new Long(123L), false));        assertEquals(PeriodType.getPreciseAllType(),            LongConverter.INSTANCE.getPeriodType(new Long(123L), true));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());        LongConverter.INSTANCE.setInto(m, new Long(123L));        assertEquals(123L, m.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.lang.Long]", LongConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import java.util.Random;import junit.framework.TestCase;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeField;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.JulianChronology;/** * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj * against the implementations in this package. It tests all the date fields * against their principal methods. * <p> * Randomly generated values are fed into the DateTimeField methods and the * results are compared between the two chronologies. If any result doesn't * match, an error report is generated and the program exits. Each time this * test program is run, the pseudo random number generator is seeded with the * same value. This ensures consistent results between test runs. * <p> * The main method accepts three optional arguments: iterations, mode, seed. By * default, iterations is set to 1,000,000. The test will take several minutes * to run, depending on the computer's performance. Every 5 seconds a progress * message is printed. * <p> * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for * proleptic julian. To override the default random number generator seed, pass * in a third argument which accepts a long signed integer. * * @author Brian S O'Neill */public class MainTest extends TestCase {    public static final int GREGORIAN_MODE = 0;    public static final int JULIAN_MODE = 1;    private static final long MILLIS_PER_YEAR = (long)365.2425 * 24 * 60 * 60 * 1000;    private static final long _1000_YEARS = 1000 * MILLIS_PER_YEAR;    private static final long _500_YEARS = 500 * MILLIS_PER_YEAR;    private static final long MAX_MILLIS = (10000 - 1970) * MILLIS_PER_YEAR;    private static final long MIN_MILLIS = (-10000 - 1970) * MILLIS_PER_YEAR;    // Show progess reports every 5 seconds.    private static final long UPDATE_INTERVAL = 5000;    /**     * Arguments: iterations [mode [seed]]     */    public static void main(String[] args) throws Exception {        int iterations = 1000000;        int mode = GREGORIAN_MODE;        long seed = 1345435247779935L;        if (args.length > 0) {            iterations = Integer.parseInt(args[0]);            if (args.length > 1) {                if (args[1].startsWith("g")) {                    mode = GREGORIAN_MODE;                } else if (args[1].startsWith("j")) {                    mode = JULIAN_MODE;                } else {                    throw new IllegalArgumentException                        ("Unknown mode: " + args[1]);                }                if (args.length > 2) {                    seed = Long.parseLong(args[2]);                }            }        }        new MainTest(iterations, mode, seed).testChronology();    }    //-----------------------------------------------------------------------    private final int iIterations;    private final int iMode;    private final long iSeed;    private final Chronology iTest;    private final Chronology iActual;    /**     * @param iterations number of test iterations to perform     * @param mode GREGORIAN_MODE or JULIAN_MODE,0=Gregorian, 1=Julian     * @param seed seed for random number generator     */    public MainTest(int iterations, int mode, long seed) {        super("testChronology");        iIterations = iterations;        iMode = mode;        iSeed = seed;        if (mode == GREGORIAN_MODE) {            iTest = new TestGregorianChronology();            iActual = GregorianChronology.getInstanceUTC();        } else {            iTest = new TestJulianChronology();            iActual = JulianChronology.getInstanceUTC();        }    }    //-----------------------------------------------------------------------    /**     * Main junit test     */    public void testChronology() {        int iterations = iIterations;        long seed = iSeed;        String modeStr;        if (iMode == GREGORIAN_MODE) {            modeStr = "Gregorian";        } else {            modeStr = "Julian";        }        System.out.println("Testing " + modeStr + " chronology over " + iterations + " iterations");        Random rnd = new Random(seed);        long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;        for (int i=0; i<iterations; i++) {            long now = System.currentTimeMillis();            if (now >= updateMillis) {                updateMillis = now + UPDATE_INTERVAL;                double complete = ((int)((double)i / iterations * 1000.0)) / 10d;                if (complete < 100) {                    System.out.println("" + complete + "% complete (i=" + i + ")");                }            }            long millis = randomMillis(rnd);            int value = rnd.nextInt(200) - 100;            // millis2 is used for difference tests.            long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;            try {                testFields(millis, value, millis2);            } catch (RuntimeException e) {                System.out.println("Failure index: " + i);                System.out.println("Test millis: " + millis);                System.out.println("Test value: " + value);                System.out.println("Test millis2: " + millis2);                fail(e.getMessage());            }        }        System.out.println("100% complete (i=" + iterations + ")");    }    //-----------------------------------------------------------------------    private void testFields(long millis, int value, long millis2) {        testField(iTest.year(), iActual.year(), millis, value, millis2);        testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);        testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);        testField(iTest.weekyear(), iActual.weekyear(), millis, value, millis2);        testField(iTest.weekOfWeekyear(),                  iActual.weekOfWeekyear(), millis, value, millis2);        testField(iTest.dayOfWeek(), iActual.dayOfWeek(), millis, value, millis2);        testField(iTest.dayOfYear(), iActual.dayOfYear(), millis, value, millis2);    }    private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,                           int value, long millis2)    {        int a, b;        long x, y;        boolean m, n;        // get test        a = fieldA.get(millis);        b = fieldB.get(millis);        testValue(fieldA, fieldB, "get", millis, a, b);        // getMaximumValue test        // Restrict this test to the fields that matter.        Class fieldClass = fieldA.getClass();        if (fieldClass == TestGJDayOfYearField.class ||            fieldClass == TestGJDayOfMonthField.class ||            fieldClass == TestGJWeekOfWeekyearField.class) {                        a = fieldA.getMaximumValue(millis);            b = fieldB.getMaximumValue(millis);            testValue(fieldA, fieldB, "getMaximumValue", millis, a, b);        }        // set test        a = getWrappedValue            (value, fieldA.getMinimumValue(millis), fieldA.getMaximumValue(millis));        b = getWrappedValue            (value, fieldB.getMinimumValue(millis), fieldB.getMaximumValue(millis));        if (iMode == JULIAN_MODE && a == 0            && (fieldA.getName().equals("year") || fieldA.getName().equals("weekyear"))) {            // Exclude setting Julian year of zero.        } else {            x = fieldA.set(millis, a);            y = fieldB.set(millis, b);            testMillis(fieldA, fieldB, "set", millis, x, y, a, b);        }        // roundFloor test        x = fieldA.roundFloor(millis);        y = fieldB.roundFloor(millis);        testMillis(fieldA, fieldB, "roundFloor", millis, x, y);        // roundCeiling test        x = fieldA.roundCeiling(millis);        y = fieldB.roundCeiling(millis);        testMillis(fieldA, fieldB, "roundCeiling", millis, x, y);        // roundHalfFloor test        x = fieldA.roundHalfFloor(millis);        y = fieldB.roundHalfFloor(millis);        testMillis(fieldA, fieldB, "roundHalfFloor", millis, x, y);        // roundHalfEven test        x = fieldA.roundHalfEven(millis);        y = fieldB.roundHalfEven(millis);        testMillis(fieldA, fieldB, "roundHalfEven", millis, x, y);        // remainder test        x = fieldA.remainder(millis);        y = fieldB.remainder(millis);        testMillis(fieldA, fieldB, "remainder", millis, x, y);        // add test        x = fieldA.add(millis, value);        y = fieldB.add(millis, value);        testMillis(fieldA, fieldB, "add", millis, x, y);        // addWrapField test        x = fieldA.addWrapField(millis, value);        y = fieldB.addWrapField(millis, value);        testMillis(fieldA, fieldB, "addWrapField", millis, x, y);        // getDifference test        x = fieldA.getDifference(millis, millis2);        y = fieldB.getDifference(millis, millis2);        try {            testValue(fieldA, fieldB, "getDifference", millis, x, y);        } catch (RuntimeException e) {            System.out.println("Test datetime 2: " + makeDatetime(millis2));            throw e;        }        // isLeap test        m = fieldA.isLeap(millis);        n = fieldB.isLeap(millis);        testBoolean(fieldA, fieldB, "isLeap", millis, m, n);        // getLeapAmount test        a = fieldA.getLeapAmount(millis);        b = fieldB.getLeapAmount(millis);        testValue(fieldA, fieldB, "getLeapAmount", millis, a, b);    }    private int getWrappedValue(int value, int minValue, int maxValue) {        if (minValue >= maxValue) {            throw new IllegalArgumentException("MIN > MAX");        }        int wrapRange = maxValue - minValue + 1;        value -= minValue;        if (value >= 0) {            return (value % wrapRange) + minValue;        }        int remByRange = (-value) % wrapRange;        if (remByRange == 0) {            return 0 + minValue;        }        return (wrapRange - remByRange) + minValue;    }    private void testValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        if (valueA != valueB) {            failValue(fieldA, fieldB, method, millis, valueA, valueB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB, valueA, valueB);        }    }    private void testBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        if (boolA != boolB) {            failBoolean(fieldA, fieldB, method, millis, boolA, boolB);        }    }    private void failValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(valueA + " != " + valueB);        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        System.out.println("Value to set for first field: " + valueA);        System.out.println("Value to set for second field: " + valueB);        throw new RuntimeException();    }    private void failBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(boolA + " != " + boolB);        throw new RuntimeException();    }    private String makeName(DateTimeField fieldA, DateTimeField fieldB) {        if (fieldA.getName().equals(fieldB.getName())) {            return fieldA.getName();        } else {            return fieldA.getName() + "/" + fieldB.getName();        }    }    private String makeDatetime(long millis) {        return makeDatetime(millis, iActual);    }    private String makeDatetime(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString() + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }    private String makeDate(long millis) {        return makeDate(millis, iActual);    }    private String makeDate(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString("yyyy-MM-dd") + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }    //-----------------------------------------------------------------------    private static long randomMillis(Random rnd) {        long millis = rnd.nextLong();        if (millis >= 0) {            millis = millis % MAX_MILLIS;        } else {            millis = millis % -MIN_MILLIS;        }        return millis;    }    private static void dump(Chronology chrono, long millis) {        System.out.println("year:           " + chrono.year().get(millis));        System.out.println("monthOfYear:    " + chrono.monthOfYear().get(millis));        System.out.println("dayOfMonth:     " + chrono.dayOfMonth().get(millis));        System.out.println("weekyear:       " + chrono.weekyear().get(millis));        System.out.println("weekOfWeekyear: " + chrono.weekOfWeekyear().get(millis));        System.out.println("dayOfWeek:      " + chrono.dayOfWeek().get(millis));        System.out.println("dayOfYear:      " + chrono.dayOfYear().get(millis));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianMonthOfYearField extends TestGJMonthOfYearField {    public TestJulianMonthOfYearField(TestJulianChronology chrono) {        super(chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long add(long millis, long value) {        int year = iChronology.year().get(millis);        int newYear = year + (int)iChronology.div(value, 12);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        int newMonth = get(millis) + (int)iChronology.mod(value, 12);        if (newMonth > 12) {            if (newYear == -1) {                newYear = 1;            } else {                newYear++;            }            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;import org.joda.time.DurationField;import org.joda.time.chrono.AbstractChronology;/** * A reference Gregorian/Julian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * <p>In theory, this class can be used to test any other Gregorian/Julian * chronology as long as almost all datetime fields are implemented differently * between the two. Fields that would most likely be implemented the same are * not supported by this class. * * <p>Unsupported features * <ul> * <li>time zones * <li>time of day * <li>year of era * <li>year of century * <li>century of era * <li>era * </ul> * * @author Brian S O'Neill */abstract class TestGJChronology extends AbstractChronology {    static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;    /**     * Divide with round-negative behavior.     *     * @param divisor must be positive     */    static long div(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend / divisor;        } else {            return (dividend + 1) / divisor - 1;        }    }    /**     * Modulus with round-negative behavior, result is always positive.     *     * @param divisor must be positive     */    static long mod(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend % divisor;        } else {            return (dividend + 1) % divisor - 1 + divisor;        }    }    static long amod(long dividend, long divisor) {        long mod = mod(dividend, divisor);        return (mod == 0) ? divisor : mod;    }    /** Milliseconds from 0001-01-01 to the epoch. */    private final long iEpochMillis;    public TestGJChronology(int epochYear, int epochMonth, int epochDay) {        iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;    }    public DateTimeZone getZone() {        return null;    }    public Chronology withUTC() {        return this;    }    /**     * Unsupported.     */    public Chronology withZone(DateTimeZone zone) {        throw new UnsupportedOperationException();    }    long getTimeOnlyMillis(long millis) {        return mod(millis, MILLIS_PER_DAY);    }    long getDateOnlyMillis(long millis) {        return millis - mod(millis, MILLIS_PER_DAY);    }    public DurationField days() {        return dayOfWeek().getDurationField();    }    public DateTimeField dayOfWeek() {        return new TestGJDayOfWeekField(this);    }    public DateTimeField dayOfMonth() {        return new TestGJDayOfMonthField(this);     }    public DateTimeField dayOfYear() {        return new TestGJDayOfYearField(this);    }    public DurationField weeks() {        return weekOfWeekyear().getDurationField();    }    public DateTimeField weekOfWeekyear() {        return new TestGJWeekOfWeekyearField(this);    }    public DurationField weekyears() {        return weekyear().getDurationField();    }    public DateTimeField weekyear() {        return new TestGJWeekyearField(this);    }    public DurationField months() {        return monthOfYear().getDurationField();    }    public DateTimeField monthOfYear() {        return new TestGJMonthOfYearField(this);    }    public DurationField years() {        return year().getDurationField();    }    public DateTimeField year() {        return new TestGJYearField(this);    }    abstract long millisPerYear();    abstract long millisPerMonth();    abstract boolean isLeapYear(int year);    /**     * @return days from 0001-01-01     */    abstract long fixedFromGJ(int year, int monthOfYear, int dayOfMonth);    /**     * @param date days from 0001-01-01     * @return gj year     */    abstract int gjYearFromFixed(long date);    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    abstract int[] gjFromFixed(long date);    abstract long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek);    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    abstract int[] isoFromFixed(long date);    /**     * @param millis milliseconds from epoch     * @return days from 0001-01-01     */    long fixedFromMillis(long millis) {        return div(millis + iEpochMillis, MILLIS_PER_DAY);    }    /**     * @param fixed days from 0001-01-01     * @return milliseconds from epoch     */    long millisFromFixed(long fixed) {        return fixed * MILLIS_PER_DAY - iEpochMillis;    }    /**     * @return milliseconds from epoch     */    long millisFromGJ(int year, int monthOfYear, int dayOfMonth) {        return millisFromFixed(fixedFromGJ(year, monthOfYear, dayOfMonth));    }    /**     * @param millis milliseconds from epoch     * @return gj year     */    int gjYearFromMillis(long millis) {        return gjYearFromFixed(fixedFromMillis(millis));    }    /**     * @param millis milliseconds from epoch     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromMillis(long millis) {        return gjFromFixed(fixedFromMillis(millis));    }    /**     * @return milliseconds from epoch     */    long millisFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return millisFromFixed(fixedFromISO(weekyear, weekOfWeekyear, dayOfWeek));    }    /**     * @param millis milliseconds from epoch     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromMillis(long millis) {        return isoFromFixed(fixedFromMillis(millis));    }    /**     * @param date days from 0001-01-01     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday     * @param date days from 0001-01-01, on or before weekday     */    long weekdayOnOrBefore(long date, int weekday) {        return date - mod(date - mod(weekday, 7), 7);    }    long weekdayOnOrAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 6, weekday);    }    long weekdayNearest(long date, int weekday) {        return weekdayOnOrBefore(date + 3, weekday);    }    long weekdayBefore(long date, int weekday) {        return weekdayOnOrBefore(date - 1, weekday);    }    long weekdayAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 7, weekday);    }    long nthWeekday(int n, int weekday,                    int year, int monthOfYear, int dayOfMonth)    {        if (n > 0) {            return 7 * n + weekdayBefore                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        } else {            return 7 * n + weekdayAfter                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        }    }    long firstWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(1, weekday, year, monthOfYear, dayOfMonth);    }    long lastWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(-1, weekday, year, monthOfYear, dayOfMonth);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfMonthField extends TestGJDateTimeField {    public TestGJDayOfMonthField(TestGJChronology chrono) {        super("dayOfMonth", "days", chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[2];    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(ymd[0], ymd[1], value);    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.months();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 31;    }    public int getMaximumValue(long millis) {        int[] lengths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};        if (iChronology.year().isLeap(millis)) {            lengths[2] = 29;        }        return lengths[iChronology.monthOfYear().get(millis)];    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.field.FieldUtils;/** *  * @author Brian S O'Neill */class TestJulianWeekyearField extends TestGJWeekyearField {    public TestJulianWeekyearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapField(long millis, int value) {        int weekyear = get(millis);        int wrapped = FieldUtils.getWrappedValue            (weekyear, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - weekyear);    }    public long add(long millis, long value) {        int weekyear = get(millis);        int newWeekyear = weekyear + FieldUtils.safeToInt(value);        if (weekyear < 0) {            if (newWeekyear >= 0) {                newWeekyear++;            }        } else {            if (newWeekyear <= 0) {                newWeekyear--;            }        }        return set(millis, newWeekyear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekOfWeekyearField extends TestGJDateTimeField {    public TestGJWeekOfWeekyearField(TestGJChronology chrono) {        super("weekOfWeekyear", "weeks",              (long)(chrono.MILLIS_PER_DAY * 7), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[1];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(wwd[0], value, wwd[2]);    }    public long add(long millis, long value) {        return iChronology.dayOfYear().add(millis, value * 7);    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 53;    }    public int getMaximumValue(long millis) {        // Move millis to end of weekyear.        millis = iChronology.weekyear().roundFloor(millis);        millis = iChronology.weekyear().add(millis, 1);        millis = iChronology.dayOfYear().add(millis, -1);        return get(millis);    }    public long roundFloor(long millis) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.millisFromISO(wwd[0], wwd[1], 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfYearField extends TestGJDateTimeField {    public TestGJDayOfYearField(TestGJChronology chrono) {        super("dayOfYear", "days", chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int year = iChronology.gjYearFromMillis(millis);        return (int)(iChronology.fixedFromMillis(millis)                     - iChronology.fixedFromGJ(year, 1, 1)) + 1;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 366;    }    public int getMaximumValue(long millis) {        return iChronology.year().isLeap(millis) ? 366 : 365;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.field.FieldUtils;/** *  * @author Brian S O'Neill */class TestJulianYearField extends TestGJYearField {    public TestJulianYearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapField(long millis, int value) {        int year = get(millis);        int wrapped = FieldUtils.getWrappedValue            (year, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - year);    }    public long add(long millis, long value) {        int year = get(millis);        int newYear = year + FieldUtils.safeToInt(value);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        return set(millis, newYear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJMonthOfYearField extends TestGJDateTimeField {    public TestGJMonthOfYearField(TestGJChronology chrono) {        super("monthOfYear", "months", chrono.millisPerMonth(), chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long set(long millis, int value) {        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);        int[] ymd = iChronology.gjFromMillis(millis);        // First set to start of month...        millis = iChronology.millisFromGJ(ymd[0], value, 1);        // ...and use dayOfMonth field to check range.        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);        if (ymd[2] > maxDay) {            ymd[2] = maxDay;        }        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);    }    public long add(long millis, long value) {        int newYear = iChronology.year().get(millis)            + (int)iChronology.div(value, 12);        int newMonth = get(millis) + (int)iChronology.mod(value, 12);        if (newMonth > 12) {            newYear++;            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public boolean isLeap(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return ymd[1] == 2 && iChronology.isLeapYear(ymd[0]);    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 12;    }    public long roundFloor(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.millisFromGJ(ymd[0], ymd[1], 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfWeekField extends TestGJDateTimeField {    public TestGJDayOfWeekField(TestGJChronology chrono) {        super("dayOfWeek", "days", chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);        if (dayOfWeek == 0) {            dayOfWeek = 7;        }        return dayOfWeek;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 7;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianDayOfMonthField extends TestGJDayOfMonthField {    public TestJulianDayOfMonthField(TestJulianChronology chrono) {        super(chrono);    }    public long getRangeMillis() {        return iChronology.millisPerMonth();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJYearField extends TestGJDateTimeField {    public TestGJYearField(TestGJChronology chrono) {        super("year", "years", chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.gjYearFromMillis(millis);    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(value, ymd[1], ymd[2]);        if (ymd[1] == 2 && ymd[2] == 29 && !iChronology.isLeapYear(value)) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public boolean isLeap(long millis) {        return iChronology.isLeapYear(get(millis));    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromGJ(get(millis), 1, 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;/** * A reference Julian chronology implementation, intended for testing purposes * only. Correctness is favored over performance. The key functions for date * calculations are based on ones provided in "Calendrical Calculations", ISBN * 0-521-77752-6. * * @author Brian S O'Neill */public final class TestJulianChronology extends TestGJChronology {    private static final long JULIAN_EPOCH;    static {        // Constant as defined in book.        JULIAN_EPOCH = new TestGregorianChronology().fixedFromGJ(0, 12, 30);    }    /**     * Constructs with an epoch of 1969-12-19.     */    public TestJulianChronology() {        super(1969, 12, 19);    }    public TestJulianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public DateTimeField dayOfMonth() {        return new TestJulianDayOfMonthField(this);     }    public DateTimeField weekyear() {        return new TestJulianWeekyearField(this);    }    public DateTimeField monthOfYear() {        return new TestJulianMonthOfYearField(this);    }    public DateTimeField year() {        return new TestJulianYearField(this);    }    public String toString() {        return "TestJulianChronology";    }    long millisPerYear() {        return (long)(365.25 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.25 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        return mod(year, 4) == (year > 0 ? 0 : 3);    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        int y = (year < 0) ? year + 1 : year;        long y_m1 = y - 1;        long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4)            + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        return gjFromFixed(date)[0];    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);        long year = (approx <= 0) ? approx - 1 : approx;        int year_i = (int)year;        if (year_i != year) {            throw new RuntimeException("year cannot be cast to an int: " + year);        }        long priorDays = date - fixedFromGJ(year_i, 1, 1);        long correction;        if (date < fixedFromGJ(year_i, 3, 1)) {            correction = 0;        } else if (isLeapYear(year_i)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year_i, monthOfYear, 1) + 1);        return new int[]{year_i, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        if (weekyear == 0) {            throw new IllegalArgumentException("Illegal weekyear: " + weekyear);        }        if (weekyear == 1) {            weekyear = -1;        } else {            weekyear--;        }        return nthWeekday(weekOfWeekyear, 0, weekyear, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        int nextWeekyear;        if (weekyear == -1) {            nextWeekyear = 1;        } else {            nextWeekyear = weekyear + 1;        }        if (date >= fixedFromISO(nextWeekyear, 1, 1)) {            weekyear = nextWeekyear;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(new MainTest(200, 0, 1345435247779935L));        suite.addTest(new MainTest(200, 1, 1345435247779935L));        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.field.ImpreciseDateTimeField;/** *  * @author Brian S O'Neill */abstract class TestGJDateTimeField extends ImpreciseDateTimeField {    protected final TestGJChronology iChronology;    public TestGJDateTimeField(String name, String duratioName,                               long unitMillis, TestGJChronology chrono) {        super(name, duratioName, unitMillis);        iChronology = chrono;    }    public boolean isLenient() {        return false;    }    public long add(long instant, int value) {        return add(instant, (long)value);    }    public abstract long add(long instant, long value);}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekyearField extends TestGJDateTimeField {    public TestGJWeekyearField(TestGJChronology chrono) {        super("weekyear", "weekyears", chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[0];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(value, wwd[1], wwd[2]);        if (wwd[1] == 53) {            int[] wwd2 = iChronology.isoFromMillis(millis);            if (wwd2[0] != value) {                // Set year doesn't have 53 weeks, so back off a week.                millis = iChronology.dayOfYear().add(millis, -7);            }        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public boolean isLeap(long millis) {        return iChronology.weekOfWeekyear().getMaximumValue(millis) > 52;    }    public int getLeapAmount(long millis) {        return iChronology.weekOfWeekyear().getMaximumValue(millis) - 52;    }     public DurationField getLeapDurationField() {        return iChronology.weeks();    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromISO(get(millis), 1, 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;/** * A reference Gregorian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * @author Brian S O'Neill */public final class TestGregorianChronology extends TestGJChronology {    /**     * Constructs with an epoch of 1970-01-01.     */    public TestGregorianChronology() {        super(1970, 1, 1);    }    public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public String toString() {        return "TestGregorianChronology";    }    long millisPerYear() {        return (long)(365.2425 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.2425 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (mod(year, 4) == 0) {            int t = (int)mod(year, 400);            if (t != 100 && t != 200 & t != 300) {                return true;            }        }        return false;    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        long year_m1 = year - 1;        long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100)            + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        long d0 = date - 1;        long n400 = div(d0, 146097);        long d1 = mod(d0, 146097);        long n100 = div(d1, 36524);        long d2 = mod(d1, 36524);        long n4 = div(d2, 1461);        long d3 = mod(d2, 1461);        long n1 = div(d3, 365);        long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;        if (!(n100 == 4 || n1 == 4)) {            year += 1;        }        int year_i = (int)year;        if (year_i == year) {            return year_i;        } else {            throw new RuntimeException("year cannot be cast to an int: " + year);        }    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        int year = gjYearFromFixed(date);        long priorDays = date - fixedFromGJ(year, 1, 1);        long correction;        if (date < fixedFromGJ(year, 3, 1)) {            correction = 0;        } else if (isLeapYear(year)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year, monthOfYear, 1) + 1);        return new int[]{year, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return nthWeekday(weekOfWeekyear, 0, weekyear - 1, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        if (date >= fixedFromISO(weekyear + 1, 1, 1)) {            weekyear += 1;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestISOChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOChronology.class);    }    public TestISOChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, ISOChronology.getInstanceUTC().getZone());    }    public void testFactory() {        assertEquals(LONDON, ISOChronology.getInstance().getZone());    }    public void testFactory_Zone() {        assertEquals(TOKYO, ISOChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, ISOChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, ISOChronology.getInstance(null).getZone());    }    public void testEquality() {        assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(LONDON));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(PARIS));        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC());        assertSame(ISOChronology.getInstance(), ISOChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(LONDON).withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(TOKYO).withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC().withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(null));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance().withZone(PARIS));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance(LONDON).toString());        assertEquals("ISOChronology[Asia/Tokyo]", ISOChronology.getInstance(TOKYO).toString());        assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance().toString());        assertEquals("ISOChronology[UTC]", ISOChronology.getInstanceUTC().toString());    }    public void testDurationFields() {        assertEquals("eras", ISOChronology.getInstance().eras().getName());        assertEquals("centuries", ISOChronology.getInstance().centuries().getName());        assertEquals("years", ISOChronology.getInstance().years().getName());        assertEquals("weekyears", ISOChronology.getInstance().weekyears().getName());        assertEquals("months", ISOChronology.getInstance().months().getName());        assertEquals("weeks", ISOChronology.getInstance().weeks().getName());        assertEquals("days", ISOChronology.getInstance().days().getName());        assertEquals("hours", ISOChronology.getInstance().hours().getName());        assertEquals("minutes", ISOChronology.getInstance().minutes().getName());        assertEquals("seconds", ISOChronology.getInstance().seconds().getName());        assertEquals("millis", ISOChronology.getInstance().millis().getName());                assertEquals(false, ISOChronology.getInstance().eras().isSupported());        assertEquals(true, ISOChronology.getInstance().centuries().isSupported());        assertEquals(true, ISOChronology.getInstance().years().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyears().isSupported());        assertEquals(true, ISOChronology.getInstance().months().isSupported());        assertEquals(true, ISOChronology.getInstance().weeks().isSupported());        assertEquals(true, ISOChronology.getInstance().days().isSupported());        assertEquals(true, ISOChronology.getInstance().hours().isSupported());        assertEquals(true, ISOChronology.getInstance().minutes().isSupported());        assertEquals(true, ISOChronology.getInstance().seconds().isSupported());        assertEquals(true, ISOChronology.getInstance().millis().isSupported());                assertEquals(false, ISOChronology.getInstance().centuries().isPrecise());        assertEquals(false, ISOChronology.getInstance().years().isPrecise());        assertEquals(false, ISOChronology.getInstance().weekyears().isPrecise());        assertEquals(false, ISOChronology.getInstance().months().isPrecise());        assertEquals(false, ISOChronology.getInstance().weeks().isPrecise());        assertEquals(false, ISOChronology.getInstance().days().isPrecise());        assertEquals(true, ISOChronology.getInstance().hours().isPrecise());        assertEquals(true, ISOChronology.getInstance().minutes().isPrecise());        assertEquals(true, ISOChronology.getInstance().seconds().isPrecise());        assertEquals(true, ISOChronology.getInstance().millis().isPrecise());                assertEquals(false, ISOChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", ISOChronology.getInstance().era().getName());        assertEquals("centuryOfEra", ISOChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", ISOChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", ISOChronology.getInstance().yearOfEra().getName());        assertEquals("year", ISOChronology.getInstance().year().getName());        assertEquals("monthOfYear", ISOChronology.getInstance().monthOfYear().getName());        assertEquals("weekyear", ISOChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", ISOChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", ISOChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", ISOChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", ISOChronology.getInstance().dayOfWeek().getName());                assertEquals(true, ISOChronology.getInstance().era().isSupported());        assertEquals(true, ISOChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, ISOChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, ISOChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, ISOChronology.getInstance().year().isSupported());        assertEquals(true, ISOChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyear().isSupported());        assertEquals(true, ISOChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", ISOChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", ISOChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", ISOChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", ISOChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", ISOChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", ISOChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", ISOChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", ISOChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", ISOChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", ISOChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", ISOChronology.getInstance().millisOfSecond().getName());                assertEquals(true, ISOChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, ISOChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, ISOChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, ISOChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, ISOChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().millisOfSecond().isSupported());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestISOChronology.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.Assert;import junit.framework.TestSuite;import org.joda.test.time.*;import org.joda.time.DateTimeZone;import org.joda.time.MutableDateTime;import org.joda.time.format.DateTimeParser;import org.joda.time.format.ISODateTimeFormat;/** * Unit test the parsing of ISO format datetimes * * @author Guy Allard * @author Stephen Colebourne */public class TestParseISO extends BulkTest {        private static final int DEFAULT = 99999;    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }        /**     * TestSuite suite() is a junit required method.     * @see org.joda.test.time.BulkTest     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestParseISO.class);    }        /**     * TestConstructors constructor.     * @param name     */    public TestParseISO(String name) {        super(name);    }    protected void setUp() throws Exception {        super.setUp();    }        protected void tearDown() throws Exception {        super.tearDown();    }        //-----------------------------------------------------------------------    // Dates    //-----------------------------------------------------------------------    public void testSpecCompleteDate() {        new DMatcher("5.2.1.1", "1999-10-20", "19991020",            19, 99, 10, 20, DEFAULT).run();    }            //-----------------------------------------------------------------------    public void testSpecReducedPrecisionCYM() {        new DMatcher("5.2.1.2", "1999-10", "199910",            19, 99, 10, DEFAULT, DEFAULT).run();    }    public void testSpecReducedPrecisionCY() {        new DMatcher("5.2.1.2", "1999", "1999",            19, 99, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecReducedPrecisionC() {        new DMatcher("5.2.1.2", "20", "20",            20, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();        new DMatcher("5.2.1.2", "19", "19",            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTruncatedYMD() {        new DMatcher("5.2.1.3", "85-04-11", "850411",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecTruncatedYM() {        new DMatcher("5.2.1.3", "-85-04", "-8504",            DEFAULT, 85, 4, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedY() {        new DMatcher("5.2.1.3", "-85", "-85",            DEFAULT, 85, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedMD() {        new DMatcher("5.2.1.3", "--04-11", "--0411",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    public void testSpecTruncatedM() {        new DMatcher("5.2.1.3", "--04", "--04",            DEFAULT, DEFAULT, 4, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedD() {        new DMatcher("5.2.1.3", "---11", "---11",            DEFAULT, DEFAULT, DEFAULT, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecExpandedCYMD() {        new DMatcher("5.2.1.4", "+001985-04-11", "+0019850411",            19, 85, 4, 11, DEFAULT).run();    }    public void testSpecExpandedCYM() {        new DMatcher("5.2.1.4", "+001985-04", "+00198504",            19, 85, 4, DEFAULT, DEFAULT).run();    }    public void testSpecExpandedCY() {        new DMatcher("5.2.1.4", "+001985", "+001985",            19, 85, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecExpandedC() {        // Not supported - could only tell difference from CY if you knew        // number of digits representing year//        new DMatcher("5.2.1.4", "+0019", "+0019",//            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).assert();    }        //-----------------------------------------------------------------------    // Ordinal based date    //-----------------------------------------------------------------------    public void testSpecOrdinalComplete() {        new DMatcher("5.2.2.1", "1985-101", "1985101",            19, 85, 4, 11, DEFAULT).run();        new DMatcher("5.2.2.1", "1985-021", "1985021",            19, 85, 1, 21, DEFAULT).run();        new DMatcher("5.2.2.1", "1985-006", "1985006",            19, 85, 1, 6, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecOrdinalTruncatedYD() {        new DMatcher("5.2.2.2", "85-101", "85101",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecOrdinalTruncatedD() {        new DMatcher("5.2.2.2", "-101", "-101",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecOrdinalExpandedYD() {        new DMatcher("5.2.2.3", "+001985-101", "+001985101",            19, 85, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    // Week based date    //-----------------------------------------------------------------------    public void testSpecWeekComplete() {        new DMatcher("5.2.3.1", "1985-W15-1", "1985W151",            19, 85, 4, 8, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-2", "1985W152",            19, 85, 4, 9, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-3", "1985W153",            19, 85, 4, 10, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-4", "1985W154",            19, 85, 4, 11, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-5", "1985W155",            19, 85, 4, 12, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-6", "1985W156",            19, 85, 4, 13, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-7", "1985W157",            19, 85, 4, 14, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecWeekReducedPrecision() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "1985-W15", "1985W15",            19, 85, 4, 14, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecWeekTruncatedYWD() {        new DMatcher("5.2.3.2", "85-W154", "85W154",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecWeekTruncatedYW() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "85-W15", "85W15",            DEFAULT, 85, 4, 14, DEFAULT).run();    }    public void testSpecWeekTruncatedDWD() {        // decade not supported    }    public void testSpecWeekTruncatedDW() {        // decade not supported    }    public void testSpecWeekTruncatedWD() {        new DMatcher("5.2.3.2", "-W154", "-W154",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    public void testSpecWeekTruncatedW() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "-W15", "-W15",            DEFAULT, DEFAULT, 4, 14, DEFAULT).run();    }    public void testSpecWeekTruncatedD() {        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov        new DMatcher("5.2.3.3", "-W-4", "-W-4",            DEFAULT, DEFAULT, 11, 30, DEFAULT).run();    }    public void testSpecWeekExpandedYWD() {        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov        new DMatcher("5.2.3.4", "+001985-W15-4", "+001985W154",            19, 85, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    // Times    //-----------------------------------------------------------------------    public void testSpecTimeComplete() {        new TMatcher("5.3.1.1", "23:20:50", "232050",            23, 20, 50, 0, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeReducedPrecisionHM() {        new TMatcher("5.3.1.2", "23:20", "2320",            23, 20, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTimeReducedPrecisionH() {        new TMatcher("5.3.1.2", "23", "23",            23, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeFractionalHMS() {        new TMatcher("5.3.1.3", "23:20:50.607", "232050.607",            23, 20, 50, 607, DEFAULT).run();        new TMatcher("5.3.1.3", "23:20:50,607", "232050,607",            23, 20, 50, 607, DEFAULT).run();    }    public void testSpecTimeFractionalHM() {        new TMatcher("5.3.1.3", "23:20.4", "2320.4",            23, 20, 24, 0, DEFAULT).run();        new TMatcher("5.3.1.3", "23:20,4", "2320,4",            23, 20, 24, 0, DEFAULT).run();    }    public void testSpecTimeFractionalH() {        new TMatcher("5.3.1.3", "23.25", "23.25",            23, 15, 0, 0, DEFAULT).run();        new TMatcher("5.3.1.3", "23.25", "23,25",            23, 15, 0, 0, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeTruncatedMS() {        new TMatcher("5.3.1.4", "-20:50", "-2050",            DEFAULT, 20, 50, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedM() {        new TMatcher("5.3.1.4", "-20", "-20",            DEFAULT, 20, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTimeTruncatedS() {        new TMatcher("5.3.1.4", "--50", "--50",            DEFAULT, DEFAULT, 50, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionMS() {        new TMatcher("5.3.1.4", "-20:50.607", "-2050.607",            DEFAULT, 20, 50, 607, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionM() {        new TMatcher("5.3.1.4", "-20.4", "-20.4",            DEFAULT, 20, 24, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionS() {        new TMatcher("5.3.1.4", "--50.607", "--50.607",            DEFAULT, DEFAULT, 50, 607, DEFAULT).run();    }        //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    /**     * Perform test.     */            protected static abstract class Matcher extends Assert {        String spec, extended, basic;        int century, yearOfCentury, monthOfYear, dayOfMonth, hour, min, sec, milli, zone;        MutableDateTime dt;                protected Matcher(String spec, String extended, String basic) {            this.spec = spec;            this.extended = extended;            this.basic = basic;        }                protected abstract void run();        protected void assertDate() {            String msg = "\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     " + dt;            assertEquals(msg + "\nCentury: ", century, dt.getCenturyOfEra());            assertEquals(msg + "\nYear: ", yearOfCentury, dt.getYearOfCentury());            assertEquals(msg + "\nMonth: ", monthOfYear, dt.getMonthOfYear());            assertEquals(msg + "\nDay: ", dayOfMonth, dt.getDayOfMonth());            assertEquals(msg + "\nHour: ", hour, dt.getHourOfDay());            assertEquals(msg + "\nMinute: ", min, dt.getMinuteOfHour());            assertEquals(msg + "\nSecond: ", sec, dt.getSecondOfMinute());            assertEquals(msg + "\nMilli: ", milli, dt.getMillisOfSecond());            DateTimeZone z;            if (zone == DEFAULT) {                z = DateTimeZone.getDefault();            } else if (zone == 0) {                    z = DateTimeZone.UTC;            } else {                String str = "0" + Math.abs(zone) + ":00";                str = str.substring(str.length() - 4);                str = (zone < 0 ? "-" : "+") + str;                z = DateTimeZone.getInstance(str);            }            assertEquals(msg + "\nZone: ", z, dt.getZone());        }        protected void parse(DateTimeParser p) {            int result = p.parseInto(dt, extended, 0);            assertTrue("\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     "                + dt + "\nParse failed at: " + ~result,                result >= 0);        }    }    protected static class DTMatcher extends Matcher {        protected DTMatcher(String spec, String extended, String basic,                int century, int yearOfCentury, int monthOfYear, int dayOfMonth,                int hour, int min, int sec, int milli, int zone) {            super(spec, extended, basic);            this.century = (century == DEFAULT ? 19 : century);            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);            this.hour = (hour == DEFAULT ? 10 : hour);            this.min = (min == DEFAULT ? 32 : min);            this.sec = (sec == DEFAULT ? 40 : sec);            this.milli = (milli == DEFAULT ? 205 : milli);            this.zone = zone;        }                    protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateTimeParser());            super.assertDate();        }    }    protected static class DMatcher extends Matcher {        protected DMatcher(String spec, String extended, String basic,                int century, int yearOfCentury, int monthOfYear, int dayOfMonth, int zone) {            super(spec, extended, basic);            this.century = (century == DEFAULT ? 19 : century);            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);            this.hour = 10;            this.min = 32;            this.sec = 40;            this.milli = 205;            this.zone = zone;        }        protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateParser());            super.assertDate();                    dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateTimeParser());            super.assertDate();        }    }    protected static class TMatcher extends Matcher {        protected TMatcher(String spec, String extended, String basic,                int hour, int min, int sec, int milli, int zone) {            super(spec, extended, basic);            this.century = 19;            this.yearOfCentury = 72;            this.monthOfYear = 12;            this.dayOfMonth = 3;            this.hour = (hour == DEFAULT ? 10 : hour);            this.min = (min == DEFAULT ? 32 : min);            this.sec = (sec == DEFAULT ? 40 : sec);            this.milli = (milli == DEFAULT ? 205 : milli);            this.zone = zone;        }        protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().timeParser());            super.assertDate();                        extended = "T" + extended;            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().timeParser());            super.assertDate();                        dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateTimeParser());            super.assertDate();        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Modifier;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInstant_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInstant_Basics.class);    }    public TestInstant_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet() {        Instant test = new Instant();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        Instant test = new Instant();                assertEquals(null, test.getChronology());        assertEquals(null, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    public void testEqualsHashCode() {        Instant test1 = new Instant(TEST_TIME1);        Instant test2 = new Instant(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Instant test3 = new Instant(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return null;        }    }    public void testCompareTo() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        //-----------------------------------------------------------------------    public void testIsEqual_long() {        assertEquals(false, new Instant(TEST_TIME1).isEqual(TEST_TIME2));        assertEquals(true, new Instant(TEST_TIME1).isEqual(TEST_TIME1));        assertEquals(false, new Instant(TEST_TIME2).isEqual(TEST_TIME1));    }        public void testIsEqualNow() {        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqualNow());        assertEquals(true, new Instant(TEST_TIME_NOW).isEqualNow());        assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqualNow());    }        public void testIsEqual_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new Instant(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqual(null));    }        //-----------------------------------------------------------------------    public void testIsBefore_long() {        assertEquals(true, new Instant(TEST_TIME1).isBefore(TEST_TIME2));        assertEquals(false, new Instant(TEST_TIME1).isBefore(TEST_TIME1));        assertEquals(false, new Instant(TEST_TIME2).isBefore(TEST_TIME1));    }        public void testIsBeforeNow() {        assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBeforeNow());        assertEquals(false, new Instant(TEST_TIME_NOW).isBeforeNow());        assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBeforeNow());    }        public void testIsBefore_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new Instant(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBefore(null));    }        //-----------------------------------------------------------------------    public void testIsAfter_long() {        assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME2));        assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME1));        assertEquals(true, new Instant(TEST_TIME2).isAfter(TEST_TIME1));    }        public void testIsAfterNow() {        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfterNow());        assertEquals(false, new Instant(TEST_TIME_NOW).isAfterNow());        assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfterNow());    }        public void testIsAfter_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new Instant(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Instant test = new Instant(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Instant result = (Instant) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        Instant test = new Instant(TEST_TIME_NOW);        assertEquals("2002-06-09T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testToInstant() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.toInstant();        assertSame(test, result);    }    public void testToDateTime() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTime_DateTimeZone() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_Chronology() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToTrustedISODateTime() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toTrustedISODateTime();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        Instant test = new Instant(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        Instant test = new Instant(TEST_TIME1);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new Instant(TEST_TIME1);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());    }    public void testToGregorianCalendar() {        Instant test = new Instant(TEST_TIME1);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new Instant(TEST_TIME1);        result = test.withMillis(TEST_TIME1);        assertSame(test, result);    }    public void testImmutable() {        assertTrue(Modifier.isFinal(Instant.class.getModifiers()));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestDateTimeUtils extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeUtils.class);    }    public TestDateTimeUtils(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testClass() {        Class cls = DateTimeUtils.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isFinal(cls.getModifiers()));                assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(cls.getDeclaredConstructors()[0].getModifiers()));                DateTimeUtils utils = new DateTimeUtils() {};    }        //-----------------------------------------------------------------------    public void testSystemMillis() {        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testSystemMillisSecurity() {        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisSystem();                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testFixedMillis() {        try {            DateTimeUtils.setCurrentMillisFixed(0L);            assertEquals(0L, DateTimeUtils.currentTimeMillis());            assertEquals(0L, DateTimeUtils.currentTimeMillis());            assertEquals(0L, DateTimeUtils.currentTimeMillis());        } finally {            DateTimeUtils.setCurrentMillisSystem();        }        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testFixedMillisSecurity() {        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisFixed(0L);                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testOffsetMillis() {        try {            // set time to one day ago            DateTimeUtils.setCurrentMillisOffset(-24 * 60 *  60 * 1000);            long nowSystem = System.currentTimeMillis();            long now = DateTimeUtils.currentTimeMillis();            long nowAdjustDay = now + (24 * 60 *  60 * 1000);            assertTrue((now < nowSystem));            assertTrue((nowAdjustDay >= nowSystem));            assertTrue((nowAdjustDay - nowSystem) < 10000L);        } finally {            DateTimeUtils.setCurrentMillisSystem();        }        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testOffsetMillisSecurity() {        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisOffset(-24 * 60 *  60 * 1000);                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_RI() {        Instant i = new Instant(123L);        assertEquals(123L, DateTimeUtils.getInstantMillis(i));        try {            DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);            assertEquals(TEST_TIME_NOW, DateTimeUtils.getInstantMillis(null));        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testGetInstantChronology_RI() {        DateTime dt = new DateTime(123L, BuddhistChronology.getInstance());        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt));                Instant i = new Instant(123L);        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(i));                assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(null));    }    public void testGetInstantChronology_RI_long() {        DateTime dt = new DateTime(123L, BuddhistChronology.getInstance());        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt, CopticChronology.getInstance()));        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt, null));                Instant i = new Instant(123L);        assertEquals(CopticChronology.getInstance(), DateTimeUtils.getInstantChronology(i, CopticChronology.getInstance()));        assertEquals(null, DateTimeUtils.getInstantChronology(i, null));                assertEquals(CopticChronology.getInstance(), DateTimeUtils.getInstantChronology(null, CopticChronology.getInstance()));        assertEquals(null, DateTimeUtils.getInstantChronology(null, null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Chronology() {        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getChronology(BuddhistChronology.getInstance()));        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getChronology(null));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_RI() {        Duration dur = new Duration(123L);        assertEquals(123L, DateTimeUtils.getDurationMillis(dur));        assertEquals(0L, DateTimeUtils.getDurationMillis(null));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateMidnight_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Properties.class);    }    public TestDateMidnight_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getReadableInstant());        assertSame(test, test.era().getDateMidnight());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getReadableInstant());        assertSame(test, test.yearOfEra().getDateMidnight());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getReadableInstant());        assertSame(test, test.centuryOfEra().getDateMidnight());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getReadableInstant());        assertSame(test, test.yearOfCentury().getDateMidnight());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getReadableInstant());        assertSame(test, test.weekyear().getDateMidnight());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadableInstant());        assertSame(test, test.year().getDateMidnight());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadableInstant());        assertSame(test, test.monthOfYear().getDateMidnight());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new DateMidnight(2004, 7, 9);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertySetMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy(8);        assertEquals(2004, copy.getYear());        assertEquals(8, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertySetTextMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy("8");        assertEquals(2004, copy.getYear());        assertEquals(8, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertySetTextLocaleMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy("mars", Locale.FRENCH);        assertEquals(2004, copy.getYear());        assertEquals(3, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addToCopy(8);        assertEquals(2005, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddLongMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addToCopy(8L);        assertEquals(2005, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddWrapFieldMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addWrapFieldToCopy(8);        assertEquals(2004, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyGetDifferenceMonthOfYear() {        DateMidnight test1 = new DateMidnight(2004, 6, 9);        DateMidnight test2 = new DateMidnight(2004, 8, 9);        assertEquals(-2, test1.monthOfYear().getDifference(test2));        assertEquals(2, test2.monthOfYear().getDifference(test1));        assertEquals(-2L, test1.monthOfYear().getDifferenceAsLong(test2));        assertEquals(2L, test2.monthOfYear().getDifferenceAsLong(test1));    }    public void testPropertyRoundFloorMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundCeilingMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfFloorMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfCeilingMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfEvenMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 9, 16);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-10-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRemainderMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertEquals((9L - 1L) * DateTimeConstants.MILLIS_PER_DAY, test.monthOfYear().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadableInstant());        assertSame(test, test.dayOfMonth().getDateMidnight());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getReadableInstant());        assertSame(test, test.dayOfYear().getDateMidnight());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getReadableInstant());        assertSame(test, test.weekOfWeekyear().getDateMidnight());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getReadableInstant());        assertSame(test, test.dayOfWeek().getDateMidnight());        assertEquals(3, test.dayOfWeek().get());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.AbstractChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Basics.class);    }    public TestMutableDateTime_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet() {        MutableDateTime test = new MutableDateTime();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        MutableDateTime test = new MutableDateTime();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(1, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(60, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(60 * 60, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(60 * 60 * 1000, test.getMillisOfDay());    }    public void testEqualsHashCode() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test2 = new MutableDateTime(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutableDateTime test3 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                DateTime test4 = new DateTime(TEST_TIME2);        assertEquals(true, test4.equals(test3));        assertEquals(true, test3.equals(test4));        assertEquals(false, test4.equals(test1));        assertEquals(false, test1.equals(test4));        assertEquals(true, test3.hashCode() == test4.hashCode());        assertEquals(false, test1.hashCode() == test4.hashCode());                MutableDateTime test5 = new MutableDateTime(TEST_TIME2);        test5.setRounding(ISOChronology.getInstance().millisOfSecond());        assertEquals(true, test5.equals(test3));        assertEquals(true, test5.equals(test4));        assertEquals(true, test3.equals(test5));        assertEquals(true, test4.equals(test5));        assertEquals(true, test3.hashCode() == test5.hashCode());        assertEquals(true, test4.hashCode() == test5.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance())));        assertEquals(true, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, new MockEqualsChronology())));        assertEquals(false, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, ISOChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    class MockEqualsChronology extends AbstractChronology {        public boolean equals(Object obj) {            return obj instanceof MockEqualsChronology;        }        public DateTimeZone getZone() {            return null;        }        public Chronology withUTC() {            return this;        }        public Chronology withZone(DateTimeZone zone) {            return this;        }        public String toString() {            return "";        }    }    public void testCompareTo() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        public void testIsEqual() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new MutableDateTime(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isEqual(null));    }        public void testIsBefore() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new MutableDateTime(TEST_TIME_NOW - 1).isBefore(null));    }        public void testIsAfter() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new MutableDateTime(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutableDateTime result = (MutableDateTime) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString());                test = new MutableDateTime(TEST_TIME_NOW, PARIS);        assertEquals("2002-06-09T02:00:00.000+02:00", test.toString());    }    public void testToString_String() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("2002 01", test.toString("yyyy HH"));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null));    }    public void testToString_String_String() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Instant result = test.toInstant();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTime() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        DateTime result = test.toDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(test.getChronology(), result.getChronology());    }    public void testToDateTime_DateTimeZone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(test.getChronology(), result.getChronology());        assertEquals(LONDON, result.getZone());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(PARIS, result.getZone());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(LONDON), result.getChronology());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_Chronology() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToTrustedISOMutableDateTime() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        DateTime result = test.toTrustedISODateTime();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MockUntrustedMutableDateTime(TEST_TIME1);        result = test.toTrustedISODateTime();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1, new MockUntrustedZone("Europe/Paris"));        result = test.toTrustedISODateTime();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());    }    static class MockUntrustedMutableDateTime extends MutableDateTime {        MockUntrustedMutableDateTime(long millis) {            super(millis);        }    }    static class MockUntrustedZone extends DateTimeZone {        MockUntrustedZone(String id) {            super(id);        }        public String getNameKey(long instant) {            return null;        }        public int getOffset(long instant) {            return 60 * 60 * 1000;        }        public int getStandardOffset(long instant) {            return 60 * 60 * 1000;        }        public boolean isFixed() {            return true;        }        public long nextTransition(long instant) {            return 0;        }        public long previousTransition(long instant) {            return 0;        }        public boolean equals(Object object) {            return false;        }    }    public void testToMutableDateTime() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testClone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = (MutableDateTime) test.clone();        assertEquals(true, test.equals(result));        assertEquals(true, test != result);    }    public void testCopy() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.copy();        assertEquals(true, test.equals(result));        assertEquals(true, test != result);    }    public void testRounding1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay());        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());    }    public void testRounding2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());    }    public void testRounding3() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());    }    public void testRounding4() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());    }    public void testRounding5() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_EVEN, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());                test = new MutableDateTime(2002, 6, 9, 4, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T04:00:00.000+01:00", test.toString());    }    public void testRounding6() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE);        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());    }    public void testRounding7() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setRounding(ISOChronology.getInstance().hourOfDay(), -1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testRounding8() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING);        assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(null, -1);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay());        assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test.setRounding(null);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Constructors.class);    }    public TestDateTime_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        DateTime test = new DateTime();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateTime test = new DateTime(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        DateTime test = new DateTime(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        DateTime test = new DateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        DateTime test = new DateTime(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        DateTime test = new DateTime(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME2, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new DateTime(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        DateTime test = new DateTime((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new DateTime(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        DateTime test = new DateTime((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new DateTime(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        DateTime test = new DateTime((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        DateTime test = new DateTime((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0);        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  // +02:00        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePeriod;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */public class TestPeriod_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriod_Basics.class);    }    public TestPeriod_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetPeriodType() {        Period test = new Period(0L);        assertEquals(PeriodType.getAllType(), test.getPeriodType());    }    public void testGetIsPrecise() {        Period test = new Period(123L);        assertEquals(true, test.isPrecise());        test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(false, test.isPrecise());    }    public void testGetMethods() {        Period test = new Period(0L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testEqualsHashCode() {        Period test1 = new Period(123L);        Period test2 = new Period(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Period test3 = new Period(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockPeriod(123L)));        assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));    }        class MockPeriod extends BasePeriod {        public MockPeriod(long value) {            super(value, null);        }    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Period test = new Period(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Period result = (Period) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testAddTo1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, 1);        assertEquals(expected, added);    }        public void testAddTo2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, -2);        assertEquals(expected, added);    }        public void testAddTo3() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        long added = test.addTo(TEST_TIME_NOW, -2);        assertEquals(expected, added);    }        public void testAddTo4() {        long expected = TEST_TIME_NOW;        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, 0);        assertEquals(expected, added);    }        public void testAddTo5() {        long expected = TEST_TIME_NOW + 100L;        Period test = new Period(100L);        long added = test.addTo(TEST_TIME_NOW, 1);        assertEquals(expected, added);    }        //-----------------------------------------------------------------------    public void testAddToWithChronology1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());        assertEquals(expected, added);    }        public void testAddToWithChronology2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it        assertEquals(expected, added);    }        public void testAddToWithChronology3() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)        assertEquals(expected, added);    }        //-----------------------------------------------------------------------    public void testAddToRI1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        public void testAddToRI2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        public void testAddToRI3() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(new DateTime(), -2);  // DateTime has local time zone        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        public void testAddToRI4() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());    }        public void testAddToRI5() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        //-----------------------------------------------------------------------    public void testAddIntoRWI1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        MutableDateTime mdt = new MutableDateTime();        test.addInto(mdt, 1);        assertEquals(expected, mdt.getMillis());    }        public void testAddIntoRWI2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        MutableDateTime mdt = new MutableDateTime();        test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it        assertEquals(expected, mdt.getMillis());    }        public void testAddIntoRWI3() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.addInto(null, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testToString() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString());                test = new Period(0, 0, 0, 0, 0, 0, 0, 0);        assertEquals("PT0S", test.toString());                test = new Period(12345L);        assertEquals("PT12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToPeriod() {        Period test = new Period(123L);        Period result = test.toPeriod();        assertSame(test, result);    }    public void testToMutablePeriod() {        Period test = new Period(123L);        MutablePeriod result = test.toMutablePeriod();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToDurationMillis() {        Period test = new Period(123L);        assertEquals(123L, test.toDurationMillis());                test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testToDuration() {        Period test = new Period(123L);        assertEquals(new Duration(123L), test.toDuration());                test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.toDuration();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    public void testWithPeriodTypeRetainDuration1() {        Period test = new Period(123L);        Period result = test.withPeriodTypeRetainDuration(PeriodType.getAllType());        assertSame(test, result);    }    public void testWithPeriodTypeRetainDuration2() {        Period test = new Period(3123L);        Period result = test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(3123L, result.toDurationMillis());        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());    }    public void testWithPeriodTypeRetainDuration3() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());        try {            test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());            fail();        } catch (IllegalStateException ex) {}    }    public void testWithPeriodTypeRetainDuration4() {        Period test = new Period(3123L);        Period result = test.withPeriodTypeRetainDuration(null);        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(3123L, result.toDurationMillis());        assertEquals(PeriodType.getAllType(), result.getPeriodType());    }    //-----------------------------------------------------------------------    public void testWithPeriodType1() {        Period test = new Period(123L);        Period result = test.withPeriodType(PeriodType.getAllType());        assertSame(test, result);    }    public void testWithPeriodType2() {        Period test = new Period(3123L);        Period result = test.withPeriodType(PeriodType.getDayHourType());        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(3123L, result.toDurationMillis());        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());    }    public void testWithPeriodType3() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());        try {            test.withPeriodType(PeriodType.getDayHourType());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithPeriodType4() {        Period test = new Period(3123L);        Period result = test.withPeriodType(null);        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(3123L, result.toDurationMillis());        assertEquals(PeriodType.getAllType(), result.getPeriodType());    }    public void testWithPeriodType5() {        Period test = new Period(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getAllType());        Period result = test.withPeriodType(PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testWithFieldsNormalized1() {        Period test = new Period(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getPreciseAllType());        Period result = test.withFieldsNormalized();        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(3, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(7, result.getMinutes());        assertEquals(1, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testWithFieldsNormalized2() {        Period test = new Period(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getAllType());        try {            test.withFieldsNormalized();            fail();        } catch (IllegalStateException ex) {}    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.MutableDateTime;import org.joda.time.ReadableInstant;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestYearMonthDay extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestYearMonthDay.class);    }    public TestYearMonthDay(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        YearMonthDay test = new YearMonthDay();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1971, test.getYear());        assertEquals(5, test.getMonthOfYear());        assertEquals(7, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1971, test.getYear());        assertEquals(5, test.getMonthOfYear());        assertEquals(7, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        YearMonthDay test = new YearMonthDay(null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            YearMonthDay test = new YearMonthDay(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(1970, test.getYear());            assertEquals(1, test.getMonthOfYear());            assertEquals(1, test.getDayOfMonth());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Object) null, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            YearMonthDay test = new YearMonthDay(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(1970, test.getYear());            assertEquals(1, test.getMonthOfYear());            assertEquals(1, test.getDayOfMonth());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new YearMonthDay(Integer.MIN_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(Integer.MAX_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 0, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 13, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 31);            fail();        } catch (IllegalArgumentException ex) {}        new YearMonthDay(1970, 7, 31);        try {            new YearMonthDay(1970, 7, 32);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new YearMonthDay(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 0, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 13, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 31, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new YearMonthDay(1970, 7, 31, GregorianChronology.getInstance());        try {            new YearMonthDay(1970, 7, 32, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    public void testGet() {        YearMonthDay test = new YearMonthDay();        assertEquals(1970, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(ISOChronology.getInstance().hourOfDay());            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(ISOChronology.getInstance(PARIS).year());            fail();        } catch (IllegalArgumentException ex) {}        // TODO: Should this fail or suceed - by succeeding it exposes out implementation//        try {//            test.get(GregorianChronology.getInstance().year());//            fail();//        } catch (IllegalArgumentException ex) {}    }    public void testGetFieldSize() {        YearMonthDay test = new YearMonthDay();        assertEquals(3, test.getFieldSize());    }    public void testGetField() {        YearMonthDay test = new YearMonthDay();        assertSame(ISOChronology.getInstance().year(), test.getField(0));        assertSame(ISOChronology.getInstance().monthOfYear(), test.getField(1));        assertSame(ISOChronology.getInstance().dayOfMonth(), test.getField(2));        try {            test.getField(-1);        } catch (IllegalArgumentException ex) {}        try {            test.getField(3);        } catch (IllegalArgumentException ex) {}    }    public void testGetFields() {        YearMonthDay test = new YearMonthDay();        DateTimeField[] fields = test.getFields();        assertSame(ISOChronology.getInstance().year(), fields[0]);        assertSame(ISOChronology.getInstance().monthOfYear(), fields[1]);        assertSame(ISOChronology.getInstance().dayOfMonth(), fields[2]);    }    public void testGetValue() {        YearMonthDay test = new YearMonthDay();        assertEquals(1970, test.getValue(0));        assertEquals(6, test.getValue(1));        assertEquals(9, test.getValue(2));        try {            test.getValue(-1);        } catch (IllegalArgumentException ex) {}        try {            test.getValue(3);        } catch (IllegalArgumentException ex) {}    }    public void testGetValues() {        YearMonthDay test = new YearMonthDay();        int[] values = test.getValues();        assertEquals(1970, values[0]);        assertEquals(6, values[1]);        assertEquals(9, values[2]);    }    public void testIsSupported() {        YearMonthDay test = new YearMonthDay();        assertEquals(true, test.isSupported(ISOChronology.getInstance().year()));        assertEquals(true, test.isSupported(ISOChronology.getInstance().monthOfYear()));        assertEquals(true, test.isSupported(ISOChronology.getInstance().dayOfMonth()));        assertEquals(false, test.isSupported(ISOChronology.getInstance().hourOfDay()));        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).year()));    }    public void testEqualsHashCode() {        YearMonthDay test1 = new YearMonthDay(1970, 6, 9);        YearMonthDay test2 = new YearMonthDay(1970, 6, 9);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                YearMonthDay test3 = new YearMonthDay(1971, 6, 9);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));    }        class MockInstant extends MockPartial {        public DateTimeField[] getFields() {            return new DateTimeField[] {                ISOChronology.getInstance().year(),                ISOChronology.getInstance().monthOfYear(),                ISOChronology.getInstance().dayOfMonth(),            };        }        public int[] getValues() {            return new int[] {1970, 6, 9};        }    }    //-----------------------------------------------------------------------    public void testResolve_long() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        DateTime dt = new DateTime(TEST_TIME1);        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());                DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));        check(test, 1972, 6, 9);        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());        assertEquals("1972-06-09T12:24:00.000Z", result.toString());    }    public void testResolveDateTime_RI() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        DateTime dt = new DateTime(TEST_TIME1);        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());                DateTime result = test.resolveDateTime(dt);        check(test, 1972, 6, 9);        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());        assertEquals("1972-06-09T12:24:00.000Z", result.toString());    }    public void testResolveDateTime_nullRI() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);                DateTime result = test.resolveDateTime(null);        check(test, 1972, 6, 9);        assertEquals("1972-06-09T12:24:00.000Z", result.toString());    }    public void testResolveInto_RWI() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        MutableDateTime mdt = new MutableDateTime(TEST_TIME1);        assertEquals("1970-04-06T12:24:00.000Z", mdt.toString());                test.resolveInto(mdt);        check(test, 1972, 6, 9);        assertEquals("1972-06-09T12:24:00.000Z", mdt.toString());    }    public void testResolveInto_nullRWI() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);                try {            test.resolveInto(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        YearMonthDay test = new YearMonthDay(1972, 6, 9);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        YearMonthDay result = (YearMonthDay) ois.readObject();        ois.close();                assertEquals(test, result);        assertTrue(Arrays.equals(test.getValues(), result.getValues()));        assertTrue(Arrays.equals(test.getFields(), result.getFields()));        assertEquals(test.getChronology(), result.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals("1972-06-09", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadablePartial());        assertSame(test, test.year().getYearMonthDay());        assertEquals(1972, test.year().get());        assertEquals("1972", test.year().getAsText());        assertEquals("1972", test.year().getAsText(Locale.FRENCH));        assertEquals("1972", test.year().getAsShortText());        assertEquals("1972", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyAddYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().addToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1981, 6, 9);                copy = test.year().addToCopy(0);        check(copy, 1972, 6, 9);                copy = test.year().addToCopy(292277023 - 1972);        check(copy, 292277023, 6, 9);                try {            test.year().addToCopy(292277023 - 1972 + 1);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 1972, 6, 9);                copy = test.year().addToCopy(-1972);        check(copy, 0, 6, 9);                copy = test.year().addToCopy(-1973);        check(copy, -1, 6, 9);                try {            test.year().addToCopy(-292275054 - 1972 - 1);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 1972, 6, 9);    }    public void testPropertyAddWrapFieldYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().addWrapFieldToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1981, 6, 9);                copy = test.year().addWrapFieldToCopy(0);        check(copy, 1972, 6, 9);                copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);        check(copy, -292275054, 6, 9);                copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);        check(copy, 292277023, 6, 9);    }    public void testPropertySetYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 12, 6, 9);    }    public void testPropertySetTextYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 12, 6, 9);    }    public void testPropertyCompareToYear() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.year().compareTo(test2) < 0);        assertEquals(true, test2.year().compareTo(test1) > 0);        assertEquals(true, test1.year().compareTo(test1) == 0);        try {            test1.year().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.year().compareTo(dt2) < 0);        assertEquals(true, test2.year().compareTo(dt1) > 0);        assertEquals(true, test1.year().compareTo(dt1) == 0);        try {            test1.year().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadablePartial());        assertSame(test, test.monthOfYear().getYearMonthDay());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new YearMonthDay(1972, 7, 9);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));    }    public void testPropertyGetMaxMinValuesMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyAddMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().addToCopy(6);        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().addToCopy(7);        check(copy, 1973, 1, 9);                copy = test.monthOfYear().addToCopy(-5);        check(copy, 1972, 1, 9);                copy = test.monthOfYear().addToCopy(-6);        check(copy, 1971, 12, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().addToCopy(1);        check(copy, 1972, 2, 29);                copy = test.monthOfYear().addToCopy(2);        check(copy, 1972, 3, 31);                copy = test.monthOfYear().addToCopy(3);        check(copy, 1972, 4, 30);                test = new YearMonthDay(1971, 1, 31);        copy = test.monthOfYear().addToCopy(1);        check(copy, 1971, 2, 28);    }    public void testPropertyAddWrapFieldMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().addWrapFieldToCopy(4);        check(test, 1972, 6, 9);        check(copy, 1972, 10, 9);                copy = test.monthOfYear().addWrapFieldToCopy(8);        check(copy, 1972, 2, 9);                copy = test.monthOfYear().addWrapFieldToCopy(-8);        check(copy, 1972, 10, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().addWrapFieldToCopy(1);        check(copy, 1972, 2, 29);                copy = test.monthOfYear().addWrapFieldToCopy(2);        check(copy, 1972, 3, 31);                copy = test.monthOfYear().addWrapFieldToCopy(3);        check(copy, 1972, 4, 30);                test = new YearMonthDay(1971, 1, 31);        copy = test.monthOfYear().addWrapFieldToCopy(1);        check(copy, 1971, 2, 28);    }    public void testPropertySetMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().setCopy(2);        check(copy, 1972, 2, 29);                try {            test.monthOfYear().setCopy(13);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.monthOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().setCopy("December");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().setCopy("Dec");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);    }    public void testPropertyCompareToMonth() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);        try {            test1.monthOfYear().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadablePartial());        assertSame(test, test.dayOfMonth().getYearMonthDay());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        test = new YearMonthDay(1972, 7, 9);        assertEquals(31, test.dayOfMonth().getMaximumValue());        test = new YearMonthDay(1972, 2, 9);        assertEquals(29, test.dayOfMonth().getMaximumValue());        test = new YearMonthDay(1971, 2, 9);        assertEquals(28, test.dayOfMonth().getMaximumValue());    }    public void testPropertyAddDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().addToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 18);                copy = test.dayOfMonth().addToCopy(21);        check(copy, 1972, 6, 30);                copy = test.dayOfMonth().addToCopy(22);        check(copy, 1972, 7, 1);                copy = test.dayOfMonth().addToCopy(22 + 30);        check(copy, 1972, 7, 31);                copy = test.dayOfMonth().addToCopy(22 + 31);        check(copy, 1972, 8, 1);        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        check(copy, 1972, 12, 31);                copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        check(copy, 1973, 1, 1);                copy = test.dayOfMonth().addToCopy(-8);        check(copy, 1972, 6, 1);                copy = test.dayOfMonth().addToCopy(-9);        check(copy, 1972, 5, 31);                copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        check(copy, 1972, 1, 1);                copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        check(copy, 1971, 12, 31);    }    public void testPropertyAddWrapFieldDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().addWrapFieldToCopy(21);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 30);                copy = test.dayOfMonth().addWrapFieldToCopy(22);        check(copy, 1972, 6, 1);                copy = test.dayOfMonth().addWrapFieldToCopy(-12);        check(copy, 1972, 6, 27);                test = new YearMonthDay(1972, 7, 9);        copy = test.dayOfMonth().addWrapFieldToCopy(21);        check(copy, 1972, 7, 30);            copy = test.dayOfMonth().addWrapFieldToCopy(22);        check(copy, 1972, 7, 31);            copy = test.dayOfMonth().addWrapFieldToCopy(23);        check(copy, 1972, 7, 1);            copy = test.dayOfMonth().addWrapFieldToCopy(-12);        check(copy, 1972, 7, 28);    }    public void testPropertySetDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 12);                try {            test.dayOfMonth().setCopy(31);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfMonth().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 1972, 6, 12);    }    public void testPropertyCompareToDay() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);        try {            test1.dayOfMonth().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    private void check(YearMonthDay test, int hour, int min, int sec) {        assertEquals(hour, test.getYear());        assertEquals(min, test.getMonthOfYear());        assertEquals(sec, test.getDayOfMonth());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Properties.class);    }    public TestDateTime_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getReadableInstant());        assertSame(test, test.era().getDateTime());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getReadableInstant());        assertSame(test, test.yearOfEra().getDateTime());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getReadableInstant());        assertSame(test, test.centuryOfEra().getDateTime());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getReadableInstant());        assertSame(test, test.yearOfCentury().getDateTime());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getReadableInstant());        assertSame(test, test.weekyear().getDateTime());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadableInstant());        assertSame(test, test.year().getDateTime());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyLeapYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(true, test.year().isLeap());        assertEquals(1, test.year().getLeapAmount());        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());        test = new DateTime(2003, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.year().isLeap());        assertEquals(0, test.year().getLeapAmount());        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());    }    public void testPropertyAddYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addToCopy(0);        assertEquals("2004-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addToCopy(292277023 - 2004);        assertEquals(292277023, copy.getYear());                try {            test.year().addToCopy(292277023 - 2004 + 1);            fail();        } catch (IllegalArgumentException ex) {}                copy = test.year().addToCopy(-2004);        assertEquals(0, copy.getYear());                copy = test.year().addToCopy(-2005);        assertEquals(-1, copy.getYear());                try {            test.year().addToCopy(-292275054 - 2004 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertyAddWrapFieldYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().addWrapFieldToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addWrapFieldToCopy(0);        assertEquals(2004, copy.getYear());                copy = test.year().addWrapFieldToCopy(292277023 - 2004 + 1);        assertEquals(-292275054, copy.getYear());                copy = test.year().addWrapFieldToCopy(-292275054 - 2004 - 1);        assertEquals(292277023, copy.getYear());    }    public void testPropertySetYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().setCopy(1960);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetTextYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().setCopy("1960");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.year().compareTo(test2) < 0);        assertEquals(true, test2.year().compareTo(test1) > 0);        assertEquals(true, test1.year().compareTo(test1) == 0);        try {            test1.year().compareTo(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadableInstant());        assertSame(test, test.monthOfYear().getDateTime());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyLeapMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2004, 2, 9, 0, 0, 0, 0);        assertEquals(true, test.monthOfYear().isLeap());        assertEquals(1, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2003, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2003, 2, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());    }    public void testPropertyAddMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().addToCopy(6);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(7);        assertEquals("2005-01-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(-5);        assertEquals("2004-01-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(-6);        assertEquals("2003-12-09T00:00:00.000Z", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addToCopy(1);        assertEquals("2004-01-31T00:00:00.000Z", test.toString());        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(2);        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addToCopy(3);        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());                test = new DateTime(2003, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addToCopy(1);        assertEquals("2003-02-28T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().addWrapFieldToCopy(4);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(8);        assertEquals("2004-02-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(-8);        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addWrapFieldToCopy(1);        assertEquals("2004-01-31T00:00:00.000Z", test.toString());        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(2);        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(3);        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());                test = new DateTime(2005, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addWrapFieldToCopy(1);        assertEquals("2005-01-31T00:00:00.000Z", test.toString());        assertEquals("2005-02-28T00:00:00.000Z", copy.toString());    }    public void testPropertySetMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().setCopy(2);        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                try {            test.monthOfYear().setCopy(13);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.monthOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().setCopy("December");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().setCopy("Dec");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToMonthOfYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadableInstant());        assertSame(test, test.dayOfMonth().getDateTime());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals(31, test.dayOfMonth().getMaximumValue());        test = new DateTime(2004, 2, 9, 0, 0, 0, 0);        assertEquals(29, test.dayOfMonth().getMaximumValue());        test = new DateTime(2003, 2, 9, 0, 0, 0, 0);        assertEquals(28, test.dayOfMonth().getMaximumValue());    }    public void testPropertyAddDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 30);        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 31);        assertEquals("2004-08-01T00:00:00.000+01:00", copy.toString());        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().addWrapFieldToCopy(21);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addWrapFieldToCopy(22);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addWrapFieldToCopy(-12);        assertEquals("2004-06-27T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        copy = test.dayOfMonth().addWrapFieldToCopy(21);        assertEquals("2004-07-30T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(22);        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(23);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(-12);        assertEquals("2004-07-28T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());                try {            test.dayOfMonth().setCopy(31);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfMonth().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToDayOfMonth() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getReadableInstant());        assertSame(test, test.dayOfYear().getDateTime());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.dayOfYear().getMinimumValue());        assertEquals(1, test.dayOfYear().getMinimumValueOverall());        assertEquals(366, test.dayOfYear().getMaximumValue());        assertEquals(366, test.dayOfYear().getMaximumValueOverall());        test = new DateTime(2002, 6, 9, 0, 0, 0, 0);        assertEquals(365, test.dayOfYear().getMaximumValue());        assertEquals(366, test.dayOfYear().getMaximumValueOverall());    }    public void testPropertyAddDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().addWrapFieldToCopy(21);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-12);        assertEquals("2004-05-28T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(205);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(206);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-160);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-161);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertySetDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());                try {            test.dayOfYear().setCopy(367);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToDayOfYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfYear().compareTo(test2) < 0);        assertEquals(true, test2.dayOfYear().compareTo(test1) > 0);        assertEquals(true, test1.dayOfYear().compareTo(test1) == 0);        try {            test1.dayOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfYear().compareTo(dt1) == 0);        try {            test1.dayOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        // 2002-01-01 = Thu        // 2002-12-31 = Thu (+364 days)        // 2003-12-30 = Thu (+364 days)        // 2004-01-03 = Mon             W1        // 2004-01-31 = Mon (+28 days)  W5        // 2004-02-28 = Mon (+28 days)  W9        // 2004-03-27 = Mon (+28 days)  W13        // 2004-04-24 = Mon (+28 days)  W17        // 2004-05-23 = Mon (+28 days)  W21        // 2004-06-05 = Mon (+14 days)  W23        // 2004-06-09 = Fri        // 2004-12-25 = Mon             W52        // 2005-01-01 = Mon             W1        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getReadableInstant());        assertSame(test, test.weekOfWeekyear().getDateTime());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.weekOfWeekyear().getMinimumValue());        assertEquals(1, test.weekOfWeekyear().getMinimumValueOverall());        assertEquals(53, test.weekOfWeekyear().getMaximumValue());        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());        test = new DateTime(2005, 6, 9, 0, 0, 0, 0);        assertEquals(52, test.weekOfWeekyear().getMaximumValue());        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());    }    public void testPropertyAddWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().addToCopy(1);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());                copy = test.weekOfWeekyear().addToCopy(29);        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(30);        assertEquals("2005-01-03T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(-22);        assertEquals("2004-01-05T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(-23);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().addWrapFieldToCopy(1);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(29);        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(30);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(-23);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());    }    public void testPropertySetWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().setCopy(4);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());                try {            test.weekOfWeekyear().setCopy(54);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.weekOfWeekyear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().setCopy("4");        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToWeekOfWeekyear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.weekOfWeekyear().compareTo(test2) < 0);        assertEquals(true, test2.weekOfWeekyear().compareTo(test1) > 0);        assertEquals(true, test1.weekOfWeekyear().compareTo(test1) == 0);        try {            test1.weekOfWeekyear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.weekOfWeekyear().compareTo(dt2) < 0);        assertEquals(true, test2.weekOfWeekyear().compareTo(dt1) > 0);        assertEquals(true, test1.weekOfWeekyear().compareTo(dt1) == 0);        try {            test1.weekOfWeekyear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getReadableInstant());        assertSame(test, test.dayOfWeek().getDateTime());        assertEquals(3, test.dayOfWeek().get());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }    public void testPropertyAddDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().addToCopy(1);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddLongDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().addToCopy(1L);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());    }            public void testPropertyAddWrapFieldDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);  // Wed        DateTime copy = test.dayOfWeek().addWrapFieldToCopy(1);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addWrapFieldToCopy(5);        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addWrapFieldToCopy(-10);        assertEquals("2004-06-13T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 2, 0, 0, 0, 0);        copy = test.dayOfWeek().addWrapFieldToCopy(5);        assertEquals("2004-06-02T00:00:00.000+01:00", test.toString());        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().setCopy(4);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                try {            test.dayOfWeek().setCopy(8);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfWeek().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().setCopy("4");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("Mon");        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("Tuesday");        assertEquals("2004-06-08T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("lundi", Locale.FRENCH);        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToDayOfWeek() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test2.dayOfWeek().compareTo(test1) < 0);        assertEquals(true, test1.dayOfWeek().compareTo(test2) > 0);        assertEquals(true, test1.dayOfWeek().compareTo(test1) == 0);        try {            test1.dayOfWeek().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test2.dayOfWeek().compareTo(dt1) < 0);        assertEquals(true, test1.dayOfWeek().compareTo(dt2) > 0);        assertEquals(true, test1.dayOfWeek().compareTo(dt1) == 0);        try {            test1.dayOfWeek().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getReadableInstant());        assertSame(test, test.hourOfDay().getDateTime());        assertEquals(13, test.hourOfDay().get());        assertEquals("13", test.hourOfDay().getAsText());        assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("13", test.hourOfDay().getAsShortText());        assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyGetDifferenceHourOfDay() {        DateTime test1 = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime test2 = new DateTime(2004, 6, 9, 15, 30, 0, 0);        assertEquals(-2, test1.hourOfDay().getDifference(test2));        assertEquals(2, test2.hourOfDay().getDifference(test1));        assertEquals(-2L, test1.hourOfDay().getDifferenceAsLong(test2));        assertEquals(2L, test2.hourOfDay().getDifferenceAsLong(test1));                DateTime test = new DateTime(TEST_TIME_NOW + (13L * DateTimeConstants.MILLIS_PER_HOUR));        assertEquals(13, test.hourOfDay().getDifference(null));        assertEquals(13L, test.hourOfDay().getDifferenceAsLong(null));    }    public void testPropertyRoundFloorHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundCeilingHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfFloorHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfCeilingHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfEvenHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 14, 30, 0, 0);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRemainderHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfHour() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getReadableInstant());        assertSame(test, test.minuteOfHour().getDateTime());        assertEquals(23, test.minuteOfHour().get());        assertEquals("23", test.minuteOfHour().getAsText());        assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("23", test.minuteOfHour().getAsShortText());        assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());        assertEquals("minuteOfDay", test.minuteOfDay().getName());        assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString());        assertSame(test, test.minuteOfDay().getReadableInstant());        assertSame(test, test.minuteOfDay().getDateTime());        assertEquals(803, test.minuteOfDay().get());        assertEquals("803", test.minuteOfDay().getAsText());        assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH));        assertEquals("803", test.minuteOfDay().getAsShortText());        assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());        assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));        assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfMinute() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getReadableInstant());        assertSame(test, test.secondOfMinute().getDateTime());        assertEquals(43, test.secondOfMinute().get());        assertEquals("43", test.secondOfMinute().getAsText());        assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("43", test.secondOfMinute().getAsShortText());        assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());        assertEquals("secondOfDay", test.secondOfDay().getName());        assertEquals("Property[secondOfDay]", test.secondOfDay().toString());        assertSame(test, test.secondOfDay().getReadableInstant());        assertSame(test, test.secondOfDay().getDateTime());        assertEquals(48223, test.secondOfDay().get());        assertEquals("48223", test.secondOfDay().getAsText());        assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH));        assertEquals("48223", test.secondOfDay().getAsShortText());        assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());        assertEquals(5, test.secondOfDay().getMaximumTextLength(null));        assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfSecond() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getReadableInstant());        assertSame(test, test.millisOfSecond().getDateTime());        assertEquals(53, test.millisOfSecond().get());        assertEquals("53", test.millisOfSecond().getAsText());        assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("53", test.millisOfSecond().getAsShortText());        assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());        assertEquals("millisOfDay", test.millisOfDay().getName());        assertEquals("Property[millisOfDay]", test.millisOfDay().toString());        assertSame(test, test.millisOfDay().getReadableInstant());        assertSame(test, test.millisOfDay().getDateTime());        assertEquals(48223053, test.millisOfDay().get());        assertEquals("48223053", test.millisOfDay().getAsText());        assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH));        assertEquals("48223053", test.millisOfDay().getAsShortText());        assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());        assertEquals(8, test.millisOfDay().getMaximumTextLength(null));        assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Adds extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Adds.class);    }    public TestMutableDateTime_Adds(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testAdd_long1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(123456L);        assertEquals(TEST_TIME1 + 123456L, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testAdd_Object1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(new Long(123456L));        assertEquals(TEST_TIME1 + 123456L, test.getMillis());    }    public void testAdd_Object2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((Object) null);        assertEquals(TEST_TIME1, test.getMillis());    }    public void testAdd_Object3() {        Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());        test.add(d);        assertEquals("2003-07-10T06:07:08.009+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAdd_Object_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(new Long(123L), -2);        assertEquals(TEST_TIME1 + (-2 * 123L), test.getMillis());    }    public void testAdd_Object_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadableDuration) null, 1);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    public void testAdd_Object_int3() {        Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());        test.add(d, -2);        assertEquals("2000-04-07T03:04:05.006+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAdd_DateTimeField_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(ISOChronology.getInstance().year(), 8);        assertEquals(2010, test.getYear());    }    public void testAdd_DateTimeField_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.add((DateTimeField) null, 2010);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_DurationField_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(ISOChronology.getInstance().years(), 8);        assertEquals(2010, test.getYear());    }    public void testAdd_DurationField_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.add((DurationField) null, 2010);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAddWrapField_DateTimeField_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 1, 0, 0, 0, 0);        test.addWrapField(ISOChronology.getInstance().monthOfYear(), 8);        assertEquals(2, test.getMonthOfYear());    }    public void testAddWrapField_DateTimeField_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.addWrapField(null, 2010);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAddYears_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addYears(8);        assertEquals("2010-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMonths_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMonths(6);        assertEquals("2002-12-09T05:06:07.008Z", test.toString());    }    //-----------------------------------------------------------------------    public void testAddDays_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addDays(17);        assertEquals("2002-06-26T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddWeekyears_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addWeekyears(-1);        assertEquals("2001-06-10T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddWeeks_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addWeeks(-21);        assertEquals("2002-01-13T05:06:07.008Z", test.toString());    }    //-----------------------------------------------------------------------    public void testAddHours_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addHours(13);        assertEquals("2002-06-09T18:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMinutes_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMinutes(13);        assertEquals("2002-06-09T05:19:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddSeconds_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addSeconds(13);        assertEquals("2002-06-09T05:06:20.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMillis_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMillis(13);        assertEquals("2002-06-09T05:06:07.021+01:00", test.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.IntervalConverter;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */public class TestInterval_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInterval_Constructors.class);    }    public TestInterval_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.getMillis(), dt2.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1.getMillis(), dt1.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_long_long3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new Interval(dt1.getMillis(), dt2.getMillis());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0));        Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1));        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1, (ReadableInstant) null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval((ReadableInstant) null, dt2);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI6() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1, dt1);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI7() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new Interval(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RP1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().days().add(result, 3);        result = ISOChronology.getInstance().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP3() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, 6);        result = ISOChronology.getInstanceUTC().days().add(result, 3);        result = ISOChronology.getInstanceUTC().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, 1);        result = ISOChronology.getInstance().millis().add(result, 23);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP5() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadablePeriod) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RP6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval(dt, (ReadablePeriod) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RP7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Interval test = new Interval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new Interval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RI1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().days().add(result, -3);        result = ISOChronology.getInstance().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI3() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, -6);        result = ISOChronology.getInstanceUTC().days().add(result, -3);        result = ISOChronology.getInstanceUTC().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, -1);        result = ISOChronology.getInstance().millis().add(result, -23);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI5() throws Throwable {        Interval test = new Interval((ReadablePeriod) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval((ReadablePeriod) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Interval test = new Interval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new Interval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(result - TEST_TIME_NOW);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadableDuration) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RD3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval(dt, (ReadableDuration) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RD4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Duration dur = new Duration(result - TEST_TIME_NOW);                Interval test = new Interval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new Interval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(TEST_TIME_NOW - result);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI2() throws Throwable {        Interval test = new Interval((ReadableDuration) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval((ReadableDuration) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Duration dur = new Duration(TEST_TIME_NOW - result);                Interval test = new Interval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new Interval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_Object1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.toString() + '/' + dt2.toString());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);        Duration dur = base.getDuration();                Interval test = new Interval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertNotSame(dur, test.getDuration());    }    public void testConstructor_Object3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval base = new MutableInterval(dt1, dt2);        Duration dur = base.getDuration();                Interval test = new Interval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertNotSame(dur, test.getDuration());    }    public void testConstructor_Object4() throws Throwable {        MockInterval base = new MockInterval();        Interval test = new Interval(base);        assertEquals(base.getStartMillis(), test.getStartMillis());        assertEquals(base.getEndMillis(), test.getEndMillis());    }    public void testConstructor_Object5() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter("");        IntervalConverter conv = new IntervalConverter() {            public long[] getIntervalMillis(Object object) {                return new long[] {1234L, 5678L};            }            public void setInto(ReadWritableInterval interval, Object object) {            }            public Class getSupportedType() {                return String.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);            DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);            Interval test = new Interval(dt1.toString() + '/' + dt2.toString());            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    public void testConstructor_Object6() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 0L));        IntervalConverter conv = new IntervalConverter() {            public long[] getIntervalMillis(Object object) {                return new long[] {1234L, 5678L};            }            public void setInto(ReadWritableInterval interval, Object object) {            }            public Class getSupportedType() {                return ReadableInterval.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            Interval base = new Interval(-1000L, 1000L);            Duration dur = base.getDuration();            Interval test = new Interval(base);            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());            assertNotSame(dur, test.getDuration());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    class MockInterval implements ReadableInterval {        public long getStartMillis() {            return 1234L;        }        public Instant getStartInstant() {            return new Instant(1234L);        }        public long getEndMillis() {            return 5678L;        }        public Instant getEndInstant() {            return new Instant(5678L);        }        public long getDurationMillis() {            return (5678L - 1234L);        }        public Duration getDuration() {            return new Duration(5678L - 1234L);        }        public boolean contains(long millisInstant) {            return false;        }        public boolean containsNow() {            return false;        }        public boolean contains(ReadableInstant instant) {            return false;        }        public boolean contains(ReadableInterval interval) {            return false;        }        public boolean overlaps(ReadableInterval interval) {            return false;        }        public boolean isBefore(long millisInstant) {            return false;        }        public boolean isBeforeNow() {            return false;        }        public boolean isBefore(ReadableInstant instant) {            return false;        }        public boolean isAfter(long millisInstant) {            return false;        }        public boolean isAfterNow() {            return false;        }        public boolean isAfter(ReadableInstant instant) {            return false;        }        public Interval toInterval() {            return null;        }        public MutableInterval toMutableInterval() {            return null;        }        public Period toPeriod() {            return null;        }        public Period toPeriod(PeriodType type) {            return null;        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractDuration;/** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */public class TestDuration_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDuration_Basics.class);    }    public TestDuration_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        Duration test = new Duration(0L);        assertEquals(0, test.getMillis());                test = new Duration(1234567890L);        assertEquals(1234567890L, test.getMillis());    }    public void testEqualsHashCode() {        Duration test1 = new Duration(123L);        Duration test2 = new Duration(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Duration test3 = new Duration(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockDuration(123L)));    }        class MockDuration extends AbstractDuration {        private final long iValue;        public MockDuration(long value) {            super();            iValue = value;        }        public long getMillis() {            return iValue;        }    }    public void testCompareTo() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                Duration test2 = new Duration(321L);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                assertEquals(+1, test2.compareTo(new MockDuration(123L)));        assertEquals(0, test1.compareTo(new MockDuration(123L)));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Long(123L));            fail();        } catch (ClassCastException ex) {}    }    public void testIsEqual() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                Duration test2 = new Duration(321L);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                assertEquals(false, test2.isEqual(new MockDuration(123L)));        assertEquals(true, test1.isEqual(new MockDuration(123L)));        assertEquals(false, test1.isEqual(null));        assertEquals(true, new Duration(0L).isEqual(null));    }        public void testIsBefore() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(false, test1.isShorterThan(test1a));        assertEquals(false, test1a.isShorterThan(test1));        assertEquals(false, test1.isShorterThan(test1));        assertEquals(false, test1a.isShorterThan(test1a));                Duration test2 = new Duration(321L);        assertEquals(true, test1.isShorterThan(test2));        assertEquals(false, test2.isShorterThan(test1));                assertEquals(false, test2.isShorterThan(new MockDuration(123L)));        assertEquals(false, test1.isShorterThan(new MockDuration(123L)));        assertEquals(false, test1.isShorterThan(null));        assertEquals(false, new Duration(0L).isShorterThan(null));    }        public void testIsAfter() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(false, test1.isLongerThan(test1a));        assertEquals(false, test1a.isLongerThan(test1));        assertEquals(false, test1.isLongerThan(test1));        assertEquals(false, test1a.isLongerThan(test1a));                Duration test2 = new Duration(321L);        assertEquals(false, test1.isLongerThan(test2));        assertEquals(true, test2.isLongerThan(test1));                assertEquals(true, test2.isLongerThan(new MockDuration(123L)));        assertEquals(false, test1.isLongerThan(new MockDuration(123L)));        assertEquals(true, test1.isLongerThan(null));        assertEquals(false, new Duration(0L).isLongerThan(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Duration test = new Duration(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Duration result = (Duration) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        long length = (365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        int total = (365 + 2 * 30 + 3 * 7 + 4) * 24 + 5;        Duration test = new Duration(length);        assertEquals("PT" + total + "H6M7.008S", test.toString());                test = new Duration(0L);        assertEquals("PT0S", test.toString());                test = new Duration(12345L);        assertEquals("PT12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToDuration1() {        Duration test = new Duration(123L);        Duration result = test.toDuration();        assertSame(test, result);    }        public void testToDuration2() {        MockDuration test = new MockDuration(123L);        Duration result = test.toDuration();        assertNotSame(test, result);        assertEquals(test, result);    }        //-----------------------------------------------------------------------    public void testToPeriod1() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod();        assertEquals(PeriodType.getAllType(), result.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, result.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(0, result.getDays());        assertEquals((450 * 24) + 5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());        assertEquals(true, result.isPrecise());        assertEquals(length, result.toDurationMillis());    }    public void testToPeriod_PeriodType1() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(null);        assertEquals(PeriodType.getAllType(), result.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, result.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(0, result.getDays());        assertEquals((450 * 24) + 5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());        assertEquals(true, result.isPrecise());        assertEquals(length, result.toDurationMillis());    }    public void testToPeriod_PeriodType2() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(PeriodType.getPreciseAllType());        assertEquals(PeriodType.getPreciseAllType(), result.getPeriodType());        // only time fields are precise in AllType        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(3, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());        assertEquals(true, result.isPrecise());        assertEquals(length, result.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testWithMillis1() {        Duration test = new Duration(123L);        Duration result = test.withMillis(123L);        assertSame(test, result);    }    public void testWithMillis2() {        Duration test = new Duration(123L);        Duration result = test.withMillis(1234567890L);        assertEquals(1234567890L, result.getMillis());    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L);        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_long2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(0L);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long_int1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 1);        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_long_int2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 2);        assertEquals(16123L, result.getMillis());    }    public void testWithDurationAdded_long_int3() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, -1);        assertEquals((123L - 8000L), result.getMillis());    }    public void testWithDurationAdded_long_int4() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(0L, 1);        assertSame(test, result);    }    public void testWithDurationAdded_long_int5() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_RD1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L));        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_RD2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(0L));        assertSame(test, result);    }    public void testWithDurationAdded_RD3() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_RD_int1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 1);        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_RD_int2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 2);        assertEquals(16123L, result.getMillis());    }    public void testWithDurationAdded_RD_int3() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), -1);        assertEquals((123L - 8000L), result.getMillis());    }    public void testWithDurationAdded_RD_int4() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(0L), 1);        assertSame(test, result);    }    public void testWithDurationAdded_RD_int5() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 0);        assertSame(test, result);    }    public void testWithDurationAdded_RD_int6() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(null, 0);        assertSame(test, result);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePeriod;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Basics.class);    }    public TestMutablePeriod_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetPeriodType() {        MutablePeriod test = new MutablePeriod();        assertEquals(PeriodType.getAllType(), test.getPeriodType());    }    public void testGetIsPrecise() {        MutablePeriod test = new MutablePeriod(123L);        assertEquals(true, test.isPrecise());        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(false, test.isPrecise());    }    public void testGetMethods() {        MutablePeriod test = new MutablePeriod();        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getDays());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testEqualsHashCode() {        MutablePeriod test1 = new MutablePeriod(123L);        MutablePeriod test2 = new MutablePeriod(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutablePeriod test3 = new MutablePeriod(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockMutablePeriod(123L)));        assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));    }        class MockMutablePeriod extends BasePeriod {        public MockMutablePeriod(long value) {            super(value, null);        }    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutablePeriod test = new MutablePeriod(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutablePeriod result = (MutablePeriod) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testAddTo1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, 1);        assertEquals(expected, added);    }        public void testAddTo2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, -2);        assertEquals(expected, added);    }        public void testAddTo3() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        long added = test.addTo(TEST_TIME_NOW, -2);        assertEquals(expected, added);    }        public void testAddTo4() {        long expected = TEST_TIME_NOW;        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, 0);        assertEquals(expected, added);    }        public void testAddTo5() {        long expected = TEST_TIME_NOW + 100L;        MutablePeriod test = new MutablePeriod(100L);        long added = test.addTo(TEST_TIME_NOW, 1);        assertEquals(expected, added);    }        //-----------------------------------------------------------------------    public void testAddToWithChronology1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());        assertEquals(expected, added);    }        public void testAddToWithChronology2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it        assertEquals(expected, added);    }        public void testAddToWithChronology3() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)        assertEquals(expected, added);    }        //-----------------------------------------------------------------------    public void testAddToRI1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        public void testAddToRI2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        public void testAddToRI3() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(new DateTime(), -2);  // DateTime has local time zone        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        public void testAddToRI4() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());    }        public void testAddToRI5() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        DateTime added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)        assertEquals(expected, added.getMillis());        assertEquals(ISOChronology.getInstance(), added.getChronology());    }        //-----------------------------------------------------------------------    public void testAddIntoRWI1() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, 1);        expected = ISOChronology.getInstance().months().add(expected, 2);        expected = ISOChronology.getInstance().weeks().add(expected, 3);        expected = ISOChronology.getInstance().days().add(expected, 4);        expected = ISOChronology.getInstance().hours().add(expected, 5);        expected = ISOChronology.getInstance().minutes().add(expected, 6);        expected = ISOChronology.getInstance().seconds().add(expected, 7);        expected = ISOChronology.getInstance().millis().add(expected, 8);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        MutableDateTime mdt = new MutableDateTime();        test.addInto(mdt, 1);        assertEquals(expected, mdt.getMillis());    }        public void testAddIntoRWI2() {        long expected = TEST_TIME_NOW;        expected = ISOChronology.getInstance().years().add(expected, -2);        expected = ISOChronology.getInstance().months().add(expected, -4);        expected = ISOChronology.getInstance().weeks().add(expected, -6);        expected = ISOChronology.getInstance().days().add(expected, -8);        expected = ISOChronology.getInstance().hours().add(expected, -10);        expected = ISOChronology.getInstance().minutes().add(expected, -12);        expected = ISOChronology.getInstance().seconds().add(expected, -14);        expected = ISOChronology.getInstance().millis().add(expected, -16);                MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));        MutableDateTime mdt = new MutableDateTime();        test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it        assertEquals(expected, mdt.getMillis());    }        public void testAddIntoRWI3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.addInto(null, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testToString() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString());                test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 0);        assertEquals("PT0S", test.toString());                test = new MutablePeriod(12345L);        assertEquals("PT12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToPeriod() {        MutablePeriod test = new MutablePeriod(123L);        Period result = test.toPeriod();        assertEquals(test, result);    }    public void testToMutablePeriod() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod result = test.toMutablePeriod();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToDurationMillis() {        MutablePeriod test = new MutablePeriod(123L);        assertEquals(123L, test.toDurationMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testToDuration() {        MutablePeriod test = new MutablePeriod(123L);        assertEquals(new Duration(123L), test.toDuration());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.toDuration();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    public void testCopy() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod copy = test.copy();        assertEquals(test.getPeriodType(), copy.getPeriodType());        assertEquals(test.isPrecise(), copy.isPrecise());        assertEquals(test.toDurationMillis(), copy.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testClone() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod copy = (MutablePeriod) test.clone();        assertEquals(test.getPeriodType(), copy.getPeriodType());        assertEquals(test.isPrecise(), copy.isPrecise());        assertEquals(test.toDurationMillis(), copy.toDurationMillis());    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.Calendar;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.List;import junit.framework.TestSuite;import org.joda.test.time.BulkTest;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.DateTimeComparator class. * * @author Guy Allard */public class TestDateTimeComparator extends BulkTest {    private static final Chronology ISO = ISOChronology.getInstance();        /**     * The main method for this test program.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestDateTimeComparator.class);    }    /**     * TestDateTimeComparator constructor.     * @param name     */    public TestDateTimeComparator(String name) {        super(name);    }    /**     * A reference to a DateTime object.     */    DateTime aDateTime = null;    /**     * A reference to a DateTime object.     */    DateTime bDateTime = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for millis of seconds.     */    Comparator cMillis = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for seconds.     */    Comparator cSecond = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for minutes.     */    Comparator cMinute = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for hours.     */    Comparator cHour = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the week.     */    Comparator cDayOfWeek = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the month.     */    Comparator cDayOfMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the year.     */    Comparator cDayOfYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for week of the weekyear.     */    Comparator cWeekOfWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year given a week of the year.     */    Comparator cWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for months.     */    Comparator cMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year.     */    Comparator cYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the date portion of an     * object.     */    Comparator cDate = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the time portion of an     * object.     */    Comparator cTime = null;    /**     * Junit <code>setUp()</code> method.     */    public void setUp() /* throws Exception */ {        Chronology chrono = ISOChronology.getInstanceUTC();        // super.setUp();        // Obtain comparator's        cMillis = DateTimeComparator.getInstance(null, chrono.secondOfMinute());        cSecond = DateTimeComparator.getInstance(chrono.secondOfMinute(), chrono.minuteOfHour());        cMinute = DateTimeComparator.getInstance(chrono.minuteOfHour(), chrono.hourOfDay());        cHour = DateTimeComparator.getInstance(chrono.hourOfDay(), chrono.dayOfYear());        cDayOfWeek = DateTimeComparator.getInstance(chrono.dayOfWeek(), chrono.weekOfWeekyear());        cDayOfMonth = DateTimeComparator.getInstance(chrono.dayOfMonth(), chrono.monthOfYear());        cDayOfYear = DateTimeComparator.getInstance(chrono.dayOfYear(), chrono.year());        cWeekOfWeekyear = DateTimeComparator.getInstance(chrono.weekOfWeekyear(), chrono.weekyear());        cWeekyear = DateTimeComparator.getInstance(chrono.weekyear());        cMonth = DateTimeComparator.getInstance(chrono.monthOfYear(), chrono.year());        cYear = DateTimeComparator.getInstance(chrono.year());        cDate = DateTimeComparator.getDateOnlyInstance(chrono);        cTime = DateTimeComparator.getTimeOnlyInstance(chrono);    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();        aDateTime = null;        bDateTime = null;        //        cMillis = null;        cSecond = null;        cMinute = null;        cHour = null;        cDayOfWeek = null;        cDayOfMonth = null;        cDayOfYear = null;        cWeekOfWeekyear = null;        cWeekyear = null;        cMonth = null;        cYear = null;        cDate = null;        cTime = null;    }    //-----------------------------------------------------------------------    public void testClass() {        assertEquals(true, Modifier.isPublic(DateTimeComparator.class.getModifiers()));        assertEquals(false, Modifier.isFinal(DateTimeComparator.class.getModifiers()));        assertEquals(1, DateTimeComparator.class.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(DateTimeComparator.class.getDeclaredConstructors()[0].getModifiers()));    }        //-----------------------------------------------------------------------    public void testStaticGetInstance() {        DateTimeComparator c = DateTimeComparator.getInstance();        assertEquals(null, c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[]", c.toString());    }            public void testStaticGetDateOnlyInstance() {        DateTimeComparator c = DateTimeComparator.getDateOnlyInstance(ISO);        assertEquals(ISO.dayOfYear(), c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[dayOfYear-]", c.toString());                c = DateTimeComparator.getDateOnlyInstance(null);        assertEquals(ISO.dayOfYear(), c.getLowerLimit());        assertEquals(null, c.getUpperLimit());    }    public void testStaticGetTimeOnlyInstance() {        DateTimeComparator c = DateTimeComparator.getTimeOnlyInstance(ISO);        assertEquals(null, c.getLowerLimit());        assertEquals(ISO.dayOfYear(), c.getUpperLimit());        assertEquals("DateTimeComparator[-dayOfYear]", c.toString());                c = DateTimeComparator.getTimeOnlyInstance(null);        assertEquals(null, c.getLowerLimit());        assertEquals(ISO.dayOfYear(), c.getUpperLimit());    }    public void testStaticGetInstanceLower() {        DateTimeComparator c = DateTimeComparator.getInstance(ISO.hourOfDay());        assertEquals(ISO.hourOfDay(), c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay-]", c.toString());                c = DateTimeComparator.getInstance(null);        assertSame(DateTimeComparator.getInstance(), c);    }    public void testStaticGetInstanceLowerUpper() {        DateTimeComparator c = DateTimeComparator.getInstance(ISO.hourOfDay(), ISO.dayOfYear());        assertEquals(ISO.hourOfDay(), c.getLowerLimit());        assertEquals(ISO.dayOfYear(), c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay-dayOfYear]", c.toString());                c = DateTimeComparator.getInstance(ISO.hourOfDay(), ISO.hourOfDay());        assertEquals(ISO.hourOfDay(), c.getLowerLimit());        assertEquals(ISO.hourOfDay(), c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay]", c.toString());                c = DateTimeComparator.getInstance(null, null);        assertSame(DateTimeComparator.getInstance(), c);                try {            DateTimeComparator.getInstance(ISO.dayOfYear(), ISO.hourOfDay());            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testEqualsHashCode() {        DateTimeComparator c1 = DateTimeComparator.getInstance();        assertEquals(true, c1.equals(c1));        assertEquals(false, c1.equals(null));        assertEquals(true, c1.hashCode() == c1.hashCode());                DateTimeComparator c2 = DateTimeComparator.getTimeOnlyInstance(ISOChronology.getInstance());        assertEquals(true, c2.equals(c2));        assertEquals(false, c2.equals(c1));        assertEquals(false, c1.equals(c2));        assertEquals(false, c2.equals(null));        assertEquals(false, c1.hashCode() == c2.hashCode());                DateTimeComparator c3 = DateTimeComparator.getTimeOnlyInstance(ISOChronology.getInstance());        assertEquals(true, c3.equals(c3));        assertEquals(false, c3.equals(c1));        assertEquals(true, c3.equals(c2));        assertEquals(false, c1.equals(c3));        assertEquals(true, c2.equals(c3));        assertEquals(false, c1.hashCode() == c3.hashCode());        assertEquals(true, c2.hashCode() == c3.hashCode());                DateTimeComparator c4 = DateTimeComparator.getDateOnlyInstance(ISOChronology.getInstance());        assertEquals(false, c4.hashCode() == c3.hashCode());    }        //-----------------------------------------------------------------------    public void testSerialization1() throws Exception {        DateTimeField f = ISO.dayOfYear();        f.toString();        DateTimeComparator c = DateTimeComparator.getInstance(ISO.hourOfDay(), ISO.dayOfYear());                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(c);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeComparator result = (DateTimeComparator) ois.readObject();        ois.close();                assertEquals(c, result);    }    //-----------------------------------------------------------------------    public void testSerialization2() throws Exception {        DateTimeComparator c = DateTimeComparator.getInstance();                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(c);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeComparator result = (DateTimeComparator) ois.readObject();        ois.close();                assertSame(c, result);    }    //-----------------------------------------------------------------------    /**     * Test all basic comparator operation with DateTime objects.     */    public void testBasicComps1() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with ReadableInstant objects.     */    public void testBasicComps2() {        ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with java Date objects.     */    public void testBasicComps3() {        Date aDateTime            = new Date( System.currentTimeMillis() );        Date bDateTime            = new Date( aDateTime.getTime() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Long objects.     */    public void testBasicComps4() {        Long aDateTime            = new Long( System.currentTimeMillis() );        Long bDateTime            = new Long( aDateTime.longValue() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Calendar objects.     */    public void testBasicComps5() {        Calendar aDateTime            = Calendar.getInstance();   // right now        Calendar bDateTime = aDateTime;        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test unequal comparisons with millis of second comparators.     */    public void testMillis() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC );        assertEquals( "MillisM1", -1, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "MillisP1", 1, cMillis.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with second comparators.     */    public void testSecond() {        aDateTime = getADate( "1969-12-31T23:59:58" );        bDateTime = getADate( "1969-12-31T23:50:59" );        assertEquals( "SecondM1a", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1a", 1, cSecond.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:00:01" );        assertEquals( "SecondM1b", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1b", 1, cSecond.compare( bDateTime, aDateTime ) );    }   // end of testSecond    /**     * Test unequal comparisons with minute comparators.     */    public void testMinute() {        aDateTime = getADate( "1969-12-31T23:58:00" );        bDateTime = getADate( "1969-12-31T23:59:00" );        assertEquals( "MinuteM1a", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1a", 1, cMinute.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:01:00" );        assertEquals( "MinuteM1b", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1b", 1, cMinute.compare( bDateTime, aDateTime ) );    }   // end of testMinute    /**     * Test unequal comparisons with hour comparators.     */    public void testHour() {        aDateTime = getADate( "1969-12-31T22:00:00" );        bDateTime = getADate( "1969-12-31T23:00:00" );        assertEquals( "HourM1a", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1a", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T01:00:00" );        assertEquals( "HourM1b", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1b", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "HourP1c", 1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourM1c", -1, cHour.compare( bDateTime, aDateTime ) );    }   // end of testHour    /**     * Test unequal comparisons with day of week comparators.     */    public void testDOW() {        /*         * Dates chosen when I wrote the code, so I know what day of         * the week it is.         */        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOWM1a", -1, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOWP1a", 1, cDayOfWeek.compare( bDateTime, aDateTime ) );    }   // end of testDOW    /**     * Test unequal comparisons with day of month comparators.     */    public void testDOM() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOMM1a", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1a", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-12-01T00:00:00" );        bDateTime = getADate( "1814-04-30T00:00:00" );        assertEquals( "DOMM1b", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1b", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );    }   // end of testDOM    /**     * Test unequal comparisons with day of year comparators.     */    public void testDOY() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOYM1a", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1a", 1, cDayOfYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-02-29T00:00:00" );        bDateTime = getADate( "1814-11-30T00:00:00" );        assertEquals( "DOYM1b", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1b", 1, cDayOfYear.compare( bDateTime, aDateTime ) );    }   // end of testDOY    /**     * Test unequal comparisons with week of weekyear comparators.     */    public void testWOW() {        // 1st week of year contains Jan 04.        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "2000-01-11T00:00:00" );        assertEquals( "WOWM1a", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1a", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "1999-12-31T00:00:00" );        assertEquals( "WOWM1b", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1b", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with year given the week comparators.     */    public void testWOYY() {        // How do I test the end conditions of this?        // Don't understand ......        aDateTime = getADate( "1998-12-31T23:59:59" );        bDateTime = getADate( "1999-01-01T00:00:00" );        assertEquals( "YOYYZ", 0, cWeekyear.compare( aDateTime, bDateTime ) );        bDateTime = getADate( "1999-01-04T00:00:00" );        assertEquals( "YOYYM1", -1, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "YOYYP1", 1, cWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testWOYY    /**     * Test unequal comparisons with month comparators.     */    public void testMonth() {        aDateTime = getADate( "2002-04-30T00:00:00" );        bDateTime = getADate( "2002-05-01T00:00:00" );        assertEquals( "MONTHM1a", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1a", 1, cMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1900-01-01T00:00:00" );        bDateTime = getADate( "1899-12-31T00:00:00" );        assertEquals( "MONTHM1b", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1b", 1, cMonth.compare( bDateTime, aDateTime ) );    }   // end of testMonth    /**     * Test unequal comparisons with year comparators.     */    public void testYear() {        aDateTime = getADate( "2000-01-01T00:00:00" );        bDateTime = getADate( "2001-01-01T00:00:00" );        assertEquals( "YEARM1a", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1a", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1968-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1b", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1b", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1c", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1c", 1, cYear.compare( bDateTime, aDateTime ) );    }   // end of testYear    /*     * 'List' processing tests follow.     */     /**      * Test sorting with full default comparator.      */     public void testListBasic() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-01-20T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListBasic", !isSorted1, isSorted2);     } // end of testListBasic     /**      * Test sorting with millis of second comparator.      */    public void testListMillis() {        //        List sl = new ArrayList();        long base = 12345L * 1000L;        sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) );        //        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMillis );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListLillis", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with second comparator.      */    public void testListSecond() {        String[] dtStrs = {            "1999-02-01T00:00:10",            "1999-02-01T00:00:30",            "1999-02-01T00:00:25",            "1999-02-01T00:00:18",            "1999-02-01T00:00:01",            "1999-02-01T00:00:59",            "1999-02-01T00:00:22"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cSecond );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListSecond", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with minute comparator.      */    public void testListMinute() {        String[] dtStrs = {            "1999-02-01T00:10:00",            "1999-02-01T00:30:00",            "1999-02-01T00:25:00",            "1999-02-01T00:18:00",            "1999-02-01T00:01:00",            "1999-02-01T00:59:00",            "1999-02-01T00:22:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMinute );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMinute", !isSorted1, isSorted2);    } // end of testListMinute     /**      * Test sorting with hour comparator.      */    public void testListHour() {        String[] dtStrs = {            "1999-02-01T10:00:00",            "1999-02-01T23:00:00",            "1999-02-01T01:00:00",            "1999-02-01T15:00:00",            "1999-02-01T05:00:00",            "1999-02-01T20:00:00",            "1999-02-01T17:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cHour );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListHour", !isSorted1, isSorted2);    } // end of testListHour     /**      * Test sorting with day of week comparator.      */    public void testListDOW() {        String[] dtStrs = {            /* 2002-04-15 = Monday */            "2002-04-21T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-20T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfWeek );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOW", !isSorted1, isSorted2);    } // end of testListDOW     /**      * Test sorting with day of month comparator.      */    public void testListDOM() {        String[] dtStrs = {            /* 2002-04-14 = Sunday */            "2002-04-20T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-14T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOM", !isSorted1, isSorted2);    } // end of testListDOM     /**      * Test sorting with day of year comparator.      */    public void testListDOY() {        String[] dtStrs = {            "2002-04-20T10:00:00",            "2002-01-16T10:00:00",            "2002-12-31T10:00:00",            "2002-09-14T10:00:00",            "2002-09-19T10:00:00",            "2002-02-14T10:00:00",            "2002-10-30T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOY", !isSorted1, isSorted2);    } // end of testListDOY     /**      * Test sorting with week of weekyear comparator.      */    public void testListWOW() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekOfWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListWOW", !isSorted1, isSorted2);    } // end of testListWOW     /**      * Test sorting with year (given week) comparator.      */    public void testListYOYY() {        // ?? How to catch end conditions ??        String[] dtStrs = {            "2010-04-01T10:00:00",            "2002-01-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYOYY", !isSorted1, isSorted2);    } // end of testListYOYY     /**      * Test sorting with month comparator.      */    public void testListMonth() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMonth", !isSorted1, isSorted2);    } // end of testListMonth     /**      * Test sorting with year comparator.      */     public void testListYear() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-02-01T00:00:00",            "2525-02-01T00:00:00",            "1776-02-01T00:00:00",            "1863-02-01T00:00:00",            "1066-02-01T00:00:00",            "2100-02-01T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYear", !isSorted1, isSorted2);     } // end of testListYear     /**      * Test sorting with date only comparator.      */    public void testListDate() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-10-03T00:00:00",            "2525-05-20T00:00:00",            "1776-12-25T00:00:00",            "1863-01-31T00:00:00",            "1066-09-22T00:00:00",            "2100-07-04T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDate );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDate", !isSorted1, isSorted2);    } // end of testListDate     /**      * Test sorting with time only comparator.      */    public void testListTime() {        String[] dtStrs = {            "1999-02-01T01:02:05",            "1999-02-01T22:22:22",            "1999-02-01T05:30:45",            "1999-02-01T09:17:59",            "1999-02-01T09:17:58",            "1999-02-01T15:30:00",            "1999-02-01T17:00:44"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cTime );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListTime", !isSorted1, isSorted2);    } // end of testListTime    /**     * Test comparator operation with null object(s).     */    public void testNullDT() {        // null means now        aDateTime = getADate("2000-01-01T00:00:00");        assertTrue(cYear.compare(null, aDateTime) > 0);        assertTrue(cYear.compare(aDateTime, null) < 0);    }    /**     * Test comparator operation with an invalid object type.     */    public void testInvalidObj() {        aDateTime = getADate("2000-01-01T00:00:00");        try {            cYear.compare("FreeBird", aDateTime);            fail("Invalid object failed");        } catch (IllegalArgumentException cce) {}    }    // private convenience methods    //-----------------------------------------------------------------------    /**     * Creates a date to test with.     */    private DateTime getADate(String s) {        DateTime retDT = null;        try {            retDT = new DateTime(s, DateTimeZone.UTC);        } catch (IllegalArgumentException pe) {            pe.printStackTrace();        }        return retDT;    }    /**     * Load a string array.     */    private List loadAList(String[] someStrs) {        List newList = new ArrayList();        try {            for (int i = 0; i < someStrs.length; ++i) {                newList.add(new DateTime(someStrs[i], DateTimeZone.UTC));            } // end of the for        } catch (IllegalArgumentException pe) {            pe.printStackTrace();        }        return newList;    }    /**     * Check if the list is sorted.     */    private boolean isListSorted(List tl) {        // tl must be populated with DateTime objects.        DateTime lhDT = (DateTime)tl.get(0);        DateTime rhDT = null;        Long lhVal = new Long( lhDT.getMillis() );        Long rhVal = null;        for (int i = 1; i < tl.size(); ++i) {            rhDT = (DateTime)tl.get(i);            rhVal = new Long( rhDT.getMillis() );            if ( lhVal.compareTo( rhVal) > 0 ) return false;            //            lhVal = rhVal;  // swap for next iteration            lhDT = rhDT;    // swap for next iteration        }        return true;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.IntervalConverter;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */public class TestMutableInterval_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Constructors.class);    }    public TestMutableInterval_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testConstructor() throws Throwable {        MutableInterval test = new MutableInterval();        assertEquals(0L, test.getStartMillis());        assertEquals(0L, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt1.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_long_long3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new MutableInterval(dt1.getMillis(), dt2.getMillis());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0));        Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1));        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1, (ReadableInstant) null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval((ReadableInstant) null, dt2);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI6() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1, dt1);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI7() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new MutableInterval(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RP1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().days().add(result, 3);        result = ISOChronology.getInstance().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP3() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, 6);        result = ISOChronology.getInstanceUTC().days().add(result, 3);        result = ISOChronology.getInstanceUTC().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, 1);        result = ISOChronology.getInstance().millis().add(result, 23);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP5() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadablePeriod) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RP6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval(dt, (ReadablePeriod) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RP7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                MutableInterval test = new MutableInterval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new MutableInterval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RI1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().days().add(result, -3);        result = ISOChronology.getInstance().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI3() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, -6);        result = ISOChronology.getInstanceUTC().days().add(result, -3);        result = ISOChronology.getInstanceUTC().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, -1);        result = ISOChronology.getInstance().millis().add(result, -23);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI5() throws Throwable {        MutableInterval test = new MutableInterval((ReadablePeriod) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval((ReadablePeriod) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                MutableInterval test = new MutableInterval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new MutableInterval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(result - TEST_TIME_NOW);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableDuration) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RD3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval(dt, (ReadableDuration) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RD4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Duration dur = new Duration(result - TEST_TIME_NOW);                MutableInterval test = new MutableInterval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new MutableInterval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(TEST_TIME_NOW - result);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI2() throws Throwable {        MutableInterval test = new MutableInterval((ReadableDuration) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval((ReadableDuration) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Duration dur = new Duration(TEST_TIME_NOW - result);                MutableInterval test = new MutableInterval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new MutableInterval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_Object1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval base = new MutableInterval(dt1, dt2);                MutableInterval test = new MutableInterval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                MutableInterval test = new MutableInterval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object4() throws Throwable {        MockInterval base = new MockInterval();        MutableInterval test = new MutableInterval(base);        assertEquals(base.getStartMillis(), test.getStartMillis());        assertEquals(base.getEndMillis(), test.getEndMillis());    }    public void testConstructor_Object5() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter("");        IntervalConverter conv = new IntervalConverter() {            public long[] getIntervalMillis(Object object) {                return null;            }            public void setInto(ReadWritableInterval interval, Object object) {                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return String.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);            DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);            MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString());            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    public void testConstructor_Object6() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new MutableInterval(0L, 0L));        IntervalConverter conv = new IntervalConverter() {            public long[] getIntervalMillis(Object object) {                return null;            }            public void setInto(ReadWritableInterval interval, Object object) {                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return ReadableInterval.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            Interval base = new Interval(-1000L, 1000L);            MutableInterval test = new MutableInterval(base);            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    class MockInterval implements ReadableInterval {        public long getStartMillis() {            return 1234L;        }        public Instant getStartInstant() {            return new Instant(1234L);        }        public long getEndMillis() {            return 5678L;        }        public Instant getEndInstant() {            return new Instant(5678L);        }        public long getDurationMillis() {            return (5678L - 1234L);        }        public Duration getDuration() {            return new Duration(5678L - 1234L);        }        public boolean contains(long millisInstant) {            return false;        }        public boolean containsNow() {            return false;        }        public boolean contains(ReadableInstant instant) {            return false;        }        public boolean contains(ReadableInterval interval) {            return false;        }        public boolean overlaps(ReadableInterval interval) {            return false;        }        public boolean isBefore(long millisInstant) {            return false;        }        public boolean isBeforeNow() {            return false;        }        public boolean isBefore(ReadableInstant instant) {            return false;        }        public boolean isAfter(long millisInstant) {            return false;        }        public boolean isAfterNow() {            return false;        }        public boolean isAfter(ReadableInstant instant) {            return false;        }        public Interval toInterval() {            return null;        }        public MutableInterval toMutableInterval() {            return null;        }        public Period toPeriod() {            return null;        }        public Period toPeriod(PeriodType type) {            return null;        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Sets extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Sets.class);    }    public TestMutableDateTime_Sets(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testSetMillis_long1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setMillis(TEST_TIME2);        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetChronology_Chronology1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setChronology(GregorianChronology.getInstance(PARIS));        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), test.getChronology());    }            public void testSetChronology_Chronology2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setChronology(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetZone_DateTimeZone1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZone(PARIS);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());    }            public void testSetZone_DateTimeZone2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZone(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }            //-----------------------------------------------------------------------    public void testSetZoneRetainFields_DateTimeZone1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZoneRetainFields(PARIS);        assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZoneRetainFields(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone3() {        MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        test.setZoneRetainFields(null);        assertEquals(TEST_TIME1 + DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertEquals(GregorianChronology.getInstance(), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone4() {        Chronology chrono = new MockNullZoneChronology();        MutableDateTime test = new MutableDateTime(TEST_TIME1, chrono);        test.setZoneRetainFields(PARIS);        assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertSame(chrono, test.getChronology());    }            //-----------------------------------------------------------------------    public void testSetMillis_Object1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setMillis(new Long(TEST_TIME2));        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    public void testSetMillis_Object2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setMillis(null);        assertEquals(TEST_TIME_NOW, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSet_DateTimeField_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.set(ISOChronology.getInstance().year(), 2010);        assertEquals(2010, test.getYear());    }    public void testSet_DateTimeField_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.set(null, 2010);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    public void testSet_DateTimeField_int3() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.set(ISOChronology.getInstance().monthOfYear(), 13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetDate_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(2010, 12, 3);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    public void testSetDate_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setDate(2010, 13, 3);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetDate_long1() {        long setter = new DateTime(2010, 12, 3, 5, 7, 9, 501).getMillis();        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(setter);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetDate_Object1() {        Long setter = new Long(new DateTime(2010, 12, 3, 5, 7, 9, 501).getMillis());        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(setter);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    public void testSetDate_Object2() {        MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501);        test.setDate(null);  // sets to TEST_TIME_NOW        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetTime_int_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(5, 6, 7, 8);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    public void testSetTime_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setTime(60, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetTime_long1() {        long setter = new DateTime(2010, 12, 3, 5, 7, 9, 11).getMillis();        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetTime_Object1() {        Long setter = new Long(new DateTime(2010, 12, 3, 5, 7, 9, 11).getMillis());        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    public void testSetTime_Object2() {        MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501);        test.setTime(null);  // sets to TEST_TIME_NOW, which has no time part        assertEquals(2010, test.getYear());        assertEquals(7, test.getMonthOfYear());        assertEquals(8, test.getDayOfMonth());        assertEquals(new DateTime(TEST_TIME_NOW).getHourOfDay(), test.getHourOfDay());        assertEquals(new DateTime(TEST_TIME_NOW).getMinuteOfHour(), test.getMinuteOfHour());        assertEquals(new DateTime(TEST_TIME_NOW).getSecondOfMinute(), test.getSecondOfMinute());        assertEquals(new DateTime(TEST_TIME_NOW).getMillisOfSecond(), test.getMillisOfSecond());    }    public void testSetTime_Object3() {        DateTime temp = new DateTime(2010, 12, 3, 5, 7, 9, 11);        DateTime setter = new DateTime(temp.getMillis(), new MockNullZoneChronology());        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetDateTime_int_int_int_int_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDateTime(2010, 12, 3, 5, 6, 7, 8);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }        public void testSetDateTime_int_int_int_int_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setDateTime(2010, 13, 3, 5, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {        }        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetDateTime_long1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setDateTime(TEST_TIME2);        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetDateTime_Object1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setDateTime(new Long(TEST_TIME2));        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    public void testSetDateTime_Object2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setDateTime(null);        assertEquals(TEST_TIME_NOW, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setYear(2010);        assertEquals("2010-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMonthOfYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMonthOfYear(12);        assertEquals("2002-12-09T05:06:07.008Z", test.toString());    }    public void testSetMonthOfYear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMonthOfYear(13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfMonth_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfMonth(17);        assertEquals("2002-06-17T05:06:07.008+01:00", test.toString());    }    public void testSetDayOfMonth_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfMonth(31);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfYear(3);        assertEquals("2002-01-03T05:06:07.008Z", test.toString());    }    public void testSetDayOfYear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfYear(366);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetWeekyear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setWeekyear(2001);        assertEquals("2001-06-10T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetWeekOfWeekyear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setWeekOfWeekyear(2);        assertEquals("2002-01-13T05:06:07.008Z", test.toString());    }    public void testSetWeekOfWeekyear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setWeekOfWeekyear(53);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfWeek_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfWeek(5);        assertEquals("2002-06-07T05:06:07.008+01:00", test.toString());    }    public void testSetDayOfWeek_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfWeek(8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetHourOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setHourOfDay(13);        assertEquals("2002-06-09T13:06:07.008+01:00", test.toString());    }    public void testSetHourOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setHourOfDay(24);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMinuteOfHour_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMinuteOfHour(13);        assertEquals("2002-06-09T05:13:07.008+01:00", test.toString());    }    public void testSetMinuteOfHour_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMinuteOfHour(60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMinuteOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMinuteOfDay(13);        assertEquals("2002-06-09T00:13:07.008+01:00", test.toString());    }    public void testSetMinuteOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMinuteOfDay(24 * 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetSecondOfMinute_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setSecondOfMinute(13);        assertEquals("2002-06-09T05:06:13.008+01:00", test.toString());    }    public void testSetSecondOfMinute_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setSecondOfMinute(60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetSecondOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setSecondOfDay(13);        assertEquals("2002-06-09T00:00:13.008+01:00", test.toString());    }    public void testSetSecondOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setSecondOfDay(24 * 60 * 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMilliOfSecond_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMillisOfSecond(13);        assertEquals("2002-06-09T05:06:07.013+01:00", test.toString());    }    public void testSetMilliOfSecond_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMillisOfSecond(1000);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMilliOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMillisOfDay(13);        assertEquals("2002-06-09T00:00:00.013+01:00", test.toString());    }    public void testSetMilliOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMillisOfDay(24 * 60 * 60 * 1000);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInterval_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInterval_Basics.class);    }    public TestInterval_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getStartInstant().getMillis());        assertEquals(TEST_TIME2, test.getEndMillis());        assertEquals(TEST_TIME2, test.getEndInstant().getMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());    }    public void testGetDuration1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());    }    public void testGetDuration2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME1);        assertSame(Duration.ZERO, test.getDuration());    }    public void testEqualsHashCode() {        Interval test1 = new Interval(TEST_TIME1, TEST_TIME2);        Interval test2 = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Interval test3 = new Interval(TEST_TIME_NOW, TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                MutableInterval test4 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test4));        assertEquals(true, test2.equals(test4));        assertEquals(false, test3.equals(test4));        assertEquals(true, test4.equals(test1));        assertEquals(true, test4.equals(test2));        assertEquals(false, test4.equals(test3));        assertEquals(true, test1.hashCode() == test4.hashCode());        assertEquals(true, test2.hashCode() == test4.hashCode());        assertEquals(false, test3.hashCode() == test4.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInterval()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInterval extends AbstractInterval {        public MockInterval() {            super();        }        public long getStartMillis() {            return TEST_TIME1;        }        public long getEndMillis() {            return TEST_TIME2;        }    }    //-----------------------------------------------------------------------    public void testContains_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(TEST_TIME1));        assertEquals(false, test.contains(TEST_TIME1 - 1));        assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2));        assertEquals(false, test.contains(TEST_TIME2));        assertEquals(true, test.contains(TEST_TIME2 - 1));    }    public void testContainsNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(true, test.containsNow());    }    public void testContains_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(new Instant(TEST_TIME1)));        assertEquals(false, test.contains(new Instant(TEST_TIME1 - 1)));        assertEquals(true, test.contains(new Instant(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2)));        assertEquals(false, test.contains(new Instant(TEST_TIME2)));        assertEquals(true, test.contains(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.contains((ReadableInstant) null));    }    //-----------------------------------------------------------------------    public void testContains_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1)));                assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));                try {            test.contains((ReadableInterval) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testOverlaps_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));                assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));                try {            test.overlaps((ReadableInterval) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testIsBefore_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(TEST_TIME1 - 1));        assertEquals(false, test.isBefore(TEST_TIME1));        assertEquals(false, test.isBefore(TEST_TIME1 + 1));                assertEquals(false, test.isBefore(TEST_TIME2 - 1));        assertEquals(true, test.isBefore(TEST_TIME2));        assertEquals(true, test.isBefore(TEST_TIME2 + 1));    }    public void testIsBeforeNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(false, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(true, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 + 1);        assertEquals(true, test.isBeforeNow());    }    public void testIsBefore_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isBefore(null));    }    //-----------------------------------------------------------------------    public void testIsAfter_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(TEST_TIME1 - 1));        assertEquals(false, test.isAfter(TEST_TIME1));        assertEquals(false, test.isAfter(TEST_TIME1 + 1));                assertEquals(false, test.isAfter(TEST_TIME2 - 1));        assertEquals(false, test.isAfter(TEST_TIME2));        assertEquals(false, test.isAfter(TEST_TIME2 + 1));    }    public void testIsAfterNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(true, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(false, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + 1);        assertEquals(false, test.isAfterNow());    }    public void testIsAfter_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Instant(TEST_TIME2 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isAfter(null));    }    //-----------------------------------------------------------------------    public void testToInterval1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.toInterval();        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testToMutableInterval1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        MutableInterval result = test.toMutableInterval();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToPeriod() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod();        assertEquals(PeriodType.getAllType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType1() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod(null);        assertEquals(PeriodType.getAllType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType2() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod(PeriodType.getYearWeekType());        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(9, result.getWeeks());        assertEquals(2, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType3() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod(PeriodType.getYearWeekType());        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(0, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Interval result = (Interval) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);        Interval test = new Interval(dt1, dt2);        assertEquals("2004-06-09T07:08:09.010/2005-08-13T12:14:16.018", test.toString());    }    //-----------------------------------------------------------------------    public void testWithStartMillis_long1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStartMillis(TEST_TIME1 - 1);        assertEquals(TEST_TIME1 - 1, result.getStartMillis());        assertEquals(TEST_TIME2, result.getEndMillis());    }    public void testWithStartMillis_long2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withStartMillis(TEST_TIME2 + 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithStartMillis_long3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStartMillis(TEST_TIME1);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithStartInstant_RI1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStartInstant(new Instant(TEST_TIME1 - 1));        assertEquals(TEST_TIME1 - 1, result.getStartMillis());        assertEquals(TEST_TIME2, result.getEndMillis());    }    public void testWithStartInstant_RI2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withStartInstant(new Instant(TEST_TIME2 + 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithStartInstant_RI3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStartInstant(null);        assertEquals(TEST_TIME_NOW, result.getStartMillis());        assertEquals(TEST_TIME2, result.getEndMillis());    }    //-----------------------------------------------------------------------    public void testWithEndMillis_long1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEndMillis(TEST_TIME2 - 1);        assertEquals(TEST_TIME1, result.getStartMillis());        assertEquals(TEST_TIME2 - 1, result.getEndMillis());    }    public void testWithEndMillis_long2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withEndMillis(TEST_TIME1 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithEndMillis_long3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEndMillis(TEST_TIME2);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithEndInstant_RI1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEndInstant(new Instant(TEST_TIME2 - 1));        assertEquals(TEST_TIME1, result.getStartMillis());        assertEquals(TEST_TIME2 - 1, result.getEndMillis());    }    public void testWithEndInstant_RI2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withEndInstant(new Instant(TEST_TIME1 - 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithEndInstant_RI3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEndInstant(null);        assertEquals(TEST_TIME1, result.getStartMillis());        assertEquals(TEST_TIME_NOW, result.getEndMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in Joda Time. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAllPackages extends TestCase {    public TestAllPackages(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(org.joda.time.TestAll.suite());        suite.addTest(org.joda.time.chrono.TestAll.suite());        suite.addTest(org.joda.time.chrono.gj.TestAll.suite());        suite.addTest(org.joda.time.convert.TestAll.suite());        suite.addTest(org.joda.time.tz.TestAll.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAllPackages.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.AbstractChronology;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Basics.class);    }    public TestDateTime_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet() {        DateTime test = new DateTime();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        DateTime test = new DateTime();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(1, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(60, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(60 * 60, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(60 * 60 * 1000, test.getMillisOfDay());    }    public void testEqualsHashCode() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                DateTime test3 = new DateTime(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1, GregorianChronology.getInstance())));        assertEquals(true, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, new MockEqualsChronology())));        assertEquals(false, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, ISOChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    class MockEqualsChronology extends AbstractChronology {        public boolean equals(Object obj) {            return obj instanceof MockEqualsChronology;        }        public DateTimeZone getZone() {            return null;        }        public Chronology withUTC() {            return this;        }        public Chronology withZone(DateTimeZone zone) {            return this;        }        public String toString() {            return "";        }    }    public void testCompareTo() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        //-----------------------------------------------------------------------    public void testIsEqual_long() {        assertEquals(false, new DateTime(TEST_TIME1).isEqual(TEST_TIME2));        assertEquals(true, new DateTime(TEST_TIME1).isEqual(TEST_TIME1));        assertEquals(false, new DateTime(TEST_TIME2).isEqual(TEST_TIME1));    }        public void testIsEqualNow() {        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqualNow());        assertEquals(true, new DateTime(TEST_TIME_NOW).isEqualNow());        assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqualNow());    }        public void testIsEqual_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new DateTime(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqual(null));    }        //-----------------------------------------------------------------------    public void testIsBefore_long() {        assertEquals(true, new DateTime(TEST_TIME1).isBefore(TEST_TIME2));        assertEquals(false, new DateTime(TEST_TIME1).isBefore(TEST_TIME1));        assertEquals(false, new DateTime(TEST_TIME2).isBefore(TEST_TIME1));    }        public void testIsBeforeNow() {        assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBeforeNow());        assertEquals(false, new DateTime(TEST_TIME_NOW).isBeforeNow());        assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBeforeNow());    }        public void testIsBefore_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new DateTime(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBefore(null));    }        //-----------------------------------------------------------------------    public void testIsAfter_long() {        assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME2));        assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME1));        assertEquals(true, new DateTime(TEST_TIME2).isAfter(TEST_TIME1));    }        public void testIsAfterNow() {        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfterNow());        assertEquals(false, new DateTime(TEST_TIME_NOW).isAfterNow());        assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfterNow());    }        public void testIsAfter_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new DateTime(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DateTime test = new DateTime(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTime result = (DateTime) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString());                test = new DateTime(TEST_TIME_NOW, PARIS);        assertEquals("2002-06-09T02:00:00.000+02:00", test.toString());    }    public void testToString_String() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("2002 01", test.toString("yyyy HH"));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null));    }    public void testToString_String_String() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        DateTime test = new DateTime(TEST_TIME1);        Instant result = test.toInstant();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTime() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime();        assertSame(test, result);    }    public void testToDateTime_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime(LONDON);        assertSame(test, result);        test = new DateTime(TEST_TIME1);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(PARIS, result.getZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateTime(TEST_TIME1);        result = test.toDateTime((DateTimeZone) null);        assertSame(test, result);    }    public void testToDateTime_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertSame(test, result);        test = new DateTime(TEST_TIME1);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toDateTime((Chronology) null);        assertSame(test, result);    }    public void testToTrustedISODateTime() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toTrustedISODateTime();        assertSame(test, result);        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());//        test = new MockUntrustedDateTime(TEST_TIME1);//        result = test.toTrustedISODateTime();//        assertSame(DateTime.class, result.getClass());//        assertSame(ISOChronology.class, result.getChronology().getClass());//        assertEquals(test.getMillis(), result.getMillis());//        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1, new MockUntrustedZone("Europe/Paris"));        result = test.toTrustedISODateTime();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());    }//    static class MockUntrustedDateTime extends DateTime {//        MockUntrustedDateTime(long millis) {//            super(millis);//        }//    }    static class MockUntrustedZone extends DateTimeZone {        MockUntrustedZone(String id) {            super(id);        }        public String getNameKey(long instant) {            return null;        }        public int getOffset(long instant) {            return 60 * 60 * 1000;        }        public int getStandardOffset(long instant) {            return 60 * 60 * 1000;        }        public boolean isFixed() {            return true;        }        public long nextTransition(long instant) {            return 0;        }        public long previousTransition(long instant) {            return 0;        }        public boolean equals(Object object) {            return false;        }    }    public void testToMutableDateTime() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        DateTime test = new DateTime(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        DateTime test = new DateTime(TEST_TIME1);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        DateTime test = new DateTime(TEST_TIME1);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withMillis(TEST_TIME1);        assertSame(test, result);    }    public void testWithChronology_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withChronology(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withChronology(ISOChronology.getInstance());        assertSame(test, result);    }    public void testWithZone_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withZone(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withZone(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withZone(null);        assertSame(test, result);    }    public void testWithZoneRetainFields_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withZoneRetainFields(PARIS);        assertEquals(test.getMillis() - DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);                test = new DateTime(TEST_TIME1);        result = test.withZoneRetainFields(null);        assertSame(test, result);                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withZoneRetainFields(null);        assertEquals(test.getMillis() + DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1, new MockNullZoneChronology());        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);    }        //-----------------------------------------------------------------------    public void testWithDate_int_int_int() {        DateTime test = new DateTime(2002, 4, 5, 1, 2, 3, 4, ISOChronology.getInstanceUTC());        DateTime result = test.withDate(2003, 5, 6);        DateTime expected = new DateTime(2003, 5, 6, 1, 2, 3, 4, ISOChronology.getInstanceUTC());        assertEquals(expected, result);                test = new DateTime(TEST_TIME1);        try {            test.withDate(2003, 13, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testWithTime_int_int_int() {        DateTime test = new DateTime(TEST_TIME1 - 12345L, BuddhistChronology.getInstanceUTC());        DateTime result = test.withTime(12, 24, 0, 0);        assertEquals(TEST_TIME1, result.getMillis());        assertEquals(BuddhistChronology.getInstanceUTC(), result.getChronology());                test = new DateTime(TEST_TIME1);        try {            test.withTime(25, 1, 1, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testWithFields_RPartial() {        DateTime test = new DateTime(2004, 5, 6, 7, 8, 9, 0);        DateTime result = test.withFields(new YearMonthDay(2003, 4, 5));        DateTime expected = new DateTime(2003, 4, 5, 7, 8, 9, 0);        assertEquals(expected, result);                test = new DateTime(TEST_TIME1);        result = test.withFields(null);        assertSame(test, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_long() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(123456789L);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);    }        public void testWithDurationAdded_long_int() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(123456789L, 1);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, 0);        assertSame(test, result);                result = test.withDurationAdded(123456789L, 2);        expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, -3);        expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_RD() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(new Duration(123456789L));        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(null);        assertSame(test, result);    }        public void testWithDurationAdded_RD_int() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(new Duration(123456789L), 1);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(null, 1);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 0);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 2);        expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(new Duration(123456789L), -3);        expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithPeriodAdded_RP() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8));        DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(null);        assertSame(test, result);    }        public void testWithDurationAdded_RP_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1);        DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(null, 1);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3);        expected = new DateTime(2005, 11, 15, 16, 20, 24, 28, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1);        expected = new DateTime(2001, 3, 2, 0, 0, 0, 0, BuddhistChronology.getInstance());        assertEquals(expected, result);    }    //    //-----------------------------------------------------------------------//    public void testImmutable() {//        MockChangeDateTime test = new MockChangeDateTime(TEST_TIME_NOW);//        assertEquals(TEST_TIME_NOW, test.getMillis());//        try {//            test.testSetMillis();//            fail();//        } catch (UnsupportedOperationException ex) {}//        assertEquals(TEST_TIME_NOW, test.getMillis());//        //        test = new MockChangeDateTime(TEST_TIME_NOW);//        assertEquals(ISOChronology.getInstance(), test.getChronology());//        try {//            test.testSetChronology();//            fail();//        } catch (UnsupportedOperationException ex) {}//        assertEquals(ISOChronology.getInstance(), test.getChronology());//    }//    //    static class MockChangeDateTime extends DateTime {//        MockChangeDateTime(long instant) {//            super(instant);//        }//        public void testSetMillis() {//            setMillis(0L);//        }//        public void testSetChronology() {//            setChronology(GregorianChronology.getInstance(PARIS));//        }//    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */public class TestPeriod_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriod_Constructors.class);    }    public TestPeriod_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long2() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long3() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Period test = new Period(length);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long_PeriodType2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.getMillisType());        assertEquals(PeriodType.getMillisType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(length, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long_PeriodType3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.getDayHourType());        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long_PeriodType4() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.getAllType().withMillisRemoved());        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length - 8, test.toDurationMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (4ints)     */    public void testConstructor_4int1() throws Throwable {        Period test = new Period(5, 6, 7, 8);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int1() throws Throwable {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int__PeriodType1() throws Throwable {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_8int__PeriodType2() throws Throwable {        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());    }    public void testConstructor_8int__PeriodType3() throws Throwable {        try {            new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_long_long_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_long_long_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());    }    public void testToPeriod_PeriodType3() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getYearWeekType());                assertEquals(PeriodType.getYearWeekType(), test.getPeriodType());        assertEquals(1, test.getYears());  // tests using years and not weekyears        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(-3, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0L, test.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.getDayHourType());        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.getAllType().withMillisRemoved());        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());    }    public void testConstructor_RI_RI_PeriodType4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.getAllType());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI_PeriodType5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2, PeriodType.getAllType());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0L, test.toDurationMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        Period test = new Period("P1Y2M3D");        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_Object2() throws Throwable {        Period test = new Period((Object) null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0, test.toDurationMillis());    }    public void testConstructor_Object3() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());    }    public void testConstructor_Object4() throws Throwable {        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());        Period test = new Period(base);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object_PeriodType1() throws Throwable {        Period test = new Period("P1Y2M3D", PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_Object_PeriodType2() throws Throwable {        Period test = new Period((Object) null, PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0, test.toDurationMillis());    }    public void testConstructor_Object_PeriodType3() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());    }    public void testConstructor_Object_PeriodType4() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Properties.class);    }    public TestMutableDateTime_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getReadableInstant());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getReadableInstant());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getReadableInstant());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getReadableInstant());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getReadableInstant());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadableInstant());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyAddYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().add(9);        assertEquals("2013-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().addWrapField(9);        assertEquals("2013-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertySetYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().set(1960);        assertEquals("1960-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().set("1960");        assertEquals("1960-06-09T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadableInstant());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new MutableDateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyAddMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().add(6);        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    public void testPropertyAddWrapFieldMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().addWrapField(8);        assertEquals("2004-02-09T00:00:00.000Z", test.toString());    }    public void testPropertySetMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set(12);        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    public void testPropertySetTextMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("12");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("December");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("Dec");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadableInstant());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    public void testPropertyAddDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().add(9);        assertEquals("2004-06-18T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().addWrapField(22);        assertEquals("2004-06-01T00:00:00.000+01:00", test.toString());    }    public void testPropertySetDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().set(12);        assertEquals("2004-06-12T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().set("12");        assertEquals("2004-06-12T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getReadableInstant());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    public void testPropertyAddDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().add(9);        assertEquals("2004-06-18T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().addWrapField(206);        assertEquals("2004-01-01T00:00:00.000Z", test.toString());    }    public void testPropertySetDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().set(12);        assertEquals("2004-01-12T00:00:00.000Z", test.toString());    }    public void testPropertySetTextDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().set("12");        assertEquals("2004-01-12T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        // 2002-01-01 = Thu        // 2002-12-31 = Thu (+364 days)        // 2003-12-30 = Thu (+364 days)        // 2004-01-03 = Mon             W1        // 2004-01-31 = Mon (+28 days)  W5        // 2004-02-28 = Mon (+28 days)  W9        // 2004-03-27 = Mon (+28 days)  W13        // 2004-04-24 = Mon (+28 days)  W17        // 2004-05-23 = Mon (+28 days)  W21        // 2004-06-05 = Mon (+14 days)  W23        // 2004-06-09 = Fri        // 2004-12-25 = Mon             W52        // 2005-01-01 = Mon             W1        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getReadableInstant());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    public void testPropertyAddWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().add(1);        assertEquals("2004-06-14T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().addWrapField(30);        assertEquals("2003-12-29T00:00:00.000Z", test.toString());    }    public void testPropertySetWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().set(4);        assertEquals("2004-01-19T00:00:00.000Z", test.toString());    }    public void testPropertySetTextWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().set("4");        assertEquals("2004-01-19T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getReadableInstant());        assertEquals(3, test.dayOfWeek().get());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }    public void testPropertyAddDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().add(1);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddLongDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().add(1L);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);  // Wed        test.dayOfWeek().addWrapField(5);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());    }    public void testPropertySetDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set(4);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("4");        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("Mon");        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("Tuesday");        assertEquals("2004-06-08T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("lundi", Locale.FRENCH);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getReadableInstant());        assertEquals(13, test.hourOfDay().get());        assertEquals("13", test.hourOfDay().getAsText());        assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("13", test.hourOfDay().getAsShortText());        assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyRoundFloorHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundCeilingHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfFloorHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfCeilingHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfEvenHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 14, 30, 0, 0);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRemainderHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfHour() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getReadableInstant());        assertEquals(23, test.minuteOfHour().get());        assertEquals("23", test.minuteOfHour().getAsText());        assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("23", test.minuteOfHour().getAsShortText());        assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());        assertEquals("minuteOfDay", test.minuteOfDay().getName());        assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString());        assertSame(test, test.minuteOfDay().getReadableInstant());        assertEquals(803, test.minuteOfDay().get());        assertEquals("803", test.minuteOfDay().getAsText());        assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH));        assertEquals("803", test.minuteOfDay().getAsShortText());        assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());        assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));        assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfMinute() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getReadableInstant());        assertEquals(43, test.secondOfMinute().get());        assertEquals("43", test.secondOfMinute().getAsText());        assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("43", test.secondOfMinute().getAsShortText());        assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());        assertEquals("secondOfDay", test.secondOfDay().getName());        assertEquals("Property[secondOfDay]", test.secondOfDay().toString());        assertSame(test, test.secondOfDay().getReadableInstant());        assertEquals(48223, test.secondOfDay().get());        assertEquals("48223", test.secondOfDay().getAsText());        assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH));        assertEquals("48223", test.secondOfDay().getAsShortText());        assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());        assertEquals(5, test.secondOfDay().getMaximumTextLength(null));        assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfSecond() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getReadableInstant());        assertEquals(53, test.millisOfSecond().get());        assertEquals("53", test.millisOfSecond().getAsText());        assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("53", test.millisOfSecond().getAsShortText());        assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());        assertEquals("millisOfDay", test.millisOfDay().getName());        assertEquals("Property[millisOfDay]", test.millisOfDay().toString());        assertSame(test, test.millisOfDay().getReadableInstant());        assertEquals(48223053, test.millisOfDay().get());        assertEquals("48223053", test.millisOfDay().getAsText());        assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH));        assertEquals("48223053", test.millisOfDay().getAsShortText());        assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());        assertEquals(8, test.millisOfDay().getMaximumTextLength(null));        assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestMutableInterval_Updates extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Updates.class);    }    public TestMutableInterval_Updates(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testSetInterval_long_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(TEST_TIME1 - 1, TEST_TIME2 + 1);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_long_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(TEST_TIME1 - 1, TEST_TIME1 - 2);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetInterval_RI_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RI_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME1 - 2));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetInterval_RI_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(null, new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RI_RI4() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Instant(TEST_TIME1 - 1), null);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testSetInterval_RI_RI5() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(null, null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetInterval_RInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RInterval2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(new MockBadInterval());            fail();        } catch (IllegalArgumentException ex) {}    }        class MockBadInterval extends AbstractInterval {        public long getStartMillis() {            return TEST_TIME1 - 1;        }        public long getEndMillis() {            return TEST_TIME1 - 2;        }    }    public void testSetInterval_RInterval3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testSetStartMillis_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStartMillis(TEST_TIME1 - 1);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSetStartMillis_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setStartMillis(TEST_TIME2 + 1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetStartInstant_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStartInstant(new Instant(TEST_TIME1 - 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSetStartInstant_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setStartInstant(new Instant(TEST_TIME2 + 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetStartInstant_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStartInstant(null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetEndMillis_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEndMillis(TEST_TIME2 + 1);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetEndMillis_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setEndMillis(TEST_TIME1 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetEndInstant_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEndInstant(new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetEndInstant_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setEndInstant(new Instant(TEST_TIME1 - 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetEndInstant_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEndInstant(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetDurationAfterStart_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(123L);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSeDurationAfterStart_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationAfterStart(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetDurationAfterStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(new Duration(123L));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSeDurationAfterStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationAfterStart(new Duration(-1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetDurationAfterStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetDurationBeforeEnd_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(123L);        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSeDurationBeforeEnd_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationBeforeEnd(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetDurationBeforeEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(new Duration(123L));        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSeDurationBeforeEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationBeforeEnd(new Duration(-1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetDurationBeforeEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(null);        assertEquals(TEST_TIME2, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriodAfterStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodAfterStart(new Period(123L));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSePeriodAfterStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setPeriodAfterStart(new Period(-1L));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetPeriodAfterStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodAfterStart(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriodBeforeEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodBeforeEnd(new Period(123L));        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSePeriodBeforeEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setPeriodBeforeEnd(new Period(-1L));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetPeriodBeforeEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodBeforeEnd(null);        assertEquals(TEST_TIME2, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */public class TestDateMidnight_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW_UTC =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private long TEST_TIME_NOW_LONDON =            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME_NOW_PARIS =            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;        // 2002-04-05    private long TEST_TIME1_UTC =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME1_LONDON =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME1_PARIS =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - 2*DateTimeConstants.MILLIS_PER_HOUR;        // 2003-05-06    private long TEST_TIME2_UTC =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME2_LONDON =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME2_PARIS =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - 2*DateTimeConstants.MILLIS_PER_HOUR;        private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Constructors.class);    }    public TestDateMidnight_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        DateMidnight test = new DateMidnight();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2_LONDON, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1_PARIS, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2_PARIS, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new DateMidnight(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        DateMidnight test = new DateMidnight((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1_PARIS, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new DateMidnight(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new DateMidnight(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31);            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31);        try {            new DateMidnight(2002, 7, 32);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31, PARIS);        try {            new DateMidnight(2002, 7, 32, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31, GregorianChronology.getInstance());        try {            new DateMidnight(2002, 7, 32, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestInstant_Constructors.suite());        suite.addTest(TestInstant_Basics.suite());                suite.addTest(TestDateTime_Constructors.suite());        suite.addTest(TestDateTime_Basics.suite());        suite.addTest(TestDateTime_Properties.suite());                suite.addTest(TestMutableDateTime_Constructors.suite());        suite.addTest(TestMutableDateTime_Basics.suite());        suite.addTest(TestMutableDateTime_Sets.suite());        suite.addTest(TestMutableDateTime_Adds.suite());        suite.addTest(TestMutableDateTime_Properties.suite());                suite.addTest(TestDateMidnight_Constructors.suite());        suite.addTest(TestDateMidnight_Basics.suite());        suite.addTest(TestDateMidnight_Properties.suite());                suite.addTest(TestDuration_Constructors.suite());        suite.addTest(TestDuration_Basics.suite());                suite.addTest(TestInterval_Constructors.suite());        suite.addTest(TestInterval_Basics.suite());                suite.addTest(TestMutableInterval_Constructors.suite());        suite.addTest(TestMutableInterval_Basics.suite());        suite.addTest(TestMutableInterval_Updates.suite());                suite.addTest(TestPeriod_Constructors.suite());        suite.addTest(TestPeriod_Basics.suite());                suite.addTest(TestMutablePeriod_Constructors.suite());        suite.addTest(TestMutablePeriod_Basics.suite());        suite.addTest(TestMutablePeriod_Updates.suite());                suite.addTest(TestTimeOfDay.suite());        suite.addTest(TestYearMonthDay.suite());                suite.addTest(TestDateTimeComparator.suite());        suite.addTest(TestDateTimeConstants.suite());        suite.addTest(TestDateTimeUtils.suite());        suite.addTest(TestDateTimeZone.suite());        suite.addTest(TestPeriodType.suite());//        suite.addTest(TestParseISO.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Updates extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Updates.class);    }    public TestMutablePeriod_Updates(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testAddYears() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(10);        assertEquals(11, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(-10);        assertEquals(-9, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(0);        assertEquals(1, test.getYears());    }    //-----------------------------------------------------------------------    public void testAddMonths() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(10);        assertEquals(12, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(-10);        assertEquals(-8, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(0);        assertEquals(2, test.getMonths());    }    //-----------------------------------------------------------------------    public void testAddWeeks() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(10);        assertEquals(13, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(-10);        assertEquals(-7, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(0);        assertEquals(3, test.getWeeks());    }    //-----------------------------------------------------------------------    public void testAddDays() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(10);        assertEquals(14, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(-10);        assertEquals(-6, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(0);        assertEquals(4, test.getDays());    }    //-----------------------------------------------------------------------    public void testAddHours() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(10);        assertEquals(15, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(-10);        assertEquals(-5, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(0);        assertEquals(5, test.getHours());    }    //-----------------------------------------------------------------------    public void testAddMinutes() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(10);        assertEquals(16, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(-10);        assertEquals(-4, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(0);        assertEquals(6, test.getMinutes());    }    //-----------------------------------------------------------------------    public void testAddSeconds() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(10);        assertEquals(17, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(-10);        assertEquals(-3, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(0);        assertEquals(7, test.getSeconds());    }    //-----------------------------------------------------------------------    public void testAddMillis() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(10);        assertEquals(18, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(-10);        assertEquals(-2, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(0);        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetYears() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(10);        assertEquals(10, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(-10);        assertEquals(-10, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(0);        assertEquals(0, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(1);        assertEquals(1, test.getYears());                test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.getMillisType());        try {            test.setYears(1);            fail();        } catch (UnsupportedOperationException ex) {}    }    //-----------------------------------------------------------------------    public void testSetMonths() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(10);        assertEquals(10, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(-10);        assertEquals(-10, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(0);        assertEquals(0, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(2);        assertEquals(2, test.getMonths());    }    //-----------------------------------------------------------------------    public void testSetWeeks() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(10);        assertEquals(10, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(-10);        assertEquals(-10, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(0);        assertEquals(0, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(3);        assertEquals(3, test.getWeeks());    }    //-----------------------------------------------------------------------    public void testSetDays() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(10);        assertEquals(10, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(-10);        assertEquals(-10, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(0);        assertEquals(0, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(4);        assertEquals(4, test.getDays());    }    //-----------------------------------------------------------------------    public void testSetHours() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(10);        assertEquals(10, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(-10);        assertEquals(-10, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(0);        assertEquals(0, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(5);        assertEquals(5, test.getHours());    }    //-----------------------------------------------------------------------    public void testSetMinutes() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(10);        assertEquals(10, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(-10);        assertEquals(-10, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(0);        assertEquals(0, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(6);        assertEquals(6, test.getMinutes());    }    //-----------------------------------------------------------------------    public void testSetSeconds() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(10);        assertEquals(10, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(-10);        assertEquals(-10, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(0);        assertEquals(0, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(7);        assertEquals(7, test.getSeconds());    }    //-----------------------------------------------------------------------    public void testSetMillis() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(10);        assertEquals(10, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(-10);        assertEquals(-10, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(0);        assertEquals(0, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(8);        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_8ints1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_8ints2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());        try {            test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());        assertEquals(100, test.toDurationMillis());    }    public void testSetPeriod_8ints3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());        test.setPeriod(0, 0, 0, 0, 0, 0, 0, 18);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(18, test.getMillis());        assertEquals(18, test.toDurationMillis());    }    public void testSetPeriod_8ints4() {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);        assertEquals(true, test.isPrecise());        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);        assertEquals(false, test.isPrecise());        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RP1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());        try {            test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());        assertEquals(100, test.toDurationMillis());    }    public void testSetPeriod_RP3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());        test.setPeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(18, test.getMillis());        assertEquals(18, test.toDurationMillis());    }    public void testSetPeriod_RP4() {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);        assertEquals(true, test.isPrecise());        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));        assertEquals(false, test.isPrecise());        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadablePeriod) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_long_long1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt2.getMillis(), dt1.getMillis());        assertEquals(-1, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(-1, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testSetPeriod_long_long3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        test.setPeriod(dt1.getMillis(), dt1.getMillis());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testSetPeriod_long_long_NoYears() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withYearsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(0, test.getYears());        assertEquals(13, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoMonths() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMonthsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(5, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoWeeks() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withWeeksRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(8, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoDays() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withDaysRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(25, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoHours() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withHoursRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(61, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoMinutes() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMinutesRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(61, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoSeconds() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withSecondsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(1001, test.getMillis());    }    public void testSetPeriod_long_long_NoMillis() {        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMillisRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RInterval1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(new Interval(dt1, dt2));        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_RInterval2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadableInterval) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_long1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(100L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_long2() {        MutablePeriod test = new MutablePeriod();        test.setPeriod(            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testSetPeriod_long3() {        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType());        test.setPeriod(            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(25, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testSetPeriod_long4() {        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType());        test.setPeriod(            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(12, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testSetPeriod_long_NoYears() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());        test.setPeriod(ms);        assertEquals(0, test.getYears());        assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(ms, test.toDurationMillis());    }    public void testSetPeriod_long_NoMonths() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());        test.setPeriod(ms);        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(85, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(ms, test.toDurationMillis());    }    public void testSetPeriod_long_NoWeeks() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());        test.setPeriod(ms);        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(85, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(ms, test.toDurationMillis());    }    public void testSetPeriod_long_NoDays() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());        test.setPeriod(ms);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5 + 25 * 24, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(ms, test.toDurationMillis());    }    public void testSetPeriod_long_NoHours() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());        test.setPeriod(ms);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(25, test.getDays());        assertEquals(0, test.getHours());        assertEquals(6 + 5 * 60, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(ms, test.toDurationMillis());    }    public void testSetPeriod_long_NoMinutes() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());        test.setPeriod(ms);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(25, test.getDays());        assertEquals(5, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(7 + 6 * 60, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(ms, test.toDurationMillis());    }    public void testSetPeriod_long_NoSeconds() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());        test.setPeriod(ms);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(25, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(8 + 7 * 1000, test.getMillis());        assertEquals(ms, test.toDurationMillis());    }    public void testSetPeriod_long_NoMillis() {        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());        test.setPeriod(ms);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(25, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(ms - 8, test.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RD1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(new Duration(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_RD2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.setPeriod(new Duration(length));        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testSetPeriod_RD3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadableDuration) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_8ints1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_8ints2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getYearMonthType());        try {            test.add(1, 2, 3, 4, 5, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_long1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(100L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());        assertEquals(200L, test.toDurationMillis());    }    public void testAdd_long2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getAllType());        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(ms);        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_long3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(ms);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion        assertEquals(25, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());        assertEquals(ms + 100L, test.toDurationMillis());    }    public void testAdd_long4() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());        long ms =0L;        test.add(ms);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());        assertEquals(100L, test.toDurationMillis());    }    public void testAdd_long5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add(2100L);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(9, test.getSeconds());        assertEquals(108, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RD1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Duration(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());        assertEquals(200L, test.toDurationMillis());    }    public void testAdd_RD2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(new Duration(ms));        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion        assertEquals(25, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());        assertEquals(ms + 100L, test.toDurationMillis());    }    public void testAdd_RD3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());        long ms =0L;        test.add(new Duration(ms));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());        assertEquals(100L, test.toDurationMillis());    }    public void testAdd_RD4() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add(new Duration(2100L));        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(9, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RD5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadableDuration) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RP1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Period(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());        assertEquals(200L, test.toDurationMillis());    }    public void testAdd_RP2() {        MutablePeriod test = new MutablePeriod(100L);  // All type        test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getPreciseAllType()));        assertEquals(1, test.getYears());  // add field value, ignore different types        assertEquals(2, test.getMonths());  // add field value, ignore different types        assertEquals(3, test.getWeeks());  // add field value, ignore different types        assertEquals(4, test.getDays());  // add field value, ignore different types        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RP3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());        test.add(new Period(0L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());        assertEquals(100L, test.toDurationMillis());    }    public void testAdd_RP4() {        MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getYearMonthType());        try {            test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testAdd_RP5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadablePeriod) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RInterval1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Interval(100L, 200L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());        assertEquals(200L, test.toDurationMillis());    }    public void testAdd_RInterval2() {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 12, 18, 0, 0, 0, 8);        MutablePeriod test = new MutablePeriod(100L);  // All type        test.add(new Interval(dt1, dt2));        assertEquals(1, test.getYears());  // add field value from interval        assertEquals(6, test.getMonths());  // add field value from interval        assertEquals(1, test.getWeeks());  // add field value from interval        assertEquals(2, test.getDays());  // add field value from interval        assertEquals(0, test.getHours());  // time zone OK        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RInterval3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());        test.add(new Interval(0L, 0L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testAdd_RInterval4() {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8);        MutablePeriod test = new MutablePeriod(100L, PeriodType.getYearMonthType());        test.add(new Interval(dt1, dt2));        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());  // no weeks        assertEquals(8, test.getDays());  // week added to days        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RInterval5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadableInterval) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testNormalize1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.normalize();            fail();        } catch (IllegalStateException ex) {}    }    public void testNormalize2() {        MutablePeriod test = new MutablePeriod(1, 14, 0, 36, 29, 66, 67, 1008, PeriodType.getPreciseYearMonthType());        //   365 + 14*30 + 6 days        // extra year created from 12 months of 30 days plus 5 extra days        // 2*365 +  2*30 + 1 day        test.normalize();        assertEquals(2, test.getYears());        assertEquals(3, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(2, test.getDays());        assertEquals(6, test.getHours());        assertEquals(7, test.getMinutes());        assertEquals(8, test.getSeconds());        assertEquals(8, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */public class TestDuration_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDuration_Constructors.class);    }    public TestDuration_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testZERO() throws Throwable {        Duration test = Duration.ZERO;        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Duration test = new Duration(length);        assertEquals(length, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration test = new Duration(dt1.getMillis(), dt2.getMillis());        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration test = new Duration(dt1, dt2);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Duration test = new Duration(dt1, dt2);        assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Duration test = new Duration(dt1, dt2);        assertEquals(TEST_TIME_NOW - dt1.getMillis(), test.getMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Duration test = new Duration(dt1, dt2);        assertEquals(0L, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        Duration test = new Duration("P1Y2M3D");        assertEquals(            (365L + 2L * 30L + 3L) * DateTimeConstants.MILLIS_PER_DAY, test.getMillis());    }    public void testConstructor_Object2() throws Throwable {        Duration test = new Duration((Object) null);        assertEquals(0L, test.getMillis());    }    public void testConstructor_Object3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Long base = new Long(length);        Duration test = new Duration(base);        assertEquals(length, test.getMillis());    }    public void testConstructor_Object4() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration base = new Duration(dt1, dt2);        Duration test = new Duration(base);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    public void testConstructor_Object5() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);        Duration test = new Duration(base);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    public void testConstructor_Object6() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period base = new Period(dt2.getMillis() - dt1.getMillis());  // precise        Duration test = new Duration(base);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */public class TestDateMidnight_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone NEWYORK = DateTimeZone.getInstance("America/New_York");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW_UTC =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private long TEST_TIME_NOW_LONDON =            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME_NOW_PARIS =            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;                // 2002-04-05    private long TEST_TIME1_UTC =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME1_LONDON =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME1_PARIS =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - 2*DateTimeConstants.MILLIS_PER_HOUR;            // 2003-05-06    private long TEST_TIME2_UTC =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME2_LONDON =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME2_PARIS =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - 2*DateTimeConstants.MILLIS_PER_HOUR;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Basics.class);    }    public TestDateMidnight_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString());    }    //-----------------------------------------------------------------------    public void testGet() {        DateMidnight test = new DateMidnight();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(24, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(12, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(0, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        DateMidnight test = new DateMidnight();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(0, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(0, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(0, test.getMillisOfDay());    }    public void testEqualsHashCode() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test2 = new DateMidnight(TEST_TIME1_UTC);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1_LONDON;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    public void testCompareTo() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(-1, test3.compareTo(test2));  // midnight paris before london                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        public void testIsEqual() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(false, test3.isEqual(test2));  // midnight paris before london                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + 1).isEqual(null));        assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC).isEqual(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - 1).isEqual(null));    }        public void testIsBefore() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(true, test3.isBefore(test2));  // midnight paris before london                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + 1).isBefore(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC).isBefore(null));        assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC - 1).isBefore(null));    }        public void testIsAfter() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));  // midnight paris before london                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC + 1).isAfter(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC).isAfter(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateMidnight result = (DateMidnight) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString());                test = new DateMidnight(TEST_TIME_NOW_UTC, PARIS);        assertEquals("2002-06-09T00:00:00.000+02:00", test.toString());                test = new DateMidnight(TEST_TIME_NOW_UTC, NEWYORK);        assertEquals("2002-06-08T00:00:00.000-04:00", test.toString());  // the 8th    }    public void testToString_String() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("2002 00", test.toString("yyyy HH"));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null));    }    public void testToString_String_String() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Instant result = test.toInstant();        assertEquals(TEST_TIME1_LONDON, result.getMillis());    }    public void testToDateMidnight() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());    }    public void testToDateTime_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(PARIS, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());    }    public void testToDateTime_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToTrustedISODateMidnight() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toTrustedISODateTime();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());//        test = new MockUntrustedDateMidnight(TEST_TIME1_UTC);//        result = test.toTrustedISODateTime();//        assertSame(DateTime.class, result.getClass());//        assertSame(ISOChronology.class, result.getChronology().getClass());//        assertEquals(test.getMillis(), result.getMillis());//        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, new MockUntrustedZone("Europe/Paris"));        result = test.toTrustedISODateTime();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());    }//    static class MockUntrustedDateMidnight extends DateMidnight {//        MockUntrustedDateMidnight(long millis) {//            super(millis);//        }//    }    static class MockUntrustedZone extends DateTimeZone {        MockUntrustedZone(String id) {            super(id);        }        public String getNameKey(long instant) {            return null;        }        public int getOffset(long instant) {            return 60 * 60 * 1000;        }        public int getStandardOffset(long instant) {            return 60 * 60 * 1000;        }        public boolean isFixed() {            return true;        }        public long nextTransition(long instant) {            return 0;        }        public long previousTransition(long instant) {            return 0;        }        public boolean equals(Object object) {            return false;        }    }    public void testToMutableDateTime() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withMillis(TEST_TIME2_UTC);        assertEquals(TEST_TIME2_LONDON, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withMillis(TEST_TIME2_UTC);        assertEquals(TEST_TIME2_PARIS, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withMillis(TEST_TIME1_UTC);        assertSame(test, result);    }    public void testWithChronology_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withChronology(GregorianChronology.getInstance(PARIS));        assertEquals(TEST_TIME1_LONDON, test.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withChronology(null);        assertEquals(TEST_TIME1_PARIS, test.getMillis());        // midnight Paris is previous day in London        assertEquals(TEST_TIME1_LONDON - DateTimeConstants.MILLIS_PER_DAY, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withChronology(ISOChronology.getInstance());        assertSame(test, result);    }    public void testWithZoneRetainFields_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withZoneRetainFields(PARIS);        assertEquals(TEST_TIME1_LONDON, test.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withZoneRetainFields(null);        assertEquals(TEST_TIME1_PARIS, test.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withZoneRetainFields(null);        assertSame(test, result);                test = new DateMidnight(TEST_TIME1_UTC, new MockNullZoneChronology());        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import org.joda.time.base.AbstractDateTime;import org.joda.time.base.AbstractInstant;/** * This class displays what the ClassLoader is up to. * Run using JVM -verbose:class. * * @author Stephen Colebourne */public class ClassLoadTest {    // run using JVM -verbose:class    public static void main(String[] args) {        System.out.println("-----------------------------------------------");        System.out.println("-----------AbstractInstant---------------------");        Class cls = AbstractInstant.class;        System.out.println("-----------ReadableDateTime--------------------");        cls = ReadableDateTime.class;        System.out.println("-----------AbstractDateTime--------------------");        cls = AbstractDateTime.class;        System.out.println("-----------DateTime----------------------------");        cls = DateTime.class;        System.out.println("-----------DateTimeZone------------------------");        cls = DateTimeZone.class;        System.out.println("-----------new DateTime()----------------------");        DateTime dt = new DateTime();        System.out.println("-----------new DateTime(ReadableInstant)-------");        dt = new DateTime(dt);        System.out.println("-----------new DateTime(Long)------------------");        dt = new DateTime(new Long(0));        System.out.println("-----------------------------------------------");    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.MutableDateTime;import org.joda.time.ReadableInstant;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */public class TestTimeOfDay extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestTimeOfDay.class);    }    public TestTimeOfDay(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        TimeOfDay test = new TimeOfDay();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        TimeOfDay test = new TimeOfDay(null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            TimeOfDay test = new TimeOfDay(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0, test.getHourOfDay());            assertEquals(0, test.getMinuteOfHour());            assertEquals(0, test.getSecondOfMinute());            assertEquals(0, test.getMillisOfSecond());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Object) null, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            TimeOfDay test = new TimeOfDay(new Integer(0), JulianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0, test.getHourOfDay());            assertEquals(0, test.getMinuteOfHour());            assertEquals(0, test.getSecondOfMinute());            assertEquals(0, test.getMillisOfSecond());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int)     */    public void testConstructor_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());    }    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());    }    /**     * Test constructor (int, int, int, int)     */    public void testConstructor_int_int_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, 1000);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testGet() {        TimeOfDay test = new TimeOfDay();        assertEquals(10, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(20, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(30, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(40, test.get(ISOChronology.getInstance().millisOfSecond()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(ISOChronology.getInstance().dayOfMonth());            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(ISOChronology.getInstance(PARIS).hourOfDay());            fail();        } catch (IllegalArgumentException ex) {}        // TODO: Should this fail or suceed - by succeeding it exposes out implementation//        try {//            test.get(JulianChronology.getInstance().hourOfDay());//            fail();//        } catch (IllegalArgumentException ex) {}    }    public void testGetFieldSize() {        TimeOfDay test = new TimeOfDay();        assertEquals(4, test.getFieldSize());    }    public void testGetField() {        TimeOfDay test = new TimeOfDay();        assertSame(ISOChronology.getInstance().hourOfDay(), test.getField(0));        assertSame(ISOChronology.getInstance().minuteOfHour(), test.getField(1));        assertSame(ISOChronology.getInstance().secondOfMinute(), test.getField(2));        assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));        try {            test.getField(-1);        } catch (IllegalArgumentException ex) {}        try {            test.getField(5);        } catch (IllegalArgumentException ex) {}    }    public void testGetFields() {        TimeOfDay test = new TimeOfDay();        DateTimeField[] fields = test.getFields();        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);    }    public void testGetValue() {        TimeOfDay test = new TimeOfDay();        assertEquals(10, test.getValue(0));        assertEquals(20, test.getValue(1));        assertEquals(30, test.getValue(2));        assertEquals(40, test.getValue(3));        try {            test.getValue(-1);        } catch (IllegalArgumentException ex) {}        try {            test.getValue(5);        } catch (IllegalArgumentException ex) {}    }    public void testGetValues() {        TimeOfDay test = new TimeOfDay();        int[] values = test.getValues();        assertEquals(10, values[0]);        assertEquals(20, values[1]);        assertEquals(30, values[2]);        assertEquals(40, values[3]);    }    public void testIsSupported() {        TimeOfDay test = new TimeOfDay();        assertEquals(true, test.isSupported(ISOChronology.getInstance().hourOfDay()));        assertEquals(true, test.isSupported(ISOChronology.getInstance().minuteOfHour()));        assertEquals(true, test.isSupported(ISOChronology.getInstance().secondOfMinute()));        assertEquals(true, test.isSupported(ISOChronology.getInstance().millisOfSecond()));        assertEquals(false, test.isSupported(ISOChronology.getInstance().dayOfMonth()));        assertEquals(false, test.isSupported(ISOChronology.getInstance(PARIS).hourOfDay()));    }    public void testEqualsHashCode() {        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));    }        class MockInstant extends MockPartial {        public DateTimeField[] getFields() {            return new DateTimeField[] {                ISOChronology.getInstance().hourOfDay(),                ISOChronology.getInstance().minuteOfHour(),                ISOChronology.getInstance().secondOfMinute(),                ISOChronology.getInstance().millisOfSecond(),            };        }        public int[] getValues() {            return new int[] {10, 20, 30, 40};        }    }    //-----------------------------------------------------------------------    public void testResolve_long() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        DateTime dt = new DateTime(0L);        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());                DateTime result = new DateTime(test.resolve(dt.getMillis(), DateTimeZone.UTC));        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());        assertEquals("1970-01-01T10:20:30.040Z", result.toString());    }    public void testResolveDateTime_RI() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        DateTime dt = new DateTime(0L);        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());                DateTime result = test.resolveDateTime(dt);        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());        assertEquals("1970-01-01T10:20:30.040Z", result.toString());    }    public void testResolveDateTime_nullRI() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4);        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);                DateTime result = test.resolveDateTime(null);        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());        assertEquals("1970-01-02T01:02:03.004Z", result.toString());    }    public void testResolveInto_RWI() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        MutableDateTime mdt = new MutableDateTime(0L);        assertEquals("1970-01-01T00:00:00.000Z", mdt.toString());                test.resolveInto(mdt);        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        assertEquals("1970-01-01T10:20:30.040Z", mdt.toString());    }    public void testResolveInto_nullRWI() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);                try {            test.resolveInto(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        TimeOfDay result = (TimeOfDay) ois.readObject();        ois.close();                assertEquals(test, result);        assertTrue(Arrays.equals(test.getValues(), result.getValues()));        assertTrue(Arrays.equals(test.getFields(), result.getFields()));        assertEquals(test.getChronology(), result.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals("T10:20:30.040", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getReadablePartial());        assertSame(test, test.hourOfDay().getTimeOfDay());        assertEquals(10, test.hourOfDay().get());        assertEquals("10", test.hourOfDay().getAsText());        assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("10", test.hourOfDay().getAsShortText());        assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.hourOfDay().getMinimumValue());        assertEquals(0, test.hourOfDay().getMinimumValueOverall());        assertEquals(23, test.hourOfDay().getMaximumValue());        assertEquals(23, test.hourOfDay().getMaximumValueOverall());    }    public void testPropertyAddHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.hourOfDay().addToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.hourOfDay().addToCopy(13);        check(copy, 23, 20, 30, 40);                try {            test.hourOfDay().addToCopy(14);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.hourOfDay().addToCopy(-10);        check(copy, 0, 20, 30, 40);                try {            test.hourOfDay().addToCopy(-11);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(18);        check(copy, 4, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(-15);        check(copy, 19, 20, 30, 40);    }    public void testPropertySetHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);                try {            test.hourOfDay().setCopy(24);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.hourOfDay().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);    }    public void testPropertyCompareToHour() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.hourOfDay().compareTo(test2) < 0);        assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);        assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);        try {            test1.hourOfDay().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0);        assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0);        assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0);        try {            test1.hourOfDay().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getReadablePartial());        assertSame(test, test.minuteOfHour().getTimeOfDay());        assertEquals(20, test.minuteOfHour().get());        assertEquals("20", test.minuteOfHour().getAsText());        assertEquals("20", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("20", test.minuteOfHour().getAsShortText());        assertEquals("20", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.minuteOfHour().getMinimumValue());        assertEquals(0, test.minuteOfHour().getMinimumValueOverall());        assertEquals(59, test.minuteOfHour().getMaximumValue());        assertEquals(59, test.minuteOfHour().getMaximumValueOverall());    }    public void testPropertyAddMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.minuteOfHour().addToCopy(39);        check(copy, 10, 59, 30, 40);                copy = test.minuteOfHour().addToCopy(40);        check(copy, 11, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(1 * 60 + 45);        check(copy, 12, 5, 30, 40);                copy = test.minuteOfHour().addToCopy(13 * 60 + 39);        check(copy, 23, 59, 30, 40);                try {            test.minuteOfHour().addToCopy(13 * 60 + 40);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.minuteOfHour().addToCopy(-9);        check(copy, 10, 11, 30, 40);                copy = test.minuteOfHour().addToCopy(-19);        check(copy, 10, 1, 30, 40);                copy = test.minuteOfHour().addToCopy(-20);        check(copy, 10, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(-21);        check(copy, 9, 59, 30, 40);                copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20));        check(copy, 0, 0, 30, 40);                try {            test.minuteOfHour().addToCopy(-(10 * 60 + 21));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.minuteOfHour().addWrapFieldToCopy(49);        check(copy, 10, 9, 30, 40);                copy = test.minuteOfHour().addWrapFieldToCopy(-47);        check(copy, 10, 33, 30, 40);    }    public void testPropertySetMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);                try {            test.minuteOfHour().setCopy(60);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.minuteOfHour().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);    }    public void testPropertyCompareToMinute() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0);        assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);        assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);        try {            test1.minuteOfHour().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0);        assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0);        assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0);        try {            test1.minuteOfHour().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getReadablePartial());        assertSame(test, test.secondOfMinute().getTimeOfDay());        assertEquals(30, test.secondOfMinute().get());        assertEquals("30", test.secondOfMinute().getAsText());        assertEquals("30", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("30", test.secondOfMinute().getAsShortText());        assertEquals("30", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.secondOfMinute().getMinimumValue());        assertEquals(0, test.secondOfMinute().getMinimumValueOverall());        assertEquals(59, test.secondOfMinute().getMaximumValue());        assertEquals(59, test.secondOfMinute().getMaximumValueOverall());    }    public void testPropertyAddSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 39, 40);                copy = test.secondOfMinute().addToCopy(29);        check(copy, 10, 20, 59, 40);                copy = test.secondOfMinute().addToCopy(30);        check(copy, 10, 21, 0, 40);                copy = test.secondOfMinute().addToCopy(39 * 60 + 29);        check(copy, 10, 59, 59, 40);                copy = test.secondOfMinute().addToCopy(39 * 60 + 30);        check(copy, 11, 0, 0, 40);                try {            test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.secondOfMinute().addToCopy(-9);        check(copy, 10, 20, 21, 40);                copy = test.secondOfMinute().addToCopy(-30);        check(copy, 10, 20, 0, 40);                copy = test.secondOfMinute().addToCopy(-31);        check(copy, 10, 19, 59, 40);                copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30));        check(copy, 0, 0, 0, 40);                try {            test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 39, 40);                copy = test.secondOfMinute().addWrapFieldToCopy(49);        check(copy, 10, 20, 19, 40);                copy = test.secondOfMinute().addWrapFieldToCopy(-47);        check(copy, 10, 20, 43, 40);    }    public void testPropertySetSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 12, 40);                try {            test.secondOfMinute().setCopy(60);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.secondOfMinute().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 12, 40);    }    public void testPropertyCompareToSecond() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0);        assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);        assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);        try {            test1.secondOfMinute().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0);        assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0);        assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0);        try {            test1.secondOfMinute().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getReadablePartial());        assertSame(test, test.millisOfSecond().getTimeOfDay());        assertEquals(40, test.millisOfSecond().get());        assertEquals("40", test.millisOfSecond().getAsText());        assertEquals("40", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("40", test.millisOfSecond().getAsShortText());        assertEquals("40", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.millisOfSecond().getMinimumValue());        assertEquals(0, test.millisOfSecond().getMinimumValueOverall());        assertEquals(999, test.millisOfSecond().getMaximumValue());        assertEquals(999, test.millisOfSecond().getMaximumValueOverall());    }    public void testPropertyAddMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 49);                copy = test.millisOfSecond().addToCopy(959);        check(copy, 10, 20, 30, 999);                copy = test.millisOfSecond().addToCopy(960);        check(copy, 10, 20, 31, 0);                copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);        check(copy, 23, 59, 59, 999);                try {            test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.millisOfSecond().addToCopy(-9);        check(copy, 10, 20, 30, 31);                copy = test.millisOfSecond().addToCopy(-40);        check(copy, 10, 20, 30, 0);                copy = test.millisOfSecond().addToCopy(-41);        check(copy, 10, 20, 29, 999);                copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));        check(copy, 0, 0, 0, 0);                try {            test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 49);                copy = test.millisOfSecond().addWrapFieldToCopy(995);        check(copy, 10, 20, 30, 35);                copy = test.millisOfSecond().addWrapFieldToCopy(-47);        check(copy, 10, 20, 30, 993);    }    public void testPropertySetMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 12);                try {            test.millisOfSecond().setCopy(1000);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.millisOfSecond().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 12);    }    public void testPropertyCompareToMilli() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0);        assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);        assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);        try {            test1.millisOfSecond().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0);        assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0);        assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0);        try {            test1.millisOfSecond().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {        assertEquals(hour, test.getHourOfDay());        assertEquals(min, test.getMinuteOfHour());        assertEquals(sec, test.getSecondOfMinute());        assertEquals(milli, test.getMillisOfSecond());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Constructors.class);    }    public TestMutableDateTime_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        MutableDateTime test = new MutableDateTime();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new MutableDateTime(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new MutableDateTime(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new MutableDateTime(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0);        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  // +02:00        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInstant_Constructors extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        // 1970-06-09    private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 1970-04-05    private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 1971-05-06    private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInstant_Constructors.class);    }    public TestInstant_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        Instant test = new Instant();        assertEquals(null, test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        Instant test = new Instant(TEST_TIME1);        assertEquals(null, test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        Instant test = new Instant(TEST_TIME2);        assertEquals(null, test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        Instant test = new Instant(date);        assertEquals(null, test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new Instant(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        Instant test = new Instant((Object) null);        assertEquals(null, test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            Instant test = new Instant(new Integer(0));            assertEquals(null, test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.PrintStream;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import java.util.HashSet;import java.util.Locale;import java.util.Set;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.tz.DefaultNameProvider;import org.joda.time.tz.NameProvider;import org.joda.time.tz.Provider;import org.joda.time.tz.UTCProvider;import org.joda.time.tz.ZoneInfoProvider;/** * This class is a JUnit test for DateTimeZone. * * @author Stephen Colebourne */public class TestDateTimeZone extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_SUMMER =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-01-09    private long TEST_TIME_WINTER =            (y2002days + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }        private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeZone.class);    }    public TestDateTimeZone(String name) {        super(name);    }    protected void setUp() throws Exception {        locale = Locale.getDefault();        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        Locale.setDefault(locale);    }    //-----------------------------------------------------------------------    public void testDefault() {        assertNotNull(DateTimeZone.getDefault());                DateTimeZone.setDefault(PARIS);        assertSame(PARIS, DateTimeZone.getDefault());                try {            DateTimeZone.setDefault(null);            fail();        } catch (IllegalArgumentException ex) {}    }                public void testDefaultSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setDefault(PARIS);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    //-----------------------------------------------------------------------    public void testGetInstance_String() {        assertEquals(DateTimeZone.getDefault(), DateTimeZone.getInstance((String) null));                DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("Europe/London", zone.getID());                zone = DateTimeZone.getInstance("UTC");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance("+00:00");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance("+00");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance("+01:23");        assertEquals("+01:23", zone.getID());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),                zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.getInstance("-02:00");        assertEquals("-02:00", zone.getID());        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR),                zone.getOffset(TEST_TIME_SUMMER));                try {            DateTimeZone.getInstance("SST");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance("Europe/UK");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance("+");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance("+0");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetInstance_TimeZone() {        assertEquals(DateTimeZone.getDefault(), DateTimeZone.getInstance((TimeZone) null));                DateTimeZone zone = DateTimeZone.getInstance(TimeZone.getTimeZone("Europe/London"));        assertEquals("Europe/London", zone.getID());        assertSame(DateTimeZone.UTC, DateTimeZone.getInstance(TimeZone.getTimeZone("UTC")));                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+01:23"));        assertEquals("+01:23", zone.getID());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),                zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT-02:00"));        assertEquals("-02:00", zone.getID());        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("EST"));        assertEquals("America/New_York", zone.getID());    }    //-----------------------------------------------------------------------    public void testGetAvailableIDs() {        assertTrue(DateTimeZone.getAvailableIDs().contains("UTC"));    }    //-----------------------------------------------------------------------    public void testProvider() {        try {            assertNotNull(DateTimeZone.getProvider());                    Provider provider = DateTimeZone.getProvider();            DateTimeZone.setProvider(null);            assertEquals(provider.getClass(), DateTimeZone.getProvider().getClass());                    try {                DateTimeZone.setProvider(new MockNullIDSProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockEmptyIDSProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockNoUTCProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockBadUTCProvider());                fail();            } catch (IllegalArgumentException ex) {}                    Provider prov = new MockOKProvider();            DateTimeZone.setProvider(prov);            assertSame(prov, DateTimeZone.getProvider());            assertEquals(2, DateTimeZone.getAvailableIDs().size());            assertTrue(DateTimeZone.getAvailableIDs().contains("UTC"));            assertTrue(DateTimeZone.getAvailableIDs().contains("Europe/London"));        } finally {            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }                try {            System.setProperty("org.joda.time.DateTimeZone.Provider", "org.joda.time.tz.UTCProvider");            DateTimeZone.setProvider(null);            assertEquals(UTCProvider.class, DateTimeZone.getProvider().getClass());        } finally {            System.getProperties().remove("org.joda.time.DateTimeZone.Provider");            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }                PrintStream syserr = System.err;        try {            System.setProperty("org.joda.time.DateTimeZone.Provider", "xxx");            ByteArrayOutputStream baos = new ByteArrayOutputStream();            System.setErr(new PrintStream(baos));                        DateTimeZone.setProvider(null);                        assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());            String str = new String(baos.toByteArray());            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);        } finally {            System.setErr(syserr);            System.getProperties().remove("org.joda.time.DateTimeZone.Provider");            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }    }        public void testProviderSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setProvider(new MockOKProvider());            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    static class MockNullIDSProvider implements Provider {        public Set getAvailableIDs() {            return null;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockEmptyIDSProvider implements Provider {        public Set getAvailableIDs() {            return new HashSet();        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockNoUTCProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockBadUTCProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("UTC");            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockOKProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("UTC");            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return DateTimeZone.UTC;        }    }    //-----------------------------------------------------------------------    public void testNameProvider() {        try {            assertNotNull(DateTimeZone.getNameProvider());                    NameProvider provider = DateTimeZone.getNameProvider();            DateTimeZone.setNameProvider(null);            assertEquals(provider.getClass(), DateTimeZone.getNameProvider().getClass());                    provider = new MockOKButNullNameProvider();            DateTimeZone.setNameProvider(provider);            assertSame(provider, DateTimeZone.getNameProvider());                        assertEquals("+00:00", DateTimeZone.UTC.getShortName(TEST_TIME_SUMMER));            assertEquals("+00:00", DateTimeZone.UTC.getName(TEST_TIME_SUMMER));        } finally {            DateTimeZone.setNameProvider(null);        }                try {            System.setProperty("org.joda.time.DateTimeZone.NameProvider", "org.joda.time.tz.DefaultNameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        } finally {            System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        }                PrintStream syserr = System.err;        try {            System.setProperty("org.joda.time.DateTimeZone.NameProvider", "xxx");            ByteArrayOutputStream baos = new ByteArrayOutputStream();            System.setErr(new PrintStream(baos));                        DateTimeZone.setNameProvider(null);                        assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());            String str = new String(baos.toByteArray());            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);        } finally {            System.setErr(syserr);            System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        }    }                public void testNameProviderSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setNameProvider(new MockOKButNullNameProvider());            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    static class MockOKButNullNameProvider implements NameProvider {        public String getShortName(Locale locale, String id, String nameKey) {            return null;        }        public String getName(Locale locale, String id, String nameKey) {            return null;        }    }    //-----------------------------------------------------------------------    public void testConstructor() {        assertEquals(1, DateTimeZone.class.getDeclaredConstructors().length);        assertTrue(Modifier.isProtected(DateTimeZone.class.getDeclaredConstructors()[0].getModifiers()));        try {            new DateTimeZone(null) {                public String getNameKey(long instant) {                    return null;                }                public int getOffset(long instant) {                    return 0;                }                public int getStandardOffset(long instant) {                    return 0;                }                public boolean isFixed() {                    return false;                }                public long nextTransition(long instant) {                    return 0;                }                public long previousTransition(long instant) {                    return 0;                }                public boolean equals(Object object) {                    return false;                }            };        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetID() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals("Europe/Paris", zone.getID());    }    public void testGetNameKey() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("BST", zone.getNameKey(TEST_TIME_SUMMER));        assertEquals("GMT", zone.getNameKey(TEST_TIME_WINTER));    }    public void testGetShortName() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER));        assertEquals("GMT", zone.getShortName(TEST_TIME_WINTER));        assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));    }                public void testGetShortNameProviderName() {        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, "Europe/London", "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, null, "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, "Europe/London", null));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, null, null));    }        public void testGetShortNameNullKey() {        DateTimeZone zone = new MockDateTimeZone("Europe/London");        assertEquals("Europe/London", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));    }        public void testGetName() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER));        assertEquals("Greenwich Mean Time", zone.getName(TEST_TIME_WINTER));        assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));            }        public void testGetNameProviderName() {        assertEquals(null, DateTimeZone.getNameProvider().getName(null, "Europe/London", "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, null, "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, "Europe/London", null));        assertEquals(null, DateTimeZone.getNameProvider().getName(null, null, null));    }        public void testGetNameNullKey() {        DateTimeZone zone = new MockDateTimeZone("Europe/London");        assertEquals("Europe/London", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));    }        static class MockDateTimeZone extends DateTimeZone {        public MockDateTimeZone(String id) {            super(id);        }        public String getNameKey(long instant) {            return null;  // null        }        public int getOffset(long instant) {            return 0;        }        public int getStandardOffset(long instant) {            return 0;        }        public boolean isFixed() {            return false;        }        public long nextTransition(long instant) {            return 0;        }        public long previousTransition(long instant) {            return 0;        }        public boolean equals(Object object) {            return false;        }    }    //-----------------------------------------------------------------------    public void testGetOffset() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));                assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));                assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));                assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));    }    public void testGetOffsetFixed() {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));                assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));    }    //-----------------------------------------------------------------------    public void testGetMillisKeepLocal() {        long millisLondon = TEST_TIME_SUMMER;        long millisParis = TEST_TIME_SUMMER - 1L * DateTimeConstants.MILLIS_PER_HOUR;                assertEquals(millisParis, LONDON.getMillisKeepLocal(PARIS, millisLondon));        assertEquals(millisLondon, PARIS.getMillisKeepLocal(LONDON, millisParis));                DateTimeZone zone = DateTimeZone.getDefault();        try {            DateTimeZone.setDefault(LONDON);            assertEquals(millisLondon, PARIS.getMillisKeepLocal(null, millisParis));        } finally {            DateTimeZone.setDefault(zone);        }    }    //-----------------------------------------------------------------------    public void testIsFixed() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals(false, zone.isFixed());        assertEquals(true, DateTimeZone.UTC.isFixed());    }    //-----------------------------------------------------------------------    public void testTransitionFixed() {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");        assertEquals(TEST_TIME_SUMMER, zone.nextTransition(TEST_TIME_SUMMER));        assertEquals(TEST_TIME_WINTER, zone.nextTransition(TEST_TIME_WINTER));        assertEquals(TEST_TIME_SUMMER, zone.previousTransition(TEST_TIME_SUMMER));        assertEquals(TEST_TIME_WINTER, zone.previousTransition(TEST_TIME_WINTER));    }    //-----------------------------------------------------------------------    public void testToTimeZone() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        TimeZone tz = zone.toTimeZone();        assertEquals("Europe/Paris", tz.getID());    }    //-----------------------------------------------------------------------    public void testEqualsHashCode() {        DateTimeZone zone1 = DateTimeZone.getInstance("Europe/Paris");        DateTimeZone zone2 = DateTimeZone.getInstance("Europe/Paris");        assertEquals(true, zone1.equals(zone1));        assertEquals(true, zone1.equals(zone2));        assertEquals(true, zone2.equals(zone1));        assertEquals(true, zone2.equals(zone2));        assertEquals(true, zone1.hashCode() == zone2.hashCode());                DateTimeZone zone3 = DateTimeZone.getInstance("Europe/London");        assertEquals(true, zone3.equals(zone3));        assertEquals(false, zone1.equals(zone3));        assertEquals(false, zone2.equals(zone3));        assertEquals(false, zone3.equals(zone1));        assertEquals(false, zone3.equals(zone2));        assertEquals(false, zone1.hashCode() == zone3.hashCode());        assertEquals(true, zone3.hashCode() == zone3.hashCode());                DateTimeZone zone4 = DateTimeZone.getInstance("+01:00");        assertEquals(true, zone4.equals(zone4));        assertEquals(false, zone1.equals(zone4));        assertEquals(false, zone2.equals(zone4));        assertEquals(false, zone3.equals(zone4));        assertEquals(false, zone4.equals(zone1));        assertEquals(false, zone4.equals(zone2));        assertEquals(false, zone4.equals(zone3));        assertEquals(false, zone1.hashCode() == zone4.hashCode());        assertEquals(true, zone4.hashCode() == zone4.hashCode());                DateTimeZone zone5 = DateTimeZone.getInstance("+02:00");        assertEquals(true, zone5.equals(zone5));        assertEquals(false, zone1.equals(zone5));        assertEquals(false, zone2.equals(zone5));        assertEquals(false, zone3.equals(zone5));        assertEquals(false, zone4.equals(zone5));        assertEquals(false, zone5.equals(zone1));        assertEquals(false, zone5.equals(zone2));        assertEquals(false, zone5.equals(zone3));        assertEquals(false, zone5.equals(zone4));        assertEquals(false, zone1.hashCode() == zone5.hashCode());        assertEquals(true, zone5.hashCode() == zone5.hashCode());    }    //-----------------------------------------------------------------------    public void testToString() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals("Europe/Paris", zone.toString());        assertEquals("UTC", DateTimeZone.UTC.toString());    }    //-----------------------------------------------------------------------    public void testSerialization1() throws Exception {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(zone);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeZone result = (DateTimeZone) ois.readObject();        ois.close();                assertSame(zone, result);    }    //-----------------------------------------------------------------------    public void testSerialization2() throws Exception {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(zone);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeZone result = (DateTimeZone) ois.readObject();        ois.close();                assertSame(zone, result);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Modifier;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for PeriodType. * * @author Stephen Colebourne */public class TestPeriodType extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodType.class);    }    public TestPeriodType(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    private void assertEqualsAfterSerialization(PeriodType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        PeriodType result = (PeriodType) ois.readObject();        ois.close();                assertEquals(type, result);    }    private void assertSameAfterSerialization(PeriodType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        PeriodType result = (PeriodType) ois.readObject();        ois.close();                assertSame(type, result);    }    //-----------------------------------------------------------------------    public void testMillisType() throws Exception {        PeriodType type = PeriodType.getMillisType();        assertEquals(false, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(false, type.days().isSupported());        assertEquals(false, type.hours().isSupported());        assertEquals(false, type.minutes().isSupported());        assertEquals(false, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getMillisType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("MillisType", type.getName());        assertEquals("PeriodType[MillisType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testDayHourType() throws Exception {        PeriodType type = PeriodType.getDayHourType();        assertEquals(false, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstance(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getDayHourType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getDayHourType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("DayHourType", type.getName());        assertEquals("PeriodType[DayHourType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testDayHourType_Chronology() throws Exception {        PeriodType type = PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC());        assertEquals(false, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(null));        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(ISOChronology.getInstance()));        assertEquals(true, type.equals(PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC())));        assertEquals(false, type.equals(PeriodType.getDayHourType()));        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(false, type.hashCode() == PeriodType.getDayHourType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("DayHourType", type.getName());        assertEquals("PeriodType[DayHourType]", type.toString());        assertEqualsAfterSerialization(type);        assertSame(PeriodType.getDayHourType(), type.withChronology(null));        assertSame(PeriodType.getDayHourType(), type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testYearDayType() throws Exception {        PeriodType type = PeriodType.getYearDayType();        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstance(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getYearDayType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getYearDayType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearDayType", type.getName());        assertEquals("PeriodType[YearDayType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testYearWeekType() throws Exception {        PeriodType type = PeriodType.getYearWeekType();        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstance(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getYearWeekType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getYearWeekType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearWeekType", type.getName());        assertEquals("PeriodType[YearWeekType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testYearWeekType_Chronology() throws Exception {        PeriodType type = PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC());        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(null));        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(ISOChronology.getInstance()));        assertEquals(true, type.equals(PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC())));        assertEquals(false, type.equals(PeriodType.getYearWeekType()));        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(false, type.hashCode() == PeriodType.getYearWeekType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearWeekType", type.getName());        assertEquals("PeriodType[YearWeekType]", type.toString());        assertEqualsAfterSerialization(type);        assertSame(PeriodType.getYearWeekType(), type.withChronology(null));        assertSame(PeriodType.getYearWeekType(), type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testYearMonthType() throws Exception {        PeriodType type = PeriodType.getYearMonthType();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstance(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getYearMonthType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getYearMonthType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearMonthType", type.getName());        assertEquals("PeriodType[YearMonthType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testYearMonthType_Chronology() throws Exception {        PeriodType type = PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC());        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(null));        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(ISOChronology.getInstance()));        assertEquals(true, type.equals(PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC())));        assertEquals(false, type.equals(PeriodType.getYearMonthType()));        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(false, type.hashCode() == PeriodType.getYearMonthType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearMonthType", type.getName());        assertEquals("PeriodType[YearMonthType]", type.toString());        assertEqualsAfterSerialization(type);        assertSame(PeriodType.getYearMonthType(), type.withChronology(null));        assertSame(PeriodType.getYearMonthType(), type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testAllType() throws Exception {        PeriodType type = PeriodType.getAllType();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstance(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getAllType());        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("AllType", type.getName());        assertEquals("PeriodType[AllType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testAllType_Chronology() throws Exception {        PeriodType type = PeriodType.getAllType(BuddhistChronology.getInstanceUTC());        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(null));        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(ISOChronology.getInstance()));        assertEquals(true, type.equals(PeriodType.getAllType(BuddhistChronology.getInstanceUTC())));        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("AllType", type.getName());        assertEquals("PeriodType[AllType]", type.toString());        assertEqualsAfterSerialization(type);        assertSame(PeriodType.getAllType(), type.withChronology(null));        assertSame(PeriodType.getAllType(), type.withChronology(ISOChronology.getInstance()));        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());    }    //-----------------------------------------------------------------------    public void testDayHourTypeUTC() throws Exception {        PeriodType type = PeriodType.getDayHourTypeUTC();        assertEquals(false, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getDayHourTypeUTC());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getDayHourTypeUTC().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("DayHourType", type.getName());        assertEquals("PeriodType[DayHourType]", type.toString());        assertSameAfterSerialization(type);        assertSame(PeriodType.getDayHourType(), type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertEquals(PeriodType.getDayHourType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testYearDayTypeUTC() throws Exception {        PeriodType type = PeriodType.getYearDayTypeUTC();        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getYearDayTypeUTC());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getYearDayTypeUTC().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearDayType", type.getName());        assertEquals("PeriodType[YearDayType]", type.toString());        assertSameAfterSerialization(type);        assertSame(PeriodType.getYearDayType(), type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertEquals(PeriodType.getYearDayType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testYearWeekTypeUTC() throws Exception {        PeriodType type = PeriodType.getYearWeekTypeUTC();        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getYearWeekTypeUTC());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getYearWeekTypeUTC().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearWeekType", type.getName());        assertEquals("PeriodType[YearWeekType]", type.toString());        assertSameAfterSerialization(type);        assertSame(PeriodType.getYearWeekType(), type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertEquals(PeriodType.getYearWeekType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testYearMonthTypeUTC() throws Exception {        PeriodType type = PeriodType.getYearMonthTypeUTC();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getYearMonthTypeUTC());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getYearMonthTypeUTC().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("YearMonthType", type.getName());        assertEquals("PeriodType[YearMonthType]", type.toString());        assertSameAfterSerialization(type);        assertSame(PeriodType.getYearMonthType(), type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertEquals(PeriodType.getYearMonthType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testAllTypeUTC() throws Exception {        PeriodType type = PeriodType.getAllTypeUTC();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getAllTypeUTC());        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getAllTypeUTC().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("AllType", type.getName());        assertEquals("PeriodType[AllType]", type.toString());        assertSameAfterSerialization(type);        assertSame(PeriodType.getAllType(), type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertEquals(PeriodType.getAllType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testPreciseDayHourType() throws Exception {        PeriodType type = PeriodType.getPreciseDayHourType();        assertEquals(false, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getPreciseDayHourType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseDayHourType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("PreciseDayHourType", type.getName());        assertEquals("PeriodType[PreciseDayHourType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testPreciseYearDayType() throws Exception {        PeriodType type = PeriodType.getPreciseYearDayType();        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getPreciseYearDayType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearDayType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("PreciseYearDayType", type.getName());        assertEquals("PeriodType[PreciseYearDayType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testPreciseYearWeekType() throws Exception {        PeriodType type = PeriodType.getPreciseYearWeekType();        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getPreciseYearWeekType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearWeekType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("PreciseYearWeekType", type.getName());        assertEquals("PeriodType[PreciseYearWeekType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testPreciseYearMonthType() throws Exception {        PeriodType type = PeriodType.getPreciseYearMonthType();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getPreciseYearMonthType());        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearMonthType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());        assertEquals("PreciseYearMonthType", type.getName());        assertEquals("PeriodType[PreciseYearMonthType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testPreciseAllType() throws Exception {        PeriodType type = PeriodType.getPreciseAllType();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.getPreciseAllType());        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("PreciseAllType", type.getName());        assertEquals("PeriodType[PreciseAllType]", type.toString());        assertSameAfterSerialization(type);        assertSame(type, type.withChronology(null));        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));    }    //-----------------------------------------------------------------------    public void testMaskYears() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();        assertEquals(false, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withYearsRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withYearsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedYears[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedYears[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMonths() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withMonthsRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMonthsRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMonthsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedMonths[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedMonths[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskWeeks() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withWeeksRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withWeeksRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withWeeksRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedWeeks[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedWeeks[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskDays() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withDaysRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(false, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withDaysRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withDaysRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedDays[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedDays[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskHours() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(false, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedHours[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedHours[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMinutes() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withMinutesRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(false, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMinutesRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMinutesRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedMinutes[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedMinutes[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskSeconds() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withSecondsRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(false, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withSecondsRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withSecondsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedSeconds[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedSeconds[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMillis() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withMillisRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(true, type.hours().isSupported());        assertEquals(true, type.minutes().isSupported());        assertEquals(true, type.seconds().isSupported());        assertEquals(false, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMillisRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMillisRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedMillis[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedMillis[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskHoursMinutesSeconds() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();        assertEquals(true, type.years().isSupported());        assertEquals(true, type.months().isSupported());        assertEquals(true, type.weeks().isSupported());        assertEquals(true, type.days().isSupported());        assertEquals(false, type.hours().isSupported());        assertEquals(false, type.minutes().isSupported());        assertEquals(false, type.seconds().isSupported());        assertEquals(true, type.millis().isSupported());        assertEquals(true, type.isPrecise());        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));        assertEquals(false, type.equals(PeriodType.getMillisType()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());        assertEquals("MaskedHoursMinutesSeconds[PreciseAllType]", type.getName());        assertEquals("PeriodType[MaskedHoursMinutesSeconds[PreciseAllType]]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskWithChronology() throws Exception {        PeriodType type = PeriodType.getAllType().withYearsRemoved();        assertEquals(type, type.withChronology(null));        assertEquals(type, type.withChronology(ISOChronology.getInstance()));                PeriodType type2 = type.withChronology(CopticChronology.getInstanceUTC());        assertEquals(CopticChronology.getInstanceUTC(), type2.getChronology());        assertEquals(false, type2.years().isSupported());        assertEquals(true, type2.months().isSupported());        assertEquals(true, type2.weeks().isSupported());        assertEquals(true, type2.days().isSupported());        assertEquals(true, type2.hours().isSupported());        assertEquals(true, type2.minutes().isSupported());        assertEquals(true, type2.seconds().isSupported());        assertEquals(true, type2.millis().isSupported());    }    //-----------------------------------------------------------------------    public void testMaskTwice1() throws Exception {        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();        PeriodType type2 = type.withYearsRemoved();        assertEquals(true, type == type2);                type = PeriodType.getPreciseAllType().withMonthsRemoved();        type2 = type.withMonthsRemoved();        assertEquals(true, type == type2);                type = PeriodType.getPreciseAllType().withWeeksRemoved();        type2 = type.withWeeksRemoved();        assertEquals(true, type == type2);                type = PeriodType.getPreciseAllType().withDaysRemoved();        type2 = type.withDaysRemoved();        assertEquals(true, type == type2);                type = PeriodType.getPreciseAllType().withHoursRemoved();        type2 = type.withHoursRemoved();        assertEquals(true, type == type2);                type = PeriodType.getPreciseAllType().withMinutesRemoved();        type2 = type.withMinutesRemoved();        assertEquals(true, type == type2);                type = PeriodType.getPreciseAllType().withSecondsRemoved();        type2 = type.withSecondsRemoved();        assertEquals(true, type == type2);                type = PeriodType.getPreciseAllType().withMillisRemoved();        type2 = type.withMillisRemoved();        assertEquals(true, type == type2);    }    //-----------------------------------------------------------------------    public void testMaskTwice2() throws Exception {        PeriodType type = PeriodType.getDayHourType();        PeriodType type2 = type.withYearsRemoved();        assertEquals(true, type == type2);                type = PeriodType.getDayHourType();        type2 = type.withMonthsRemoved();        assertEquals(true, type == type2);                type = PeriodType.getDayHourType();        type2 = type.withWeeksRemoved();        assertEquals(true, type == type2);                type = PeriodType.getMillisType();        type2 = type.withDaysRemoved();        assertEquals(true, type == type2);                type = PeriodType.getMillisType();        type2 = type.withHoursRemoved();        assertEquals(true, type == type2);                type = PeriodType.getMillisType();        type2 = type.withMinutesRemoved();        assertEquals(true, type == type2);                type = PeriodType.getMillisType();        type2 = type.withSecondsRemoved();        assertEquals(true, type == type2);    }    //-----------------------------------------------------------------------    public void testMaskNullName() throws Exception {        PeriodType type = new MockPeriodTypeWithFields().withYearsRemoved();        assertEquals("MaskedYears[]", type.getName());        assertEquals("PeriodType[MaskedYears[]]", type.toString());    }            //-----------------------------------------------------------------------    public void testHashCode() throws Exception {        PeriodType type = new MockPeriodType();        assertEquals(type.hashCode(), type.hashCode());    }    //-----------------------------------------------------------------------    public void testAbstract() throws Exception {        assertEquals(true, Modifier.isPublic(PeriodType.class.getModifiers()));        assertEquals(true, Modifier.isAbstract(PeriodType.class.getModifiers()));                PeriodType type = new MockPeriodType();        assertEquals(false, type.years().isSupported());        assertEquals(false, type.months().isSupported());        assertEquals(false, type.weeks().isSupported());        assertEquals(false, type.days().isSupported());        assertEquals(false, type.hours().isSupported());        assertEquals(false, type.minutes().isSupported());        assertEquals(false, type.seconds().isSupported());        assertEquals(false, type.millis().isSupported());        assertEquals(false, type.isPrecise());        assertEquals(null, type.getChronology());        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(new MockPeriodType()));        assertEquals(false, type.equals(PeriodType.getAllType()));        assertEquals(false, type.equals(null));        assertEquals(false, type.equals("six"));        assertEquals(null, type.getName());        assertEquals("PeriodType[]", type.toString());    }    static class MockPeriodType extends PeriodType {        public String getName() {            return null;        }        public Chronology getChronology() {            return null;        }        public PeriodType withChronology(Chronology chrono) {            return null;        }        public boolean isPrecise() {            return false;        }    }    static class MockPeriodTypeWithFields extends PeriodType {        public String getName() {            return null;        }        public Chronology getChronology() {            return null;        }        public DurationField years() {            return ISOChronology.getInstanceUTC().years();        }        public DurationField months() {            return ISOChronology.getInstanceUTC().months();        }        public PeriodType withChronology(Chronology chrono) {            return null;        }        public boolean isPrecise() {            return false;        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Constructors.class);    }    public TestMutablePeriod_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor1() throws Throwable {        MutablePeriod test = new MutablePeriod();        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0, test.toDurationMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (PeriodType)     */    public void testConstructor_PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod(PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0, test.toDurationMillis());    }    public void testConstructor_PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod((PeriodType) null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0, test.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long2() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long3() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long_PeriodType2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.getMillisType());        assertEquals(PeriodType.getMillisType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(length, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long_PeriodType3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.getAllType());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length, test.toDurationMillis());    }    public void testConstructor_long_PeriodType4() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.getAllType().withMillisRemoved());        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(length - 8, test.toDurationMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (4ints)     */    public void testConstructor_4int1() throws Throwable {        MutablePeriod test = new MutablePeriod(5, 6, 7, 8);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int1() throws Throwable {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int__PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_8int__PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());    }    public void testConstructor_8int__PeriodType3() throws Throwable {        try {            new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_long_long_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_long_long_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(-3, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0L, test.toDurationMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getDayHourType());        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType().withMillisRemoved());        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());    }    public void testConstructor_RI_RI_PeriodType4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_RI_RI_PeriodType5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType());        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0L, test.toDurationMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        MutablePeriod test = new MutablePeriod("P1Y2M3D");        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_Object2() throws Throwable {        MutablePeriod test = new MutablePeriod((Object) null);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0, test.toDurationMillis());    }    public void testConstructor_Object3() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());    }    public void testConstructor_Object4() throws Throwable {        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());        MutablePeriod test = new MutablePeriod(base);        assertEquals(PeriodType.getAllType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object,PeriodType)     */    public void testConstructor_Object_PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod("P1Y2M3D", PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(false, test.isPrecise());        try {            test.toDurationMillis();            fail();        } catch (IllegalStateException ex) {}    }    public void testConstructor_Object_PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod((Object) null, PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(0, test.toDurationMillis());    }    public void testConstructor_Object_PeriodType3() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());    }    public void testConstructor_Object_PeriodType4() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());        assertEquals(true, test.isPrecise());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.TestSuite;import org.joda.test.time.BulkTest;/** * Test case. * * @author Stephen Colebourne */public class TestDateTimeConstants extends BulkTest {    /**     * The main method for this test program.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestDateTimeConstants.class);    }    /**     * TestDateTimeComparator constructor.     * @param name     */    public TestDateTimeConstants(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testConstructor() {        DateTimeConstants c = new DateTimeConstants() {        };        c.toString();    }    public void testHalfdaysOfDay() {        assertEquals(0, DateTimeConstants.AM);        assertEquals(1, DateTimeConstants.PM);    }    public void testDaysOfWeek() {        assertEquals(1, DateTimeConstants.MONDAY);        assertEquals(2, DateTimeConstants.TUESDAY);        assertEquals(3, DateTimeConstants.WEDNESDAY);        assertEquals(4, DateTimeConstants.THURSDAY);        assertEquals(5, DateTimeConstants.FRIDAY);        assertEquals(6, DateTimeConstants.SATURDAY);        assertEquals(7, DateTimeConstants.SUNDAY);    }    public void testMonthsOfYear() {        assertEquals(1, DateTimeConstants.JANUARY);        assertEquals(2, DateTimeConstants.FEBRUARY);        assertEquals(3, DateTimeConstants.MARCH);        assertEquals(4, DateTimeConstants.APRIL);        assertEquals(5, DateTimeConstants.MAY);        assertEquals(6, DateTimeConstants.JUNE);        assertEquals(7, DateTimeConstants.JULY);        assertEquals(8, DateTimeConstants.AUGUST);        assertEquals(9, DateTimeConstants.SEPTEMBER);        assertEquals(10, DateTimeConstants.OCTOBER);        assertEquals(11, DateTimeConstants.NOVEMBER);        assertEquals(12, DateTimeConstants.DECEMBER);    }    public void testEras() {        assertEquals(0, DateTimeConstants.BC);        assertEquals(0, DateTimeConstants.BCE);        assertEquals(1, DateTimeConstants.AD);        assertEquals(1, DateTimeConstants.CE);    }    public void testMaths() {        assertEquals(1000, DateTimeConstants.MILLIS_PER_SECOND);        assertEquals(60 * 1000, DateTimeConstants.MILLIS_PER_MINUTE);        assertEquals(60 * 60 * 1000, DateTimeConstants.MILLIS_PER_HOUR);        assertEquals(24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_DAY);        assertEquals(7 * 24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_WEEK);                assertEquals(60, DateTimeConstants.SECONDS_PER_MINUTE);        assertEquals(60 * 60, DateTimeConstants.SECONDS_PER_HOUR);        assertEquals(24 * 60 * 60, DateTimeConstants.SECONDS_PER_DAY);        assertEquals(7 * 24 * 60 * 60, DateTimeConstants.SECONDS_PER_WEEK);                assertEquals(60, DateTimeConstants.MINUTES_PER_HOUR);        assertEquals(24 * 60, DateTimeConstants.MINUTES_PER_DAY);        assertEquals(7 * 24 * 60, DateTimeConstants.MINUTES_PER_WEEK);                assertEquals(24, DateTimeConstants.HOURS_PER_DAY);        assertEquals(7 * 24, DateTimeConstants.HOURS_PER_WEEK);                assertEquals(7, DateTimeConstants.DAYS_PER_WEEK);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestMutableInterval_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Basics.class);    }    public TestMutableInterval_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getStartInstant().getMillis());        assertEquals(TEST_TIME2, test.getEndMillis());        assertEquals(TEST_TIME2, test.getEndInstant().getMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());    }    public void testGetDuration1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.getDuration().getMillis());    }    public void testGetDuration2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME1);        assertSame(Duration.ZERO, test.getDuration());    }    public void testEqualsHashCode() {        MutableInterval test1 = new MutableInterval(TEST_TIME1, TEST_TIME2);        MutableInterval test2 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutableInterval test3 = new MutableInterval(TEST_TIME_NOW, TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                MutableInterval test4 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test4));        assertEquals(true, test2.equals(test4));        assertEquals(false, test3.equals(test4));        assertEquals(true, test4.equals(test1));        assertEquals(true, test4.equals(test2));        assertEquals(false, test4.equals(test3));        assertEquals(true, test1.hashCode() == test4.hashCode());        assertEquals(true, test2.hashCode() == test4.hashCode());        assertEquals(false, test3.hashCode() == test4.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInterval()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInterval extends AbstractInterval {        public MockInterval() {            super();        }        public long getStartMillis() {            return TEST_TIME1;        }        public long getEndMillis() {            return TEST_TIME2;        }    }    //-----------------------------------------------------------------------    public void testContains_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(TEST_TIME1));        assertEquals(false, test.contains(TEST_TIME1 - 1));        assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2));        assertEquals(false, test.contains(TEST_TIME2));        assertEquals(true, test.contains(TEST_TIME2 - 1));    }    public void testContainsNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(true, test.containsNow());    }    public void testContains_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(new Instant(TEST_TIME1)));        assertEquals(false, test.contains(new Instant(TEST_TIME1 - 1)));        assertEquals(true, test.contains(new Instant(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2)));        assertEquals(false, test.contains(new Instant(TEST_TIME2)));        assertEquals(true, test.contains(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.contains((ReadableInstant) null));    }    //-----------------------------------------------------------------------    public void testContains_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1)));                assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));                try {            test.contains((ReadableInterval) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testOverlaps_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));                assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));                try {            test.overlaps((ReadableInterval) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testIsBefore_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(TEST_TIME1 - 1));        assertEquals(false, test.isBefore(TEST_TIME1));        assertEquals(false, test.isBefore(TEST_TIME1 + 1));                assertEquals(false, test.isBefore(TEST_TIME2 - 1));        assertEquals(true, test.isBefore(TEST_TIME2));        assertEquals(true, test.isBefore(TEST_TIME2 + 1));    }    public void testIsBeforeNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(false, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(true, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 + 1);        assertEquals(true, test.isBeforeNow());    }    public void testIsBefore_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isBefore(null));    }    //-----------------------------------------------------------------------    public void testIsAfter_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(TEST_TIME1 - 1));        assertEquals(false, test.isAfter(TEST_TIME1));        assertEquals(false, test.isAfter(TEST_TIME1 + 1));                assertEquals(false, test.isAfter(TEST_TIME2 - 1));        assertEquals(false, test.isAfter(TEST_TIME2));        assertEquals(false, test.isAfter(TEST_TIME2 + 1));    }    public void testIsAfterNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(true, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(false, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + 1);        assertEquals(false, test.isAfterNow());    }    public void testIsAfter_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Instant(TEST_TIME2 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isAfter(null));    }    //-----------------------------------------------------------------------    public void testToInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        Interval result = test.toInterval();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToMutableInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        MutableInterval result = test.toMutableInterval();        assertEquals(test, result);        assertNotSame(test, result);    }    //-----------------------------------------------------------------------    public void testToPeriod() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod();        assertEquals(PeriodType.getAllType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType1() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod(null);        assertEquals(PeriodType.getAllType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType2() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod(PeriodType.getYearWeekType());        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(9, result.getWeeks());        assertEquals(2, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType3() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod(PeriodType.getYearWeekType());        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(0, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutableInterval result = (MutableInterval) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals("2004-06-09T07:08:09.010/2005-08-13T12:14:16.018", test.toString());    }    //-----------------------------------------------------------------------    public void testCopy() {        MutableInterval test = new MutableInterval(123L, 456L);        MutableInterval cloned = test.copy();        assertEquals(test, cloned);        assertNotSame(test, cloned);    }    public void testClone() {        MutableInterval test = new MutableInterval(123L, 456L);        MutableInterval cloned = (MutableInterval) test.clone();        assertEquals(test, cloned);        assertNotSame(test, cloned);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.buddhist;import java.util.Calendar;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.test.time.BulkTest;import org.joda.time.DateTimeField;import org.joda.time.chrono.BuddhistChronology;/** * This class is the Junit unit test for a DateTimeField. * * @author Stephen Colebourne */public class TestBuddhistEraDateTimeField extends AbstractTestDateTimeField {    public TestBuddhistEraDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBuddhistEraDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "era";    }    protected DateTimeField getField() {        return BuddhistChronology.getInstanceUTC().era();    }    protected int getMinimumValue() {        return BuddhistChronology.BE;    }    protected int getMaximumValue() {        return BuddhistChronology.BE;    }    protected int getCalendarValue(long millis) {        return BuddhistChronology.BE;    }    protected long getUnitSize() {        return Long.MAX_VALUE;    }    public void testGetAsTextLocale() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsText(var[i], Locale.ENGLISH));        }    }    public void testGetAsText() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsText(var[i]));        }    }    public void testGetAsShortTextLocale() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsShortText(var[i], Locale.ENGLISH));        }    }    public void testGetAsShortText() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsShortText(var[i]));        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMinuteOfHourDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMinuteOfHourDateTimeField extends TestGJMinuteOfHourDateTimeField {    public TestISOMinuteOfHourDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMinuteOfHourDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).minuteOfHour();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMinuteOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMinuteOfDayDateTimeField extends TestGJMinuteOfDayDateTimeField {    public TestISOMinuteOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMinuteOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).minuteOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJHourOfHalfdayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOHourOfHalfdayDateTimeField extends TestGJHourOfHalfdayDateTimeField {    public TestISOHourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOHourOfHalfdayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).hourOfHalfday();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJHourOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOHourOfDayDateTimeField extends TestGJHourOfDayDateTimeField {    public TestISOHourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOHourOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).hourOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;/** * This class is a Junit unit test suite. * * @author Stephen Colebourne */public class TestSuiteISO extends TestSuite {    public TestSuiteISO(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }        public static TestSuite suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestISOMillisOfSecondDateTimeField.suite());        suite.addTest(TestISOMillisOfDayDateTimeField.suite());        suite.addTest(TestISOSecondOfMinuteDateTimeField.suite());        suite.addTest(TestISOSecondOfDayDateTimeField.suite());        suite.addTest(TestISOMinuteOfHourDateTimeField.suite());        suite.addTest(TestISOMinuteOfDayDateTimeField.suite());        suite.addTest(TestISOHalfdayOfDayDateTimeField.suite());        suite.addTest(TestISOHourOfDayDateTimeField.suite());        suite.addTest(TestISOHourOfHalfdayDateTimeField.suite());        suite.addTest(TestISOClockhourOfDayDateTimeField.suite());        suite.addTest(TestISOClockhourOfHalfdayDateTimeField.suite());                suite.addTest(TestISODayOfWeekDateTimeField.suite());        suite.addTest(TestISODayOfMonthDateTimeField.suite());        suite.addTest(TestISODayOfYearDateTimeField.suite());                suite.addTest(TestISOMonthOfYearDateTimeField.suite());//        suite.addTest(TestISOYearDateTimeField.suite());//        suite.addTest(TestISOYearOfEraDateTimeField.suite());//        suite.addTest(TestISOYearOfCenturyDateTimeField.suite());        return suite;    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMillisOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMillisOfDayDateTimeField extends TestGJMillisOfDayDateTimeField {    public TestISOMillisOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMillisOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).millisOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJClockhourOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOClockhourOfDayDateTimeField extends TestGJClockhourOfDayDateTimeField {    public TestISOClockhourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOClockhourOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).clockhourOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJDayOfWeekDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISODayOfWeekDateTimeField extends TestGJDayOfWeekDateTimeField {    public TestISODayOfWeekDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODayOfWeekDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).dayOfWeek();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMonthOfYearDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMonthOfYearDateTimeField extends TestGJMonthOfYearDateTimeField {    public TestISOMonthOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMonthOfYearDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).monthOfYear();    }    protected int[] getDMYDS(long millis) {        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJSecondOfMinuteDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOSecondOfMinuteDateTimeField extends TestGJSecondOfMinuteDateTimeField {    public TestISOSecondOfMinuteDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOSecondOfMinuteDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).secondOfMinute();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJClockhourOfHalfdayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOClockhourOfHalfdayDateTimeField extends TestGJClockhourOfHalfdayDateTimeField {    public TestISOClockhourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOClockhourOfHalfdayDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).clockhourOfHalfday();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMillisOfSecondDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMillisOfSecondDateTimeField extends TestGJMillisOfSecondDateTimeField {    public TestISOMillisOfSecondDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMillisOfSecondDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).millisOfSecond();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJHalfdayOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOHalfdayOfDayDateTimeField extends TestGJHalfdayOfDayDateTimeField {    public TestISOHalfdayOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOHalfdayOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).halfdayOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJDayOfMonthDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISODayOfMonthDateTimeField extends TestGJDayOfMonthDateTimeField {    public TestISODayOfMonthDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODayOfMonthDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).dayOfMonth();    }    protected int[] getDMYDS(long millis) {        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJDayOfYearDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISODayOfYearDateTimeField extends TestGJDayOfYearDateTimeField {    public TestISODayOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODayOfYearDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).dayOfYear();    }    protected int[] getDMYDS(long millis) {        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);    }        }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJSecondOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOSecondOfDayDateTimeField extends TestGJSecondOfDayDateTimeField {    public TestISOSecondOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOSecondOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).secondOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJClockhourOfHalfdayDateTimeField extends AbstractTestDateTimeField {    public TestGJClockhourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJClockhourOfHalfdayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }        protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int val = getCalendarValue(millis);        if (val == 12) {            val = 0;        }        int max = 11;        int min = 0;        int add = val + addWrapped;        while (add > max || add < min) {            if (addWrapped >= 0) {                add = add - (max - min) - 1;            } else {                add = add + (max - min) + 1;            }        }        return millis + ((add - val) * getUnitSize());    }        protected String getFieldName() {        return "clockhourOfHalfday";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).clockhourOfHalfday();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 12;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = ((int) ((millis / (60 * 60 * 1000)) % 24)) % 12;        } else {            val = ((int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24)) % 12;        }        return (val == 0 ? 12 : val);    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJSecondOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJSecondOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJSecondOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "secondOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).secondOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 24 * 60 * 60 - 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 1000) % (24 * 60 * 60));        } else {            return (int) (24 * 60 * 60 - 1) + (int) (((millis + 1) / 1000) % (24 * 60 * 60));        }    }    protected long getUnitSize() {        return 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJClockhourOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJClockhourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJClockhourOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }        protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int val = getCalendarValue(millis);        if (val == 24) {            val = 0;        }        int max = 23;        int min = 0;        int add = val + addWrapped;        while (add > max || add < min) {            if (addWrapped >= 0) {                add = add - (max - min) - 1;            } else {                add = add + (max - min) + 1;            }        }        return millis + ((add - val) * getUnitSize());    }        protected String getFieldName() {        return "clockhourOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).clockhourOfDay();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 24;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = (int) ((millis / (60 * 60 * 1000)) % 24);        } else {            val = (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);        }        return (val == 0 ? 24 : val);    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMillisOfSecondDateTimeField extends AbstractTestDateTimeField {    public TestGJMillisOfSecondDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMillisOfSecondDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "millisOfSecond";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).millisOfSecond();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 999;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) (millis % 1000);        } else {            return (int) (999 - ((-millis - 1) % 1000));        }    }    protected long getUnitSize() {        return 1; // 1 milli    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.text.DateFormatSymbols;import java.util.Calendar;import java.util.Locale;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJDayOfWeekDateTimeField extends AbstractTestDateTimeField {    public TestGJDayOfWeekDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJDayOfWeekDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "dayOfWeek";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).dayOfWeek();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 7;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = (int) ((millis / (24 * 60 * 60 * 1000)) % 7);        } else {            val = (int) 6 + (int) (((millis + 1) / (24 * 60 * 60 * 1000)) % 7);        }        val = val + 4;  // shift 1970-01-01 to Thursday        val = val % 7;  // readjust        return (val == 0 ? 7 : val);    }    protected long getUnitSize() {        return 24 * 60 * 60 * 1000; // 1 day    }    protected String getText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        switch (value) {            case DateTimeConstants.MONDAY :            return sym.getWeekdays()[Calendar.MONDAY];            case DateTimeConstants.TUESDAY :            return sym.getWeekdays()[Calendar.TUESDAY];            case DateTimeConstants.WEDNESDAY :            return sym.getWeekdays()[Calendar.WEDNESDAY];            case DateTimeConstants.THURSDAY :            return sym.getWeekdays()[Calendar.THURSDAY];            case DateTimeConstants.FRIDAY :            return sym.getWeekdays()[Calendar.FRIDAY];            case DateTimeConstants.SATURDAY :            return sym.getWeekdays()[Calendar.SATURDAY];            case DateTimeConstants.SUNDAY :            return sym.getWeekdays()[Calendar.SUNDAY];        }        return null;    }    protected String getShortText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        switch (value) {            case DateTimeConstants.MONDAY :            return sym.getShortWeekdays()[Calendar.MONDAY];            case DateTimeConstants.TUESDAY :            return sym.getShortWeekdays()[Calendar.TUESDAY];            case DateTimeConstants.WEDNESDAY :            return sym.getShortWeekdays()[Calendar.WEDNESDAY];            case DateTimeConstants.THURSDAY :            return sym.getShortWeekdays()[Calendar.THURSDAY];            case DateTimeConstants.FRIDAY :            return sym.getShortWeekdays()[Calendar.FRIDAY];            case DateTimeConstants.SATURDAY :            return sym.getShortWeekdays()[Calendar.SATURDAY];            case DateTimeConstants.SUNDAY :            return sym.getShortWeekdays()[Calendar.SUNDAY];        }        return null;    }    protected int getMaximumTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getWeekdays().length; i++) {            max = (max >= sym.getWeekdays()[i].length() ? max : sym.getWeekdays()[i].length());        }        return max;    }    protected int getMaximumShortTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getShortWeekdays().length; i++) {            max = (max >= sym.getShortWeekdays()[i].length() ? max : sym.getShortWeekdays()[i].length());        }        return max;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMillisOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJMillisOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMillisOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "millisOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).millisOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 24 * 60 * 60 * 1000 - 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) (millis % (24 * 60 * 60 * 1000));        } else {            return (int) (24 * 60 * 60 * 1000 - 1) + (int) ((millis + 1) % (24 * 60 * 60 * 1000));        }    }    protected long getUnitSize() {        return 1; // 1 milli    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJDayOfMonthDateTimeField extends AbstractTestGJDateTimeField {    public TestGJDayOfMonthDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJDayOfMonthDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "dayOfMonth";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).dayOfMonth();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 31;    }        protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[0];    }    protected long getAddWrappedResult(long millis, int addWrapped) {        int[] dmyd = getDMYDS(millis + getZone().getOffset(millis));        int day = dmyd[0];        int month = dmyd[1];        int year = dmyd[2];        int monthSize = dmyd[4];        if (millis == -12219469260000L && addWrapped == -13) {            int i = 0;        }                if (addWrapped == 0) {            return millis;        }        int newDay = day + addWrapped;        boolean loop = false;        do {            loop = false;            if (newDay < 1) {                newDay = newDay + monthSize;                loop = true;            } else if (newDay > monthSize) {                newDay = newDay - monthSize;                loop = true;            }        } while (loop);        return millis + ((long) (newDay - day)) * 24 * 60 * 60 * 1000;    }    protected long getUnitSize() {        return 24 * 60 * 60 * 1000; // 1 day    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJHourOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJHourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJHourOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "hourOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).hourOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 23;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / (60 * 60 * 1000)) % 24);        } else {            return (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);        }    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.util.Calendar;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJYearOfEraDateTimeField extends AbstractTestDateTimeField {    public TestGJYearOfEraDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJYearOfEraDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "yearOfEra";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).yearOfEra();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 292278993;    }    protected int getCalendarValue(long millis) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        int val = iCalendar.get(Calendar.YEAR);        return val;    }    protected long getAddedResult(long millis, int add) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        iCalendar.add(Calendar.YEAR, add);        return iCalendar.getTime().getTime();    }    protected long getAddWrappedResult(long millis, int add) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        iCalendar.add(Calendar.YEAR, add);        return iCalendar.getTime().getTime();    }        protected long getUnitSize() {        return 365 * 24 * 60 * 60 * 1000; // 365 day    }    protected long getIncrementSize() {        return 8 * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 32L * 24 * 60 * 60 * 1000;  // 32 days    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.text.DateFormatSymbols;import java.util.Locale;import junit.framework.TestSuite;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMonthOfYearDateTimeField extends AbstractTestGJDateTimeField {    public TestGJMonthOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMonthOfYearDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "monthOfYear";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).monthOfYear();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 12;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[1];    }    protected long getAddedResult(long millis, int add) {        if (add == 0) {            return millis;        }//        System.out.println(new Instant(millis) + "  " + add);                int[] before = getDMYDS(millis + getZone().getOffset(millis));        int currentDay = before[0];        int currentMonth = before[1];        long newMillis = millis + (add * getUnitSize()) + (((int) (add/2)) * 24 * 60 * 60 * 1000);        int[] after = getDMYDS(newMillis + getZone().getOffset(newMillis));        int newDay = after[0];        int newMonth = after[1];                // calc effective add        int max = 12;        int min = 1;        int added = currentMonth + add;        while (added > max || added < min) {            if (add >= 0) {                added = added - (max - min) - 1;            } else {                added = added + (max - min) + 1;            }        }        int effectiveAdd = added - currentMonth;                // ensure month correct        while (currentMonth + effectiveAdd != newMonth) {            if (currentMonth + effectiveAdd == 1 && newMonth == 12) {                newMillis = newMillis + 24 * 60 * 60 * 1000;            } else if (currentMonth + effectiveAdd == 12 && newMonth == 1) {                newMillis = newMillis - 24 * 60 * 60 * 1000;            } else if (currentMonth + effectiveAdd > newMonth) {                newMillis = newMillis + 24 * 60 * 60 * 1000;            } else {                newMillis = newMillis - 24 * 60 * 60 * 1000;            }            after = getDMYDS(newMillis + getZone().getOffset(newMillis));            newDay = after[0];            newMonth = after[1];        }                // ensure day correct        if (currentDay < newDay) {            while (currentDay < newDay) {                newMillis = newMillis - 24 * 60 * 60 * 1000;                after = getDMYDS(newMillis + getZone().getOffset(newMillis));                newDay = after[0];                newMonth = after[1];                if (currentMonth + effectiveAdd != newMonth) {                    newMillis = newMillis + 24 * 60 * 60 * 1000;                    break;                }            }        } else {            while (currentDay > newDay) {                newMillis = newMillis + 24 * 60 * 60 * 1000;                after = getDMYDS(newMillis + getZone().getOffset(newMillis));                newDay = after[0];                newMonth = after[1];                if (currentMonth + effectiveAdd != newMonth) {                    newMillis = newMillis - 24 * 60 * 60 * 1000;                    break;                }            }        }        //        System.out.println(new Instant(newMillis) + "  " + add);        return newMillis;    }    protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int[] before = getDMYDS(millis + getZone().getOffset(millis));        int val = before[1];        int max = 12;        int min = 1;        int add = val + addWrapped;        while (add > max || add < min) {            if (addWrapped >= 0) {                add = add - (max - min) - 1;            } else {                add = add + (max - min) + 1;            }        }        int amount = add - val;        if (amount == 0) {            return millis;        } else {            return getAddedResult(millis, amount);        }    }        protected long getUnitSize() {        return 30L * 24 * 60 * 60 * 1000; // 30 day    }    protected long getIncrementSize() {        return 8L * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 32L * 24 * 60 * 60 * 1000;  // 32 days    }        protected String getText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getMonths()[value - 1];    }    protected String getShortText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getShortMonths()[value - 1];    }        protected int getMaximumTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getMonths().length; i++) {            max = (max >= sym.getMonths()[i].length() ? max : sym.getMonths()[i].length());        }        return max;    }    protected int getMaximumShortTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getShortMonths().length; i++) {            max = (max >= sym.getShortMonths()[i].length() ? max : sym.getShortMonths()[i].length());        }        return max;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.text.DateFormatSymbols;import java.util.Locale;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJHalfdayOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJHalfdayOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJHalfdayOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "halfdayOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).halfdayOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = (int) ((millis / (60 * 60 * 1000)) % 24);        } else {            val = (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);        }        return (val < 12 ? 0 : 1);    }    protected long getUnitSize() {        return 12 * 60 * 60 * 1000; // 12 hours    }    protected String getText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getAmPmStrings()[value];    }    protected String getShortText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getAmPmStrings()[value];    }        protected int getMaximumTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getAmPmStrings().length; i++) {            max = (max >= sym.getAmPmStrings()[i].length() ? max : sym.getAmPmStrings()[i].length());        }        return max;    }    protected int getMaximumShortTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getAmPmStrings().length; i++) {            max = (max >= sym.getAmPmStrings()[i].length() ? max : sym.getAmPmStrings()[i].length());        }        return max;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJHourOfHalfdayDateTimeField extends AbstractTestDateTimeField {    public TestGJHourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJHourOfHalfdayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "hourOfHalfday";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).hourOfHalfday();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 11;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return ((int) ((millis / (60 * 60 * 1000)) % 24)) % 12;        } else {            return ((int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24)) % 12;        }    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMinuteOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJMinuteOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMinuteOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "minuteOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).minuteOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 24 * 60 - 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 60000) % (24 * 60));        } else {            return (int) (24 * 60 - 1) + (int) (((millis + 1) / 60000) % (24 * 60));        }    }    protected long getUnitSize() {        return 60 * 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJSecondOfMinuteDateTimeField extends AbstractTestDateTimeField {    public TestGJSecondOfMinuteDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJSecondOfMinuteDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "secondOfMinute";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).secondOfMinute();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 59;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 1000) % 60);        } else {            return (int) 59 + (int) (((millis + 1) / 1000) % 60);        }    }    protected long getUnitSize() {        return 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.util.Date;import junit.framework.AssertionFailedError;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeField;import org.joda.time.Instant;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJYearDateTimeField extends AbstractTestGJDateTimeField {    public TestGJYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJYearDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "year";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).year();    }    protected int getMinimumValue() {        return -292269053;    }    protected int getMaximumValue() {        return 292278993;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[2];    }    protected long getAddedResult(long millis, int add) {        if (add == 0) {            return millis;        }        int[] fields = getDMYDS(millis + getZone().getOffset(millis));        int day = fields[0];        int month = fields[1];        int year = fields[2];        int yearLength = fields[5];        int newYear = year + add;        if (add > 0) {            int addDays = 0;            if (month >= 3) {                for (int i = year + 1; i <= newYear; i++) {                    if (isLeap(i, 1582)) {                        addDays += 366;                    } else {                        addDays += 365;                    }                }            } else {                for (int i = year; i < newYear; i++) {                    if (isLeap(i, 1582)) {                        addDays += 366;                    } else {                        addDays += 365;                    }                }            }            if (day == 29 && month == 2 && isLeap(newYear, 1582) == false) {                addDays = addDays - 1;            }            millis = millis + (addDays * 24 * 60 * 60 * 1000L);        } else {            int addDays = 0;            if (month >= 3) {                for (int i = year; i > newYear; i--) {                    if (isLeap(i, 1582)) {                        addDays -= 366;                    } else {                        addDays -= 365;                    }                }            } else {                for (int i = year - 1; i >= newYear; i--) {                    if (isLeap(i, 1582)) {                        addDays -= 366;                    } else {                        addDays -= 365;                    }                }            }            if (day == 29 && month == 2 && isLeap(newYear, 1582) == false) {                addDays = addDays - 1;            }            millis = millis + (addDays * 24 * 60 * 60 * 1000L);        }        return millis;    }    protected long getAddWrappedResult(long millis, int add) {        return getAddedResult(millis, add);    }        protected long getUnitSize() {        return 365 * 24 * 60 * 60 * 1000; // 365 day    }    protected long getIncrementSize() {        return 8 * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 20L * 24 * 60 * 60 * 1000;  // 20 days    }            public void testIsLeapYear() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            try {                assertEquals(iCalendar.isLeapYear(field.get(var[i])), field.isLeap(var[i]));            } catch (AssertionFailedError ex) {                System.out.println("LEAPYEAR: i: "+i+" cal:"+getCalendarValue(var[i])+" get:"+getField().get(var[i])+                    " time:"+new Instant(var[i])+","+new Date(var[i])+                    " day:"+new DateTime(var[i], GJChronology.getInstance()).getDayOfMonth()+                    " month:"+new DateTime(var[i], GJChronology.getInstance()).getMonthOfYear()+                    " year:"+new DateTime(var[i], GJChronology.getInstance()).getYear());                throw ex;            }        }    }        public void testGetLeapAmount() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals(iCalendar.isLeapYear(field.get(var[i])) ? 1 : 0, field.getLeapAmount(var[i]));        }    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMinuteOfHourDateTimeField extends AbstractTestDateTimeField {    public TestGJMinuteOfHourDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMinuteOfHourDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "minuteOfHour";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).minuteOfHour();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 59;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 60000) % 60);        } else {            return (int) 59 + (int) (((millis + 1) / 60000) % 60);        }    }    protected long getUnitSize() {        return 60 * 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;/** * This class is a Junit unit test suite. * * @author Stephen Colebourne */public class TestSuiteGJ extends TestSuite {    public TestSuiteGJ(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }        public static TestSuite suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestGJMillisOfSecondDateTimeField.suite());        suite.addTest(TestGJMillisOfDayDateTimeField.suite());        suite.addTest(TestGJSecondOfMinuteDateTimeField.suite());        suite.addTest(TestGJSecondOfDayDateTimeField.suite());        suite.addTest(TestGJMinuteOfHourDateTimeField.suite());        suite.addTest(TestGJMinuteOfDayDateTimeField.suite());        suite.addTest(TestGJHalfdayOfDayDateTimeField.suite());        suite.addTest(TestGJHourOfDayDateTimeField.suite());        suite.addTest(TestGJHourOfHalfdayDateTimeField.suite());        suite.addTest(TestGJClockhourOfDayDateTimeField.suite());        suite.addTest(TestGJClockhourOfHalfdayDateTimeField.suite());                suite.addTest(TestGJDayOfWeekDateTimeField.suite());        suite.addTest(TestGJDayOfMonthDateTimeField.suite());        suite.addTest(TestGJDayOfYearDateTimeField.suite());                suite.addTest(TestGJMonthOfYearDateTimeField.suite());        suite.addTest(TestGJYearDateTimeField.suite());        suite.addTest(TestGJYearOfEraDateTimeField.suite());        suite.addTest(TestGJYearOfCenturyDateTimeField.suite());        return suite;    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJDayOfYearDateTimeField extends AbstractTestGJDateTimeField {    public TestGJDayOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJDayOfYearDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "dayOfYear";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).dayOfYear();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 366;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[3];    }    protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int[] dmyds = getDMYDS(millis + getZone().getOffset(millis));        int val = dmyds[3];        int max = dmyds[5];        int add = val + addWrapped;        while (add > max || add < 1) {            if (addWrapped >= 0) {                add -= max;            } else {                add += max;            }        }        return millis + ((add - val) * getUnitSize());    }    protected long getUnitSize() {        return 24 * 60 * 60 * 1000; // 1 day    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.util.Calendar;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJYearOfCenturyDateTimeField extends AbstractTestDateTimeField {    public TestGJYearOfCenturyDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJYearOfCenturyDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "yearOfCentury";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).yearOfCentury();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 100;    }    protected int getCalendarValue(long millis) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        int val = iCalendar.get(Calendar.YEAR);        val = val % 100;        return (val == 0 ? 100 : val);    }    protected long getAddedResult(long millis, int add) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        iCalendar.add(Calendar.YEAR, add);        return iCalendar.getTime().getTime();    }        protected long getUnitSize() {        return 365 * 24 * 60 * 60 * 1000; // 365 day    }    protected long getIncrementSize() {        return 8 * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 32L * 24 * 60 * 60 * 1000;  // 32 days    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;//import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.Arrays;import java.util.Calendar;import java.util.GregorianCalendar;import java.util.List;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.MutableDateTime;import org.joda.time.chrono.ISOChronology;/** *  A {@link TestCase} that can define both simple and bulk test methods.<P> * *  A <I>simple test method</I> is the type of test traditionally *  supplied by by {@link TestCase}.  To define a simple test, create a public *  no-argument method whose name starts with "test".  You can specify the *  the name of simple test in the constructor of <Code>BulkTest</Code>; *  a subsequent call to {@link TestCase#run} will run that simple test.<P> * *  A <I>bulk test method</I>, on the other hand, returns a new instance *  of <Code>BulkTest</Code>, which can itself define new simple and bulk *  test methods.  By using the {@link #makeSuite} method, you can *  automatically create a hierarchal suite of tests and child bulk tests.<P> * *  For instance, consider the following two classes: * *  <Pre> *  public class TestSet extends BulkTest { * *      private Set set; * *      public TestSet(Set set) { *          this.set = set; *      } * *      public void testContains() { *          boolean r = set.contains(set.iterator().next())); *          assertTrue("Set should contain first element, r); *      } * *      public void testClear() { *          set.clear(); *          assertTrue("Set should be empty after clear", set.isEmpty()); *      } *  } * * *  public class TestHashMap extends BulkTest { * *      private Map makeFullMap() { *          HashMap result = new HashMap(); *          result.put("1", "One"); *          result.put("2", "Two"); *          return result; *      } * *      public void testClear() { *          Map map = makeFullMap(); *          map.clear(); *          assertTrue("Map empty after clear", map.isEmpty()); *      } * *      public BulkTest bulkTestKeySet() { *          return new TestSet(makeFullMap().keySet()); *      } * *      public BulkTest bulkTestEntrySet() { *          return new TestSet(makeFullMap().entrySet()); *      } *  } *  </Pre> * *  In the above examples, <Code>TestSet</Code> defines two *  simple test methods and no bulk test methods; <Code>TestHashMap</Code> *  defines one simple test method and two bulk test methods.  When *  <Code>makeSuite(TestHashMap.class).run</Code> is executed, *  <I>five</I> simple test methods will be run, in this order:<P> * *  <Ol> *  <Li>TestHashMap.testClear() *  <Li>TestHashMap.bulkTestKeySet().testContains(); *  <Li>TestHashMap.bulkTestKeySet().testClear(); *  <Li>TestHashMap.bulkTestEntrySet().testContains(); *  <Li>TestHashMap.bulkTestEntrySet().testClear(); *  </Ol> * *  In the graphical junit test runners, the tests would be displayed in *  the following tree:<P> * *  <UL> *  <LI>TestHashMap</LI> *      <UL> *      <LI>testClear *      <LI>bulkTestKeySet *          <UL> *          <LI>testContains *          <LI>testClear *          </UL> *      <LI>bulkTestEntrySet *          <UL> *          <LI>testContains *          <LI>testClear *          </UL> *      </UL> *  </UL> * *  A subclass can override a superclass's bulk test by *  returning <Code>null</Code> from the bulk test method.  If you only *  want to override specific simple tests within a bulk test, use the *  {@link #ignoredSimpleTests} method.<P> * *  Note that if you want to use the bulk test methods, you <I>must</I> *  define your <Code>suite()</Code> method to use {@link #makeSuite}. *  The ordinary {@link TestSuite} constructor doesn't know how to *  interpret bulk test methods. * *  Original implementation modified slightly for use with Joda ISO Time *  testing. * *  @author Paul Jack *  @author Guy Allard * */public class BulkTest extends TestCase implements Cloneable {    // Note:  BulkTest is Cloneable to make it easier to construct    // BulkTest instances for simple test methods that are defined in    // anonymous inner classes.  Basically we don't have to worry about    // finding wierd constructors.  (And even if we found them, techinically    // it'd be illegal for anyone but the outer class to invoke them).    // Given one BulkTest instance, we can just clone it and reset the    // method name for every simple test it defines.    /**     *  The full name of this bulk test instance.  This is the full name     *  that is compared to {@link #ignoredSimpleTests} to see if this     *  test should be ignored.  It's also displayed in the text runner     *  to ease debugging.     */    String verboseName;    /**     *  Constructs a new <Code>BulkTest</Code> instance that will run the     *  specified simple test.     *     *  @param name  the name of the simple test method to run     */    public BulkTest(String name) {        super(name);        this.verboseName = getClass().getName();    }    /**     *  Creates a clone of this <Code>BulkTest</Code>.<P>     *     *  @return  a clone of this <Code>BulkTest</Code>     */    public Object clone() {        try {            return super.clone();        } catch (CloneNotSupportedException e) {            throw new Error(); // should never happen        }    }    /**     *  Returns an array of simple test names to ignore.<P>     *     *  If a simple test that's defined by this <Code>BulkTest</Code> or     *  by one of its bulk test methods has a name that's in the returned     *  array, then that simple test will not be executed.<P>     *     *  A simple test's name is formed by taking the class name of the     *  root <Code>BulkTest</Code>, eliminating the package name, then     *  appending the names of any bulk test methods that were invoked     *  to get to the simple test, and then appending the simple test     *  method name.  The method names are delimited by periods:     *     *  <Pre>     *  TestHashMap.bulkTestEntrySet.testClear     *  </Pre>     *     *  is the name of one of the simple tests defined in the sample classes     *  described above.  If the sample <Code>TestHashMap</Code> class     *  included this method:     *     *  <Pre>     *  public String[] ignoredSimpleTests() {     *      return new String[] { "TestHashMap.bulkTestEntrySet.testClear" };     *  }     *  </Pre>     *     *  then the entry set's clear method wouldn't be tested, but the key     *  set's clear method would.     *     *  @return an array of the names of simple tests to ignore, or null if     *   no tests should be ignored     */    public String[] ignoredSimpleTests() {        return null;    }    /**     *  Returns the display name of this <Code>BulkTest</Code>.     *     *  @return the display name of this <Code>BulkTest</Code>     */    public String toString() {        return getName() + "(" + verboseName + ") ";    }    /**     *  Returns a {@link TestSuite} for testing all of the simple tests     *  <I>and</I> all the bulk tests defined by the given class.<P>     *     *  The class is examined for simple and bulk test methods; any child     *  bulk tests are also examined recursively; and the results are stored     *  in a hierarchal {@link TestSuite}.<P>     *     *  The given class must be a subclass of <Code>BulkTest</Code> and must     *  not be abstract.<P>     *     *  @param c  the class to examine for simple and bulk tests     *  @return  a {@link TestSuite} containing all the simple and bulk tests     *    defined by that class     */    public static TestSuite makeSuite(Class c) {        if (Modifier.isAbstract(c.getModifiers())) {            throw new IllegalArgumentException("Class must not be abstract.");        }        if (!BulkTest.class.isAssignableFrom(c)) {            throw new IllegalArgumentException("Class must extend BulkTest.");        }        return new BulkTestSuiteMaker(c).make();    }    //    // Methods added by the Joda project for testing of the    // org.joda.time package and it's subpackages.    //    /**     * Build an ISODateTime string from a Gregorian calendar.     * @param gc a Gregorian Calendar instance.     * @return a String suitable for ISODateTime instantiation.     */    protected String getDateTimeString(GregorianCalendar gc) {        int year = gc.get(Calendar.YEAR);        StringBuffer retVal = new StringBuffer();        if ( gc.get(Calendar.ERA) == GregorianCalendar.BC ) {            if ( year > 1 ) retVal.append("-");            year = year - 1;        }        //        retVal.append( padNumberToLen( Math.abs(year), 4 ) );        retVal.append("-");        retVal.append( padNumberToLen(gc.get(Calendar.MONTH)+1, 2) );        retVal.append("-");        retVal.append( padNumberToLen(gc.get(Calendar.DATE), 2) );        retVal.append("T");        retVal.append(  padNumberToLen(gc.get(Calendar.HOUR), 2) );        retVal.append(":");        retVal.append( padNumberToLen(gc.get(Calendar.MINUTE), 2) );        retVal.append(":");        retVal.append( padNumberToLen(gc.get(Calendar.SECOND), 2) );        retVal.append(".");        retVal.append( padNumberToLen(gc.get(Calendar.MILLISECOND), 3) );        retVal.append("Z");        return retVal.toString();    }    /**     * Create a string from an integer, pad it on the left with     * '0's to the length specified.     * @param num The number to use.     * @param len The length to pad to.     * @return The created string.     */    protected String padNumberToLen(int num, int len) {        StringBuffer retVal = new StringBuffer( len );        retVal.insert(0, "" + num);        if ( retVal.length() >= len ) return retVal.toString();        retVal.insert(0, copiesOf("0", len - retVal.length()));        if (num < 0) {            retVal.insert(0,"-");        }        return retVal.toString();    }    /**     * Generate the specified number of copies of a String and     * return it.     * @param s The String to copy.     * @param c The number of copies.     * @return The generated String.     */    protected String copiesOf(String s, int c) {        if ( c == 0 ) return s;        StringBuffer retBuff = new StringBuffer( s.length() * c );        for (int i = 1; i <= c; ++i) {            retBuff.insert( retBuff.length(), s );        }        return retBuff.toString();    }    /**     * Convert a String to an Integer, and return the int     * value.     * @param s The string to convert.     * @return The int to return.     * @throws A NullPointerException if the string fails conversion.     */    protected int getPartValue(String s) {        Integer iVal = null;        try        {            iVal = new Integer( s );        }        catch(NumberFormatException nfe)        {        }        return iVal.intValue();    }    /**     *     * @param s An ISO format Date/Time string.     * @return The left hand side of the string.     */    protected String lhsDT(String s) {        return s.substring(0,s.indexOf('T'));    }    /**     *     * @param s An ISO format Date/Time string.     * @return The right hand side of the string.     */    protected String rhsDT(String s) {        return s.substring(s.indexOf('T')+1);    }    /**     *     * @param s An ISO format Date/Time string.     * @return An array list containing all the subelements     * of the input string.     */    protected ArrayList getDTA(String s) {        ArrayList al = new ArrayList();        String dateSide = lhsDT( s );        String timeSide = rhsDT( s );        // Date Side        if ( dateSide.substring(0,1).equals("-") )        {            al.add("-");            dateSide = dateSide.substring(1);        }        else        {            al.add("");        }        int pos = dateSide.indexOf('-');        al.add( dateSide.substring(0, pos) );        al.add("-");        pos += 1;        dateSide = dateSide.substring( pos );        //        pos = dateSide.indexOf('-');        al.add( dateSide.substring(0, pos) );        al.add("-");        al.add( dateSide.substring( ++pos ) );        al.add("T");        //        // Time Side        //        pos = timeSide.indexOf(':');        al.add( timeSide.substring(0, pos) );        al.add(":");        pos += 1;        timeSide = timeSide.substring( pos );        //        pos = timeSide.indexOf(':');        al.add( timeSide.substring(0, pos) );        al.add(":");        pos += 1;        timeSide = timeSide.substring( pos );        //        pos = timeSide.indexOf('.');        if ( pos == -1 ) {            al.add( timeSide );            return al;        }        al.add( timeSide.substring(0,pos) );        al.add(".");        pos += 1;        timeSide = timeSide.substring(pos);        pos = timeSide.indexOf('Z');        al.add( timeSide.substring(0,pos) );        al.add("Z");        //        return al;    }    /**     * An array of the short names of the days of the week.     */    protected final String[] dowShort = {        "N/A","Mon","Tue","Wed","Thu","Fri","Sat","Sun"    };    /**     * An array of the long names of the days of the week.     */    protected final String[] dowLong = {        "N/A","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"    };    /**     * An array of the short names of the month.     */    protected final String[] moyShort = {        "N/A","Jan","Feb","Mar","Apr","May","Jun",            "Jul","Aug","Sep","Oct","Nov","Dec"    };    /**     * An array of the long names of the month.     */    protected final String[] moyLong = {        "N/A","January","February","March","April","May","June",            "July","August","September","October","November","December"    };    /**     *     * @param s An ISO format Date/Time string.     * @return A Joda MutableDateTime object, or null if     * parsing fails.     */    MutableDateTime getMDTFromString(String s) {        MutableDateTime retVal = null;        try        {            retVal = new MutableDateTime( s,                ISOChronology.getInstanceUTC() );        }        catch(IllegalArgumentException pe)        {            System.err.println("IllegalArgumentException Detected");            pe.printStackTrace();        }        return retVal;    }} // End of BulkTest class// It was easier to use a separate class to do all the reflection stuff// for making the TestSuite instances.  Having permanent state around makes// it easier to handle the recursion.class BulkTestSuiteMaker {    /** The class that defines simple and bulk tests methods. */    private Class startingClass;    /** List of ignored simple test names. */    private List ignored;    /** The TestSuite we're currently populating.  Can change over time. */    private TestSuite result;    /**     *  The prefix for simple test methods.  Used to check if a test is in     *  the ignored list.     */    private String prefix;    /**     *  Constructor.     *     *  @param startingClass  the starting class     */    public BulkTestSuiteMaker(Class startingClass) {        this.startingClass = startingClass;    }    /**     *  Makes a hierarchal TestSuite based on the starting class.     *     *  @return  the hierarchal TestSuite for startingClass     */    public TestSuite make() {         this.result = new TestSuite();         this.prefix = getBaseName(startingClass);         result.setName(prefix);         BulkTest bulk = makeFirstTestCase(startingClass);         ignored = new ArrayList();         String[] s = bulk.ignoredSimpleTests();         if (s != null) {             ignored.addAll(Arrays.asList(s));         }         make(bulk);         return result;    }    /**     *  Appends all the simple tests and bulk tests defined by the given     *  instance's class to the current TestSuite.     *     *  @param bulk  An instance of the class that defines simple and bulk     *    tests for us to append     */    void make(BulkTest bulk) {        Class c = bulk.getClass();        Method[] all = c.getMethods();        for (int i = 0; i < all.length; i++) {            if (isTest(all[i])) addTest(bulk, all[i]);            if (isBulk(all[i])) addBulk(bulk, all[i]);        }    }    /**     *  Adds the simple test defined by the given method to the TestSuite.     *     *  @param bulk  The instance of the class that defined the method     *   (I know it's wierd.  But the point is, we can clone the instance     *   and not have to worry about constructors.)     *  @param m  The simple test method     */    void addTest(BulkTest bulk, Method m) {        BulkTest bulk2 = (BulkTest)bulk.clone();        bulk2.setName(m.getName());        bulk2.verboseName = prefix + "." + m.getName();        if (ignored.contains(bulk2.verboseName)) return;        result.addTest(bulk2);    }    /**     *  Adds a whole new suite of tests that are defined by the result of     *  the given bulk test method.  In other words, the given bulk test     *  method is invoked, and the resulting BulkTest instance is examined     *  for yet more simple and bulk tests.     *     *  @param bulk  The instance of the class that defined the method     *  @param m  The bulk test method     */    void addBulk(BulkTest bulk, Method m) {        BulkTest bulk2;        try {            bulk2 = (BulkTest)m.invoke(bulk, null);            if (bulk2 == null) return;        } catch (InvocationTargetException e) {            throw new Error(); // FIXME;        } catch (IllegalAccessException e) {            throw new Error(); // FIXME;        }        // Save current state on the stack.        String oldPrefix = prefix;        TestSuite oldResult = result;        prefix = prefix + "." + m.getName();        result = new TestSuite();        result.setName(m.getName());        make(bulk2);        oldResult.addTest(result);        // Restore the old state        prefix = oldPrefix;        result = oldResult;    }    /**     *  Returns the base name of the given class.     *     *  @param c  the class     *  @return the name of that class, minus any package names     */    private static String getBaseName(Class c) {        String name = c.getName();        int p = name.lastIndexOf('.');        if (p > 0) {            name = name.substring(p + 1);        }        return name;    }    // These three methods are used to create a valid BulkTest instance    // from a class.    private static Constructor getTestCaseConstructor(Class c) {        try {            return c.getConstructor(new Class[] { String.class });        } catch (NoSuchMethodException e) {            throw new IllegalArgumentException(c + " must provide " +             "a (String) constructor");        }    }    private static BulkTest makeTestCase(Class c, Method m) {        Constructor con = getTestCaseConstructor(c);        try {            return (BulkTest)con.newInstance(new String[] { m.getName() });        } catch (InvocationTargetException e) {            e.printStackTrace();            throw new RuntimeException(); // FIXME;        } catch (IllegalAccessException e) {            throw new Error(); // should never occur        } catch (InstantiationException e) {            throw new RuntimeException(); // FIXME;        }    }    private static BulkTest makeFirstTestCase(Class c) {        Method[] all = c.getMethods();        for (int i = 0; i < all.length; i++) {            if (isTest(all[i])) return makeTestCase(c, all[i]);        }        throw new IllegalArgumentException(c.getName() + " must provide "          + " at least one test method.");    }    /**     *  Returns true if the given method is a simple test method.     */    private static boolean isTest(Method m) {        if (!m.getName().startsWith("test")) return false;        if (m.getReturnType() != Void.TYPE) return false;        if (m.getParameterTypes().length != 0) return false;        int mods = m.getModifiers();        if (Modifier.isStatic(mods)) return false;        if (Modifier.isAbstract(mods)) return false;        return true;    }    /**     *  Returns true if the given method is a bulk test method.     */    private static boolean isBulk(Method m) {        if (!m.getName().startsWith("bulkTest")) return false;        if (m.getReturnType() != BulkTest.class) return false;        if (m.getParameterTypes().length != 0) return false;        int mods = m.getModifiers();        if (Modifier.isStatic(mods)) return false;        if (Modifier.isAbstract(mods)) return false;        return true;    }} // end of BulkTestSuiteMaker class
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.util.GregorianCalendar;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeZone;import org.joda.time.chrono.BuddhistChronology;import junit.framework.TestSuite;/** * This class is a Junit unit test for the * BuddhistChronology date time class. * * @author Stephen Colebourne */public class TestBuddhistChronology extends BulkTest {    // TODO: These are not TimeZone safe    private static final long SMALL_MILLIS = new GregorianCalendar(-20000, 0, 1).getTime().getTime();    private static final long LARGE_MILLIS = new GregorianCalendar(20000, 0, 1).getTime().getTime();    private static final long MILLIS_1971 = new GregorianCalendar(1971, 0, 1).getTime().getTime();    private static final long MILLIS_1970 = new GregorianCalendar(1970, 0, 1).getTime().getTime();    private static final long MILLIS_1969 = new GregorianCalendar(1969, 0, 1).getTime().getTime();        private BuddhistChronology iChrono = null;    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestBuddhistChronology.class);    }    /**     * TestDateTimeField constructor.     * @param name     */    public TestBuddhistChronology(String name) {        super(name);    }    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() throws Exception {        super.setUp();        iChrono = BuddhistChronology.getInstanceUTC();    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() throws Exception {        super.tearDown();    }    public void testEraConstant() throws Exception {        assertEquals(DateTimeConstants.CE, BuddhistChronology.BE);    }    public void testGetInstanceUTC() throws Exception {        assertNotNull(BuddhistChronology.getInstanceUTC());        assertTrue(BuddhistChronology.getInstanceUTC() instanceof BuddhistChronology);        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC());    }    public void testGetInstanceNull() throws Exception {        DateTimeZone zone = DateTimeZone.getDefault();        assertNotNull(BuddhistChronology.getInstance());        assertTrue(BuddhistChronology.getInstance() instanceof BuddhistChronology);        assertSame(zone, BuddhistChronology.getInstance().getZone());    }    public void testGetInstanceZone() throws Exception {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");        assertNotNull(BuddhistChronology.getInstance(zone));        assertTrue(BuddhistChronology.getInstance(zone) instanceof BuddhistChronology);        assertSame(zone, BuddhistChronology.getInstance(zone).getZone());    }    public void testGetInstanceZoneUTC() throws Exception {        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(DateTimeZone.UTC));    }        public void testMillisOfSecond() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMillisOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testSecondOfMinute() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testSecondOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMinuteOfHour() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMinuteOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testHourOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testClockhourOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testHourOfHalfday() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testClockhourOfHalfday() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testAmPm() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testDayOfWeek() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testDayOfMonth() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testDayOfYear() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testWeekOfYearWeek() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMonthOfYear() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testLeapYear() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }        public void testWeekOfYearYear() {        fail("TBD");    }    public void testYear() {        assertEquals("year", iChrono.year().getName());        assertSame(iChrono.year(), iChrono.year());                assertEquals(1970 + 543, iChrono.year().get(MILLIS_1970));        assertEquals(20000 + 543, iChrono.year().get(LARGE_MILLIS));                assertEquals(MILLIS_1970, iChrono.year().set(LARGE_MILLIS, 1970 + 543));                assertEquals(MILLIS_1971, iChrono.year().add(MILLIS_1970, 1));        assertEquals(MILLIS_1969, iChrono.year().add(MILLIS_1970, -1));                assertEquals(MILLIS_1971, iChrono.year().addWrapField(MILLIS_1970, 1));        assertEquals(MILLIS_1969, iChrono.year().addWrapField(MILLIS_1970, -1));                assertEquals("2513", iChrono.year().getAsShortText(MILLIS_1970));        assertEquals(9, iChrono.year().getMaximumShortTextLength(null));        assertEquals("2513", iChrono.year().getAsText(MILLIS_1970));        assertEquals(9, iChrono.year().getMaximumTextLength(null));                assertEquals(1, iChrono.year().getMinimumValue());        assertEquals(250000000 + 543, iChrono.year().getMaximumValue());                assertEquals(MILLIS_1970, iChrono.year().set(MILLIS_1970, "2513"));        assertEquals(MILLIS_1971, iChrono.year().set(MILLIS_1970, "2514"));        assertEquals(LARGE_MILLIS, iChrono.year().set(MILLIS_1970, "20543"));        try {            iChrono.year().set(MILLIS_1970, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            iChrono.year().set(MILLIS_1970, "AD");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testYearOfCentury() {        try {            iChrono.yearOfCentury();            fail();        } catch (UnsupportedOperationException ex) {}    }    public void testCenturyOfEra() {        try {            iChrono.centuryOfEra();            fail();        } catch (UnsupportedOperationException ex) {}    }    public void testEra() {        assertEquals("era", iChrono.era().getName());        assertSame(iChrono.era(), iChrono.era());                assertEquals(BuddhistChronology.BE, iChrono.era().get(SMALL_MILLIS));        assertEquals(BuddhistChronology.BE, iChrono.era().get(MILLIS_1970));        assertEquals(BuddhistChronology.BE, iChrono.era().get(LARGE_MILLIS));                assertEquals(SMALL_MILLIS, iChrono.era().set(SMALL_MILLIS, BuddhistChronology.BE));        try {            iChrono.era().set(SMALL_MILLIS, DateTimeConstants.BCE);            fail();        } catch (IllegalArgumentException ex) {}                try {            iChrono.era().add(SMALL_MILLIS, 1);            fail();        } catch (UnsupportedOperationException ex) {}                try {            iChrono.era().addWrapField(SMALL_MILLIS, 1);            fail();        } catch (UnsupportedOperationException ex) {}                assertEquals("BE", iChrono.era().getAsShortText(MILLIS_1970));        assertEquals(2, iChrono.era().getMaximumShortTextLength(null));        assertEquals("BE", iChrono.era().getAsText(MILLIS_1970));        assertEquals(2, iChrono.era().getMaximumTextLength(null));                assertEquals(BuddhistChronology.BE, iChrono.era().getMinimumValue());        assertEquals(BuddhistChronology.BE, iChrono.era().getMaximumValue());                assertEquals(MILLIS_1970, iChrono.era().set(MILLIS_1970, "BE"));        try {            iChrono.era().set(SMALL_MILLIS, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            iChrono.era().set(SMALL_MILLIS, "AD");            fail();        } catch (IllegalArgumentException ex) {}    }}