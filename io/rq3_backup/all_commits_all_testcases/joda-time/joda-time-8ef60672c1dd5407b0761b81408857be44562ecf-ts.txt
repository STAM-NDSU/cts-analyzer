/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.tz;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;import java.util.Set;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeZone;/** * This class is a JUnit test for UTCProvider. * * @author Stephen Colebourne */public class TestUTCProvider extends TestCase {    private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestUTCProvider.class);    }    public TestUTCProvider(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testClass() throws Exception {        Class cls = UTCProvider.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isPublic(con.getModifiers()));    }    //-----------------------------------------------------------------------    public void testGetAvailableIDs() throws Exception {        Provider p = new UTCProvider();        Set set = p.getAvailableIDs();        assertEquals(1, set.size());        assertEquals("UTC", set.iterator().next());    }    //-----------------------------------------------------------------------    public void testGetZone_String() throws Exception {        Provider p = new UTCProvider();        assertSame(DateTimeZone.UTC, p.getZone("UTC"));        assertEquals(null, p.getZone(null));        assertEquals(null, p.getZone("Europe/London"));        assertEquals(null, p.getZone("Blah"));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.tz;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestUTCProvider.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;import org.joda.time.PeriodType;/** * This class is a Junit unit test for PeriodFormatterBuilder. * * @author Stephen Colebourne */public class TestPeriodFormatterBuilder extends TestCase {        private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);    private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());    private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);    private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;        private PeriodFormatterBuilder builder;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodFormatterBuilder.class);    }    public TestPeriodFormatterBuilder(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);                builder = new PeriodFormatterBuilder();    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFormatYears() {        PeriodFormatter f = builder.appendYears().toFormatter();        assertEquals("1", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatMonths() {        PeriodFormatter f = builder.appendMonths().toFormatter();        assertEquals("2", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatWeeks() {        PeriodFormatter f = builder.appendWeeks().toFormatter();        assertEquals("3", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatDays() {        PeriodFormatter f = builder.appendDays().toFormatter();        assertEquals("4", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatHours() {        PeriodFormatter f = builder.appendHours().toFormatter();        assertEquals("5", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatMinutes() {        PeriodFormatter f = builder.appendMinutes().toFormatter();        assertEquals("6", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatSeconds() {        PeriodFormatter f = builder.appendSeconds().toFormatter();        assertEquals("7", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatSecondsWithMillis() {        PeriodFormatter f = builder.appendSecondsWithMillis().toFormatter();        Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0);        assertEquals("7.000", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1);        assertEquals("7.001", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 999);        assertEquals("7.999", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1000);        assertEquals("8.000", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1001);        assertEquals("8.001", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, -1);        assertEquals("6.999", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, -7, 1);        assertEquals("-6.999", f.print(p));        assertEquals(6, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, -7, -1);        assertEquals("-7.001", f.print(p));        assertEquals(6, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));    }    public void testFormatSecondsWithOptionalMillis() {        PeriodFormatter f = builder.appendSecondsWithOptionalMillis().toFormatter();        Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0);        assertEquals("7", f.print(p));        assertEquals(1, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1);        assertEquals("7.001", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 999);        assertEquals("7.999", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1000);        assertEquals("8", f.print(p));        assertEquals(1, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1001);        assertEquals("8.001", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, 7, -1);        assertEquals("6.999", f.print(p));        assertEquals(5, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, -7, 1);        assertEquals("-6.999", f.print(p));        assertEquals(6, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));                p = new Period(0, 0, 0, 0, 0, 0, -7, -1);        assertEquals("-7.001", f.print(p));        assertEquals(6, f.calculatePrintedLength(p));        assertEquals(1, f.countFieldsToPrint(p));    }    public void testFormatMillis() {        PeriodFormatter f = builder.appendMillis().toFormatter();        assertEquals("8", f.print(PERIOD));        assertEquals(1, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatMillis3Digit() {        PeriodFormatter f = builder.appendMillis3Digit().toFormatter();        assertEquals("008", f.print(PERIOD));        assertEquals(3, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatPrefixSimple1() {        PeriodFormatter f = builder.appendPrefix("Years:").appendYears().toFormatter();        assertEquals("Years:1", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatPrefixSimple2() {        PeriodFormatter f = builder.appendPrefix("Hours:").appendHours().toFormatter();        assertEquals("Hours:5", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatPrefixSimple3() {        try {            builder.appendPrefix(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormatPrefixPlural1() {        PeriodFormatter f = builder.appendPrefix("Year:", "Years:").appendYears().toFormatter();        assertEquals("Year:1", f.print(PERIOD));        assertEquals(6, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatPrefixPlural2() {        PeriodFormatter f = builder.appendPrefix("Hour:", "Hours:").appendHours().toFormatter();        assertEquals("Hours:5", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatPrefixPlural3() {        try {            builder.appendPrefix(null, "");            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendPrefix("", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendPrefix(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testFormatSuffixSimple1() {        PeriodFormatter f = builder.appendYears().appendSuffix(" years").toFormatter();        assertEquals("1 years", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatSuffixSimple2() {        PeriodFormatter f = builder.appendHours().appendSuffix(" hours").toFormatter();        assertEquals("5 hours", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatSuffixSimple3() {        try {            builder.appendSuffix(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormatSuffixSimple4() {        try {            builder.appendSuffix(" hours");            fail();        } catch (IllegalStateException ex) {}    }    public void testFormatSuffixPlural1() {        PeriodFormatter f = builder.appendYears().appendSuffix(" year", " years").toFormatter();        assertEquals("1 year", f.print(PERIOD));        assertEquals(6, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatSuffixPlural2() {        PeriodFormatter f = builder.appendHours().appendSuffix(" hour", " hours").toFormatter();        assertEquals("5 hours", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    public void testFormatSuffixPlural3() {        try {            builder.appendSuffix(null, "");            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendSuffix("", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendSuffix(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormatSuffixPlural4() {        try {            builder.appendSuffix(" hour", " hours");            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    public void testFormatPrefixSuffix() {        PeriodFormatter f = builder.appendPrefix("P").appendYears().appendSuffix("Y").toFormatter();        assertEquals("P1Y", f.print(PERIOD));        assertEquals(3, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatSeparatorSimple() {        PeriodFormatter f = builder.appendYears().appendSeparator("T").appendHours().toFormatter();        assertEquals("1T5", f.print(PERIOD));        assertEquals(3, f.calculatePrintedLength(PERIOD));        assertEquals(2, f.countFieldsToPrint(PERIOD));                assertEquals("5", f.print(TIME_PERIOD));        assertEquals(1, f.calculatePrintedLength(TIME_PERIOD));        assertEquals(1, f.countFieldsToPrint(TIME_PERIOD));                assertEquals("1", f.print(DATE_PERIOD));        assertEquals(1, f.calculatePrintedLength(DATE_PERIOD));        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));    }    public void testFormatSeparatorComplex() {        PeriodFormatter f = builder            .appendYears().appendSeparator(", ", " and ")            .appendHours().appendSeparator(", ", " and ")            .appendMinutes().appendSeparator(", ", " and ")            .toFormatter();        assertEquals("1, 5 and 6", f.print(PERIOD));        assertEquals(10, f.calculatePrintedLength(PERIOD));        assertEquals(3, f.countFieldsToPrint(PERIOD));                assertEquals("5 and 6", f.print(TIME_PERIOD));        assertEquals(7, f.calculatePrintedLength(TIME_PERIOD));        assertEquals(2, f.countFieldsToPrint(TIME_PERIOD));                assertEquals("1", f.print(DATE_PERIOD));        assertEquals(1, f.calculatePrintedLength(DATE_PERIOD));        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));    }    public void testFormatSeparatorIfFieldsAfter() {        PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsAfter("T").appendHours().toFormatter();        assertEquals("1T5", f.print(PERIOD));        assertEquals(3, f.calculatePrintedLength(PERIOD));        assertEquals(2, f.countFieldsToPrint(PERIOD));                assertEquals("T5", f.print(TIME_PERIOD));        assertEquals(2, f.calculatePrintedLength(TIME_PERIOD));        assertEquals(1, f.countFieldsToPrint(TIME_PERIOD));                assertEquals("1", f.print(DATE_PERIOD));        assertEquals(1, f.calculatePrintedLength(DATE_PERIOD));        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));    }    public void testFormatSeparatorIfFieldsBefore() {        PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsBefore("T").appendHours().toFormatter();        assertEquals("1T5", f.print(PERIOD));        assertEquals(3, f.calculatePrintedLength(PERIOD));        assertEquals(2, f.countFieldsToPrint(PERIOD));                assertEquals("5", f.print(TIME_PERIOD));        assertEquals(1, f.calculatePrintedLength(TIME_PERIOD));        assertEquals(1, f.countFieldsToPrint(TIME_PERIOD));                assertEquals("1T", f.print(DATE_PERIOD));        assertEquals(2, f.calculatePrintedLength(DATE_PERIOD));        assertEquals(1, f.countFieldsToPrint(DATE_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatLiteral() {        PeriodFormatter f = builder.appendLiteral("HELLO").toFormatter();        assertEquals("HELLO", f.print(PERIOD));        assertEquals(5, f.calculatePrintedLength(PERIOD));        assertEquals(0, f.countFieldsToPrint(PERIOD));    }    public void testFormatAppendFormatter() {        PeriodFormatter base = builder.appendYears().appendLiteral("-").toFormatter();        PeriodFormatter f = new PeriodFormatterBuilder().append(base).appendYears().toFormatter();        assertEquals("1-1", f.print(PERIOD));        assertEquals(3, f.calculatePrintedLength(PERIOD));        assertEquals(2, f.countFieldsToPrint(PERIOD));    }    public void testFormatMinDigits() {        PeriodFormatter f = new PeriodFormatterBuilder().minimumPrintedDigits(4).appendYears().toFormatter();        assertEquals("0001", f.print(PERIOD));        assertEquals(4, f.calculatePrintedLength(PERIOD));        assertEquals(1, f.countFieldsToPrint(PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatPrintZeroDefault() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(4, f.countFieldsToPrint(PERIOD));                assertEquals("---0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(4, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));        assertEquals(1, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));                assertEquals("---0", f.print(EMPTY_PERIOD));        assertEquals(4, f.calculatePrintedLength(EMPTY_PERIOD));        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));                // test only last instance of same field is output        f = new PeriodFormatterBuilder()                .appendYears().appendLiteral("-")                .appendYears().toFormatter();        assertEquals("-0", f.print(EMPTY_PERIOD));        assertEquals(2, f.calculatePrintedLength(EMPTY_PERIOD));        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));    }    public void testFormatPrintZeroRarelyLast() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroRarelyLast()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(4, f.countFieldsToPrint(PERIOD));                assertEquals("---0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(4, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));        assertEquals(1, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));                assertEquals("---0", f.print(EMPTY_PERIOD));        assertEquals(4, f.calculatePrintedLength(EMPTY_PERIOD));        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));    }    public void testFormatPrintZeroRarelyFirst() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroRarelyFirst()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(4, f.countFieldsToPrint(PERIOD));                assertEquals("0---", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(4, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));        assertEquals(1, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));                assertEquals("0---", f.print(EMPTY_PERIOD));        assertEquals(4, f.calculatePrintedLength(EMPTY_PERIOD));        assertEquals(1, f.countFieldsToPrint(EMPTY_PERIOD));    }    public void testFormatPrintZeroIfSupported() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroIfSupported()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(4, f.countFieldsToPrint(PERIOD));                assertEquals("0---0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(5, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));        assertEquals(2, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));                assertEquals("0-0-0-0", f.print(EMPTY_PERIOD));        assertEquals(7, f.calculatePrintedLength(EMPTY_PERIOD));        assertEquals(4, f.countFieldsToPrint(EMPTY_PERIOD));    }    public void testFormatPrintZeroAlways() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroAlways()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(4, f.countFieldsToPrint(PERIOD));                assertEquals("0-0-0-0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(7, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));        assertEquals(4, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));                assertEquals("1-0-0-4", f.print(YEAR_DAY_PERIOD));        assertEquals(7, f.calculatePrintedLength(YEAR_DAY_PERIOD));        assertEquals(4, f.countFieldsToPrint(YEAR_DAY_PERIOD));                assertEquals("0-0-0-0", f.print(EMPTY_PERIOD));        assertEquals(7, f.calculatePrintedLength(EMPTY_PERIOD));        assertEquals(4, f.countFieldsToPrint(EMPTY_PERIOD));    }    public void testFormatPrintZeroNever() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroNever()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.calculatePrintedLength(PERIOD));        assertEquals(4, f.countFieldsToPrint(PERIOD));                assertEquals("---", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(3, f.calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD));        assertEquals(0, f.countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.calculatePrintedLength(YEAR_DAY_PERIOD));        assertEquals(2, f.countFieldsToPrint(YEAR_DAY_PERIOD));                assertEquals("---", f.print(EMPTY_PERIOD));        assertEquals(3, f.calculatePrintedLength(EMPTY_PERIOD));        assertEquals(0, f.countFieldsToPrint(EMPTY_PERIOD));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;import org.joda.time.PeriodType;/** * This class is a Junit unit test for PeriodFormatterBuilder. * * @author Stephen Colebourne */public class TestISOPeriodFormat extends TestCase {        private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);    private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());    private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);    private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOPeriodFormat.class);    }    public TestISOPeriodFormat(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFormatStandard() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", ISOPeriodFormat.getInstance().standard().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P1Y2M3W4DT5H6M7S", ISOPeriodFormat.getInstance().standard().print(p));                p = new Period(0);        assertEquals("PT0S", ISOPeriodFormat.getInstance().standard().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("PT0M", ISOPeriodFormat.getInstance().standard().print(p));                assertEquals("P1Y4DT5H6M7.008S", ISOPeriodFormat.getInstance().standard().print(YEAR_DAY_PERIOD));        assertEquals("PT0S", ISOPeriodFormat.getInstance().standard().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P1Y2M3W4D", ISOPeriodFormat.getInstance().standard().print(DATE_PERIOD));        assertEquals("PT5H6M7.008S", ISOPeriodFormat.getInstance().standard().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternate() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P00010204T050607.008", ISOPeriodFormat.getInstance().alternate().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P00010204T050607", ISOPeriodFormat.getInstance().alternate().print(p));                p = new Period(0);        assertEquals("P00000000T000000", ISOPeriodFormat.getInstance().alternate().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P00000000T000000", ISOPeriodFormat.getInstance().alternate().print(p));                assertEquals("P00010004T050607.008", ISOPeriodFormat.getInstance().alternate().print(YEAR_DAY_PERIOD));        assertEquals("P00000000T000000", ISOPeriodFormat.getInstance().alternate().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P00010204T000000", ISOPeriodFormat.getInstance().alternate().print(DATE_PERIOD));        assertEquals("P00000000T050607.008", ISOPeriodFormat.getInstance().alternate().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternateExtended() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P0001-02-04T05:06:07.008", ISOPeriodFormat.getInstance().alternateExtended().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P0001-02-04T05:06:07", ISOPeriodFormat.getInstance().alternateExtended().print(p));                p = new Period(0);        assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.getInstance().alternateExtended().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.getInstance().alternateExtended().print(p));                assertEquals("P0001-00-04T05:06:07.008", ISOPeriodFormat.getInstance().alternateExtended().print(YEAR_DAY_PERIOD));        assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.getInstance().alternateExtended().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P0001-02-04T00:00:00", ISOPeriodFormat.getInstance().alternateExtended().print(DATE_PERIOD));        assertEquals("P0000-00-00T05:06:07.008", ISOPeriodFormat.getInstance().alternateExtended().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternateWithWeeks() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P0001W0304T050607.008", ISOPeriodFormat.getInstance().alternateWithWeeks().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P0001W0304T050607", ISOPeriodFormat.getInstance().alternateWithWeeks().print(p));                p = new Period(0);        assertEquals("P0000W0000T000000", ISOPeriodFormat.getInstance().alternateWithWeeks().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P0000W0000T000000", ISOPeriodFormat.getInstance().alternateWithWeeks().print(p));                assertEquals("P0001W0004T050607.008", ISOPeriodFormat.getInstance().alternateWithWeeks().print(YEAR_DAY_PERIOD));        assertEquals("P0000W0000T000000", ISOPeriodFormat.getInstance().alternateWithWeeks().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P0001W0304T000000", ISOPeriodFormat.getInstance().alternateWithWeeks().print(DATE_PERIOD));        assertEquals("P0000W0000T050607.008", ISOPeriodFormat.getInstance().alternateWithWeeks().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternateExtendedWithWeeks() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P0001-W03-04T05:06:07.008", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P0001-W03-04T05:06:07", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(p));                p = new Period(0);        assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(p));                assertEquals("P0001-W00-04T05:06:07.008", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(YEAR_DAY_PERIOD));        assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P0001-W03-04T00:00:00", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(DATE_PERIOD));        assertEquals("P0000-W00-00T05:06:07.008", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(TIME_PERIOD));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.format;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();                suite.addTest(TestISOPeriodFormat.suite());        suite.addTest(TestPeriodFormatterBuilder.suite());                return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.ReadablePeriod;import org.joda.time.Period;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadablePeriodConverter. * * @author Stephen Colebourne */public class TestReadablePeriodConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadablePeriodConverter.class);    }    public TestReadablePeriodConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadablePeriodConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadablePeriod.class, ReadablePeriodConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.standard())));        assertEquals(PeriodType.yearMonthDayTime(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.yearMonthDayTime())));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());        ReadablePeriodConverter.INSTANCE.setInto(m, new Period(0, 0, 0, 3, 0, 4, 0, 5), null);        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(0, m.getHours());        assertEquals(4, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(5, m.getMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadablePeriod]", ReadablePeriodConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.Interval;import org.joda.time.MutablePeriod;import org.joda.time.MutableInterval;import org.joda.time.ReadableInterval;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a JUnit test for ReadableIntervalConverter. * * @author Stephen Colebourne */public class TestReadableIntervalConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableIntervalConverter.class);    }    public TestReadableIntervalConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableIntervalConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableInterval.class, ReadableIntervalConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        Interval i = new Interval(100L, 223L);        assertEquals(123L, ReadableIntervalConverter.INSTANCE.getDurationMillis(i));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        Interval i = new Interval(100L, 223L);        assertEquals(PeriodType.standard(),            ReadableIntervalConverter.INSTANCE.getPeriodType(i));    }    public void testSetIntoPeriod_Object() throws Exception {        Interval i = new Interval(100L, 223L);        MutablePeriod m = new MutablePeriod(PeriodType.millis());        ReadableIntervalConverter.INSTANCE.setInto(m, i, null);        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(0, m.getDays());        assertEquals(0, m.getHours());        assertEquals(0, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(123, m.getMillis());    }    //-----------------------------------------------------------------------    public void testIsReadableInterval_Object_Chronology() throws Exception {        Interval i = new Interval(1234L, 5678L);        assertEquals(true, ReadableIntervalConverter.INSTANCE.isReadableInterval(i, null));    }    public void testSetIntoInterval_Object1() throws Exception {        Interval i = new Interval(0L, 123L, Chronology.getCoptic());        MutableInterval m = new MutableInterval(-1000L, 1000L, Chronology.getBuddhist());        ReadableIntervalConverter.INSTANCE.setInto(m, i, null);        assertEquals(0L, m.getStartMillis());        assertEquals(123L, m.getEndMillis());        assertEquals(Chronology.getCoptic(), m.getChronology());    }    public void testSetIntoInterval_Object2() throws Exception {        Interval i = new Interval(0L, 123L, Chronology.getCoptic());        MutableInterval m = new MutableInterval(-1000L, 1000L, Chronology.getBuddhist());        ReadableIntervalConverter.INSTANCE.setInto(m, i, Chronology.getGJ());        assertEquals(0L, m.getStartMillis());        assertEquals(123L, m.getEndMillis());        assertEquals(Chronology.getGJ(), m.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableInterval]", ReadableIntervalConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeZone;import org.joda.time.Duration;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.ReadableDuration;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadableDurationConverter. * * @author Stephen Colebourne */public class TestReadableDurationConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableDurationConverter.class);    }    public TestReadableDurationConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableDurationConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableDuration.class, ReadableDurationConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(123L)));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L)));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());        ReadableDurationConverter.INSTANCE.setInto(m, new Duration(            3L * DateTimeConstants.MILLIS_PER_DAY +            4L * DateTimeConstants.MILLIS_PER_MINUTE + 5L        ), null);        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(0, m.getDays());        assertEquals(3 * 24, m.getHours());        assertEquals(4, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(5, m.getMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableDuration]", ReadableDurationConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.MutableInterval;import org.joda.time.MutablePeriod;import org.joda.time.PeriodType;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for NullConverter. * * @author Stephen Colebourne */public class TestNullConverter extends TestCase {    private long TEST_TIME_NOW =            20 * DateTimeConstants.MILLIS_PER_DAY            + 10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestNullConverter.class);    }    public TestNullConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = NullConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(null, NullConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, PARIS));        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, JULIAN));        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, NullConverter.INSTANCE.getChronology(null, PARIS));        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, NullConverter.INSTANCE.getChronology(null, JULIAN));        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(0L, NullConverter.INSTANCE.getDurationMillis(null));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            NullConverter.INSTANCE.getPeriodType(null));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.millis());        NullConverter.INSTANCE.setInto(m, null, null);        assertEquals(0L, m.getMillis());    }    //-----------------------------------------------------------------------    public void testIsReadableInterval_Object_Chronology() throws Exception {        assertEquals(false, NullConverter.INSTANCE.isReadableInterval(null, null));    }    public void testSetInto_Object_Chronology1() throws Exception {        MutableInterval m = new MutableInterval(1000L, 2000L, Chronology.getGJ());        NullConverter.INSTANCE.setInto(m, null, null);        assertEquals(TEST_TIME_NOW, m.getStartMillis());        assertEquals(TEST_TIME_NOW, m.getEndMillis());        assertEquals(Chronology.getISO(), m.getChronology());    }    public void testSetInto_Object_Chronology2() throws Exception {        MutableInterval m = new MutableInterval(1000L, 2000L, Chronology.getGJ());        NullConverter.INSTANCE.setInto(m, null, Chronology.getCoptic());        assertEquals(TEST_TIME_NOW, m.getStartMillis());        assertEquals(TEST_TIME_NOW, m.getEndMillis());        assertEquals(Chronology.getCoptic(), m.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[null]", NullConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for CalendarConverter. * * @author Stephen Colebourne */public class TestCalendarConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone MOSCOW = DateTimeZone.getInstance("Europe/Moscow");    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO = ISOChronology.getInstance();        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestCalendarConverter.class);    }    public TestCalendarConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = CalendarConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Calendar.class, CalendarConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(123L));        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(123L));        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, PARIS));        assertEquals(123L, cal.getTime().getTime());        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (DateTimeZone) null));        assertEquals(123L, cal.getTime().getTime());    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(123L));        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN));        assertEquals(123L, cal.getTime().getTime());        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, (Chronology) null));        assertEquals(123L, cal.getTime().getTime());    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(GJChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(0L));        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MAX_VALUE));        assertEquals(JulianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MIN_VALUE));        assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal));                cal = new GregorianCalendar(new MockUnknownTimeZone());        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal));                Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc));                try {            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            assertEquals(BuddhistChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(bc));        } catch (ClassNotFoundException ex) {            // ignore        }    }    public void testGetChronology_Object_Zone() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(GJChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (DateTimeZone) null));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(0L));        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MAX_VALUE));        assertEquals(JulianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MIN_VALUE));        assertEquals(GregorianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));                Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(ISOChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(uc, PARIS));                try {            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            assertEquals(BuddhistChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(bc, PARIS));        } catch (ClassNotFoundException ex) {            // ignore        }    }    public void testGetChronology_Object_Chronology() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(JULIAN, CalendarConverter.INSTANCE.getChronology(cal, JULIAN));        assertEquals(ISO, CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.util.Calendar]", CalendarConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.Instant;import org.joda.time.ReadableInstant;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadableInstantConverter. * * @author Stephen Colebourne */public class TestReadableInstantConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableInstantConverter.class);    }    public TestReadableInstantConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableInstantConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableInstant.class, ReadableInstantConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L)));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L)));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), PARIS));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), PARIS));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (DateTimeZone) null));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), JULIAN));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), JULIAN));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (Chronology) null));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO.withUTC(), ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L)));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L)));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), PARIS));        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), DateTimeZone.getDefault()));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), DateTimeZone.getDefault()));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (DateTimeZone) null));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (DateTimeZone) null));                assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L, new MockBadChronology()), PARIS));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), JULIAN));        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), JULIAN));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (Chronology) null));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableInstant]", ReadableInstantConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestConverterManager.suite());        suite.addTest(TestConverterSet.suite());                suite.addTest(TestCalendarConverter.suite());        suite.addTest(TestDateConverter.suite());        suite.addTest(TestLongConverter.suite());        suite.addTest(TestNullConverter.suite());        suite.addTest(TestReadableDurationConverter.suite());        suite.addTest(TestReadableIntervalConverter.suite());        suite.addTest(TestReadableInstantConverter.suite());        suite.addTest(TestReadablePeriodConverter.suite());        suite.addTest(TestStringConverter.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.MutableInterval;import org.joda.time.MutablePeriod;import org.joda.time.PeriodType;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for StringConverter. * * @author Stephen Colebourne */public class TestStringConverter extends TestCase {    private static final DateTimeZone ONE_HOUR = DateTimeZone.getInstance("+01:00");    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestStringConverter.class);    }    public TestStringConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = StringConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(String.class, StringConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00"));                dt = new DateTime(2004, 1, 1, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004T+01:00"));                dt = new DateTime(2004, 6, 1, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06T+01:00"));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T+01:00"));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-161T+01:00"));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24-3T+01:00"));                dt = new DateTime(2004, 6, 7, 0, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24T+01:00"));                dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48+01:00"));                dt = new DateTime(2004, 6, 9, 12, 30, 0, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12.5+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 30, 0, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24.5+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, ONE_HOUR);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.5+01:00"));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501"));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+02:00", PARIS));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", (DateTimeZone) null));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", PARIS));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, JulianChronology.getInstance(LONDON));        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", JULIAN));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, ISOChronology.getInstance(LONDON));        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", (Chronology) null));    }    public void testGetInstantMillisInvalid() {        try {            StringConverter.INSTANCE.getInstantMillis("");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getInstantMillis("X");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00"));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501"));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", PARIS));        assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", PARIS));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (DateTimeZone) null));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", JULIAN));        assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", JULIAN));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (Chronology) null));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetDateTime() throws Exception {        DateTime base = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        DateTime test = new DateTime(base.toString(), PARIS);        assertEquals(base, test);    }    public void testGetDateTime1() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+01:00");        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(LONDON, test.getZone());    }    public void testGetDateTime2() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501");        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(LONDON, test.getZone());    }    public void testGetDateTime3() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", PARIS);        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime4() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501", PARIS);        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime5() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", JulianChronology.getInstance(PARIS));        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime6() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501", JulianChronology.getInstance(PARIS));        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object1() throws Exception {        long millis = StringConverter.INSTANCE.getDurationMillis("PT12.345S");        assertEquals(12345, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12.345s");        assertEquals(12345, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12s");        assertEquals(12000, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12.s");        assertEquals(12000, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt-12.32s");        assertEquals(-12320, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12.3456s");        assertEquals(12345, millis);    }    public void testGetDurationMillis_Object2() throws Exception {        try {            StringConverter.INSTANCE.getDurationMillis("P2Y6M9DXYZ");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PTS");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("XT0S");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PX0S");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PT0X");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PTXS");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PT0.0.0S");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PT0-00S");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            StringConverter.INSTANCE.getPeriodType("P2Y6M9D"));    }    public void testSetIntoPeriod_Object1() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y6M9DT12H24M48S", null);        assertEquals(2, m.getYears());        assertEquals(6, m.getMonths());        assertEquals(9, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(48, m.getSeconds());        assertEquals(0, m.getMillis());    }    public void testSetIntoPeriod_Object2() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48S", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(48, m.getSeconds());        assertEquals(0, m.getMillis());    }            public void testSetIntoPeriod_Object3() throws Exception {        MutablePeriod m = new MutablePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3D", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(0, m.getHours());        assertEquals(0, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(0, m.getMillis());    }            public void testSetIntoPeriod_Object4() throws Exception {        MutablePeriod m = new MutablePeriod();        try {            StringConverter.INSTANCE.setInto(m, "", null);            fail();        } catch (IllegalArgumentException ex) {}                try {            StringConverter.INSTANCE.setInto(m, "PXY", null);            fail();        } catch (IllegalArgumentException ex) {}                try {            StringConverter.INSTANCE.setInto(m, "PT0SXY", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48SX", null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testIsReadableInterval_Object_Chronology() throws Exception {        assertEquals(false, StringConverter.INSTANCE.isReadableInterval("", null));    }    public void testSetIntoInterval_Object_Chronology1() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2004-06-09/P1Y2M", null);        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getStart());        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0), m.getEnd());        assertEquals(Chronology.getISO(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology2() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "P1Y2M/2004-06-09", null);        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd());        assertEquals(Chronology.getISO(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology3() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2003-08-09/2004-06-09", null);        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd());        assertEquals(Chronology.getISO(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology4() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2004-06-09T+06:00/P1Y2M", null);        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());        assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology5() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "P1Y2M/2004-06-09T+06:00", null);        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());        assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology6() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2003-08-09T+06:00/2004-06-09T+07:00", null);        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, DateTimeZone.getInstance(6)), m.getEnd());        assertEquals(Chronology.getISO(DateTimeZone.getInstance(6)), m.getChronology());    }    public void testSetIntoIntervalEx_Object_Chronology1() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology2() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "/", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology3() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "P1Y/", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology4() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "/P1Y", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology5() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "P1Y/P2Y", null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.lang.String]", StringConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.Duration;import org.joda.time.ReadablePeriod;import org.joda.time.Period;import org.joda.time.PeriodType;import org.joda.time.Interval;import org.joda.time.JodaTimePermission;import org.joda.time.ReadWritablePeriod;import org.joda.time.ReadWritableInterval;import org.joda.time.ReadableDateTime;import org.joda.time.ReadableDuration;import org.joda.time.ReadableInstant;import org.joda.time.ReadableInterval;/** * This class is a JUnit test for ConverterManager. * * @author Stephen Colebourne */public class TestConverterManager extends TestCase {    private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestConverterManager.class);    }    public TestConverterManager(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ConverterManager.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(true, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testGetInstantConverter() {        InstantConverter c = ConverterManager.getInstance().getInstantConverter(new Long(0L));        assertEquals(Long.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new DateTime());        assertEquals(ReadableInstant.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new Date());        assertEquals(Date.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new GregorianCalendar());        assertEquals(Calendar.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getInstantConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetInstantConverterRemovedNull() {        try {            ConverterManager.getInstance().removeInstantConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getInstantConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addInstantConverter(NullConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testGetInstantConverterOKMultipleMatches() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return ReadableDateTime.class;}        };        try {            ConverterManager.getInstance().addInstantConverter(c);            InstantConverter ok = ConverterManager.getInstance().getInstantConverter(new DateTime());            // ReadableDateTime and ReadableInstant both match, but RI discarded as less specific            assertEquals(ReadableDateTime.class, ok.getSupportedType());        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testGetInstantConverterBadMultipleMatches() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Serializable.class;}        };        try {            ConverterManager.getInstance().addInstantConverter(c);            try {                ConverterManager.getInstance().getInstantConverter(new DateTime());                fail();            } catch (IllegalStateException ex) {                // Serializable and ReadableInstant both match, so cannot pick            }        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    public void testGetInstantConverters() {        InstantConverter[] array = ConverterManager.getInstance().getInstantConverters();        assertEquals(6, array.length);    }    //-----------------------------------------------------------------------    public void testAddInstantConverter1() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        try {            InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getInstantConverter(Boolean.TRUE).getSupportedType());            assertEquals(7, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter2() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return String.class;}        };        try {            InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getInstantConverter("").getSupportedType());            assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter3() {        InstantConverter removed = ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter4() {        InstantConverter removed = ConverterManager.getInstance().addInstantConverter(null);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveInstantConverter1() {        try {            InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(5, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverter2() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(c);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverter3() {        InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(null);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int DURATION_SIZE = 5;        public void testGetDurationConverter() {        DurationConverter c = ConverterManager.getInstance().getDurationConverter(new Long(0L));        assertEquals(Long.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(new Duration(123L));        assertEquals(ReadableDuration.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getDurationConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetDurationConverterRemovedNull() {        try {            ConverterManager.getInstance().removeDurationConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getDurationConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addDurationConverter(NullConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    public void testGetDurationConverters() {        DurationConverter[] array = ConverterManager.getInstance().getDurationConverters();        assertEquals(DURATION_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddDurationConverter1() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return Boolean.class;}        };        try {            DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getDurationConverter(Boolean.TRUE).getSupportedType());            assertEquals(DURATION_SIZE + 1, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().removeDurationConverter(c);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverter2() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return String.class;}        };        try {            DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getDurationConverter("").getSupportedType());            assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverter3() {        DurationConverter removed = ConverterManager.getInstance().addDurationConverter(null);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveDurationConverter1() {        try {            DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(DURATION_SIZE - 1, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverter2() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return Boolean.class;}        };        DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(c);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverter3() {        DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(null);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int PERIOD_SIZE = 5;        public void testGetPeriodConverter() {        PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8));        assertEquals(ReadablePeriod.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(new Duration(123L));        assertEquals(ReadableDuration.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetPeriodConverterRemovedNull() {        try {            ConverterManager.getInstance().removePeriodConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getPeriodConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addPeriodConverter(NullConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    public void testGetPeriodConverters() {        PeriodConverter[] array = ConverterManager.getInstance().getPeriodConverters();        assertEquals(PERIOD_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddPeriodConverter1() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}            public PeriodType getPeriodType(Object object) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        try {            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE).getSupportedType());            assertEquals(PERIOD_SIZE + 1, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().removePeriodConverter(c);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverter2() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}            public PeriodType getPeriodType(Object object) {return null;}            public Class getSupportedType() {return String.class;}        };        try {            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getPeriodConverter("").getSupportedType());            assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverter3() {        PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(null);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    public void testRemovePeriodConverter1() {        try {            PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(PERIOD_SIZE - 1, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverter2() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}            public PeriodType getPeriodType(Object object) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(c);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverter3() {        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(null);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int INTERVAL_SIZE = 3;    public void testGetIntervalConverter() {        IntervalConverter c = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getIntervalConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getIntervalConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}        try {            ConverterManager.getInstance().getIntervalConverter(new Long(0));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetIntervalConverterRemovedNull() {        try {            ConverterManager.getInstance().removeIntervalConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getIntervalConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addIntervalConverter(NullConverter.INSTANCE);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testGetIntervalConverters() {        IntervalConverter[] array = ConverterManager.getInstance().getIntervalConverters();        assertEquals(INTERVAL_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddIntervalConverter1() {        IntervalConverter c = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}            public Class getSupportedType() {return Boolean.class;}        };        try {            IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE).getSupportedType());            assertEquals(INTERVAL_SIZE + 1, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().removeIntervalConverter(c);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverter2() {        IntervalConverter c = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}            public Class getSupportedType() {return String.class;}        };        try {            IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getIntervalConverter("").getSupportedType());            assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverter3() {        IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(null);        assertEquals(null, removed);        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveIntervalConverter1() {        try {            IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(INTERVAL_SIZE - 1, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverter2() {        IntervalConverter c = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}            public Class getSupportedType() {return Boolean.class;}        };        IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(c);        assertEquals(null, removed);        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverter3() {        IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(null);        assertEquals(null, removed);        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverterSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("ConverterManager[6 instant,5 duration,5 period,3 interval]", ConverterManager.getInstance().toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;import java.util.Calendar;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateMidnight;import org.joda.time.DateTime;import org.joda.time.ReadWritableDateTime;import org.joda.time.ReadWritableInstant;import org.joda.time.ReadableDateTime;import org.joda.time.ReadableInstant;/** * This class is a JUnit test for ConverterSet. * Mostly for coverage. * * @author Stephen Colebourne */public class TestConverterSet extends TestCase {    private static final Converter c1 = new Converter() {        public Class getSupportedType() {return Boolean.class;}    };    private static final Converter c2 = new Converter() {        public Class getSupportedType() {return Character.class;}    };    private static final Converter c3 = new Converter() {        public Class getSupportedType() {return Byte.class;}    };    private static final Converter c4 = new Converter() {        public Class getSupportedType() {return Short.class;}    };    private static final Converter c4a = new Converter() {        public Class getSupportedType() {return Short.class;}    };    private static final Converter c5 = new Converter() {        public Class getSupportedType() {return Integer.class;}    };        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestConverterSet.class);    }    public TestConverterSet(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testClass() throws Exception {        Class cls = ConverterSet.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                assertEquals(1, cls.getDeclaredConstructors().length);        Constructor con = cls.getDeclaredConstructors()[0];        assertEquals(false, Modifier.isPublic(con.getModifiers()));        assertEquals(false, Modifier.isProtected(con.getModifiers()));        assertEquals(false, Modifier.isPrivate(con.getModifiers()));    }    //-----------------------------------------------------------------------    public void testBigHashtable() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        set.select(Boolean.class);        set.select(Character.class);        set.select(Byte.class);        set.select(Short.class);        set.select(Integer.class);        set.select(Long.class);        set.select(Float.class);        set.select(Double.class);        set.select(null);        set.select(Calendar.class);        set.select(GregorianCalendar.class);        set.select(DateTime.class);        set.select(DateMidnight.class);        set.select(ReadableInstant.class);        set.select(ReadableDateTime.class);        set.select(ReadWritableInstant.class);  // 16        set.select(ReadWritableDateTime.class);        set.select(DateTime.class);        assertEquals(4, set.size());    }    //-----------------------------------------------------------------------    public void testAddNullRemoved1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c5, null);        assertEquals(4, set.size());        assertEquals(5, result.size());    }    public void testAddNullRemoved2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c4, null);        assertSame(set, result);    }    public void testAddNullRemoved3() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c4a, null);        assertTrue(set != result);        assertEquals(4, set.size());        assertEquals(4, result.size());    }    //-----------------------------------------------------------------------    public void testRemoveNullRemoved1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.remove(c3, null);        assertEquals(4, set.size());        assertEquals(3, result.size());    }    public void testRemoveNullRemoved2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.remove(c5, null);        assertSame(set, result);    }    //-----------------------------------------------------------------------    public void testRemoveBadIndex1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        try {            set.remove(200, null);            fail();        } catch (IndexOutOfBoundsException ex) {}        assertEquals(4, set.size());    }    public void testRemoveBadIndex2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        try {            set.remove(-1, null);            fail();        } catch (IndexOutOfBoundsException ex) {}        assertEquals(4, set.size());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Date;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for DateConverter. * * @author Stephen Colebourne */public class TestDateConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateConverter.class);    }    public TestDateConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = DateConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Date.class, DateConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L)));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), PARIS));        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), JULIAN));        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L)));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, DateConverter.INSTANCE.getChronology(new Date(123L), PARIS));        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, DateConverter.INSTANCE.getChronology(new Date(123L), JULIAN));        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.util.Date]", DateConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for LongConverter. * * @author Stephen Colebourne */public class TestLongConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final Chronology ISO = ISOChronology.getInstance();    private static final Chronology JULIAN = JulianChronology.getInstance();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestLongConverter.class);    }    public TestLongConverter(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = LongConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Long.class, LongConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L)));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), PARIS));        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (DateTimeZone) null));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), JULIAN));        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object() throws Exception {        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L)));    }    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, LongConverter.INSTANCE.getChronology(new Long(123L), PARIS));        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, LongConverter.INSTANCE.getChronology(new Long(123L), JULIAN));        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getDurationMillis(new Long(123L)));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.lang.Long]", LongConverter.INSTANCE.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import java.util.Random;import junit.framework.TestCase;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeField;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.JulianChronology;/** * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj * against the implementations in this package. It tests all the date fields * against their principal methods. * <p> * Randomly generated values are fed into the DateTimeField methods and the * results are compared between the two chronologies. If any result doesn't * match, an error report is generated and the program exits. Each time this * test program is run, the pseudo random number generator is seeded with the * same value. This ensures consistent results between test runs. * <p> * The main method accepts three optional arguments: iterations, mode, seed. By * default, iterations is set to 1,000,000. The test will take several minutes * to run, depending on the computer's performance. Every 5 seconds a progress * message is printed. * <p> * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for * proleptic julian. To override the default random number generator seed, pass * in a third argument which accepts a long signed integer. * * @author Brian S O'Neill */public class MainTest extends TestCase {    public static final int GREGORIAN_MODE = 0;    public static final int JULIAN_MODE = 1;    private static final long MILLIS_PER_YEAR = (long)365.2425 * 24 * 60 * 60 * 1000;    private static final long _1000_YEARS = 1000 * MILLIS_PER_YEAR;    private static final long _500_YEARS = 500 * MILLIS_PER_YEAR;    private static final long MAX_MILLIS = (10000 - 1970) * MILLIS_PER_YEAR;    private static final long MIN_MILLIS = (-10000 - 1970) * MILLIS_PER_YEAR;    // Show progess reports every 5 seconds.    private static final long UPDATE_INTERVAL = 5000;    /**     * Arguments: iterations [mode [seed]]     */    public static void main(String[] args) throws Exception {        int iterations = 1000000;        int mode = GREGORIAN_MODE;        long seed = 1345435247779935L;        if (args.length > 0) {            iterations = Integer.parseInt(args[0]);            if (args.length > 1) {                if (args[1].startsWith("g")) {                    mode = GREGORIAN_MODE;                } else if (args[1].startsWith("j")) {                    mode = JULIAN_MODE;                } else {                    throw new IllegalArgumentException                        ("Unknown mode: " + args[1]);                }                if (args.length > 2) {                    seed = Long.parseLong(args[2]);                }            }        }        new MainTest(iterations, mode, seed).testChronology();    }    //-----------------------------------------------------------------------    private final int iIterations;    private final int iMode;    private final long iSeed;    private final Chronology iTest;    private final Chronology iActual;    /**     * @param iterations number of test iterations to perform     * @param mode GREGORIAN_MODE or JULIAN_MODE,0=Gregorian, 1=Julian     * @param seed seed for random number generator     */    public MainTest(int iterations, int mode, long seed) {        super("testChronology");        iIterations = iterations;        iMode = mode;        iSeed = seed;        if (mode == GREGORIAN_MODE) {            iTest = new TestGregorianChronology();            iActual = GregorianChronology.getInstanceUTC();        } else {            iTest = new TestJulianChronology();            iActual = JulianChronology.getInstanceUTC();        }    }    //-----------------------------------------------------------------------    /**     * Main junit test     */    public void testChronology() {        int iterations = iIterations;        long seed = iSeed;        String modeStr;        if (iMode == GREGORIAN_MODE) {            modeStr = "Gregorian";        } else {            modeStr = "Julian";        }        System.out.println("Testing " + modeStr + " chronology over " + iterations + " iterations");        Random rnd = new Random(seed);        long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;        for (int i=0; i<iterations; i++) {            long now = System.currentTimeMillis();            if (now >= updateMillis) {                updateMillis = now + UPDATE_INTERVAL;                double complete = ((int)((double)i / iterations * 1000.0)) / 10d;                if (complete < 100) {                    System.out.println("" + complete + "% complete (i=" + i + ")");                }            }            long millis = randomMillis(rnd);            int value = rnd.nextInt(200) - 100;            // millis2 is used for difference tests.            long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;            try {                testFields(millis, value, millis2);            } catch (RuntimeException e) {                System.out.println("Failure index: " + i);                System.out.println("Test millis: " + millis);                System.out.println("Test value: " + value);                System.out.println("Test millis2: " + millis2);                fail(e.getMessage());            }        }        System.out.println("100% complete (i=" + iterations + ")");    }    //-----------------------------------------------------------------------    private void testFields(long millis, int value, long millis2) {        testField(iTest.year(), iActual.year(), millis, value, millis2);        testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);        testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);        testField(iTest.weekyear(), iActual.weekyear(), millis, value, millis2);        testField(iTest.weekOfWeekyear(),                  iActual.weekOfWeekyear(), millis, value, millis2);        testField(iTest.dayOfWeek(), iActual.dayOfWeek(), millis, value, millis2);        testField(iTest.dayOfYear(), iActual.dayOfYear(), millis, value, millis2);    }    private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,                           int value, long millis2)    {        int a, b;        long x, y;        boolean m, n;        // get test        a = fieldA.get(millis);        b = fieldB.get(millis);        testValue(fieldA, fieldB, "get", millis, a, b);        // getMaximumValue test        // Restrict this test to the fields that matter.        Class fieldClass = fieldA.getClass();        if (fieldClass == TestGJDayOfYearField.class ||            fieldClass == TestGJDayOfMonthField.class ||            fieldClass == TestGJWeekOfWeekyearField.class) {                        a = fieldA.getMaximumValue(millis);            b = fieldB.getMaximumValue(millis);            testValue(fieldA, fieldB, "getMaximumValue", millis, a, b);        }        // set test        a = getWrappedValue            (value, fieldA.getMinimumValue(millis), fieldA.getMaximumValue(millis));        b = getWrappedValue            (value, fieldB.getMinimumValue(millis), fieldB.getMaximumValue(millis));        if (iMode == JULIAN_MODE && a == 0            && (fieldA.getName().equals("year") || fieldA.getName().equals("weekyear"))) {            // Exclude setting Julian year of zero.        } else {            x = fieldA.set(millis, a);            y = fieldB.set(millis, b);            testMillis(fieldA, fieldB, "set", millis, x, y, a, b);        }        // roundFloor test        x = fieldA.roundFloor(millis);        y = fieldB.roundFloor(millis);        testMillis(fieldA, fieldB, "roundFloor", millis, x, y);        // roundCeiling test        x = fieldA.roundCeiling(millis);        y = fieldB.roundCeiling(millis);        testMillis(fieldA, fieldB, "roundCeiling", millis, x, y);        // roundHalfFloor test        x = fieldA.roundHalfFloor(millis);        y = fieldB.roundHalfFloor(millis);        testMillis(fieldA, fieldB, "roundHalfFloor", millis, x, y);        // roundHalfEven test        x = fieldA.roundHalfEven(millis);        y = fieldB.roundHalfEven(millis);        testMillis(fieldA, fieldB, "roundHalfEven", millis, x, y);        // remainder test        x = fieldA.remainder(millis);        y = fieldB.remainder(millis);        testMillis(fieldA, fieldB, "remainder", millis, x, y);        // add test        x = fieldA.add(millis, value);        y = fieldB.add(millis, value);        testMillis(fieldA, fieldB, "add", millis, x, y);        // addWrapField test        x = fieldA.addWrapField(millis, value);        y = fieldB.addWrapField(millis, value);        testMillis(fieldA, fieldB, "addWrapField", millis, x, y);        // getDifference test        x = fieldA.getDifference(millis, millis2);        y = fieldB.getDifference(millis, millis2);        try {            testValue(fieldA, fieldB, "getDifference", millis, x, y);        } catch (RuntimeException e) {            System.out.println("Test datetime 2: " + makeDatetime(millis2));            throw e;        }        // isLeap test        m = fieldA.isLeap(millis);        n = fieldB.isLeap(millis);        testBoolean(fieldA, fieldB, "isLeap", millis, m, n);        // getLeapAmount test        a = fieldA.getLeapAmount(millis);        b = fieldB.getLeapAmount(millis);        testValue(fieldA, fieldB, "getLeapAmount", millis, a, b);    }    private int getWrappedValue(int value, int minValue, int maxValue) {        if (minValue >= maxValue) {            throw new IllegalArgumentException("MIN > MAX");        }        int wrapRange = maxValue - minValue + 1;        value -= minValue;        if (value >= 0) {            return (value % wrapRange) + minValue;        }        int remByRange = (-value) % wrapRange;        if (remByRange == 0) {            return 0 + minValue;        }        return (wrapRange - remByRange) + minValue;    }    private void testValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        if (valueA != valueB) {            failValue(fieldA, fieldB, method, millis, valueA, valueB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB, valueA, valueB);        }    }    private void testBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        if (boolA != boolB) {            failBoolean(fieldA, fieldB, method, millis, boolA, boolB);        }    }    private void failValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(valueA + " != " + valueB);        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        System.out.println("Value to set for first field: " + valueA);        System.out.println("Value to set for second field: " + valueB);        throw new RuntimeException();    }    private void failBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(boolA + " != " + boolB);        throw new RuntimeException();    }    private String makeName(DateTimeField fieldA, DateTimeField fieldB) {        if (fieldA.getName().equals(fieldB.getName())) {            return fieldA.getName();        } else {            return fieldA.getName() + "/" + fieldB.getName();        }    }    private String makeDatetime(long millis) {        return makeDatetime(millis, iActual);    }    private String makeDatetime(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString() + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }    private String makeDate(long millis) {        return makeDate(millis, iActual);    }    private String makeDate(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString("yyyy-MM-dd") + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }    //-----------------------------------------------------------------------    private static long randomMillis(Random rnd) {        long millis = rnd.nextLong();        if (millis >= 0) {            millis = millis % MAX_MILLIS;        } else {            millis = millis % -MIN_MILLIS;        }        return millis;    }    private static void dump(Chronology chrono, long millis) {        System.out.println("year:           " + chrono.year().get(millis));        System.out.println("monthOfYear:    " + chrono.monthOfYear().get(millis));        System.out.println("dayOfMonth:     " + chrono.dayOfMonth().get(millis));        System.out.println("weekyear:       " + chrono.weekyear().get(millis));        System.out.println("weekOfWeekyear: " + chrono.weekOfWeekyear().get(millis));        System.out.println("dayOfWeek:      " + chrono.dayOfWeek().get(millis));        System.out.println("dayOfYear:      " + chrono.dayOfYear().get(millis));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianMonthOfYearField extends TestGJMonthOfYearField {    public TestJulianMonthOfYearField(TestJulianChronology chrono) {        super(chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long add(long millis, long value) {        int year = iChronology.year().get(millis);        int newYear = year + (int)iChronology.div(value, 12);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        int newMonth = get(millis) + (int)iChronology.mod(value, 12);        if (newMonth > 12) {            if (newYear == -1) {                newYear = 1;            } else {                newYear++;            }            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;import org.joda.time.DurationField;import org.joda.time.chrono.BaseChronology;/** * A reference Gregorian/Julian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * <p>In theory, this class can be used to test any other Gregorian/Julian * chronology as long as almost all datetime fields are implemented differently * between the two. Fields that would most likely be implemented the same are * not supported by this class. * * <p>Unsupported features * <ul> * <li>time zones * <li>time of day * <li>year of era * <li>year of century * <li>century of era * <li>era * </ul> * * @author Brian S O'Neill */abstract class TestGJChronology extends BaseChronology {    static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;    /**     * Divide with round-negative behavior.     *     * @param divisor must be positive     */    static long div(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend / divisor;        } else {            return (dividend + 1) / divisor - 1;        }    }    /**     * Modulus with round-negative behavior, result is always positive.     *     * @param divisor must be positive     */    static long mod(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend % divisor;        } else {            return (dividend + 1) % divisor - 1 + divisor;        }    }    static long amod(long dividend, long divisor) {        long mod = mod(dividend, divisor);        return (mod == 0) ? divisor : mod;    }    /** Milliseconds from 0001-01-01 to the epoch. */    private final long iEpochMillis;    public TestGJChronology(int epochYear, int epochMonth, int epochDay) {        iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;    }    public DateTimeZone getZone() {        return null;    }    public Chronology withUTC() {        return this;    }    /**     * Unsupported.     */    public Chronology withZone(DateTimeZone zone) {        throw new UnsupportedOperationException();    }    long getTimeOnlyMillis(long millis) {        return mod(millis, MILLIS_PER_DAY);    }    long getDateOnlyMillis(long millis) {        return millis - mod(millis, MILLIS_PER_DAY);    }    public DurationField days() {        return dayOfWeek().getDurationField();    }    public DateTimeField dayOfWeek() {        return new TestGJDayOfWeekField(this);    }    public DateTimeField dayOfMonth() {        return new TestGJDayOfMonthField(this);     }    public DateTimeField dayOfYear() {        return new TestGJDayOfYearField(this);    }    public DurationField weeks() {        return weekOfWeekyear().getDurationField();    }    public DateTimeField weekOfWeekyear() {        return new TestGJWeekOfWeekyearField(this);    }    public DurationField weekyears() {        return weekyear().getDurationField();    }    public DateTimeField weekyear() {        return new TestGJWeekyearField(this);    }    public DurationField months() {        return monthOfYear().getDurationField();    }    public DateTimeField monthOfYear() {        return new TestGJMonthOfYearField(this);    }    public DurationField years() {        return year().getDurationField();    }    public DateTimeField year() {        return new TestGJYearField(this);    }    abstract long millisPerYear();    abstract long millisPerMonth();    abstract boolean isLeapYear(int year);    /**     * @return days from 0001-01-01     */    abstract long fixedFromGJ(int year, int monthOfYear, int dayOfMonth);    /**     * @param date days from 0001-01-01     * @return gj year     */    abstract int gjYearFromFixed(long date);    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    abstract int[] gjFromFixed(long date);    abstract long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek);    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    abstract int[] isoFromFixed(long date);    /**     * @param millis milliseconds from epoch     * @return days from 0001-01-01     */    long fixedFromMillis(long millis) {        return div(millis + iEpochMillis, MILLIS_PER_DAY);    }    /**     * @param fixed days from 0001-01-01     * @return milliseconds from epoch     */    long millisFromFixed(long fixed) {        return fixed * MILLIS_PER_DAY - iEpochMillis;    }    /**     * @return milliseconds from epoch     */    long millisFromGJ(int year, int monthOfYear, int dayOfMonth) {        return millisFromFixed(fixedFromGJ(year, monthOfYear, dayOfMonth));    }    /**     * @param millis milliseconds from epoch     * @return gj year     */    int gjYearFromMillis(long millis) {        return gjYearFromFixed(fixedFromMillis(millis));    }    /**     * @param millis milliseconds from epoch     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromMillis(long millis) {        return gjFromFixed(fixedFromMillis(millis));    }    /**     * @return milliseconds from epoch     */    long millisFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return millisFromFixed(fixedFromISO(weekyear, weekOfWeekyear, dayOfWeek));    }    /**     * @param millis milliseconds from epoch     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromMillis(long millis) {        return isoFromFixed(fixedFromMillis(millis));    }    /**     * @param date days from 0001-01-01     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday     * @param date days from 0001-01-01, on or before weekday     */    long weekdayOnOrBefore(long date, int weekday) {        return date - mod(date - mod(weekday, 7), 7);    }    long weekdayOnOrAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 6, weekday);    }    long weekdayNearest(long date, int weekday) {        return weekdayOnOrBefore(date + 3, weekday);    }    long weekdayBefore(long date, int weekday) {        return weekdayOnOrBefore(date - 1, weekday);    }    long weekdayAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 7, weekday);    }    long nthWeekday(int n, int weekday,                    int year, int monthOfYear, int dayOfMonth)    {        if (n > 0) {            return 7 * n + weekdayBefore                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        } else {            return 7 * n + weekdayAfter                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        }    }    long firstWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(1, weekday, year, monthOfYear, dayOfMonth);    }    long lastWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(-1, weekday, year, monthOfYear, dayOfMonth);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfMonthField extends TestGJDateTimeField {    public TestGJDayOfMonthField(TestGJChronology chrono) {        super(DateTimeFieldType.dayOfMonth(), chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[2];    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(ymd[0], ymd[1], value);    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.months();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 31;    }    public int getMaximumValue(long millis) {        int[] lengths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};        if (iChronology.year().isLeap(millis)) {            lengths[2] = 29;        }        return lengths[iChronology.monthOfYear().get(millis)];    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.field.FieldUtils;/** *  * @author Brian S O'Neill */class TestJulianWeekyearField extends TestGJWeekyearField {    public TestJulianWeekyearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapField(long millis, int value) {        int weekyear = get(millis);        int wrapped = FieldUtils.getWrappedValue            (weekyear, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - weekyear);    }    public long add(long millis, long value) {        int weekyear = get(millis);        int newWeekyear = weekyear + FieldUtils.safeToInt(value);        if (weekyear < 0) {            if (newWeekyear >= 0) {                newWeekyear++;            }        } else {            if (newWeekyear <= 0) {                newWeekyear--;            }        }        return set(millis, newWeekyear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekOfWeekyearField extends TestGJDateTimeField {    public TestGJWeekOfWeekyearField(TestGJChronology chrono) {        super(DateTimeFieldType.weekOfWeekyear(),              (long)(chrono.MILLIS_PER_DAY * 7), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[1];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(wwd[0], value, wwd[2]);    }    public long add(long millis, long value) {        return iChronology.dayOfYear().add(millis, value * 7);    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 53;    }    public int getMaximumValue(long millis) {        // Move millis to end of weekyear.        millis = iChronology.weekyear().roundFloor(millis);        millis = iChronology.weekyear().add(millis, 1);        millis = iChronology.dayOfYear().add(millis, -1);        return get(millis);    }    public long roundFloor(long millis) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.millisFromISO(wwd[0], wwd[1], 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfYearField extends TestGJDateTimeField {    public TestGJDayOfYearField(TestGJChronology chrono) {        super(DateTimeFieldType.dayOfYear(), chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int year = iChronology.gjYearFromMillis(millis);        return (int)(iChronology.fixedFromMillis(millis)                     - iChronology.fixedFromGJ(year, 1, 1)) + 1;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 366;    }    public int getMaximumValue(long millis) {        return iChronology.year().isLeap(millis) ? 366 : 365;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.field.FieldUtils;/** *  * @author Brian S O'Neill */class TestJulianYearField extends TestGJYearField {    public TestJulianYearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapField(long millis, int value) {        int year = get(millis);        int wrapped = FieldUtils.getWrappedValue            (year, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - year);    }    public long add(long millis, long value) {        int year = get(millis);        int newYear = year + FieldUtils.safeToInt(value);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        return set(millis, newYear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJMonthOfYearField extends TestGJDateTimeField {    public TestGJMonthOfYearField(TestGJChronology chrono) {        super(DateTimeFieldType.monthOfYear(), chrono.millisPerMonth(), chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long set(long millis, int value) {        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);        int[] ymd = iChronology.gjFromMillis(millis);        // First set to start of month...        millis = iChronology.millisFromGJ(ymd[0], value, 1);        // ...and use dayOfMonth field to check range.        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);        if (ymd[2] > maxDay) {            ymd[2] = maxDay;        }        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);    }    public long add(long millis, long value) {        int newYear = iChronology.year().get(millis)            + (int)iChronology.div(value, 12);        int newMonth = get(millis) + (int)iChronology.mod(value, 12);        if (newMonth > 12) {            newYear++;            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public boolean isLeap(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return ymd[1] == 2 && iChronology.isLeapYear(ymd[0]);    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 12;    }    public long roundFloor(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.millisFromGJ(ymd[0], ymd[1], 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfWeekField extends TestGJDateTimeField {    public TestGJDayOfWeekField(TestGJChronology chrono) {        super(DateTimeFieldType.dayOfWeek(), chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);        if (dayOfWeek == 0) {            dayOfWeek = 7;        }        return dayOfWeek;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 7;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianDayOfMonthField extends TestGJDayOfMonthField {    public TestJulianDayOfMonthField(TestJulianChronology chrono) {        super(chrono);    }    public long getRangeMillis() {        return iChronology.millisPerMonth();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJYearField extends TestGJDateTimeField {    public TestGJYearField(TestGJChronology chrono) {        super(DateTimeFieldType.year(), chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.gjYearFromMillis(millis);    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(value, ymd[1], ymd[2]);        if (ymd[1] == 2 && ymd[2] == 29 && !iChronology.isLeapYear(value)) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public boolean isLeap(long millis) {        return iChronology.isLeapYear(get(millis));    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromGJ(get(millis), 1, 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;/** * A reference Julian chronology implementation, intended for testing purposes * only. Correctness is favored over performance. The key functions for date * calculations are based on ones provided in "Calendrical Calculations", ISBN * 0-521-77752-6. * * @author Brian S O'Neill */public final class TestJulianChronology extends TestGJChronology {    private static final long JULIAN_EPOCH;    static {        // Constant as defined in book.        JULIAN_EPOCH = new TestGregorianChronology().fixedFromGJ(0, 12, 30);    }    /**     * Constructs with an epoch of 1969-12-19.     */    public TestJulianChronology() {        super(1969, 12, 19);    }    public TestJulianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public DateTimeField dayOfMonth() {        return new TestJulianDayOfMonthField(this);     }    public DateTimeField weekyear() {        return new TestJulianWeekyearField(this);    }    public DateTimeField monthOfYear() {        return new TestJulianMonthOfYearField(this);    }    public DateTimeField year() {        return new TestJulianYearField(this);    }    public String toString() {        return "TestJulianChronology";    }    long millisPerYear() {        return (long)(365.25 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.25 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        return mod(year, 4) == (year > 0 ? 0 : 3);    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        int y = (year < 0) ? year + 1 : year;        long y_m1 = y - 1;        long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4)            + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        return gjFromFixed(date)[0];    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);        long year = (approx <= 0) ? approx - 1 : approx;        int year_i = (int)year;        if (year_i != year) {            throw new RuntimeException("year cannot be cast to an int: " + year);        }        long priorDays = date - fixedFromGJ(year_i, 1, 1);        long correction;        if (date < fixedFromGJ(year_i, 3, 1)) {            correction = 0;        } else if (isLeapYear(year_i)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year_i, monthOfYear, 1) + 1);        return new int[]{year_i, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        if (weekyear == 0) {            throw new IllegalArgumentException("Illegal weekyear: " + weekyear);        }        if (weekyear == 1) {            weekyear = -1;        } else {            weekyear--;        }        return nthWeekday(weekOfWeekyear, 0, weekyear, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        int nextWeekyear;        if (weekyear == -1) {            nextWeekyear = 1;        } else {            nextWeekyear = weekyear + 1;        }        if (date >= fixedFromISO(nextWeekyear, 1, 1)) {            weekyear = nextWeekyear;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(new MainTest(200, 0, 1345435247779935L));        suite.addTest(new MainTest(200, 1, 1345435247779935L));        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.field.ImpreciseDateTimeField;/** *  * @author Brian S O'Neill */abstract class TestGJDateTimeField extends ImpreciseDateTimeField {    protected final TestGJChronology iChronology;    public TestGJDateTimeField(DateTimeFieldType type, long unitMillis, TestGJChronology chrono) {        super(type, unitMillis);        iChronology = chrono;    }    public boolean isLenient() {        return false;    }    public long add(long instant, int value) {        return add(instant, (long)value);    }    public abstract long add(long instant, long value);}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekyearField extends TestGJDateTimeField {    public TestGJWeekyearField(TestGJChronology chrono) {        super(DateTimeFieldType.weekyear(), chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[0];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(value, wwd[1], wwd[2]);        if (wwd[1] == 53) {            int[] wwd2 = iChronology.isoFromMillis(millis);            if (wwd2[0] != value) {                // Set year doesn't have 53 weeks, so back off a week.                millis = iChronology.dayOfYear().add(millis, -7);            }        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public boolean isLeap(long millis) {        return iChronology.weekOfWeekyear().getMaximumValue(millis) > 52;    }    public int getLeapAmount(long millis) {        return iChronology.weekOfWeekyear().getMaximumValue(millis) - 52;    }     public DurationField getLeapDurationField() {        return iChronology.weeks();    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromISO(get(millis), 1, 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;/** * A reference Gregorian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * @author Brian S O'Neill */public final class TestGregorianChronology extends TestGJChronology {    /**     * Constructs with an epoch of 1970-01-01.     */    public TestGregorianChronology() {        super(1970, 1, 1);    }    public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public String toString() {        return "TestGregorianChronology";    }    long millisPerYear() {        return (long)(365.2425 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.2425 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (mod(year, 4) == 0) {            int t = (int)mod(year, 400);            if (t != 100 && t != 200 & t != 300) {                return true;            }        }        return false;    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        long year_m1 = year - 1;        long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100)            + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        long d0 = date - 1;        long n400 = div(d0, 146097);        long d1 = mod(d0, 146097);        long n100 = div(d1, 36524);        long d2 = mod(d1, 36524);        long n4 = div(d2, 1461);        long d3 = mod(d2, 1461);        long n1 = div(d3, 365);        long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;        if (!(n100 == 4 || n1 == 4)) {            year += 1;        }        int year_i = (int)year;        if (year_i == year) {            return year_i;        } else {            throw new RuntimeException("year cannot be cast to an int: " + year);        }    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        int year = gjYearFromFixed(date);        long priorDays = date - fixedFromGJ(year, 1, 1);        long correction;        if (date < fixedFromGJ(year, 3, 1)) {            correction = 0;        } else if (isLeapYear(year)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year, monthOfYear, 1) + 1);        return new int[]{year, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return nthWeekday(weekOfWeekyear, 0, weekyear - 1, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        if (date >= fixedFromISO(weekyear + 1, 1, 1)) {            weekyear += 1;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Instant;/** * This class is a Junit unit test for GJChronology. * * @author Stephen Colebourne */public class TestGJChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJChronology.class);    }    public TestGJChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, GJChronology.getInstanceUTC().getZone());        assertSame(GJChronology.class, GJChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, GJChronology.getInstance().getZone());        assertSame(GJChronology.class, GJChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, GJChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, GJChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, GJChronology.getInstance(null).getZone());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO).getClass());    }    public void testFactory_Zone_long_int() {        GJChronology chrono = GJChronology.getInstance(TOKYO, 0L, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(new Instant(0L), chrono.getGregorianCutover());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, 0L, 2).getClass());                try {            GJChronology.getInstance(TOKYO, 0L, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            GJChronology.getInstance(TOKYO, 0L, 8);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFactory_Zone_RI() {        GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L));        assertEquals(TOKYO, chrono.getZone());        assertEquals(new Instant(0L), chrono.getGregorianCutover());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L)).getClass());                DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC);        chrono = GJChronology.getInstance(TOKYO, null);        assertEquals(TOKYO, chrono.getZone());        assertEquals(cutover.toInstant(), chrono.getGregorianCutover());    }    public void testFactory_Zone_RI_int() {        GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L), 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(new Instant(0L), chrono.getGregorianCutover());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L), 2).getClass());                DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC);        chrono = GJChronology.getInstance(TOKYO, null, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(cutover.toInstant(), chrono.getGregorianCutover());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());                try {            GJChronology.getInstance(TOKYO, new Instant(0L), 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            GJChronology.getInstance(TOKYO, new Instant(0L), 8);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO));        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(LONDON));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(PARIS));        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC());        assertSame(GJChronology.getInstance(), GJChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(LONDON).withUTC());        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(TOKYO).withUTC());        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC().withUTC());        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(null));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance().withZone(PARIS));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("GJChronology[Europe/London]", GJChronology.getInstance(LONDON).toString());        assertEquals("GJChronology[Asia/Tokyo]", GJChronology.getInstance(TOKYO).toString());        assertEquals("GJChronology[Europe/London]", GJChronology.getInstance().toString());        assertEquals("GJChronology[UTC]", GJChronology.getInstanceUTC().toString());        assertEquals("GJChronology[UTC,cutover=1970-01-01]", GJChronology.getInstance(DateTimeZone.UTC, 0L, 4).toString());        assertEquals("GJChronology[UTC,cutover=1970-01-01T00:00:00.001Z,mdfw=2]", GJChronology.getInstance(DateTimeZone.UTC, 1L, 2).toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", GJChronology.getInstance().eras().getName());        assertEquals("centuries", GJChronology.getInstance().centuries().getName());        assertEquals("years", GJChronology.getInstance().years().getName());        assertEquals("weekyears", GJChronology.getInstance().weekyears().getName());        assertEquals("months", GJChronology.getInstance().months().getName());        assertEquals("weeks", GJChronology.getInstance().weeks().getName());        assertEquals("halfdays", GJChronology.getInstance().halfdays().getName());        assertEquals("days", GJChronology.getInstance().days().getName());        assertEquals("hours", GJChronology.getInstance().hours().getName());        assertEquals("minutes", GJChronology.getInstance().minutes().getName());        assertEquals("seconds", GJChronology.getInstance().seconds().getName());        assertEquals("millis", GJChronology.getInstance().millis().getName());                assertEquals(false, GJChronology.getInstance().eras().isSupported());        assertEquals(true, GJChronology.getInstance().centuries().isSupported());        assertEquals(true, GJChronology.getInstance().years().isSupported());        assertEquals(true, GJChronology.getInstance().weekyears().isSupported());        assertEquals(true, GJChronology.getInstance().months().isSupported());        assertEquals(true, GJChronology.getInstance().weeks().isSupported());        assertEquals(true, GJChronology.getInstance().days().isSupported());        assertEquals(true, GJChronology.getInstance().halfdays().isSupported());        assertEquals(true, GJChronology.getInstance().hours().isSupported());        assertEquals(true, GJChronology.getInstance().minutes().isSupported());        assertEquals(true, GJChronology.getInstance().seconds().isSupported());        assertEquals(true, GJChronology.getInstance().millis().isSupported());                assertEquals(false, GJChronology.getInstance().centuries().isPrecise());        assertEquals(false, GJChronology.getInstance().years().isPrecise());        assertEquals(false, GJChronology.getInstance().weekyears().isPrecise());        assertEquals(false, GJChronology.getInstance().months().isPrecise());        assertEquals(false, GJChronology.getInstance().weeks().isPrecise());        assertEquals(false, GJChronology.getInstance().days().isPrecise());        assertEquals(false, GJChronology.getInstance().halfdays().isPrecise());        assertEquals(true, GJChronology.getInstance().hours().isPrecise());        assertEquals(true, GJChronology.getInstance().minutes().isPrecise());        assertEquals(true, GJChronology.getInstance().seconds().isPrecise());        assertEquals(true, GJChronology.getInstance().millis().isPrecise());                assertEquals(false, GJChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, GJChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, GJChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, GJChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", GJChronology.getInstance().era().getName());        assertEquals("centuryOfEra", GJChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", GJChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", GJChronology.getInstance().yearOfEra().getName());        assertEquals("year", GJChronology.getInstance().year().getName());        assertEquals("monthOfYear", GJChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", GJChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", GJChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", GJChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", GJChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", GJChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", GJChronology.getInstance().dayOfWeek().getName());                assertEquals(true, GJChronology.getInstance().era().isSupported());        assertEquals(true, GJChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, GJChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, GJChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, GJChronology.getInstance().year().isSupported());        assertEquals(true, GJChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, GJChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, GJChronology.getInstance().weekyear().isSupported());        assertEquals(true, GJChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, GJChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, GJChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, GJChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", GJChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", GJChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", GJChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", GJChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", GJChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", GJChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", GJChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", GJChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", GJChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", GJChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", GJChronology.getInstance().millisOfSecond().getName());                assertEquals(true, GJChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, GJChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, GJChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, GJChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, GJChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().millisOfSecond().isSupported());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for ISOChronology. * * @author Stephen Colebourne */public class TestISOChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOChronology.class);    }    public TestISOChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, ISOChronology.getInstanceUTC().getZone());        assertSame(ISOChronology.class, ISOChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, ISOChronology.getInstance().getZone());        assertSame(ISOChronology.class, ISOChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, ISOChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, ISOChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, ISOChronology.getInstance(null).getZone());        assertSame(ISOChronology.class, ISOChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(LONDON));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(PARIS));        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC());        assertSame(ISOChronology.getInstance(), ISOChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(LONDON).withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(TOKYO).withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC().withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(null));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance().withZone(PARIS));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance(LONDON).toString());        assertEquals("ISOChronology[Asia/Tokyo]", ISOChronology.getInstance(TOKYO).toString());        assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance().toString());        assertEquals("ISOChronology[UTC]", ISOChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", ISOChronology.getInstance().eras().getName());        assertEquals("centuries", ISOChronology.getInstance().centuries().getName());        assertEquals("years", ISOChronology.getInstance().years().getName());        assertEquals("weekyears", ISOChronology.getInstance().weekyears().getName());        assertEquals("months", ISOChronology.getInstance().months().getName());        assertEquals("weeks", ISOChronology.getInstance().weeks().getName());        assertEquals("days", ISOChronology.getInstance().days().getName());        assertEquals("halfdays", ISOChronology.getInstance().halfdays().getName());        assertEquals("hours", ISOChronology.getInstance().hours().getName());        assertEquals("minutes", ISOChronology.getInstance().minutes().getName());        assertEquals("seconds", ISOChronology.getInstance().seconds().getName());        assertEquals("millis", ISOChronology.getInstance().millis().getName());                assertEquals(false, ISOChronology.getInstance().eras().isSupported());        assertEquals(true, ISOChronology.getInstance().centuries().isSupported());        assertEquals(true, ISOChronology.getInstance().years().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyears().isSupported());        assertEquals(true, ISOChronology.getInstance().months().isSupported());        assertEquals(true, ISOChronology.getInstance().weeks().isSupported());        assertEquals(true, ISOChronology.getInstance().days().isSupported());        assertEquals(true, ISOChronology.getInstance().halfdays().isSupported());        assertEquals(true, ISOChronology.getInstance().hours().isSupported());        assertEquals(true, ISOChronology.getInstance().minutes().isSupported());        assertEquals(true, ISOChronology.getInstance().seconds().isSupported());        assertEquals(true, ISOChronology.getInstance().millis().isSupported());                assertEquals(false, ISOChronology.getInstance().centuries().isPrecise());        assertEquals(false, ISOChronology.getInstance().years().isPrecise());        assertEquals(false, ISOChronology.getInstance().weekyears().isPrecise());        assertEquals(false, ISOChronology.getInstance().months().isPrecise());        assertEquals(false, ISOChronology.getInstance().weeks().isPrecise());        assertEquals(false, ISOChronology.getInstance().days().isPrecise());        assertEquals(false, ISOChronology.getInstance().halfdays().isPrecise());        assertEquals(true, ISOChronology.getInstance().hours().isPrecise());        assertEquals(true, ISOChronology.getInstance().minutes().isPrecise());        assertEquals(true, ISOChronology.getInstance().seconds().isPrecise());        assertEquals(true, ISOChronology.getInstance().millis().isPrecise());                assertEquals(false, ISOChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", ISOChronology.getInstance().era().getName());        assertEquals("centuryOfEra", ISOChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", ISOChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", ISOChronology.getInstance().yearOfEra().getName());        assertEquals("year", ISOChronology.getInstance().year().getName());        assertEquals("monthOfYear", ISOChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", ISOChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", ISOChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", ISOChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", ISOChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", ISOChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", ISOChronology.getInstance().dayOfWeek().getName());                assertEquals(true, ISOChronology.getInstance().era().isSupported());        assertEquals(true, ISOChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, ISOChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, ISOChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, ISOChronology.getInstance().year().isSupported());        assertEquals(true, ISOChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyear().isSupported());        assertEquals(true, ISOChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", ISOChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", ISOChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", ISOChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", ISOChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", ISOChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", ISOChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", ISOChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", ISOChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", ISOChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", ISOChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", ISOChronology.getInstance().millisOfSecond().getName());                assertEquals(true, ISOChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, ISOChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, ISOChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, ISOChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, ISOChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().millisOfSecond().isSupported());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for CopticChronology. * * @author Stephen Colebourne */public class TestCopticChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestCopticChronology.class);    }    public TestCopticChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, CopticChronology.getInstanceUTC().getZone());        assertSame(CopticChronology.class, CopticChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, CopticChronology.getInstance().getZone());        assertSame(CopticChronology.class, CopticChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, CopticChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, CopticChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, CopticChronology.getInstance(null).getZone());        assertSame(CopticChronology.class, CopticChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO));        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(LONDON));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(PARIS));        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC());        assertSame(CopticChronology.getInstance(), CopticChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(LONDON).withUTC());        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(TOKYO).withUTC());        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC().withUTC());        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(null));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance().withZone(PARIS));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("CopticChronology[Europe/London]", CopticChronology.getInstance(LONDON).toString());        assertEquals("CopticChronology[Asia/Tokyo]", CopticChronology.getInstance(TOKYO).toString());        assertEquals("CopticChronology[Europe/London]", CopticChronology.getInstance().toString());        assertEquals("CopticChronology[UTC]", CopticChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", CopticChronology.getInstance().eras().getName());        assertEquals("centuries", CopticChronology.getInstance().centuries().getName());        assertEquals("years", CopticChronology.getInstance().years().getName());        assertEquals("weekyears", CopticChronology.getInstance().weekyears().getName());        assertEquals("months", CopticChronology.getInstance().months().getName());        assertEquals("weeks", CopticChronology.getInstance().weeks().getName());        assertEquals("days", CopticChronology.getInstance().days().getName());        assertEquals("halfdays", CopticChronology.getInstance().halfdays().getName());        assertEquals("hours", CopticChronology.getInstance().hours().getName());        assertEquals("minutes", CopticChronology.getInstance().minutes().getName());        assertEquals("seconds", CopticChronology.getInstance().seconds().getName());        assertEquals("millis", CopticChronology.getInstance().millis().getName());                assertEquals(false, CopticChronology.getInstance().eras().isSupported());        assertEquals(true, CopticChronology.getInstance().centuries().isSupported());        assertEquals(true, CopticChronology.getInstance().years().isSupported());        assertEquals(true, CopticChronology.getInstance().weekyears().isSupported());        assertEquals(true, CopticChronology.getInstance().months().isSupported());        assertEquals(true, CopticChronology.getInstance().weeks().isSupported());        assertEquals(true, CopticChronology.getInstance().days().isSupported());        assertEquals(true, CopticChronology.getInstance().halfdays().isSupported());        assertEquals(true, CopticChronology.getInstance().hours().isSupported());        assertEquals(true, CopticChronology.getInstance().minutes().isSupported());        assertEquals(true, CopticChronology.getInstance().seconds().isSupported());        assertEquals(true, CopticChronology.getInstance().millis().isSupported());                assertEquals(false, CopticChronology.getInstance().centuries().isPrecise());        assertEquals(false, CopticChronology.getInstance().years().isPrecise());        assertEquals(false, CopticChronology.getInstance().weekyears().isPrecise());        assertEquals(false, CopticChronology.getInstance().months().isPrecise());        assertEquals(false, CopticChronology.getInstance().weeks().isPrecise());        assertEquals(false, CopticChronology.getInstance().days().isPrecise());        assertEquals(false, CopticChronology.getInstance().halfdays().isPrecise());        assertEquals(true, CopticChronology.getInstance().hours().isPrecise());        assertEquals(true, CopticChronology.getInstance().minutes().isPrecise());        assertEquals(true, CopticChronology.getInstance().seconds().isPrecise());        assertEquals(true, CopticChronology.getInstance().millis().isPrecise());                assertEquals(false, CopticChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, CopticChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, CopticChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", CopticChronology.getInstance().era().getName());        assertEquals("centuryOfEra", CopticChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", CopticChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", CopticChronology.getInstance().yearOfEra().getName());        assertEquals("year", CopticChronology.getInstance().year().getName());        assertEquals("monthOfYear", CopticChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", CopticChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", CopticChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", CopticChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", CopticChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", CopticChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", CopticChronology.getInstance().dayOfWeek().getName());                assertEquals(true, CopticChronology.getInstance().era().isSupported());        assertEquals(true, CopticChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, CopticChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, CopticChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, CopticChronology.getInstance().year().isSupported());        assertEquals(true, CopticChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, CopticChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, CopticChronology.getInstance().weekyear().isSupported());        assertEquals(true, CopticChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, CopticChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, CopticChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, CopticChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", CopticChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", CopticChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", CopticChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", CopticChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", CopticChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", CopticChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", CopticChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", CopticChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", CopticChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", CopticChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", CopticChronology.getInstance().millisOfSecond().getName());                assertEquals(true, CopticChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, CopticChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, CopticChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, CopticChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, CopticChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().millisOfSecond().isSupported());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for JulianChronology. * * @author Stephen Colebourne */public class TestJulianChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestJulianChronology.class);    }    public TestJulianChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, JulianChronology.getInstanceUTC().getZone());        assertSame(JulianChronology.class, JulianChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, JulianChronology.getInstance().getZone());        assertSame(JulianChronology.class, JulianChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, JulianChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, JulianChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, JulianChronology.getInstance(null).getZone());        assertSame(JulianChronology.class, JulianChronology.getInstance(TOKYO).getClass());    }    public void testFactory_Zone_int() {        JulianChronology chrono = JulianChronology.getInstance(TOKYO, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());                try {            JulianChronology.getInstance(TOKYO, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            JulianChronology.getInstance(TOKYO, 8);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO));        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(LONDON));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(PARIS));        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC());        assertSame(JulianChronology.getInstance(), JulianChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(LONDON).withUTC());        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(TOKYO).withUTC());        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC().withUTC());        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(null));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance().withZone(PARIS));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("JulianChronology[Europe/London]", JulianChronology.getInstance(LONDON).toString());        assertEquals("JulianChronology[Asia/Tokyo]", JulianChronology.getInstance(TOKYO).toString());        assertEquals("JulianChronology[Europe/London]", JulianChronology.getInstance().toString());        assertEquals("JulianChronology[UTC]", JulianChronology.getInstanceUTC().toString());        assertEquals("JulianChronology[UTC,mdfw=2]", JulianChronology.getInstance(DateTimeZone.UTC, 2).toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", JulianChronology.getInstance().eras().getName());        assertEquals("centuries", JulianChronology.getInstance().centuries().getName());        assertEquals("years", JulianChronology.getInstance().years().getName());        assertEquals("weekyears", JulianChronology.getInstance().weekyears().getName());        assertEquals("months", JulianChronology.getInstance().months().getName());        assertEquals("weeks", JulianChronology.getInstance().weeks().getName());        assertEquals("days", JulianChronology.getInstance().days().getName());        assertEquals("halfdays", JulianChronology.getInstance().halfdays().getName());        assertEquals("hours", JulianChronology.getInstance().hours().getName());        assertEquals("minutes", JulianChronology.getInstance().minutes().getName());        assertEquals("seconds", JulianChronology.getInstance().seconds().getName());        assertEquals("millis", JulianChronology.getInstance().millis().getName());                assertEquals(false, JulianChronology.getInstance().eras().isSupported());        assertEquals(true, JulianChronology.getInstance().centuries().isSupported());        assertEquals(true, JulianChronology.getInstance().years().isSupported());        assertEquals(true, JulianChronology.getInstance().weekyears().isSupported());        assertEquals(true, JulianChronology.getInstance().months().isSupported());        assertEquals(true, JulianChronology.getInstance().weeks().isSupported());        assertEquals(true, JulianChronology.getInstance().days().isSupported());        assertEquals(true, JulianChronology.getInstance().halfdays().isSupported());        assertEquals(true, JulianChronology.getInstance().hours().isSupported());        assertEquals(true, JulianChronology.getInstance().minutes().isSupported());        assertEquals(true, JulianChronology.getInstance().seconds().isSupported());        assertEquals(true, JulianChronology.getInstance().millis().isSupported());                assertEquals(false, JulianChronology.getInstance().centuries().isPrecise());        assertEquals(false, JulianChronology.getInstance().years().isPrecise());        assertEquals(false, JulianChronology.getInstance().weekyears().isPrecise());        assertEquals(false, JulianChronology.getInstance().months().isPrecise());        assertEquals(false, JulianChronology.getInstance().weeks().isPrecise());        assertEquals(false, JulianChronology.getInstance().days().isPrecise());        assertEquals(false, JulianChronology.getInstance().halfdays().isPrecise());        assertEquals(true, JulianChronology.getInstance().hours().isPrecise());        assertEquals(true, JulianChronology.getInstance().minutes().isPrecise());        assertEquals(true, JulianChronology.getInstance().seconds().isPrecise());        assertEquals(true, JulianChronology.getInstance().millis().isPrecise());                assertEquals(false, JulianChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, JulianChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, JulianChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, JulianChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", JulianChronology.getInstance().era().getName());        assertEquals("centuryOfEra", JulianChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", JulianChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", JulianChronology.getInstance().yearOfEra().getName());        assertEquals("year", JulianChronology.getInstance().year().getName());        assertEquals("monthOfYear", JulianChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", JulianChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", JulianChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", JulianChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", JulianChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", JulianChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", JulianChronology.getInstance().dayOfWeek().getName());                assertEquals(true, JulianChronology.getInstance().era().isSupported());        assertEquals(true, JulianChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, JulianChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, JulianChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, JulianChronology.getInstance().year().isSupported());        assertEquals(true, JulianChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, JulianChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, JulianChronology.getInstance().weekyear().isSupported());        assertEquals(true, JulianChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, JulianChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, JulianChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, JulianChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", JulianChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", JulianChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", JulianChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", JulianChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", JulianChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", JulianChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", JulianChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", JulianChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", JulianChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", JulianChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", JulianChronology.getInstance().millisOfSecond().getName());                assertEquals(true, JulianChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, JulianChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, JulianChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, JulianChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, JulianChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().millisOfSecond().isSupported());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();                suite.addTest(TestBuddhistChronology.suite());        suite.addTest(TestCopticChronology.suite());        suite.addTest(TestGJChronology.suite());        suite.addTest(TestGregorianChronology.suite());        suite.addTest(TestJulianChronology.suite());        suite.addTest(TestISOChronology.suite());                return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for GregorianChronology. * * @author Stephen Colebourne */public class TestGregorianChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGregorianChronology.class);    }    public TestGregorianChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, GregorianChronology.getInstanceUTC().getZone());        assertSame(GregorianChronology.class, GregorianChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, GregorianChronology.getInstance().getZone());        assertSame(GregorianChronology.class, GregorianChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, GregorianChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, GregorianChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, GregorianChronology.getInstance(null).getZone());        assertSame(GregorianChronology.class, GregorianChronology.getInstance(TOKYO).getClass());    }    public void testFactory_Zone_int() {        GregorianChronology chrono = GregorianChronology.getInstance(TOKYO, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());                try {            GregorianChronology.getInstance(TOKYO, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            GregorianChronology.getInstance(TOKYO, 8);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO));        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(LONDON));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(PARIS));        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC());        assertSame(GregorianChronology.getInstance(), GregorianChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(LONDON).withUTC());        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(TOKYO).withUTC());        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC().withUTC());        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(null));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance().withZone(PARIS));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("GregorianChronology[Europe/London]", GregorianChronology.getInstance(LONDON).toString());        assertEquals("GregorianChronology[Asia/Tokyo]", GregorianChronology.getInstance(TOKYO).toString());        assertEquals("GregorianChronology[Europe/London]", GregorianChronology.getInstance().toString());        assertEquals("GregorianChronology[UTC]", GregorianChronology.getInstanceUTC().toString());        assertEquals("GregorianChronology[UTC,mdfw=2]", GregorianChronology.getInstance(DateTimeZone.UTC, 2).toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", GregorianChronology.getInstance().eras().getName());        assertEquals("centuries", GregorianChronology.getInstance().centuries().getName());        assertEquals("years", GregorianChronology.getInstance().years().getName());        assertEquals("weekyears", GregorianChronology.getInstance().weekyears().getName());        assertEquals("months", GregorianChronology.getInstance().months().getName());        assertEquals("weeks", GregorianChronology.getInstance().weeks().getName());        assertEquals("days", GregorianChronology.getInstance().days().getName());        assertEquals("halfdays", GregorianChronology.getInstance().halfdays().getName());        assertEquals("hours", GregorianChronology.getInstance().hours().getName());        assertEquals("minutes", GregorianChronology.getInstance().minutes().getName());        assertEquals("seconds", GregorianChronology.getInstance().seconds().getName());        assertEquals("millis", GregorianChronology.getInstance().millis().getName());                assertEquals(false, GregorianChronology.getInstance().eras().isSupported());        assertEquals(true, GregorianChronology.getInstance().centuries().isSupported());        assertEquals(true, GregorianChronology.getInstance().years().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekyears().isSupported());        assertEquals(true, GregorianChronology.getInstance().months().isSupported());        assertEquals(true, GregorianChronology.getInstance().weeks().isSupported());        assertEquals(true, GregorianChronology.getInstance().days().isSupported());        assertEquals(true, GregorianChronology.getInstance().halfdays().isSupported());        assertEquals(true, GregorianChronology.getInstance().hours().isSupported());        assertEquals(true, GregorianChronology.getInstance().minutes().isSupported());        assertEquals(true, GregorianChronology.getInstance().seconds().isSupported());        assertEquals(true, GregorianChronology.getInstance().millis().isSupported());                assertEquals(false, GregorianChronology.getInstance().centuries().isPrecise());        assertEquals(false, GregorianChronology.getInstance().years().isPrecise());        assertEquals(false, GregorianChronology.getInstance().weekyears().isPrecise());        assertEquals(false, GregorianChronology.getInstance().months().isPrecise());        assertEquals(false, GregorianChronology.getInstance().weeks().isPrecise());        assertEquals(false, GregorianChronology.getInstance().days().isPrecise());        assertEquals(false, GregorianChronology.getInstance().halfdays().isPrecise());        assertEquals(true, GregorianChronology.getInstance().hours().isPrecise());        assertEquals(true, GregorianChronology.getInstance().minutes().isPrecise());        assertEquals(true, GregorianChronology.getInstance().seconds().isPrecise());        assertEquals(true, GregorianChronology.getInstance().millis().isPrecise());                assertEquals(false, GregorianChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, GregorianChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, GregorianChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, GregorianChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", GregorianChronology.getInstance().era().getName());        assertEquals("centuryOfEra", GregorianChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", GregorianChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", GregorianChronology.getInstance().yearOfEra().getName());        assertEquals("year", GregorianChronology.getInstance().year().getName());        assertEquals("monthOfYear", GregorianChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", GregorianChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", GregorianChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", GregorianChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", GregorianChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", GregorianChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", GregorianChronology.getInstance().dayOfWeek().getName());                assertEquals(true, GregorianChronology.getInstance().era().isSupported());        assertEquals(true, GregorianChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, GregorianChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, GregorianChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, GregorianChronology.getInstance().year().isSupported());        assertEquals(true, GregorianChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekyear().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, GregorianChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, GregorianChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, GregorianChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", GregorianChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", GregorianChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", GregorianChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", GregorianChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", GregorianChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", GregorianChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", GregorianChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", GregorianChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", GregorianChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", GregorianChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", GregorianChronology.getInstance().millisOfSecond().getName());                assertEquals(true, GregorianChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, GregorianChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, GregorianChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, GregorianChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, GregorianChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().millisOfSecond().isSupported());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for BuddhistChronology. * * @author Stephen Colebourne */public class TestBuddhistChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.getInstance("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBuddhistChronology.class);    }    public TestBuddhistChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, BuddhistChronology.getInstanceUTC().getZone());        assertSame(BuddhistChronology.class, BuddhistChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, BuddhistChronology.getInstance().getZone());        assertSame(BuddhistChronology.class, BuddhistChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, BuddhistChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, BuddhistChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, BuddhistChronology.getInstance(null).getZone());        assertSame(BuddhistChronology.class, BuddhistChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO));        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(LONDON));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(PARIS));        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC());        assertSame(BuddhistChronology.getInstance(), BuddhistChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(LONDON).withUTC());        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(TOKYO).withUTC());        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC().withUTC());        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(null));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance().withZone(PARIS));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("BuddhistChronology[Europe/London]", BuddhistChronology.getInstance(LONDON).toString());        assertEquals("BuddhistChronology[Asia/Tokyo]", BuddhistChronology.getInstance(TOKYO).toString());        assertEquals("BuddhistChronology[Europe/London]", BuddhistChronology.getInstance().toString());        assertEquals("BuddhistChronology[UTC]", BuddhistChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", BuddhistChronology.getInstance().eras().getName());        assertEquals("centuries", BuddhistChronology.getInstance().centuries().getName());        assertEquals("years", BuddhistChronology.getInstance().years().getName());        assertEquals("weekyears", BuddhistChronology.getInstance().weekyears().getName());        assertEquals("months", BuddhistChronology.getInstance().months().getName());        assertEquals("weeks", BuddhistChronology.getInstance().weeks().getName());        assertEquals("days", BuddhistChronology.getInstance().days().getName());        assertEquals("halfdays", GregorianChronology.getInstance().halfdays().getName());        assertEquals("hours", BuddhistChronology.getInstance().hours().getName());        assertEquals("minutes", BuddhistChronology.getInstance().minutes().getName());        assertEquals("seconds", BuddhistChronology.getInstance().seconds().getName());        assertEquals("millis", BuddhistChronology.getInstance().millis().getName());                assertEquals(false, BuddhistChronology.getInstance().eras().isSupported());        assertEquals(true, BuddhistChronology.getInstance().centuries().isSupported());        assertEquals(true, BuddhistChronology.getInstance().years().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekyears().isSupported());        assertEquals(true, BuddhistChronology.getInstance().months().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weeks().isSupported());        assertEquals(true, BuddhistChronology.getInstance().days().isSupported());        assertEquals(true, BuddhistChronology.getInstance().halfdays().isSupported());        assertEquals(true, BuddhistChronology.getInstance().hours().isSupported());        assertEquals(true, BuddhistChronology.getInstance().minutes().isSupported());        assertEquals(true, BuddhistChronology.getInstance().seconds().isSupported());        assertEquals(true, BuddhistChronology.getInstance().millis().isSupported());                assertEquals(false, BuddhistChronology.getInstance().centuries().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().years().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().weekyears().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().months().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().weeks().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().days().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().halfdays().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().hours().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().minutes().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().seconds().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().millis().isPrecise());                assertEquals(false, BuddhistChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, BuddhistChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, BuddhistChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, BuddhistChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", BuddhistChronology.getInstance().era().getName());        assertEquals("centuryOfEra", BuddhistChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", BuddhistChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", BuddhistChronology.getInstance().yearOfEra().getName());        assertEquals("year", BuddhistChronology.getInstance().year().getName());        assertEquals("monthOfYear", BuddhistChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", BuddhistChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", BuddhistChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", BuddhistChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", BuddhistChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", BuddhistChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", BuddhistChronology.getInstance().dayOfWeek().getName());                assertEquals(true, BuddhistChronology.getInstance().era().isSupported());        assertEquals(true, BuddhistChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, BuddhistChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, BuddhistChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, BuddhistChronology.getInstance().year().isSupported());        assertEquals(true, BuddhistChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekyear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, BuddhistChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", BuddhistChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", BuddhistChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", BuddhistChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", BuddhistChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", BuddhistChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", BuddhistChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", BuddhistChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", BuddhistChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", BuddhistChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", BuddhistChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", BuddhistChronology.getInstance().millisOfSecond().getName());                assertEquals(true, BuddhistChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, BuddhistChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, BuddhistChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, BuddhistChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, BuddhistChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().millisOfSecond().isSupported());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.Assert;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.format.DateTimeParser;import org.joda.time.format.ISODateTimeFormat;/** * Unit test the parsing of ISO format datetimes * * @author Guy Allard * @author Stephen Colebourne */public class TestParseISO extends TestCase {        private static final int DEFAULT = 99999;    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }        /**     * TestSuite suite() is a junit required method.     * @see org.joda.test.time.BulkTest     */    public static TestSuite suite() {        return new TestSuite(TestParseISO.class);    }        /**     * Constructor.     * @param name     */    public TestParseISO(String name) {        super(name);    }    protected void setUp() throws Exception {        super.setUp();    }        protected void tearDown() throws Exception {        super.tearDown();    }        //-----------------------------------------------------------------------    // Dates    //-----------------------------------------------------------------------    public void testSpecCompleteDate() {        new DMatcher("5.2.1.1", "1999-10-20", "19991020",            19, 99, 10, 20, DEFAULT).run();    }            //-----------------------------------------------------------------------    public void testSpecReducedPrecisionCYM() {        new DMatcher("5.2.1.2", "1999-10", "199910",            19, 99, 10, DEFAULT, DEFAULT).run();    }    public void testSpecReducedPrecisionCY() {        new DMatcher("5.2.1.2", "1999", "1999",            19, 99, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecReducedPrecisionC() {        new DMatcher("5.2.1.2", "20", "20",            20, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();        new DMatcher("5.2.1.2", "19", "19",            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTruncatedYMD() {        new DMatcher("5.2.1.3", "85-04-11", "850411",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecTruncatedYM() {        new DMatcher("5.2.1.3", "-85-04", "-8504",            DEFAULT, 85, 4, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedY() {        new DMatcher("5.2.1.3", "-85", "-85",            DEFAULT, 85, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedMD() {        new DMatcher("5.2.1.3", "--04-11", "--0411",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    public void testSpecTruncatedM() {        new DMatcher("5.2.1.3", "--04", "--04",            DEFAULT, DEFAULT, 4, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedD() {        new DMatcher("5.2.1.3", "---11", "---11",            DEFAULT, DEFAULT, DEFAULT, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecExpandedCYMD() {        new DMatcher("5.2.1.4", "+001985-04-11", "+0019850411",            19, 85, 4, 11, DEFAULT).run();    }    public void testSpecExpandedCYM() {        new DMatcher("5.2.1.4", "+001985-04", "+00198504",            19, 85, 4, DEFAULT, DEFAULT).run();    }    public void testSpecExpandedCY() {        new DMatcher("5.2.1.4", "+001985", "+001985",            19, 85, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecExpandedC() {        // Not supported - could only tell difference from CY if you knew        // number of digits representing year//        new DMatcher("5.2.1.4", "+0019", "+0019",//            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).assert();    }        //-----------------------------------------------------------------------    // Ordinal based date    //-----------------------------------------------------------------------    public void testSpecOrdinalComplete() {        new DMatcher("5.2.2.1", "1985-101", "1985101",            19, 85, 4, 11, DEFAULT).run();        new DMatcher("5.2.2.1", "1985-021", "1985021",            19, 85, 1, 21, DEFAULT).run();        new DMatcher("5.2.2.1", "1985-006", "1985006",            19, 85, 1, 6, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecOrdinalTruncatedYD() {        new DMatcher("5.2.2.2", "85-101", "85101",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecOrdinalTruncatedD() {        new DMatcher("5.2.2.2", "-101", "-101",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecOrdinalExpandedYD() {        new DMatcher("5.2.2.3", "+001985-101", "+001985101",            19, 85, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    // Week based date    //-----------------------------------------------------------------------    public void testSpecWeekComplete() {        new DMatcher("5.2.3.1", "1985-W15-1", "1985W151",            19, 85, 4, 8, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-2", "1985W152",            19, 85, 4, 9, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-3", "1985W153",            19, 85, 4, 10, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-4", "1985W154",            19, 85, 4, 11, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-5", "1985W155",            19, 85, 4, 12, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-6", "1985W156",            19, 85, 4, 13, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-7", "1985W157",            19, 85, 4, 14, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecWeekReducedPrecision() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "1985-W15", "1985W15",            19, 85, 4, 14, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecWeekTruncatedYWD() {        new DMatcher("5.2.3.2", "85-W154", "85W154",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecWeekTruncatedYW() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "85-W15", "85W15",            DEFAULT, 85, 4, 14, DEFAULT).run();    }    public void testSpecWeekTruncatedDWD() {        // decade not supported    }    public void testSpecWeekTruncatedDW() {        // decade not supported    }    public void testSpecWeekTruncatedWD() {        new DMatcher("5.2.3.2", "-W154", "-W154",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    public void testSpecWeekTruncatedW() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "-W15", "-W15",            DEFAULT, DEFAULT, 4, 14, DEFAULT).run();    }    public void testSpecWeekTruncatedD() {        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov        new DMatcher("5.2.3.3", "-W-4", "-W-4",            DEFAULT, DEFAULT, 11, 30, DEFAULT).run();    }    public void testSpecWeekExpandedYWD() {        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov        new DMatcher("5.2.3.4", "+001985-W15-4", "+001985W154",            19, 85, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    // Times    //-----------------------------------------------------------------------    public void testSpecTimeComplete() {        new TMatcher("5.3.1.1", "23:20:50", "232050",            23, 20, 50, 0, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeReducedPrecisionHM() {        new TMatcher("5.3.1.2", "23:20", "2320",            23, 20, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTimeReducedPrecisionH() {        new TMatcher("5.3.1.2", "23", "23",            23, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeFractionalHMS() {        new TMatcher("5.3.1.3", "23:20:50.607", "232050.607",            23, 20, 50, 607, DEFAULT).run();        new TMatcher("5.3.1.3", "23:20:50,607", "232050,607",            23, 20, 50, 607, DEFAULT).run();    }    public void testSpecTimeFractionalHM() {        new TMatcher("5.3.1.3", "23:20.4", "2320.4",            23, 20, 24, 0, DEFAULT).run();        new TMatcher("5.3.1.3", "23:20,4", "2320,4",            23, 20, 24, 0, DEFAULT).run();    }    public void testSpecTimeFractionalH() {        new TMatcher("5.3.1.3", "23.25", "23.25",            23, 15, 0, 0, DEFAULT).run();        new TMatcher("5.3.1.3", "23.25", "23,25",            23, 15, 0, 0, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeTruncatedMS() {        new TMatcher("5.3.1.4", "-20:50", "-2050",            DEFAULT, 20, 50, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedM() {        new TMatcher("5.3.1.4", "-20", "-20",            DEFAULT, 20, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTimeTruncatedS() {        new TMatcher("5.3.1.4", "--50", "--50",            DEFAULT, DEFAULT, 50, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionMS() {        new TMatcher("5.3.1.4", "-20:50.607", "-2050.607",            DEFAULT, 20, 50, 607, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionM() {        new TMatcher("5.3.1.4", "-20.4", "-20.4",            DEFAULT, 20, 24, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionS() {        new TMatcher("5.3.1.4", "--50.607", "--50.607",            DEFAULT, DEFAULT, 50, 607, DEFAULT).run();    }        //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    /**     * Perform test.     */            protected static abstract class Matcher extends Assert {        String spec, extended, basic;        int century, yearOfCentury, monthOfYear, dayOfMonth, hour, min, sec, milli, zone;        MutableDateTime dt;                protected Matcher(String spec, String extended, String basic) {            this.spec = spec;            this.extended = extended;            this.basic = basic;        }                protected abstract void run();        protected void assertDate() {            String msg = "\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     " + dt;            assertEquals(msg + "\nCentury: ", century, dt.getCenturyOfEra());            assertEquals(msg + "\nYear: ", yearOfCentury, dt.getYearOfCentury());            assertEquals(msg + "\nMonth: ", monthOfYear, dt.getMonthOfYear());            assertEquals(msg + "\nDay: ", dayOfMonth, dt.getDayOfMonth());            assertEquals(msg + "\nHour: ", hour, dt.getHourOfDay());            assertEquals(msg + "\nMinute: ", min, dt.getMinuteOfHour());            assertEquals(msg + "\nSecond: ", sec, dt.getSecondOfMinute());            assertEquals(msg + "\nMilli: ", milli, dt.getMillisOfSecond());            DateTimeZone z;            if (zone == DEFAULT) {                z = DateTimeZone.getDefault();            } else if (zone == 0) {                    z = DateTimeZone.UTC;            } else {                String str = "0" + Math.abs(zone) + ":00";                str = str.substring(str.length() - 4);                str = (zone < 0 ? "-" : "+") + str;                z = DateTimeZone.getInstance(str);            }            assertEquals(msg + "\nZone: ", z, dt.getZone());        }        protected void parse(DateTimeParser p) {            int result = p.parseInto(dt, extended, 0);            assertTrue("\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     "                + dt + "\nParse failed at: " + ~result,                result >= 0);        }    }    protected static class DTMatcher extends Matcher {        protected DTMatcher(String spec, String extended, String basic,                int century, int yearOfCentury, int monthOfYear, int dayOfMonth,                int hour, int min, int sec, int milli, int zone) {            super(spec, extended, basic);            this.century = (century == DEFAULT ? 19 : century);            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);            this.hour = (hour == DEFAULT ? 10 : hour);            this.min = (min == DEFAULT ? 32 : min);            this.sec = (sec == DEFAULT ? 40 : sec);            this.milli = (milli == DEFAULT ? 205 : milli);            this.zone = zone;        }                    protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateTimeParser());            super.assertDate();        }    }    protected static class DMatcher extends Matcher {        protected DMatcher(String spec, String extended, String basic,                int century, int yearOfCentury, int monthOfYear, int dayOfMonth, int zone) {            super(spec, extended, basic);            this.century = (century == DEFAULT ? 19 : century);            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);            this.hour = 10;            this.min = 32;            this.sec = 40;            this.milli = 205;            this.zone = zone;        }        protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateParser());            super.assertDate();                    dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateTimeParser());            super.assertDate();        }    }    protected static class TMatcher extends Matcher {        protected TMatcher(String spec, String extended, String basic,                int hour, int min, int sec, int milli, int zone) {            super(spec, extended, basic);            this.century = 19;            this.yearOfCentury = 72;            this.monthOfYear = 12;            this.dayOfMonth = 3;            this.hour = (hour == DEFAULT ? 10 : hour);            this.min = (min == DEFAULT ? 32 : min);            this.sec = (sec == DEFAULT ? 40 : sec);            this.milli = (milli == DEFAULT ? 205 : milli);            this.zone = zone;        }        protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().timeParser());            super.assertDate();                        extended = "T" + extended;            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().timeParser());            super.assertDate();                        dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.getInstance().dateTimeParser());            super.assertDate();        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractPartial;import org.joda.time.chrono.BuddhistChronology;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestAbstractPartial extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestAbstractPartial.class);    }    public TestAbstractPartial(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testGetValue() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(1970, mock.getValue(0));        assertEquals(1, mock.getValue(1));                try {            mock.getValue(-1);            fail();        } catch (IndexOutOfBoundsException ex) {}        try {            mock.getValue(2);            fail();        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetValues() throws Throwable {        MockPartial mock = new MockPartial();        int[] vals = mock.getValues();        assertEquals(2, vals.length);        assertEquals(1970, vals[0]);        assertEquals(1, vals[1]);    }    public void testGetField() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(BuddhistChronology.getInstance().year(), mock.getField(0));        assertEquals(BuddhistChronology.getInstance().monthOfYear(), mock.getField(1));                try {            mock.getField(-1);            fail();        } catch (IndexOutOfBoundsException ex) {}        try {            mock.getField(2);            fail();        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldType() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(DateTimeFieldType.year(), mock.getFieldType(0));        assertEquals(DateTimeFieldType.monthOfYear(), mock.getFieldType(1));                try {            mock.getFieldType(-1);            fail();        } catch (IndexOutOfBoundsException ex) {}        try {            mock.getFieldType(2);            fail();        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldTypes() throws Throwable {        MockPartial mock = new MockPartial();        DateTimeFieldType[] vals = mock.getFieldTypes();        assertEquals(2, vals.length);        assertEquals(DateTimeFieldType.year(), vals[0]);        assertEquals(DateTimeFieldType.monthOfYear(), vals[1]);    }    //-----------------------------------------------------------------------    static class MockPartial extends AbstractPartial {                int[] val = new int[] {1970, 1};                MockPartial() {            super();        }        protected DateTimeField getField(int index, Chronology chrono) {            switch (index) {                case 0:                    return chrono.year();                case 1:                    return chrono.monthOfYear();                default:                    throw new IndexOutOfBoundsException();            }        }        public int size() {            return 2;        }                public int getValue(int index) {            return val[index];        }        public void setValue(int index, int value) {            val[index] = value;        }        public Chronology getChronology() {            return BuddhistChronology.getInstance();        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Modifier;import java.util.Date;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInstant_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInstant_Basics.class);    }    public TestInstant_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet() {        Instant test = new Instant();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        Instant test = new Instant();                assertEquals(Chronology.getISOUTC(), test.getChronology());        assertEquals(DateTimeZone.UTC, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    public void testEqualsHashCode() {        Instant test1 = new Instant(TEST_TIME1);        Instant test2 = new Instant(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Instant test3 = new Instant(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return Chronology.getISOUTC();        }    }    public void testCompareTo() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        //-----------------------------------------------------------------------    public void testIsEqual_long() {        assertEquals(false, new Instant(TEST_TIME1).isEqual(TEST_TIME2));        assertEquals(true, new Instant(TEST_TIME1).isEqual(TEST_TIME1));        assertEquals(false, new Instant(TEST_TIME2).isEqual(TEST_TIME1));    }        public void testIsEqualNow() {        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqualNow());        assertEquals(true, new Instant(TEST_TIME_NOW).isEqualNow());        assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqualNow());    }        public void testIsEqual_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new Instant(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqual(null));    }        //-----------------------------------------------------------------------    public void testIsBefore_long() {        assertEquals(true, new Instant(TEST_TIME1).isBefore(TEST_TIME2));        assertEquals(false, new Instant(TEST_TIME1).isBefore(TEST_TIME1));        assertEquals(false, new Instant(TEST_TIME2).isBefore(TEST_TIME1));    }        public void testIsBeforeNow() {        assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBeforeNow());        assertEquals(false, new Instant(TEST_TIME_NOW).isBeforeNow());        assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBeforeNow());    }        public void testIsBefore_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new Instant(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBefore(null));    }        //-----------------------------------------------------------------------    public void testIsAfter_long() {        assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME2));        assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME1));        assertEquals(true, new Instant(TEST_TIME2).isAfter(TEST_TIME1));    }        public void testIsAfterNow() {        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfterNow());        assertEquals(false, new Instant(TEST_TIME_NOW).isAfterNow());        assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfterNow());    }        public void testIsAfter_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new Instant(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Instant test = new Instant(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Instant result = (Instant) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        Instant test = new Instant(TEST_TIME_NOW);        assertEquals("2002-06-09T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testToInstant() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.toInstant();        assertSame(test, result);    }    public void testToDateTime() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTimeISO() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_DateTimeZone() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_Chronology() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        Instant test = new Instant(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new Instant(TEST_TIME1);        result = test.withMillis(TEST_TIME1);        assertSame(test, result);    }    public void testImmutable() {        assertTrue(Modifier.isFinal(Instant.class.getModifiers()));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestDateTimeUtils extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeUtils.class);    }    public TestDateTimeUtils(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testClass() {        Class cls = DateTimeUtils.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isFinal(cls.getModifiers()));                assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(cls.getDeclaredConstructors()[0].getModifiers()));                DateTimeUtils utils = new DateTimeUtils() {};    }        //-----------------------------------------------------------------------    public void testSystemMillis() {        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testSystemMillisSecurity() {        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisSystem();                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testFixedMillis() {        try {            DateTimeUtils.setCurrentMillisFixed(0L);            assertEquals(0L, DateTimeUtils.currentTimeMillis());            assertEquals(0L, DateTimeUtils.currentTimeMillis());            assertEquals(0L, DateTimeUtils.currentTimeMillis());        } finally {            DateTimeUtils.setCurrentMillisSystem();        }        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testFixedMillisSecurity() {        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisFixed(0L);                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testOffsetMillis() {        try {            // set time to one day ago            DateTimeUtils.setCurrentMillisOffset(-24 * 60 *  60 * 1000);            long nowSystem = System.currentTimeMillis();            long now = DateTimeUtils.currentTimeMillis();            long nowAdjustDay = now + (24 * 60 *  60 * 1000);            assertTrue((now < nowSystem));            assertTrue((nowAdjustDay >= nowSystem));            assertTrue((nowAdjustDay - nowSystem) < 10000L);        } finally {            DateTimeUtils.setCurrentMillisSystem();        }        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testOffsetMillisSecurity() {        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisOffset(-24 * 60 *  60 * 1000);                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_RI() {        Instant i = new Instant(123L);        assertEquals(123L, DateTimeUtils.getInstantMillis(i));        try {            DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);            assertEquals(TEST_TIME_NOW, DateTimeUtils.getInstantMillis(null));        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testGetInstantChronology_RI() {        DateTime dt = new DateTime(123L, BuddhistChronology.getInstance());        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt));                Instant i = new Instant(123L);        assertEquals(ISOChronology.getInstanceUTC(), DateTimeUtils.getInstantChronology(i));                AbstractInstant ai = new AbstractInstant() {            public long getMillis() {                return 0L;            }            public Chronology getChronology() {                return null; // testing for this            }        };        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(ai));                assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Chronology() {        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getChronology(BuddhistChronology.getInstance()));        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getChronology(null));    }    //-----------------------------------------------------------------------    public void testGetZone_Zone() {        assertEquals(PARIS, DateTimeUtils.getZone(PARIS));        assertEquals(LONDON, DateTimeUtils.getZone(null));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_PeriodType() {        assertEquals(PeriodType.dayTime(), DateTimeUtils.getPeriodType(PeriodType.dayTime()));        assertEquals(PeriodType.standard(), DateTimeUtils.getPeriodType(null));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_RI() {        Duration dur = new Duration(123L);        assertEquals(123L, DateTimeUtils.getDurationMillis(dur));        assertEquals(0L, DateTimeUtils.getDurationMillis(null));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateMidnight_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Properties.class);    }    public TestDateMidnight_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getReadableInstant());        assertSame(test, test.era().getDateMidnight());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getReadableInstant());        assertSame(test, test.yearOfEra().getDateMidnight());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getReadableInstant());        assertSame(test, test.centuryOfEra().getDateMidnight());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getReadableInstant());        assertSame(test, test.yearOfCentury().getDateMidnight());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getReadableInstant());        assertSame(test, test.weekyear().getDateMidnight());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadableInstant());        assertSame(test, test.year().getDateMidnight());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadableInstant());        assertSame(test, test.monthOfYear().getDateMidnight());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new DateMidnight(2004, 7, 9);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertySetMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy(8);        assertEquals(2004, copy.getYear());        assertEquals(8, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertySetTextMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy("8");        assertEquals(2004, copy.getYear());        assertEquals(8, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertySetTextLocaleMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy("mars", Locale.FRENCH);        assertEquals(2004, copy.getYear());        assertEquals(3, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addToCopy(8);        assertEquals(2005, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddLongMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addToCopy(8L);        assertEquals(2005, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddWrapFieldMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addWrapFieldToCopy(8);        assertEquals(2004, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyGetDifferenceMonthOfYear() {        DateMidnight test1 = new DateMidnight(2004, 6, 9);        DateMidnight test2 = new DateMidnight(2004, 8, 9);        assertEquals(-2, test1.monthOfYear().getDifference(test2));        assertEquals(2, test2.monthOfYear().getDifference(test1));        assertEquals(-2L, test1.monthOfYear().getDifferenceAsLong(test2));        assertEquals(2L, test2.monthOfYear().getDifferenceAsLong(test1));    }    public void testPropertyRoundFloorMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundCeilingMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfFloorMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfCeilingMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfEvenMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 9, 16);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-10-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRemainderMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertEquals((9L - 1L) * DateTimeConstants.MILLIS_PER_DAY, test.monthOfYear().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadableInstant());        assertSame(test, test.dayOfMonth().getDateMidnight());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getReadableInstant());        assertSame(test, test.dayOfYear().getDateMidnight());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getReadableInstant());        assertSame(test, test.weekOfWeekyear().getDateMidnight());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getReadableInstant());        assertSame(test, test.dayOfWeek().getDateMidnight());        assertEquals(3, test.dayOfWeek().get());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.BaseChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Basics.class);    }    public TestMutableDateTime_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet_DateTimeField() {        MutableDateTime test = new MutableDateTime();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get((DateTimeField) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGet_DateTimeFieldType() {        MutableDateTime test = new MutableDateTime();        assertEquals(1, test.get(DateTimeFieldType.era()));        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));        assertEquals(2002, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(60, test.get(DateTimeFieldType.minuteOfDay()));        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay()));        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay()));        try {            test.get((DateTimeFieldType) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        MutableDateTime test = new MutableDateTime();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(1, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(60, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(60 * 60, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(60 * 60 * 1000, test.getMillisOfDay());    }    public void testEqualsHashCode() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test2 = new MutableDateTime(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutableDateTime test3 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                DateTime test4 = new DateTime(TEST_TIME2);        assertEquals(true, test4.equals(test3));        assertEquals(true, test3.equals(test4));        assertEquals(false, test4.equals(test1));        assertEquals(false, test1.equals(test4));        assertEquals(true, test3.hashCode() == test4.hashCode());        assertEquals(false, test1.hashCode() == test4.hashCode());                MutableDateTime test5 = new MutableDateTime(TEST_TIME2);        test5.setRounding(ISOChronology.getInstance().millisOfSecond());        assertEquals(true, test5.equals(test3));        assertEquals(true, test5.equals(test4));        assertEquals(true, test3.equals(test5));        assertEquals(true, test4.equals(test5));        assertEquals(true, test3.hashCode() == test5.hashCode());        assertEquals(true, test4.hashCode() == test5.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance())));        assertEquals(true, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, new MockEqualsChronology())));        assertEquals(false, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, ISOChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    class MockEqualsChronology extends BaseChronology {        public boolean equals(Object obj) {            return obj instanceof MockEqualsChronology;        }        public DateTimeZone getZone() {            return null;        }        public Chronology withUTC() {            return this;        }        public Chronology withZone(DateTimeZone zone) {            return this;        }        public String toString() {            return "";        }    }    public void testCompareTo() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        public void testIsEqual() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new MutableDateTime(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isEqual(null));    }        public void testIsBefore() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new MutableDateTime(TEST_TIME_NOW - 1).isBefore(null));    }        public void testIsAfter() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new MutableDateTime(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutableDateTime result = (MutableDateTime) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString());                test = new MutableDateTime(TEST_TIME_NOW, PARIS);        assertEquals("2002-06-09T02:00:00.000+02:00", test.toString());    }    public void testToString_String() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("2002 01", test.toString("yyyy HH"));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null));    }    public void testToString_String_String() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Instant result = test.toInstant();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTime() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        DateTime result = test.toDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(test.getChronology(), result.getChronology());    }    public void testToDateTimeISO() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        DateTime result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_DateTimeZone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(test.getChronology(), result.getChronology());        assertEquals(LONDON, result.getZone());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(PARIS, result.getZone());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(LONDON), result.getChronology());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_Chronology() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);    }    public void testToMutableDateTime_DateTimeZone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testClone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = (MutableDateTime) test.clone();        assertEquals(true, test.equals(result));        assertEquals(true, test != result);    }    public void testCopy() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.copy();        assertEquals(true, test.equals(result));        assertEquals(true, test != result);    }    public void testRounding1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay());        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());    }    public void testRounding2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());    }    public void testRounding3() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());    }    public void testRounding4() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());    }    public void testRounding5() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_EVEN, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());                test = new MutableDateTime(2002, 6, 9, 4, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T04:00:00.000+01:00", test.toString());    }    public void testRounding6() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE);        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());    }    public void testRounding7() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setRounding(ISOChronology.getInstance().hourOfDay(), -1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testRounding8() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING);        assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(null, -1);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay());        assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test.setRounding(null);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Constructors.class);    }    public TestDateTime_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        DateTime test = new DateTime();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateTime test = new DateTime(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        DateTime test = new DateTime(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        DateTime test = new DateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        DateTime test = new DateTime(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        DateTime test = new DateTime(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME2, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new DateTime(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        DateTime test = new DateTime((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new DateTime(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        DateTime test = new DateTime((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new DateTime(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        DateTime test = new DateTime((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        DateTime test = new DateTime((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0);        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  // +02:00        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePeriod;/** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */public class TestPeriod_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriod_Basics.class);    }    public TestPeriod_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetPeriodType() {        Period test = new Period(0L);        assertEquals(PeriodType.standard(), test.getPeriodType());    }    public void testGetMethods() {        Period test = new Period(0L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testValueIndexMethods() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(6, test.size());        assertEquals(1, test.getValue(0));        assertEquals(4, test.getValue(1));        assertEquals(5, test.getValue(2));        assertEquals(6, test.getValue(3));        assertEquals(7, test.getValue(4));        assertEquals(8, test.getValue(5));        assertEquals(true, Arrays.equals(new int[] {1, 4, 5, 6, 7, 8}, test.getValues()));    }    public void testTypeIndexMethods() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(6, test.size());        assertEquals(DurationFieldType.years(), test.getFieldType(0));        assertEquals(DurationFieldType.days(), test.getFieldType(1));        assertEquals(DurationFieldType.hours(), test.getFieldType(2));        assertEquals(DurationFieldType.minutes(), test.getFieldType(3));        assertEquals(DurationFieldType.seconds(), test.getFieldType(4));        assertEquals(DurationFieldType.millis(), test.getFieldType(5));        assertEquals(true, Arrays.equals(new DurationFieldType[] {            DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(),            DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis()},            test.getFieldTypes()));    }    public void testIsSupported() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(true, test.isSupported(DurationFieldType.years()));        assertEquals(false, test.isSupported(DurationFieldType.months()));        assertEquals(false, test.isSupported(DurationFieldType.weeks()));        assertEquals(true, test.isSupported(DurationFieldType.days()));        assertEquals(true, test.isSupported(DurationFieldType.hours()));        assertEquals(true, test.isSupported(DurationFieldType.minutes()));        assertEquals(true, test.isSupported(DurationFieldType.seconds()));        assertEquals(true, test.isSupported(DurationFieldType.millis()));    }            public void testIndexOf() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(0, test.indexOf(DurationFieldType.years()));        assertEquals(-1, test.indexOf(DurationFieldType.months()));        assertEquals(-1, test.indexOf(DurationFieldType.weeks()));        assertEquals(1, test.indexOf(DurationFieldType.days()));        assertEquals(2, test.indexOf(DurationFieldType.hours()));        assertEquals(3, test.indexOf(DurationFieldType.minutes()));        assertEquals(4, test.indexOf(DurationFieldType.seconds()));        assertEquals(5, test.indexOf(DurationFieldType.millis()));    }    public void testGet() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(1, test.get(DurationFieldType.years()));        assertEquals(0, test.get(DurationFieldType.months()));        assertEquals(0, test.get(DurationFieldType.weeks()));        assertEquals(4, test.get(DurationFieldType.days()));        assertEquals(5, test.get(DurationFieldType.hours()));        assertEquals(6, test.get(DurationFieldType.minutes()));        assertEquals(7, test.get(DurationFieldType.seconds()));        assertEquals(8, test.get(DurationFieldType.millis()));    }    public void testEqualsHashCode() {        Period test1 = new Period(123L);        Period test2 = new Period(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Period test3 = new Period(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockPeriod(123L)));        assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime())));    }        class MockPeriod extends BasePeriod {        public MockPeriod(long value) {            super(value, null, null);        }    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Period test = new Period(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Period result = (Period) ois.readObject();        ois.close();                assertEquals(test, result);    }//    //-----------------------------------------------------------------------//    public void testAddTo1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    public void testAddTo2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, -2);//        assertEquals(expected, added);//    }//    //    public void testAddTo3() {//        long expected = TEST_TIME_NOW;//        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 0);//        assertEquals(expected, added);//    }//    //    public void testAddTo4() {//        long expected = TEST_TIME_NOW + 100L;//        Period test = new Period(100L);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToWithChronology1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC());  // local specified so use it//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so use default//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToRI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2);  // DateTime has UTC time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstanceUTC(), added.getChronology());//    }//    //    public void testAddToRI4() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);//        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);//        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);//        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);//        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);//        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);//        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);//        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());//    }//    //    public void testAddToRI5() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(null, -2);  // null has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    //-----------------------------------------------------------------------//    public void testAddIntoRWI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, 1);//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI3() {//        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        try {//            test.addInto(null, 1);//            fail();//        } catch (IllegalArgumentException ex) {}//    }        //-----------------------------------------------------------------------    public void testToString() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString());                test = new Period(0, 0, 0, 0, 0, 0, 0, 0);        assertEquals("PT0S", test.toString());                test = new Period(12345L);        assertEquals("PT12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToPeriod() {        Period test = new Period(123L);        Period result = test.toPeriod();        assertSame(test, result);    }    public void testToMutablePeriod() {        Period test = new Period(123L);        MutablePeriod result = test.toMutablePeriod();        assertEquals(test, result);    }    //-----------------------------------------------------------------------//    public void testToDurationMillisFrom() {//        Period test = new Period(123L);//        assertEquals(123L, test.toDurationMillisFrom(0L, null));//    }    public void testToDuration() {        Period test = new Period(123L);        assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L)));    }    //-----------------------------------------------------------------------    public void testWithPeriodType1() {        Period test = new Period(123L);        Period result = test.withPeriodType(PeriodType.standard());        assertSame(test, result);    }    public void testWithPeriodType2() {        Period test = new Period(3123L);        Period result = test.withPeriodType(PeriodType.dayTime());        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(PeriodType.dayTime(), result.getPeriodType());    }    public void testWithPeriodType3() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());        try {            test.withPeriodType(PeriodType.dayTime());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithPeriodType4() {        Period test = new Period(3123L);        Period result = test.withPeriodType(null);        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(PeriodType.standard(), result.getPeriodType());    }    public void testWithPeriodType5() {        Period test = new Period(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.standard());        Period result = test.withPeriodType(PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testWithFields1() {        Period test1 = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period test2 = new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis());        Period result = test1.withFields(test2);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()), test2);        assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 9), result);    }    public void testWithFields2() {        Period test1 = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period test2 = null;        Period result = test1.withFields(test2);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test1);        assertSame(test1, result);    }    public void testWithFields3() {        Period test1 = new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis());        Period test2 = new Period(1, 2, 3, 4, 5, 6, 7, 8);        try {            test1.withFields(test2);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()), test1);        assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test2);    }    //-----------------------------------------------------------------------    public void testWithField1() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period result = test.withField(DurationFieldType.years(), 6);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test);        assertEquals(new Period(6, 2, 3, 4, 5, 6, 7, 8), result);    }    public void testWithField2() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period result = test.withField(null, 6);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period result = test.withFieldAdded(DurationFieldType.years(), 6);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test);        assertEquals(new Period(7, 2, 3, 4, 5, 6, 7, 8), result);    }    public void testWithFieldAdded2() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period result = test.withFieldAdded(null, 6);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testPeriodStatics() {        Period test;        test = Period.years(1);        assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.months(1);        assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.weeks(1);        assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.days(1);        assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard()));        test = Period.hours(1);        assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard()));        test = Period.minutes(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard()));        test = Period.seconds(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard()));        test = Period.millis(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard()));    }    //-----------------------------------------------------------------------    public void testWith() {        Period test;        test = Period.years(5).withYears(1);        assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.months(5).withMonths(1);        assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.weeks(5).withWeeks(1);        assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.days(5).withDays(1);        assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard()));        test = Period.hours(5).withHours(1);        assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard()));        test = Period.minutes(5).withMinutes(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard()));        test = Period.seconds(5).withSeconds(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard()));        test = Period.millis(5).withMillis(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard()));                test = new Period(0L, PeriodType.millis());        try {            test.withYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPlus() {        Period test;        test = Period.years(1).plusYears(1);        assertEquals(new Period(2, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.months(1).plusMonths(1);        assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.weeks(1).plusWeeks(1);        assertEquals(new Period(0, 0, 2, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.days(1).plusDays(1);        assertEquals(new Period(0, 0, 0, 2, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.hours(1).plusHours(1);        assertEquals(new Period(0, 0, 0, 0, 2, 0, 0, 0, PeriodType.standard()), test);        test = Period.minutes(1).plusMinutes(1);        assertEquals(new Period(0, 0, 0, 0, 0, 2, 0, 0, PeriodType.standard()), test);        test = Period.seconds(1).plusSeconds(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 2, 0, PeriodType.standard()), test);        test = Period.millis(1).plusMillis(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 2, PeriodType.standard()), test);                test = new Period(0L, PeriodType.millis());        try {            test.plusYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPlusZero() {        Period test, result;        test = Period.years(1);        result = test.plusYears(0);        assertSame(test, result);        test = Period.months(1);        result = test.plusMonths(0);        assertSame(test, result);        test = Period.weeks(1);        result = test.plusWeeks(0);        assertSame(test, result);        test = Period.days(1);        result = test.plusDays(0);        assertSame(test, result);        test = Period.hours(1);        result = test.plusHours(0);        assertSame(test, result);        test = Period.minutes(1);        result = test.plusMinutes(0);        assertSame(test, result);        test = Period.seconds(1);        result = test.plusSeconds(0);        assertSame(test, result);        test = Period.millis(1);        result = test.plusMillis(0);        assertSame(test, result);    }    public void testMinus() {        Period test;        test = Period.years(3).minusYears(1);        assertEquals(new Period(2, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.months(3).minusMonths(1);        assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.weeks(3).minusWeeks(1);        assertEquals(new Period(0, 0, 2, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.days(3).minusDays(1);        assertEquals(new Period(0, 0, 0, 2, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.hours(3).minusHours(1);        assertEquals(new Period(0, 0, 0, 0, 2, 0, 0, 0, PeriodType.standard()), test);        test = Period.minutes(3).minusMinutes(1);        assertEquals(new Period(0, 0, 0, 0, 0, 2, 0, 0, PeriodType.standard()), test);        test = Period.seconds(3).minusSeconds(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 2, 0, PeriodType.standard()), test);        test = Period.millis(3).minusMillis(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 2, PeriodType.standard()), test);                test = new Period(0L, PeriodType.millis());        try {            test.minusYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestYearMonthDay extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestYearMonthDay.class);    }    public TestYearMonthDay(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        YearMonthDay test = new YearMonthDay();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1971, test.getYear());        assertEquals(5, test.getMonthOfYear());        assertEquals(7, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1971, test.getYear());        assertEquals(5, test.getMonthOfYear());        assertEquals(7, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        YearMonthDay test = new YearMonthDay(null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            YearMonthDay test = new YearMonthDay(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(1970, test.getYear());            assertEquals(1, test.getMonthOfYear());            assertEquals(1, test.getDayOfMonth());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Object) null, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            YearMonthDay test = new YearMonthDay(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(1970, test.getYear());            assertEquals(1, test.getMonthOfYear());            assertEquals(1, test.getDayOfMonth());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new YearMonthDay(Integer.MIN_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(Integer.MAX_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 0, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 13, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 31);            fail();        } catch (IllegalArgumentException ex) {}        new YearMonthDay(1970, 7, 31);        try {            new YearMonthDay(1970, 7, 32);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new YearMonthDay(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 0, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 13, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 31, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new YearMonthDay(1970, 7, 31, GregorianChronology.getInstance());        try {            new YearMonthDay(1970, 7, 32, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    public void testGet() {        YearMonthDay test = new YearMonthDay();        assertEquals(1970, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(DateTimeFieldType.hourOfDay());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSize() {        YearMonthDay test = new YearMonthDay();        assertEquals(3, test.size());    }    public void testGetFieldType() {        YearMonthDay test = new YearMonthDay();        assertSame(DateTimeFieldType.year(), test.getFieldType(0));        assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1));        assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2));        try {            test.getFieldType(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getFieldType(3);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldTypes() {        YearMonthDay test = new YearMonthDay();        DateTimeFieldType[] fields = test.getFieldTypes();        assertSame(DateTimeFieldType.year(), fields[0]);        assertSame(DateTimeFieldType.monthOfYear(), fields[1]);        assertSame(DateTimeFieldType.dayOfMonth(), fields[2]);        assertNotSame(test.getFieldTypes(), test.getFieldTypes());    }    public void testGetField() {        YearMonthDay test = new YearMonthDay();        assertSame(ISOChronology.getInstance().year(), test.getField(0));        assertSame(ISOChronology.getInstance().monthOfYear(), test.getField(1));        assertSame(ISOChronology.getInstance().dayOfMonth(), test.getField(2));        try {            test.getField(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getField(3);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFields() {        YearMonthDay test = new YearMonthDay();        DateTimeField[] fields = test.getFields();        assertSame(ISOChronology.getInstance().year(), fields[0]);        assertSame(ISOChronology.getInstance().monthOfYear(), fields[1]);        assertSame(ISOChronology.getInstance().dayOfMonth(), fields[2]);        assertNotSame(test.getFields(), test.getFields());    }    public void testGetValue() {        YearMonthDay test = new YearMonthDay();        assertEquals(1970, test.getValue(0));        assertEquals(6, test.getValue(1));        assertEquals(9, test.getValue(2));        try {            test.getValue(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getValue(3);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetValues() {        YearMonthDay test = new YearMonthDay();        int[] values = test.getValues();        assertEquals(1970, values[0]);        assertEquals(6, values[1]);        assertEquals(9, values[2]);        assertNotSame(test.getValues(), test.getValues());    }    public void testIsSupported() {        YearMonthDay test = new YearMonthDay();        assertEquals(true, test.isSupported(DateTimeFieldType.year()));        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));        assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay()));    }    public void testEqualsHashCode() {        YearMonthDay test1 = new YearMonthDay(1970, 6, 9);        YearMonthDay test2 = new YearMonthDay(1970, 6, 9);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                YearMonthDay test3 = new YearMonthDay(1971, 6, 9);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));    }        class MockInstant extends MockPartial {        public DateTimeField[] getFields() {            return new DateTimeField[] {                ISOChronology.getInstance().year(),                ISOChronology.getInstance().monthOfYear(),                ISOChronology.getInstance().dayOfMonth(),            };        }        public int[] getValues() {            return new int[] {1970, 6, 9};        }    }    //-----------------------------------------------------------------------    public void testResolveDateTime_RI() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        DateTime dt = new DateTime(TEST_TIME1);        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());                DateTime result = test.toDateTimeUsing(dt);        check(test, 1972, 6, 9);        assertEquals("1970-04-06T12:24:00.000Z", dt.toString());        assertEquals("1972-06-09T12:24:00.000Z", result.toString());    }    public void testResolveDateTime_nullRI() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);                DateTime result = test.toDateTimeUsing(null);        check(test, 1972, 6, 9);        assertEquals("1972-06-09T12:24:00.000Z", result.toString());    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        YearMonthDay test = new YearMonthDay(1972, 6, 9);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        YearMonthDay result = (YearMonthDay) ois.readObject();        ois.close();                assertEquals(test, result);        assertTrue(Arrays.equals(test.getValues(), result.getValues()));        assertTrue(Arrays.equals(test.getFields(), result.getFields()));        assertEquals(test.getChronology(), result.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals("1972-06-09", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadablePartial());        assertSame(test, test.year().getYearMonthDay());        assertEquals(1972, test.year().get());        assertEquals("1972", test.year().getAsText());        assertEquals("1972", test.year().getAsText(Locale.FRENCH));        assertEquals("1972", test.year().getAsShortText());        assertEquals("1972", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyAddYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().addToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1981, 6, 9);                copy = test.year().addToCopy(0);        check(copy, 1972, 6, 9);                copy = test.year().addToCopy(292277023 - 1972);        check(copy, 292277023, 6, 9);                try {            test.year().addToCopy(292277023 - 1972 + 1);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 1972, 6, 9);                copy = test.year().addToCopy(-1972);        check(copy, 0, 6, 9);                copy = test.year().addToCopy(-1973);        check(copy, -1, 6, 9);                try {            test.year().addToCopy(-292275054 - 1972 - 1);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 1972, 6, 9);    }    public void testPropertyAddWrapFieldYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().addWrapFieldToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1981, 6, 9);                copy = test.year().addWrapFieldToCopy(0);        check(copy, 1972, 6, 9);                copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);        check(copy, -292275054, 6, 9);                copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);        check(copy, 292277023, 6, 9);    }    public void testPropertySetYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 12, 6, 9);    }    public void testPropertySetTextYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 12, 6, 9);    }    public void testPropertyCompareToYear() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.year().compareTo(test2) < 0);        assertEquals(true, test2.year().compareTo(test1) > 0);        assertEquals(true, test1.year().compareTo(test1) == 0);        try {            test1.year().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.year().compareTo(dt2) < 0);        assertEquals(true, test2.year().compareTo(dt1) > 0);        assertEquals(true, test1.year().compareTo(dt1) == 0);        try {            test1.year().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadablePartial());        assertSame(test, test.monthOfYear().getYearMonthDay());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new YearMonthDay(1972, 7, 9);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));    }    public void testPropertyGetMaxMinValuesMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyAddMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().addToCopy(6);        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().addToCopy(7);        check(copy, 1973, 1, 9);                copy = test.monthOfYear().addToCopy(-5);        check(copy, 1972, 1, 9);                copy = test.monthOfYear().addToCopy(-6);        check(copy, 1971, 12, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().addToCopy(1);        check(copy, 1972, 2, 29);                copy = test.monthOfYear().addToCopy(2);        check(copy, 1972, 3, 31);                copy = test.monthOfYear().addToCopy(3);        check(copy, 1972, 4, 30);                test = new YearMonthDay(1971, 1, 31);        copy = test.monthOfYear().addToCopy(1);        check(copy, 1971, 2, 28);    }    public void testPropertyAddWrapFieldMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().addWrapFieldToCopy(4);        check(test, 1972, 6, 9);        check(copy, 1972, 10, 9);                copy = test.monthOfYear().addWrapFieldToCopy(8);        check(copy, 1972, 2, 9);                copy = test.monthOfYear().addWrapFieldToCopy(-8);        check(copy, 1972, 10, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().addWrapFieldToCopy(1);        check(copy, 1972, 2, 29);                copy = test.monthOfYear().addWrapFieldToCopy(2);        check(copy, 1972, 3, 31);                copy = test.monthOfYear().addWrapFieldToCopy(3);        check(copy, 1972, 4, 30);                test = new YearMonthDay(1971, 1, 31);        copy = test.monthOfYear().addWrapFieldToCopy(1);        check(copy, 1971, 2, 28);    }    public void testPropertySetMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().setCopy(2);        check(copy, 1972, 2, 29);                try {            test.monthOfYear().setCopy(13);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.monthOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().setCopy("December");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().setCopy("Dec");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);    }    public void testPropertyCompareToMonth() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);        try {            test1.monthOfYear().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadablePartial());        assertSame(test, test.dayOfMonth().getYearMonthDay());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        test = new YearMonthDay(1972, 7, 9);        assertEquals(31, test.dayOfMonth().getMaximumValue());        test = new YearMonthDay(1972, 2, 9);        assertEquals(29, test.dayOfMonth().getMaximumValue());        test = new YearMonthDay(1971, 2, 9);        assertEquals(28, test.dayOfMonth().getMaximumValue());    }    public void testPropertyAddDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().addToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 18);                copy = test.dayOfMonth().addToCopy(21);        check(copy, 1972, 6, 30);                copy = test.dayOfMonth().addToCopy(22);        check(copy, 1972, 7, 1);                copy = test.dayOfMonth().addToCopy(22 + 30);        check(copy, 1972, 7, 31);                copy = test.dayOfMonth().addToCopy(22 + 31);        check(copy, 1972, 8, 1);        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        check(copy, 1972, 12, 31);                copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        check(copy, 1973, 1, 1);                copy = test.dayOfMonth().addToCopy(-8);        check(copy, 1972, 6, 1);                copy = test.dayOfMonth().addToCopy(-9);        check(copy, 1972, 5, 31);                copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        check(copy, 1972, 1, 1);                copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        check(copy, 1971, 12, 31);    }    public void testPropertyAddWrapFieldDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().addWrapFieldToCopy(21);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 30);                copy = test.dayOfMonth().addWrapFieldToCopy(22);        check(copy, 1972, 6, 1);                copy = test.dayOfMonth().addWrapFieldToCopy(-12);        check(copy, 1972, 6, 27);                test = new YearMonthDay(1972, 7, 9);        copy = test.dayOfMonth().addWrapFieldToCopy(21);        check(copy, 1972, 7, 30);            copy = test.dayOfMonth().addWrapFieldToCopy(22);        check(copy, 1972, 7, 31);            copy = test.dayOfMonth().addWrapFieldToCopy(23);        check(copy, 1972, 7, 1);            copy = test.dayOfMonth().addWrapFieldToCopy(-12);        check(copy, 1972, 7, 28);    }    public void testPropertySetDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 12);                try {            test.dayOfMonth().setCopy(31);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfMonth().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 1972, 6, 12);    }    public void testPropertyCompareToDay() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);        try {            test1.dayOfMonth().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    private void check(YearMonthDay test, int hour, int min, int sec) {        assertEquals(hour, test.getYear());        assertEquals(min, test.getMonthOfYear());        assertEquals(sec, test.getDayOfMonth());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Properties.class);    }    public TestDateTime_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getReadableInstant());        assertSame(test, test.era().getDateTime());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getReadableInstant());        assertSame(test, test.yearOfEra().getDateTime());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getReadableInstant());        assertSame(test, test.centuryOfEra().getDateTime());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getReadableInstant());        assertSame(test, test.yearOfCentury().getDateTime());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getReadableInstant());        assertSame(test, test.weekyear().getDateTime());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadableInstant());        assertSame(test, test.year().getDateTime());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyLeapYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(true, test.year().isLeap());        assertEquals(1, test.year().getLeapAmount());        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());        test = new DateTime(2003, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.year().isLeap());        assertEquals(0, test.year().getLeapAmount());        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());    }    public void testPropertyAddYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addToCopy(0);        assertEquals("2004-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addToCopy(292277023 - 2004);        assertEquals(292277023, copy.getYear());                try {            test.year().addToCopy(292277023 - 2004 + 1);            fail();        } catch (IllegalArgumentException ex) {}                copy = test.year().addToCopy(-2004);        assertEquals(0, copy.getYear());                copy = test.year().addToCopy(-2005);        assertEquals(-1, copy.getYear());                try {            test.year().addToCopy(-292275054 - 2004 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertyAddWrapFieldYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().addWrapFieldToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addWrapFieldToCopy(0);        assertEquals(2004, copy.getYear());                copy = test.year().addWrapFieldToCopy(292277023 - 2004 + 1);        assertEquals(-292275054, copy.getYear());                copy = test.year().addWrapFieldToCopy(-292275054 - 2004 - 1);        assertEquals(292277023, copy.getYear());    }    public void testPropertySetYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().setCopy(1960);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetTextYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().setCopy("1960");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.year().compareTo(test2) < 0);        assertEquals(true, test2.year().compareTo(test1) > 0);        assertEquals(true, test1.year().compareTo(test1) == 0);        try {            test1.year().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertyCompareToYear2() {        DateTime test1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        YearMonthDay test2 = new YearMonthDay(2004, 6, 9);        YearMonthDay test3 = new YearMonthDay(2005, 6, 9);        assertEquals(true, test1.year().compareTo(test1) == 0);        assertEquals(true, test2.year().compareTo(test2) == 0);        assertEquals(true, test3.year().compareTo(test3) == 0);                assertEquals(true, test1.year().compareTo(test2) == 0);        assertEquals(true, test2.year().compareTo(test1) == 0);        assertEquals(true, test1.year().compareTo(test3) < 0);        assertEquals(true, test3.year().compareTo(test1) > 0);        try {            test1.year().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadableInstant());        assertSame(test, test.monthOfYear().getDateTime());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyLeapMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2004, 2, 9, 0, 0, 0, 0);        assertEquals(true, test.monthOfYear().isLeap());        assertEquals(1, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2003, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2003, 2, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());    }    public void testPropertyAddMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().addToCopy(6);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(7);        assertEquals("2005-01-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(-5);        assertEquals("2004-01-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(-6);        assertEquals("2003-12-09T00:00:00.000Z", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addToCopy(1);        assertEquals("2004-01-31T00:00:00.000Z", test.toString());        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(2);        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addToCopy(3);        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());                test = new DateTime(2003, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addToCopy(1);        assertEquals("2003-02-28T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().addWrapFieldToCopy(4);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(8);        assertEquals("2004-02-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(-8);        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addWrapFieldToCopy(1);        assertEquals("2004-01-31T00:00:00.000Z", test.toString());        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(2);        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(3);        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());                test = new DateTime(2005, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addWrapFieldToCopy(1);        assertEquals("2005-01-31T00:00:00.000Z", test.toString());        assertEquals("2005-02-28T00:00:00.000Z", copy.toString());    }    public void testPropertySetMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().setCopy(2);        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                try {            test.monthOfYear().setCopy(13);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.monthOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().setCopy("December");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().setCopy("Dec");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToMonthOfYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadableInstant());        assertSame(test, test.dayOfMonth().getDateTime());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals(31, test.dayOfMonth().getMaximumValue());        test = new DateTime(2004, 2, 9, 0, 0, 0, 0);        assertEquals(29, test.dayOfMonth().getMaximumValue());        test = new DateTime(2003, 2, 9, 0, 0, 0, 0);        assertEquals(28, test.dayOfMonth().getMaximumValue());    }    public void testPropertyAddDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 30);        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 31);        assertEquals("2004-08-01T00:00:00.000+01:00", copy.toString());        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().addWrapFieldToCopy(21);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addWrapFieldToCopy(22);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addWrapFieldToCopy(-12);        assertEquals("2004-06-27T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        copy = test.dayOfMonth().addWrapFieldToCopy(21);        assertEquals("2004-07-30T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(22);        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(23);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(-12);        assertEquals("2004-07-28T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());                try {            test.dayOfMonth().setCopy(31);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfMonth().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToDayOfMonth() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getReadableInstant());        assertSame(test, test.dayOfYear().getDateTime());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.dayOfYear().getMinimumValue());        assertEquals(1, test.dayOfYear().getMinimumValueOverall());        assertEquals(366, test.dayOfYear().getMaximumValue());        assertEquals(366, test.dayOfYear().getMaximumValueOverall());        test = new DateTime(2002, 6, 9, 0, 0, 0, 0);        assertEquals(365, test.dayOfYear().getMaximumValue());        assertEquals(366, test.dayOfYear().getMaximumValueOverall());    }    public void testPropertyAddDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().addWrapFieldToCopy(21);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-12);        assertEquals("2004-05-28T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(205);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(206);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-160);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-161);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertySetDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());                try {            test.dayOfYear().setCopy(367);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToDayOfYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfYear().compareTo(test2) < 0);        assertEquals(true, test2.dayOfYear().compareTo(test1) > 0);        assertEquals(true, test1.dayOfYear().compareTo(test1) == 0);        try {            test1.dayOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfYear().compareTo(dt1) == 0);        try {            test1.dayOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        // 2002-01-01 = Thu        // 2002-12-31 = Thu (+364 days)        // 2003-12-30 = Thu (+364 days)        // 2004-01-03 = Mon             W1        // 2004-01-31 = Mon (+28 days)  W5        // 2004-02-28 = Mon (+28 days)  W9        // 2004-03-27 = Mon (+28 days)  W13        // 2004-04-24 = Mon (+28 days)  W17        // 2004-05-23 = Mon (+28 days)  W21        // 2004-06-05 = Mon (+14 days)  W23        // 2004-06-09 = Fri        // 2004-12-25 = Mon             W52        // 2005-01-01 = Mon             W1        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getReadableInstant());        assertSame(test, test.weekOfWeekyear().getDateTime());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.weekOfWeekyear().getMinimumValue());        assertEquals(1, test.weekOfWeekyear().getMinimumValueOverall());        assertEquals(53, test.weekOfWeekyear().getMaximumValue());        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());        test = new DateTime(2005, 6, 9, 0, 0, 0, 0);        assertEquals(52, test.weekOfWeekyear().getMaximumValue());        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());    }    public void testPropertyAddWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().addToCopy(1);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());                copy = test.weekOfWeekyear().addToCopy(29);        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(30);        assertEquals("2005-01-03T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(-22);        assertEquals("2004-01-05T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(-23);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().addWrapFieldToCopy(1);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(29);        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(30);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(-23);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());    }    public void testPropertySetWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().setCopy(4);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());                try {            test.weekOfWeekyear().setCopy(54);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.weekOfWeekyear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().setCopy("4");        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToWeekOfWeekyear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.weekOfWeekyear().compareTo(test2) < 0);        assertEquals(true, test2.weekOfWeekyear().compareTo(test1) > 0);        assertEquals(true, test1.weekOfWeekyear().compareTo(test1) == 0);        try {            test1.weekOfWeekyear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.weekOfWeekyear().compareTo(dt2) < 0);        assertEquals(true, test2.weekOfWeekyear().compareTo(dt1) > 0);        assertEquals(true, test1.weekOfWeekyear().compareTo(dt1) == 0);        try {            test1.weekOfWeekyear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getReadableInstant());        assertSame(test, test.dayOfWeek().getDateTime());        assertEquals(3, test.dayOfWeek().get());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }    public void testPropertyAddDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().addToCopy(1);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddLongDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().addToCopy(1L);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());    }            public void testPropertyAddWrapFieldDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);  // Wed        DateTime copy = test.dayOfWeek().addWrapFieldToCopy(1);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addWrapFieldToCopy(5);        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addWrapFieldToCopy(-10);        assertEquals("2004-06-13T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 2, 0, 0, 0, 0);        copy = test.dayOfWeek().addWrapFieldToCopy(5);        assertEquals("2004-06-02T00:00:00.000+01:00", test.toString());        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().setCopy(4);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                try {            test.dayOfWeek().setCopy(8);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfWeek().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().setCopy("4");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("Mon");        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("Tuesday");        assertEquals("2004-06-08T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("lundi", Locale.FRENCH);        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToDayOfWeek() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test2.dayOfWeek().compareTo(test1) < 0);        assertEquals(true, test1.dayOfWeek().compareTo(test2) > 0);        assertEquals(true, test1.dayOfWeek().compareTo(test1) == 0);        try {            test1.dayOfWeek().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test2.dayOfWeek().compareTo(dt1) < 0);        assertEquals(true, test1.dayOfWeek().compareTo(dt2) > 0);        assertEquals(true, test1.dayOfWeek().compareTo(dt1) == 0);        try {            test1.dayOfWeek().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getReadableInstant());        assertSame(test, test.hourOfDay().getDateTime());        assertEquals(13, test.hourOfDay().get());        assertEquals("13", test.hourOfDay().getAsText());        assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("13", test.hourOfDay().getAsShortText());        assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyGetDifferenceHourOfDay() {        DateTime test1 = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime test2 = new DateTime(2004, 6, 9, 15, 30, 0, 0);        assertEquals(-2, test1.hourOfDay().getDifference(test2));        assertEquals(2, test2.hourOfDay().getDifference(test1));        assertEquals(-2L, test1.hourOfDay().getDifferenceAsLong(test2));        assertEquals(2L, test2.hourOfDay().getDifferenceAsLong(test1));                DateTime test = new DateTime(TEST_TIME_NOW + (13L * DateTimeConstants.MILLIS_PER_HOUR));        assertEquals(13, test.hourOfDay().getDifference(null));        assertEquals(13L, test.hourOfDay().getDifferenceAsLong(null));    }    public void testPropertyRoundFloorHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundCeilingHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfFloorHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfCeilingHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfEvenHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 14, 30, 0, 0);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRemainderHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfHour() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getReadableInstant());        assertSame(test, test.minuteOfHour().getDateTime());        assertEquals(23, test.minuteOfHour().get());        assertEquals("23", test.minuteOfHour().getAsText());        assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("23", test.minuteOfHour().getAsShortText());        assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());        assertEquals("minuteOfDay", test.minuteOfDay().getName());        assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString());        assertSame(test, test.minuteOfDay().getReadableInstant());        assertSame(test, test.minuteOfDay().getDateTime());        assertEquals(803, test.minuteOfDay().get());        assertEquals("803", test.minuteOfDay().getAsText());        assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH));        assertEquals("803", test.minuteOfDay().getAsShortText());        assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());        assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));        assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfMinute() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getReadableInstant());        assertSame(test, test.secondOfMinute().getDateTime());        assertEquals(43, test.secondOfMinute().get());        assertEquals("43", test.secondOfMinute().getAsText());        assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("43", test.secondOfMinute().getAsShortText());        assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());        assertEquals("secondOfDay", test.secondOfDay().getName());        assertEquals("Property[secondOfDay]", test.secondOfDay().toString());        assertSame(test, test.secondOfDay().getReadableInstant());        assertSame(test, test.secondOfDay().getDateTime());        assertEquals(48223, test.secondOfDay().get());        assertEquals("48223", test.secondOfDay().getAsText());        assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH));        assertEquals("48223", test.secondOfDay().getAsShortText());        assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());        assertEquals(5, test.secondOfDay().getMaximumTextLength(null));        assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfSecond() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getReadableInstant());        assertSame(test, test.millisOfSecond().getDateTime());        assertEquals(53, test.millisOfSecond().get());        assertEquals("53", test.millisOfSecond().getAsText());        assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("53", test.millisOfSecond().getAsShortText());        assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());        assertEquals("millisOfDay", test.millisOfDay().getName());        assertEquals("Property[millisOfDay]", test.millisOfDay().toString());        assertSame(test, test.millisOfDay().getReadableInstant());        assertSame(test, test.millisOfDay().getDateTime());        assertEquals(48223053, test.millisOfDay().get());        assertEquals("48223053", test.millisOfDay().getAsText());        assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH));        assertEquals("48223053", test.millisOfDay().getAsShortText());        assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());        assertEquals(8, test.millisOfDay().getMaximumTextLength(null));        assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Adds extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Adds.class);    }    public TestMutableDateTime_Adds(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testAdd_long1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(123456L);        assertEquals(TEST_TIME1 + 123456L, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testAdd_RD1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(new Duration(123456L));        assertEquals(TEST_TIME1 + 123456L, test.getMillis());    }    public void testAdd_RD2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadableDuration) null);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RD_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(new Duration(123456L), -2);        assertEquals(TEST_TIME1 - (2L * 123456L), test.getMillis());    }    public void testAdd_RD_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadableDuration) null, 1);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RP1() {        Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());        test.add(d);        assertEquals("2003-07-10T06:07:08.009+01:00", test.toString());    }    public void testAdd_RP2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadablePeriod) null);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RP_int1() {        Period d = new Period(0, 0, 0, 0, 0, 0, 1, 2);        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(d, -2);        assertEquals(TEST_TIME1 - (2L * 1002L), test.getMillis());    }    public void testAdd_RP_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadablePeriod) null, 1);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_DurationField_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(ISOChronology.getInstance().years(), 8);        assertEquals(2010, test.getYear());    }    public void testAdd_DurationField_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.add((DurationField) null, 2010);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAddYears_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addYears(8);        assertEquals("2010-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMonths_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMonths(6);        assertEquals("2002-12-09T05:06:07.008Z", test.toString());    }    //-----------------------------------------------------------------------    public void testAddDays_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addDays(17);        assertEquals("2002-06-26T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddWeekyears_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addWeekyears(-1);        assertEquals("2001-06-10T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddWeeks_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addWeeks(-21);        assertEquals("2002-01-13T05:06:07.008Z", test.toString());    }    //-----------------------------------------------------------------------    public void testAddHours_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addHours(13);        assertEquals("2002-06-09T18:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMinutes_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMinutes(13);        assertEquals("2002-06-09T05:19:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddSeconds_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addSeconds(13);        assertEquals("2002-06-09T05:06:20.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMillis_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMillis(13);        assertEquals("2002-06-09T05:06:07.021+01:00", test.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.IntervalConverter;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */public class TestInterval_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInterval_Constructors.class);    }    public TestInterval_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.getMillis(), dt2.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1.getMillis(), dt1.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    public void testConstructor_long_long3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new Interval(dt1.getMillis(), dt2.getMillis());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), Chronology.getGJ());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getGJ(), test.getChronology());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0));        Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1));        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1, (ReadableInstant) null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval((ReadableInstant) null, dt2);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI6() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1, dt1);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI7() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new Interval(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RI_RI8() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getGJ());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getGJ(), test.getChronology());    }    public void testConstructor_RI_RI9() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getGJ());        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RP1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, 6);        result = ISOChronology.getInstanceUTC().days().add(result, 3);        result = ISOChronology.getInstanceUTC().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getCopticUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = Chronology.getCopticUTC().months().add(result, 6);        result = Chronology.getCopticUTC().days().add(result, 3);        result = Chronology.getCopticUTC().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, 1);        result = ISOChronology.getInstance().millis().add(result, 23);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP5() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadablePeriod) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RP6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval(dt, (ReadablePeriod) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RP7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Interval test = new Interval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new Interval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RI1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = Chronology.getISOUTC().months().add(result, -6);        result = Chronology.getISOUTC().days().add(result, -3);        result = Chronology.getISOUTC().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getCopticUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = Chronology.getCopticUTC().months().add(result, -6);        result = Chronology.getCopticUTC().days().add(result, -3);        result = Chronology.getCopticUTC().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, -1);        result = ISOChronology.getInstance().millis().add(result, -23);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI5() throws Throwable {        Interval test = new Interval((ReadablePeriod) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval((ReadablePeriod) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Interval test = new Interval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new Interval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(result - TEST_TIME_NOW);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadableDuration) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RD3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval(dt, (ReadableDuration) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RD4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Duration dur = new Duration(result - TEST_TIME_NOW);                Interval test = new Interval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new Interval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(TEST_TIME_NOW - result);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI2() throws Throwable {        Interval test = new Interval((ReadableDuration) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval((ReadableDuration) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Duration dur = new Duration(TEST_TIME_NOW - result);                Interval test = new Interval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new Interval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_Object1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.toString() + '/' + dt2.toString());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                Interval test = new Interval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval base = new MutableInterval(dt1, dt2);                Interval test = new Interval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object4() throws Throwable {        MockInterval base = new MockInterval();        Interval test = new Interval(base);        assertEquals(base.getStartMillis(), test.getStartMillis());        assertEquals(base.getEndMillis(), test.getEndMillis());    }    public void testConstructor_Object5() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter("");        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return String.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);            DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);            Interval test = new Interval(dt1.toString() + '/' + dt2.toString());            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    public void testConstructor_Object6() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 0L));        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return ReadableInterval.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            Interval base = new Interval(-1000L, 1000L);            Interval test = new Interval(base);            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    class MockInterval implements ReadableInterval {        public Chronology getChronology() {            return Chronology.getISO();        }        public long getStartMillis() {            return 1234L;        }        public DateTime getStart() {            return new DateTime(1234L);        }        public long getEndMillis() {            return 5678L;        }        public DateTime getEnd() {            return new DateTime(5678L);        }        public long toDurationMillis() {            return (5678L - 1234L);        }        public Duration toDuration() {            return new Duration(5678L - 1234L);        }        public boolean contains(long millisInstant) {            return false;        }        public boolean containsNow() {            return false;        }        public boolean contains(ReadableInstant instant) {            return false;        }        public boolean contains(ReadableInterval interval) {            return false;        }        public boolean overlaps(ReadableInterval interval) {            return false;        }        public boolean isBefore(ReadableInstant instant) {            return false;        }        public boolean isBefore(ReadableInterval interval) {            return false;        }        public boolean isAfter(ReadableInstant instant) {            return false;        }        public boolean isAfter(ReadableInterval interval) {            return false;        }        public Interval toInterval() {            return null;        }        public MutableInterval toMutableInterval() {            return null;        }        public Period toPeriod() {            return null;        }        public Period toPeriod(PeriodType type) {            return null;        }    }    //-----------------------------------------------------------------------    public void testConstructor_Object_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                Interval test = new Interval(base, Chronology.getBuddhist());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getBuddhist(), test.getChronology());    }    public void testConstructor_Object_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                Interval test = new Interval(base, null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractDuration;import org.joda.time.base.BaseDuration;/** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */public class TestDuration_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDuration_Basics.class);    }    public TestDuration_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        Duration test = new Duration(0L);        assertEquals(0, test.getMillis());                test = new Duration(1234567890L);        assertEquals(1234567890L, test.getMillis());    }    public void testEqualsHashCode() {        Duration test1 = new Duration(123L);        Duration test2 = new Duration(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Duration test3 = new Duration(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockDuration(123L)));    }        class MockDuration extends AbstractDuration {        private final long iValue;        public MockDuration(long value) {            super();            iValue = value;        }        public long getMillis() {            return iValue;        }    }    public void testCompareTo() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                Duration test2 = new Duration(321L);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                assertEquals(+1, test2.compareTo(new MockDuration(123L)));        assertEquals(0, test1.compareTo(new MockDuration(123L)));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Long(123L));            fail();        } catch (ClassCastException ex) {}    }    public void testIsEqual() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                Duration test2 = new Duration(321L);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                assertEquals(false, test2.isEqual(new MockDuration(123L)));        assertEquals(true, test1.isEqual(new MockDuration(123L)));        assertEquals(false, test1.isEqual(null));        assertEquals(true, new Duration(0L).isEqual(null));    }        public void testIsBefore() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(false, test1.isShorterThan(test1a));        assertEquals(false, test1a.isShorterThan(test1));        assertEquals(false, test1.isShorterThan(test1));        assertEquals(false, test1a.isShorterThan(test1a));                Duration test2 = new Duration(321L);        assertEquals(true, test1.isShorterThan(test2));        assertEquals(false, test2.isShorterThan(test1));                assertEquals(false, test2.isShorterThan(new MockDuration(123L)));        assertEquals(false, test1.isShorterThan(new MockDuration(123L)));        assertEquals(false, test1.isShorterThan(null));        assertEquals(false, new Duration(0L).isShorterThan(null));    }        public void testIsAfter() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(false, test1.isLongerThan(test1a));        assertEquals(false, test1a.isLongerThan(test1));        assertEquals(false, test1.isLongerThan(test1));        assertEquals(false, test1a.isLongerThan(test1a));                Duration test2 = new Duration(321L);        assertEquals(false, test1.isLongerThan(test2));        assertEquals(true, test2.isLongerThan(test1));                assertEquals(true, test2.isLongerThan(new MockDuration(123L)));        assertEquals(false, test1.isLongerThan(new MockDuration(123L)));        assertEquals(true, test1.isLongerThan(null));        assertEquals(false, new Duration(0L).isLongerThan(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Duration test = new Duration(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Duration result = (Duration) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        long length = (365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 845L;        Duration test = new Duration(length);        assertEquals("PT" + (length / 1000) + "." + (length % 1000) + "S", test.toString());                test = new Duration(0L);        assertEquals("PT0S", test.toString());                test = new Duration(12345L);        assertEquals("PT12.345S", test.toString());                test = new Duration(-12345L);        assertEquals("PT-12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToDuration1() {        Duration test = new Duration(123L);        Duration result = test.toDuration();        assertSame(test, result);    }        public void testToDuration2() {        MockDuration test = new MockDuration(123L);        Duration result = test.toDuration();        assertNotSame(test, result);        assertEquals(test, result);    }        //-----------------------------------------------------------------------    public void testToPeriod() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod();        assertEquals(new Period(test), result);        assertEquals(new Period(test.getMillis()), result);    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(PeriodType.standard().withMillisRemoved());        assertEquals(new Period(test, PeriodType.standard().withMillisRemoved()), result);        assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved()), result);    }    //-----------------------------------------------------------------------    public void testToPeriod_Chronology() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(Chronology.getISOUTC());        assertEquals(new Period(test, Chronology.getISOUTC()), result);        assertEquals(new Period(test.getMillis(), Chronology.getISOUTC()), result);    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType_Chronology() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(PeriodType.standard().withMillisRemoved(), Chronology.getISOUTC());        assertEquals(new Period(test, PeriodType.standard().withMillisRemoved(), Chronology.getISOUTC()), result);        assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved(), Chronology.getISOUTC()), result);    }    //-----------------------------------------------------------------------    public void testToPeriodFrom() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Period result = test.toPeriodFrom(dt);        assertEquals(new Period(dt, test), result);    }    //-----------------------------------------------------------------------    public void testToPeriodFrom_PeriodType() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Period result = test.toPeriodFrom(dt, PeriodType.standard().withMillisRemoved());        assertEquals(new Period(dt, test, PeriodType.standard().withMillisRemoved()), result);    }    //-----------------------------------------------------------------------    public void testToIntervalFrom() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval result = test.toIntervalFrom(dt);        assertEquals(new Interval(dt, test), result);    }    //-----------------------------------------------------------------------    public void testWithMillis1() {        Duration test = new Duration(123L);        Duration result = test.withMillis(123L);        assertSame(test, result);    }    public void testWithMillis2() {        Duration test = new Duration(123L);        Duration result = test.withMillis(1234567890L);        assertEquals(1234567890L, result.getMillis());    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long_int1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 1);        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_long_int2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 2);        assertEquals(16123L, result.getMillis());    }    public void testWithDurationAdded_long_int3() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, -1);        assertEquals((123L - 8000L), result.getMillis());    }    public void testWithDurationAdded_long_int4() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(0L, 1);        assertSame(test, result);    }    public void testWithDurationAdded_long_int5() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testPlus_long1() {        Duration test = new Duration(123L);        Duration result = test.plus(8000L);        assertEquals(8123L, result.getMillis());    }    public void testPlus_long2() {        Duration test = new Duration(123L);        Duration result = test.plus(0L);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMinus_long1() {        Duration test = new Duration(123L);        Duration result = test.minus(8000L);        assertEquals(123L - 8000L, result.getMillis());    }    public void testMinus_long2() {        Duration test = new Duration(123L);        Duration result = test.minus(0L);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_RD_int1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 1);        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_RD_int2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 2);        assertEquals(16123L, result.getMillis());    }    public void testWithDurationAdded_RD_int3() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), -1);        assertEquals((123L - 8000L), result.getMillis());    }    public void testWithDurationAdded_RD_int4() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(0L), 1);        assertSame(test, result);    }    public void testWithDurationAdded_RD_int5() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 0);        assertSame(test, result);    }    public void testWithDurationAdded_RD_int6() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(null, 0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testPlus_RD1() {        Duration test = new Duration(123L);        Duration result = test.plus(new Duration(8000L));        assertEquals(8123L, result.getMillis());    }    public void testPlus_RD2() {        Duration test = new Duration(123L);        Duration result = test.plus(new Duration(0L));        assertSame(test, result);    }    public void testPlus_RD3() {        Duration test = new Duration(123L);        Duration result = test.plus(null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMinus_RD1() {        Duration test = new Duration(123L);        Duration result = test.minus(new Duration(8000L));        assertEquals(123L - 8000L, result.getMillis());    }    public void testMinus_RD2() {        Duration test = new Duration(123L);        Duration result = test.minus(new Duration(0L));        assertSame(test, result);    }    public void testMinus_RD3() {        Duration test = new Duration(123L);        Duration result = test.minus(null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMutableDuration() {        // no MutableDuration, so...        MockMutableDuration test = new MockMutableDuration(123L);        assertEquals(123L, test.getMillis());                test.setMillis(2345L);        assertEquals(2345L, test.getMillis());    }    static class MockMutableDuration extends BaseDuration {        public MockMutableDuration(long duration) {            super(duration);        }        public void setMillis(long duration) {            super.setMillis(duration);        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePeriod;/** * This class is a Junit unit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Basics.class);    }    public TestMutablePeriod_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetPeriodType() {        MutablePeriod test = new MutablePeriod();        assertEquals(PeriodType.standard(), test.getPeriodType());    }    public void testGetMethods() {        MutablePeriod test = new MutablePeriod();        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getDays());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testEqualsHashCode() {        MutablePeriod test1 = new MutablePeriod(123L);        MutablePeriod test2 = new MutablePeriod(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutablePeriod test3 = new MutablePeriod(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockMutablePeriod(123L)));        assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime())));    }        class MockMutablePeriod extends BasePeriod {        public MockMutablePeriod(long value) {            super(value, null, null);        }    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutablePeriod test = new MutablePeriod(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutablePeriod result = (MutablePeriod) ois.readObject();        ois.close();                assertEquals(test, result);    }//    //-----------------------------------------------------------------------//    public void testAddTo1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    public void testAddTo2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, -2);//        assertEquals(expected, added);//    }//    //    public void testAddTo3() {//        long expected = TEST_TIME_NOW;//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 0);//        assertEquals(expected, added);//    }//    //    public void testAddTo4() {//        long expected = TEST_TIME_NOW + 100L;//        MutablePeriod test = new MutablePeriod(100L);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToWithChronology1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC());  // chrono specified so use it//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono so use default//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToRI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2);  // DateTime has UTC time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstanceUTC(), added.getChronology());//    }//    //    public void testAddToRI4() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);//        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);//        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);//        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);//        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);//        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);//        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);//        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());//    }//    //    public void testAddToRI5() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(null, -2);  // null has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    //-----------------------------------------------------------------------//    public void testAddIntoRWI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, 1);//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI3() {//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        try {//            test.addInto(null, 1);//            fail();//        } catch (IllegalArgumentException ex) {}//    }        //-----------------------------------------------------------------------    public void testToString() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString());                test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 0);        assertEquals("PT0S", test.toString());                test = new MutablePeriod(12345L);        assertEquals("PT12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToPeriod() {        MutablePeriod test = new MutablePeriod(123L);        Period result = test.toPeriod();        assertEquals(test, result);    }    public void testToMutablePeriod() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod result = test.toMutablePeriod();        assertEquals(test, result);    }    //-----------------------------------------------------------------------//    public void testToDurationMillisFrom() {//        MutablePeriod test = new MutablePeriod(123L);//        assertEquals(123L, test.toDurationMillisFrom(0L, null));//    }    public void testToDurationFrom() {        MutablePeriod test = new MutablePeriod(123L);        assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L)));    }    //-----------------------------------------------------------------------    public void testCopy() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod copy = test.copy();        assertEquals(test.getPeriodType(), copy.getPeriodType());        assertEquals(test, copy);    }    //-----------------------------------------------------------------------    public void testClone() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod copy = (MutablePeriod) test.clone();        assertEquals(test.getPeriodType(), copy.getPeriodType());        assertEquals(test, copy);    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.Calendar;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.List;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.DateTimeComparator class. * * @author Guy Allard */public class TestDateTimeComparator extends TestCase {    private static final Chronology ISO = ISOChronology.getInstance();        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeComparator.class);    }    public TestDateTimeComparator(String name) {        super(name);    }    /**     * A reference to a DateTime object.     */    DateTime aDateTime = null;    /**     * A reference to a DateTime object.     */    DateTime bDateTime = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for millis of seconds.     */    Comparator cMillis = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for seconds.     */    Comparator cSecond = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for minutes.     */    Comparator cMinute = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for hours.     */    Comparator cHour = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the week.     */    Comparator cDayOfWeek = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the month.     */    Comparator cDayOfMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the year.     */    Comparator cDayOfYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for week of the weekyear.     */    Comparator cWeekOfWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year given a week of the year.     */    Comparator cWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for months.     */    Comparator cMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year.     */    Comparator cYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the date portion of an     * object.     */    Comparator cDate = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the time portion of an     * object.     */    Comparator cTime = null;    /**     * Junit <code>setUp()</code> method.     */    public void setUp() /* throws Exception */ {        Chronology chrono = ISOChronology.getInstanceUTC();        // super.setUp();        // Obtain comparator's        cMillis = DateTimeComparator.getInstance(null, DateTimeFieldType.secondOfMinute());        cSecond = DateTimeComparator.getInstance(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.minuteOfHour());        cMinute = DateTimeComparator.getInstance(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.hourOfDay());        cHour = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());        cDayOfWeek = DateTimeComparator.getInstance(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.weekOfWeekyear());        cDayOfMonth = DateTimeComparator.getInstance(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear());        cDayOfYear = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), DateTimeFieldType.year());        cWeekOfWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekyear());        cWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekyear());        cMonth = DateTimeComparator.getInstance(DateTimeFieldType.monthOfYear(), DateTimeFieldType.year());        cYear = DateTimeComparator.getInstance(DateTimeFieldType.year());        cDate = DateTimeComparator.getDateOnlyInstance();        cTime = DateTimeComparator.getTimeOnlyInstance();    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();        aDateTime = null;        bDateTime = null;        //        cMillis = null;        cSecond = null;        cMinute = null;        cHour = null;        cDayOfWeek = null;        cDayOfMonth = null;        cDayOfYear = null;        cWeekOfWeekyear = null;        cWeekyear = null;        cMonth = null;        cYear = null;        cDate = null;        cTime = null;    }    //-----------------------------------------------------------------------    public void testClass() {        assertEquals(true, Modifier.isPublic(DateTimeComparator.class.getModifiers()));        assertEquals(false, Modifier.isFinal(DateTimeComparator.class.getModifiers()));        assertEquals(1, DateTimeComparator.class.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(DateTimeComparator.class.getDeclaredConstructors()[0].getModifiers()));    }        //-----------------------------------------------------------------------    public void testStaticGetInstance() {        DateTimeComparator c = DateTimeComparator.getInstance();        assertEquals(null, c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[]", c.toString());    }            public void testStaticGetDateOnlyInstance() {        DateTimeComparator c = DateTimeComparator.getDateOnlyInstance();        assertEquals(DateTimeFieldType.dayOfYear(), c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[dayOfYear-]", c.toString());                assertSame(DateTimeComparator.getDateOnlyInstance(), DateTimeComparator.getDateOnlyInstance());    }    public void testStaticGetTimeOnlyInstance() {        DateTimeComparator c = DateTimeComparator.getTimeOnlyInstance();        assertEquals(null, c.getLowerLimit());        assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit());        assertEquals("DateTimeComparator[-dayOfYear]", c.toString());                assertSame(DateTimeComparator.getTimeOnlyInstance(), DateTimeComparator.getTimeOnlyInstance());    }    public void testStaticGetInstanceLower() {        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay());        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay-]", c.toString());                c = DateTimeComparator.getInstance(null);        assertSame(DateTimeComparator.getInstance(), c);    }    public void testStaticGetInstanceLowerUpper() {        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());        assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay-dayOfYear]", c.toString());                c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfDay());        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());        assertEquals(DateTimeFieldType.hourOfDay(), c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay]", c.toString());                c = DateTimeComparator.getInstance(null, null);        assertSame(DateTimeComparator.getInstance(), c);                c = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), null);        assertSame(DateTimeComparator.getDateOnlyInstance(), c);                c = DateTimeComparator.getInstance(null, DateTimeFieldType.dayOfYear());        assertSame(DateTimeComparator.getTimeOnlyInstance(), c);    }        //-----------------------------------------------------------------------    public void testEqualsHashCode() {        DateTimeComparator c1 = DateTimeComparator.getInstance();        assertEquals(true, c1.equals(c1));        assertEquals(false, c1.equals(null));        assertEquals(true, c1.hashCode() == c1.hashCode());                DateTimeComparator c2 = DateTimeComparator.getTimeOnlyInstance();        assertEquals(true, c2.equals(c2));        assertEquals(false, c2.equals(c1));        assertEquals(false, c1.equals(c2));        assertEquals(false, c2.equals(null));        assertEquals(false, c1.hashCode() == c2.hashCode());                DateTimeComparator c3 = DateTimeComparator.getTimeOnlyInstance();        assertEquals(true, c3.equals(c3));        assertEquals(false, c3.equals(c1));        assertEquals(true, c3.equals(c2));        assertEquals(false, c1.equals(c3));        assertEquals(true, c2.equals(c3));        assertEquals(false, c1.hashCode() == c3.hashCode());        assertEquals(true, c2.hashCode() == c3.hashCode());                DateTimeComparator c4 = DateTimeComparator.getDateOnlyInstance();        assertEquals(false, c4.hashCode() == c3.hashCode());    }        //-----------------------------------------------------------------------    public void testSerialization1() throws Exception {        DateTimeField f = ISO.dayOfYear();        f.toString();        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(c);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeComparator result = (DateTimeComparator) ois.readObject();        ois.close();                assertEquals(c, result);    }    //-----------------------------------------------------------------------    public void testSerialization2() throws Exception {        DateTimeComparator c = DateTimeComparator.getInstance();                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(c);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeComparator result = (DateTimeComparator) ois.readObject();        ois.close();                assertSame(c, result);    }    //-----------------------------------------------------------------------    /**     * Test all basic comparator operation with DateTime objects.     */    public void testBasicComps1() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with ReadableInstant objects.     */    public void testBasicComps2() {        ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with java Date objects.     */    public void testBasicComps3() {        Date aDateTime            = new Date( System.currentTimeMillis() );        Date bDateTime            = new Date( aDateTime.getTime() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Long objects.     */    public void testBasicComps4() {        Long aDateTime            = new Long( System.currentTimeMillis() );        Long bDateTime            = new Long( aDateTime.longValue() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Calendar objects.     */    public void testBasicComps5() {        Calendar aDateTime            = Calendar.getInstance();   // right now        Calendar bDateTime = aDateTime;        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test unequal comparisons with millis of second comparators.     */    public void testMillis() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC );        assertEquals( "MillisM1", -1, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "MillisP1", 1, cMillis.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with second comparators.     */    public void testSecond() {        aDateTime = getADate( "1969-12-31T23:59:58" );        bDateTime = getADate( "1969-12-31T23:50:59" );        assertEquals( "SecondM1a", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1a", 1, cSecond.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:00:01" );        assertEquals( "SecondM1b", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1b", 1, cSecond.compare( bDateTime, aDateTime ) );    }   // end of testSecond    /**     * Test unequal comparisons with minute comparators.     */    public void testMinute() {        aDateTime = getADate( "1969-12-31T23:58:00" );        bDateTime = getADate( "1969-12-31T23:59:00" );        assertEquals( "MinuteM1a", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1a", 1, cMinute.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:01:00" );        assertEquals( "MinuteM1b", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1b", 1, cMinute.compare( bDateTime, aDateTime ) );    }   // end of testMinute    /**     * Test unequal comparisons with hour comparators.     */    public void testHour() {        aDateTime = getADate( "1969-12-31T22:00:00" );        bDateTime = getADate( "1969-12-31T23:00:00" );        assertEquals( "HourM1a", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1a", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T01:00:00" );        assertEquals( "HourM1b", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1b", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "HourP1c", 1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourM1c", -1, cHour.compare( bDateTime, aDateTime ) );    }   // end of testHour    /**     * Test unequal comparisons with day of week comparators.     */    public void testDOW() {        /*         * Dates chosen when I wrote the code, so I know what day of         * the week it is.         */        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOWM1a", -1, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOWP1a", 1, cDayOfWeek.compare( bDateTime, aDateTime ) );    }   // end of testDOW    /**     * Test unequal comparisons with day of month comparators.     */    public void testDOM() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOMM1a", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1a", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-12-01T00:00:00" );        bDateTime = getADate( "1814-04-30T00:00:00" );        assertEquals( "DOMM1b", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1b", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );    }   // end of testDOM    /**     * Test unequal comparisons with day of year comparators.     */    public void testDOY() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOYM1a", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1a", 1, cDayOfYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-02-29T00:00:00" );        bDateTime = getADate( "1814-11-30T00:00:00" );        assertEquals( "DOYM1b", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1b", 1, cDayOfYear.compare( bDateTime, aDateTime ) );    }   // end of testDOY    /**     * Test unequal comparisons with week of weekyear comparators.     */    public void testWOW() {        // 1st week of year contains Jan 04.        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "2000-01-11T00:00:00" );        assertEquals( "WOWM1a", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1a", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "1999-12-31T00:00:00" );        assertEquals( "WOWM1b", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1b", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with year given the week comparators.     */    public void testWOYY() {        // How do I test the end conditions of this?        // Don't understand ......        aDateTime = getADate( "1998-12-31T23:59:59" );        bDateTime = getADate( "1999-01-01T00:00:00" );        assertEquals( "YOYYZ", 0, cWeekyear.compare( aDateTime, bDateTime ) );        bDateTime = getADate( "1999-01-04T00:00:00" );        assertEquals( "YOYYM1", -1, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "YOYYP1", 1, cWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testWOYY    /**     * Test unequal comparisons with month comparators.     */    public void testMonth() {        aDateTime = getADate( "2002-04-30T00:00:00" );        bDateTime = getADate( "2002-05-01T00:00:00" );        assertEquals( "MONTHM1a", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1a", 1, cMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1900-01-01T00:00:00" );        bDateTime = getADate( "1899-12-31T00:00:00" );        assertEquals( "MONTHM1b", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1b", 1, cMonth.compare( bDateTime, aDateTime ) );    }   // end of testMonth    /**     * Test unequal comparisons with year comparators.     */    public void testYear() {        aDateTime = getADate( "2000-01-01T00:00:00" );        bDateTime = getADate( "2001-01-01T00:00:00" );        assertEquals( "YEARM1a", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1a", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1968-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1b", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1b", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1c", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1c", 1, cYear.compare( bDateTime, aDateTime ) );    }   // end of testYear    /*     * 'List' processing tests follow.     */     /**      * Test sorting with full default comparator.      */     public void testListBasic() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-01-20T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListBasic", !isSorted1, isSorted2);     } // end of testListBasic     /**      * Test sorting with millis of second comparator.      */    public void testListMillis() {        //        List sl = new ArrayList();        long base = 12345L * 1000L;        sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) );        //        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMillis );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListLillis", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with second comparator.      */    public void testListSecond() {        String[] dtStrs = {            "1999-02-01T00:00:10",            "1999-02-01T00:00:30",            "1999-02-01T00:00:25",            "1999-02-01T00:00:18",            "1999-02-01T00:00:01",            "1999-02-01T00:00:59",            "1999-02-01T00:00:22"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cSecond );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListSecond", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with minute comparator.      */    public void testListMinute() {        String[] dtStrs = {            "1999-02-01T00:10:00",            "1999-02-01T00:30:00",            "1999-02-01T00:25:00",            "1999-02-01T00:18:00",            "1999-02-01T00:01:00",            "1999-02-01T00:59:00",            "1999-02-01T00:22:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMinute );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMinute", !isSorted1, isSorted2);    } // end of testListMinute     /**      * Test sorting with hour comparator.      */    public void testListHour() {        String[] dtStrs = {            "1999-02-01T10:00:00",            "1999-02-01T23:00:00",            "1999-02-01T01:00:00",            "1999-02-01T15:00:00",            "1999-02-01T05:00:00",            "1999-02-01T20:00:00",            "1999-02-01T17:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cHour );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListHour", !isSorted1, isSorted2);    } // end of testListHour     /**      * Test sorting with day of week comparator.      */    public void testListDOW() {        String[] dtStrs = {            /* 2002-04-15 = Monday */            "2002-04-21T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-20T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfWeek );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOW", !isSorted1, isSorted2);    } // end of testListDOW     /**      * Test sorting with day of month comparator.      */    public void testListDOM() {        String[] dtStrs = {            /* 2002-04-14 = Sunday */            "2002-04-20T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-14T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOM", !isSorted1, isSorted2);    } // end of testListDOM     /**      * Test sorting with day of year comparator.      */    public void testListDOY() {        String[] dtStrs = {            "2002-04-20T10:00:00",            "2002-01-16T10:00:00",            "2002-12-31T10:00:00",            "2002-09-14T10:00:00",            "2002-09-19T10:00:00",            "2002-02-14T10:00:00",            "2002-10-30T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOY", !isSorted1, isSorted2);    } // end of testListDOY     /**      * Test sorting with week of weekyear comparator.      */    public void testListWOW() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekOfWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListWOW", !isSorted1, isSorted2);    } // end of testListWOW     /**      * Test sorting with year (given week) comparator.      */    public void testListYOYY() {        // ?? How to catch end conditions ??        String[] dtStrs = {            "2010-04-01T10:00:00",            "2002-01-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYOYY", !isSorted1, isSorted2);    } // end of testListYOYY     /**      * Test sorting with month comparator.      */    public void testListMonth() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMonth", !isSorted1, isSorted2);    } // end of testListMonth     /**      * Test sorting with year comparator.      */     public void testListYear() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-02-01T00:00:00",            "2525-02-01T00:00:00",            "1776-02-01T00:00:00",            "1863-02-01T00:00:00",            "1066-02-01T00:00:00",            "2100-02-01T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYear", !isSorted1, isSorted2);     } // end of testListYear     /**      * Test sorting with date only comparator.      */    public void testListDate() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-10-03T00:00:00",            "2525-05-20T00:00:00",            "1776-12-25T00:00:00",            "1863-01-31T00:00:00",            "1066-09-22T00:00:00",            "2100-07-04T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDate );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDate", !isSorted1, isSorted2);    } // end of testListDate     /**      * Test sorting with time only comparator.      */    public void testListTime() {        String[] dtStrs = {            "1999-02-01T01:02:05",            "1999-02-01T22:22:22",            "1999-02-01T05:30:45",            "1999-02-01T09:17:59",            "1999-02-01T09:17:58",            "1999-02-01T15:30:00",            "1999-02-01T17:00:44"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cTime );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListTime", !isSorted1, isSorted2);    } // end of testListTime    /**     * Test comparator operation with null object(s).     */    public void testNullDT() {        // null means now        aDateTime = getADate("2000-01-01T00:00:00");        assertTrue(cYear.compare(null, aDateTime) > 0);        assertTrue(cYear.compare(aDateTime, null) < 0);    }    /**     * Test comparator operation with an invalid object type.     */    public void testInvalidObj() {        aDateTime = getADate("2000-01-01T00:00:00");        try {            cYear.compare("FreeBird", aDateTime);            fail("Invalid object failed");        } catch (IllegalArgumentException cce) {}    }    // private convenience methods    //-----------------------------------------------------------------------    /**     * Creates a date to test with.     */    private DateTime getADate(String s) {        DateTime retDT = null;        try {            retDT = new DateTime(s, DateTimeZone.UTC);        } catch (IllegalArgumentException pe) {            pe.printStackTrace();        }        return retDT;    }    /**     * Load a string array.     */    private List loadAList(String[] someStrs) {        List newList = new ArrayList();        try {            for (int i = 0; i < someStrs.length; ++i) {                newList.add(new DateTime(someStrs[i], DateTimeZone.UTC));            } // end of the for        } catch (IllegalArgumentException pe) {            pe.printStackTrace();        }        return newList;    }    /**     * Check if the list is sorted.     */    private boolean isListSorted(List tl) {        // tl must be populated with DateTime objects.        DateTime lhDT = (DateTime)tl.get(0);        DateTime rhDT = null;        Long lhVal = new Long( lhDT.getMillis() );        Long rhVal = null;        for (int i = 1; i < tl.size(); ++i) {            rhDT = (DateTime)tl.get(i);            rhVal = new Long( rhDT.getMillis() );            if ( lhVal.compareTo( rhVal) > 0 ) return false;            //            lhVal = rhVal;  // swap for next iteration            lhDT = rhDT;    // swap for next iteration        }        return true;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.IntervalConverter;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */public class TestMutableInterval_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Constructors.class);    }    public TestMutableInterval_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testConstructor() throws Throwable {        MutableInterval test = new MutableInterval();        assertEquals(0L, test.getStartMillis());        assertEquals(0L, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt1.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    public void testConstructor_long_long3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new MutableInterval(dt1.getMillis(), dt2.getMillis());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), Chronology.getGJ());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getGJ(), test.getChronology());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0));        Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1));        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1, (ReadableInstant) null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval((ReadableInstant) null, dt2);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI6() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1, dt1);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI7() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new MutableInterval(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RI_RI8() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getGJ());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getGJ(), test.getChronology());    }    public void testConstructor_RI_RI9() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getGJ());        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RP1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = Chronology.getISO().months().add(result, 6);        result = Chronology.getISO().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = Chronology.getISOUTC().months().add(result, 6);        result = Chronology.getISOUTC().days().add(result, 3);        result = Chronology.getISOUTC().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = Chronology.getISOUTC().months().add(result, 6);        result = Chronology.getISOUTC().days().add(result, 3);        result = Chronology.getISOUTC().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, 1);        result = ISOChronology.getInstance().millis().add(result, 23);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP5() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadablePeriod) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RP6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval(dt, (ReadablePeriod) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RP7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                MutableInterval test = new MutableInterval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new MutableInterval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RI1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = Chronology.getISO().months().add(result, -6);        result = Chronology.getISO().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = Chronology.getISOUTC().months().add(result, -6);        result = Chronology.getISOUTC().days().add(result, -3);        result = Chronology.getISOUTC().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, Chronology.getISOUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = Chronology.getISOUTC().months().add(result, -6);        result = Chronology.getISOUTC().days().add(result, -3);        result = Chronology.getISOUTC().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, -1);        result = ISOChronology.getInstance().millis().add(result, -23);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI5() throws Throwable {        MutableInterval test = new MutableInterval((ReadablePeriod) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval((ReadablePeriod) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                MutableInterval test = new MutableInterval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new MutableInterval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(result - TEST_TIME_NOW);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableDuration) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RD3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval(dt, (ReadableDuration) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RD4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Duration dur = new Duration(result - TEST_TIME_NOW);                MutableInterval test = new MutableInterval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new MutableInterval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(TEST_TIME_NOW - result);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI2() throws Throwable {        MutableInterval test = new MutableInterval((ReadableDuration) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval((ReadableDuration) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Duration dur = new Duration(TEST_TIME_NOW - result);                MutableInterval test = new MutableInterval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new MutableInterval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_Object1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval base = new MutableInterval(dt1, dt2);                MutableInterval test = new MutableInterval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                MutableInterval test = new MutableInterval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object4() throws Throwable {        MockInterval base = new MockInterval();        MutableInterval test = new MutableInterval(base);        assertEquals(base.getStartMillis(), test.getStartMillis());        assertEquals(base.getEndMillis(), test.getEndMillis());    }    public void testConstructor_Object5() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter("");        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return String.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);            DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);            MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString());            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    public void testConstructor_Object6() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new MutableInterval(0L, 0L));        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return ReadableInterval.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            Interval base = new Interval(-1000L, 1000L);            MutableInterval test = new MutableInterval(base);            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    class MockInterval implements ReadableInterval {        public Chronology getChronology() {            return Chronology.getISO();        }        public long getStartMillis() {            return 1234L;        }        public DateTime getStart() {            return new DateTime(1234L);        }        public long getEndMillis() {            return 5678L;        }        public DateTime getEnd() {            return new DateTime(5678L);        }        public long toDurationMillis() {            return (5678L - 1234L);        }        public Duration toDuration() {            return new Duration(5678L - 1234L);        }        public boolean contains(long millisInstant) {            return false;        }        public boolean containsNow() {            return false;        }        public boolean contains(ReadableInstant instant) {            return false;        }        public boolean contains(ReadableInterval interval) {            return false;        }        public boolean overlaps(ReadableInterval interval) {            return false;        }        public boolean isBefore(ReadableInstant instant) {            return false;        }        public boolean isBefore(ReadableInterval interval) {            return false;        }        public boolean isAfter(ReadableInstant instant) {            return false;        }        public boolean isAfter(ReadableInterval interval) {            return false;        }        public Interval toInterval() {            return null;        }        public MutableInterval toMutableInterval() {            return null;        }        public Period toPeriod() {            return null;        }        public Period toPeriod(PeriodType type) {            return null;        }    }    //-----------------------------------------------------------------------    public void testConstructor_Object_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                MutableInterval test = new MutableInterval(base, Chronology.getBuddhist());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getBuddhist(), test.getChronology());    }    public void testConstructor_Object_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                MutableInterval test = new MutableInterval(base, null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(Chronology.getISO(), test.getChronology());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePartial;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestBasePartial extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBasePartial.class);    }    public TestBasePartial(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testSetMethods() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(1970, mock.getYear());        assertEquals(1, mock.getMonthOfYear());                mock.setYear(2004);        assertEquals(2004, mock.getYear());        assertEquals(1, mock.getMonthOfYear());                mock.setMonthOfYear(6);        assertEquals(2004, mock.getYear());        assertEquals(6, mock.getMonthOfYear());                mock.set(2005, 5);        assertEquals(2005, mock.getYear());        assertEquals(5, mock.getMonthOfYear());                try {            mock.setMonthOfYear(0);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(2005, mock.getYear());        assertEquals(5, mock.getMonthOfYear());                try {            mock.setMonthOfYear(13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(2005, mock.getYear());        assertEquals(5, mock.getMonthOfYear());    }    static class MockPartial extends BasePartial {                MockPartial() {            super(new int[] {1970, 1}, null);        }        protected DateTimeField getField(int index, Chronology chrono) {            switch (index) {                case 0:                    return chrono.year();                case 1:                    return chrono.monthOfYear();                default:                    throw new IndexOutOfBoundsException();            }        }        public int size() {            return 2;        }                public int getYear() {            return getValue(0);        }                public void setYear(int year) {            setValue(0, year);        }                public int getMonthOfYear() {            return getValue(1);        }                public void setMonthOfYear(int month) {            setValue(1, month);        }                public void set(int year, int month) {            setValues(new int[] {year, month});        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Sets extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Sets.class);    }    public TestMutableDateTime_Sets(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testSetMillis_long1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setMillis(TEST_TIME2);        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetChronology_Chronology1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setChronology(GregorianChronology.getInstance(PARIS));        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), test.getChronology());    }            public void testSetChronology_Chronology2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setChronology(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetZone_DateTimeZone1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZone(PARIS);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());    }            public void testSetZone_DateTimeZone2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZone(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }            //-----------------------------------------------------------------------    public void testSetZoneRetainFields_DateTimeZone1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZoneRetainFields(PARIS);        assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZoneRetainFields(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone3() {        MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        test.setZoneRetainFields(null);        assertEquals(TEST_TIME1 + DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertEquals(GregorianChronology.getInstance(), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone4() {        Chronology chrono = new MockNullZoneChronology();        MutableDateTime test = new MutableDateTime(TEST_TIME1, chrono);        test.setZoneRetainFields(PARIS);        assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertSame(chrono, test.getChronology());    }            //-----------------------------------------------------------------------    public void testSetMillis_RI1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1, BuddhistChronology.getInstance());        test.setMillis(new Instant(TEST_TIME2));        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(BuddhistChronology.getInstance(), test.getChronology());    }    public void testSetMillis_RI2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1, BuddhistChronology.getInstance());        test.setMillis(null);        assertEquals(TEST_TIME_NOW, test.getMillis());        assertEquals(BuddhistChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSet_DateTimeField_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.set(ISOChronology.getInstance().year(), 2010);        assertEquals(2010, test.getYear());    }    public void testSet_DateTimeField_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.set(null, 2010);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    public void testSet_DateTimeField_int3() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.set(ISOChronology.getInstance().monthOfYear(), 13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetDate_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(2010, 12, 3);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    public void testSetDate_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setDate(2010, 13, 3);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetDate_long1() {        long setter = new DateTime(2010, 12, 3, 5, 7, 9, 501).getMillis();        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(setter);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetDate_RI1() {        DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 501);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(setter);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    public void testSetDate_RI2() {        MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501);        test.setDate(null);  // sets to TEST_TIME_NOW        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetTime_int_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(5, 6, 7, 8);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    public void testSetTime_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setTime(60, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetTime_long1() {        long setter = new DateTime(2010, 12, 3, 5, 7, 9, 11).getMillis();        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetTime_RI1() {        DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 11);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    public void testSetTime_RI2() {        MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501);        test.setTime(null);  // sets to TEST_TIME_NOW, which has no time part        assertEquals(2010, test.getYear());        assertEquals(7, test.getMonthOfYear());        assertEquals(8, test.getDayOfMonth());        assertEquals(new DateTime(TEST_TIME_NOW).getHourOfDay(), test.getHourOfDay());        assertEquals(new DateTime(TEST_TIME_NOW).getMinuteOfHour(), test.getMinuteOfHour());        assertEquals(new DateTime(TEST_TIME_NOW).getSecondOfMinute(), test.getSecondOfMinute());        assertEquals(new DateTime(TEST_TIME_NOW).getMillisOfSecond(), test.getMillisOfSecond());    }    public void testSetTime_Object3() {        DateTime temp = new DateTime(2010, 12, 3, 5, 7, 9, 11);        DateTime setter = new DateTime(temp.getMillis(), new MockNullZoneChronology());        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetDateTime_int_int_int_int_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDateTime(2010, 12, 3, 5, 6, 7, 8);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }        public void testSetDateTime_int_int_int_int_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setDateTime(2010, 13, 3, 5, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {        }        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setYear(2010);        assertEquals("2010-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMonthOfYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMonthOfYear(12);        assertEquals("2002-12-09T05:06:07.008Z", test.toString());    }    public void testSetMonthOfYear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMonthOfYear(13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfMonth_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfMonth(17);        assertEquals("2002-06-17T05:06:07.008+01:00", test.toString());    }    public void testSetDayOfMonth_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfMonth(31);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfYear(3);        assertEquals("2002-01-03T05:06:07.008Z", test.toString());    }    public void testSetDayOfYear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfYear(366);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetWeekyear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setWeekyear(2001);        assertEquals("2001-06-10T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetWeekOfWeekyear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setWeekOfWeekyear(2);        assertEquals("2002-01-13T05:06:07.008Z", test.toString());    }    public void testSetWeekOfWeekyear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setWeekOfWeekyear(53);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfWeek_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfWeek(5);        assertEquals("2002-06-07T05:06:07.008+01:00", test.toString());    }    public void testSetDayOfWeek_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfWeek(8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetHourOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setHourOfDay(13);        assertEquals("2002-06-09T13:06:07.008+01:00", test.toString());    }    public void testSetHourOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setHourOfDay(24);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMinuteOfHour_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMinuteOfHour(13);        assertEquals("2002-06-09T05:13:07.008+01:00", test.toString());    }    public void testSetMinuteOfHour_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMinuteOfHour(60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMinuteOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMinuteOfDay(13);        assertEquals("2002-06-09T00:13:07.008+01:00", test.toString());    }    public void testSetMinuteOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMinuteOfDay(24 * 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetSecondOfMinute_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setSecondOfMinute(13);        assertEquals("2002-06-09T05:06:13.008+01:00", test.toString());    }    public void testSetSecondOfMinute_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setSecondOfMinute(60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetSecondOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setSecondOfDay(13);        assertEquals("2002-06-09T00:00:13.008+01:00", test.toString());    }    public void testSetSecondOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setSecondOfDay(24 * 60 * 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMilliOfSecond_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMillisOfSecond(13);        assertEquals("2002-06-09T05:06:07.013+01:00", test.toString());    }    public void testSetMilliOfSecond_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMillisOfSecond(1000);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMilliOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMillisOfDay(13);        assertEquals("2002-06-09T00:00:00.013+01:00", test.toString());    }    public void testSetMilliOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMillisOfDay(24 * 60 * 60 * 1000);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for Chronology. * * @author Stephen Colebourne */public class TestChronology extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestChronology.class);    }    public TestChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetISO() {        assertEquals(ISOChronology.getInstance(), Chronology.getISO());    }    public void testGetISOUTC() {        assertEquals(ISOChronology.getInstanceUTC(), Chronology.getISOUTC());    }    public void testGetISO_Zone() {        assertEquals(ISOChronology.getInstance(PARIS), Chronology.getISO(PARIS));        assertEquals(ISOChronology.getInstance(), Chronology.getISO(null));    }    //-----------------------------------------------------------------------    public void testGetGJ() {        assertEquals(GJChronology.getInstance(), Chronology.getGJ());    }    public void testGetGJUTC() {        assertEquals(GJChronology.getInstanceUTC(), Chronology.getGJUTC());    }    public void testGetGJ_Zone() {        assertEquals(GJChronology.getInstance(PARIS), Chronology.getGJ(PARIS));        assertEquals(GJChronology.getInstance(), Chronology.getGJ(null));    }    //-----------------------------------------------------------------------    public void testGetGregorian() {        assertEquals(GregorianChronology.getInstance(), Chronology.getGregorian());    }    public void testGetGregorianUTC() {        assertEquals(GregorianChronology.getInstanceUTC(), Chronology.getGregorianUTC());    }    public void testGetGregorian_Zone() {        assertEquals(GregorianChronology.getInstance(PARIS), Chronology.getGregorian(PARIS));        assertEquals(GregorianChronology.getInstance(), Chronology.getGregorian(null));    }    //-----------------------------------------------------------------------    public void testGetJulian() {        assertEquals(JulianChronology.getInstance(), Chronology.getJulian());    }    public void testGetJulianUTC() {        assertEquals(JulianChronology.getInstanceUTC(), Chronology.getJulianUTC());    }    public void testGetJulian_Zone() {        assertEquals(JulianChronology.getInstance(PARIS), Chronology.getJulian(PARIS));        assertEquals(JulianChronology.getInstance(), Chronology.getJulian(null));    }    //-----------------------------------------------------------------------    public void testGetBuddhist() {        assertEquals(BuddhistChronology.getInstance(), Chronology.getBuddhist());    }    public void testGetBuddhistUTC() {        assertEquals(BuddhistChronology.getInstanceUTC(), Chronology.getBuddhistUTC());    }    public void testGetBuddhist_Zone() {        assertEquals(BuddhistChronology.getInstance(PARIS), Chronology.getBuddhist(PARIS));        assertEquals(BuddhistChronology.getInstance(), Chronology.getBuddhist(null));    }    //-----------------------------------------------------------------------    public void testGetCoptic() {        assertEquals(CopticChronology.getInstance(), Chronology.getCoptic());    }    public void testGetCopticUTC() {        assertEquals(CopticChronology.getInstanceUTC(), Chronology.getCopticUTC());    }    public void testGetCoptic_Zone() {        assertEquals(CopticChronology.getInstance(PARIS), Chronology.getCoptic(PARIS));        assertEquals(CopticChronology.getInstance(), Chronology.getCoptic(null));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInterval_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInterval_Basics.class);    }    public TestInterval_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getStart().getMillis());        assertEquals(TEST_TIME2, test.getEndMillis());        assertEquals(TEST_TIME2, test.getEnd().getMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME1);        assertSame(Duration.ZERO, test.toDuration());    }    public void testEqualsHashCode() {        Interval test1 = new Interval(TEST_TIME1, TEST_TIME2);        Interval test2 = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Interval test3 = new Interval(TEST_TIME_NOW, TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                Interval test4 = new Interval(TEST_TIME1, TEST_TIME1, Chronology.getGJ());        assertEquals(true, test4.equals(test4));        assertEquals(false, test1.equals(test4));        assertEquals(false, test2.equals(test4));        assertEquals(false, test4.equals(test1));        assertEquals(false, test4.equals(test2));        assertEquals(false, test1.hashCode() == test4.hashCode());        assertEquals(false, test2.hashCode() == test4.hashCode());                MutableInterval test5 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test5));        assertEquals(true, test2.equals(test5));        assertEquals(false, test3.equals(test5));        assertEquals(true, test5.equals(test1));        assertEquals(true, test5.equals(test2));        assertEquals(false, test5.equals(test3));        assertEquals(true, test1.hashCode() == test5.hashCode());        assertEquals(true, test2.hashCode() == test5.hashCode());        assertEquals(false, test3.hashCode() == test5.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInterval()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInterval extends AbstractInterval {        public MockInterval() {            super();        }        public Chronology getChronology() {            return Chronology.getISO();        }        public long getStartMillis() {            return TEST_TIME1;        }        public long getEndMillis() {            return TEST_TIME2;        }    }    //-----------------------------------------------------------------------    public void testContains_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(TEST_TIME1));        assertEquals(false, test.contains(TEST_TIME1 - 1));        assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2));        assertEquals(false, test.contains(TEST_TIME2));        assertEquals(true, test.contains(TEST_TIME2 - 1));    }    public void testContainsNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(true, test.containsNow());    }    public void testContains_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(new Instant(TEST_TIME1)));        assertEquals(false, test.contains(new Instant(TEST_TIME1 - 1)));        assertEquals(true, test.contains(new Instant(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2)));        assertEquals(false, test.contains(new Instant(TEST_TIME2)));        assertEquals(true, test.contains(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.contains((ReadableInstant) null));    }    //-----------------------------------------------------------------------    public void testContains_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1)));                assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));                assertEquals(true, test.contains((ReadableInterval) null));    }    public void testOverlaps_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));                assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));                assertEquals(true, test.overlaps((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testIsBefore_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(TEST_TIME1 - 1));        assertEquals(false, test.isBefore(TEST_TIME1));        assertEquals(false, test.isBefore(TEST_TIME1 + 1));                assertEquals(false, test.isBefore(TEST_TIME2 - 1));        assertEquals(true, test.isBefore(TEST_TIME2));        assertEquals(true, test.isBefore(TEST_TIME2 + 1));    }    public void testIsBeforeNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(false, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(true, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 + 1);        assertEquals(true, test.isBeforeNow());    }    public void testIsBefore_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isBefore((ReadableInstant) null));    }    public void testIsBefore_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isBefore((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testIsAfter_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(TEST_TIME1 - 1));        assertEquals(false, test.isAfter(TEST_TIME1));        assertEquals(false, test.isAfter(TEST_TIME1 + 1));                assertEquals(false, test.isAfter(TEST_TIME2 - 1));        assertEquals(false, test.isAfter(TEST_TIME2));        assertEquals(false, test.isAfter(TEST_TIME2 + 1));    }    public void testIsAfterNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(true, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(false, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + 1);        assertEquals(false, test.isAfterNow());    }    public void testIsAfter_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Instant(TEST_TIME2 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isAfter((ReadableInstant) null));    }    public void testIsAfter_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isAfter((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testToInterval1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.toInterval();        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testToMutableInterval1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        MutableInterval result = test.toMutableInterval();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToPeriod() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod();        assertEquals(PeriodType.standard(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType1() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod(null);        assertEquals(PeriodType.standard(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType2() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod(PeriodType.yearWeekDayTime());        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(9, result.getWeeks());        assertEquals(2, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType3() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);        Interval test = new Interval(dt1, dt2);                Period result = test.toPeriod(PeriodType.yearWeekDayTime());        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(0, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Interval result = (Interval) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);        Interval test = new Interval(dt1, dt2);        assertEquals("2004-06-09T07:08:09.010/2005-08-13T12:14:16.018", test.toString());    }    //-----------------------------------------------------------------------    public void testAlways() {        Interval test = Interval.ALWAYS;        assertEquals(Long.MIN_VALUE, test.getStartMillis());        assertEquals(Long.MAX_VALUE, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testWithStartMillis_long1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStartMillis(TEST_TIME1 - 1);        assertEquals(TEST_TIME1 - 1, result.getStartMillis());        assertEquals(TEST_TIME2, result.getEndMillis());    }    public void testWithStartMillis_long2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withStartMillis(TEST_TIME2 + 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithStartMillis_long3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStartMillis(TEST_TIME1);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithStartInstant_RI1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStart(new Instant(TEST_TIME1 - 1));        assertEquals(TEST_TIME1 - 1, result.getStartMillis());        assertEquals(TEST_TIME2, result.getEndMillis());    }    public void testWithStartInstant_RI2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withStart(new Instant(TEST_TIME2 + 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithStartInstant_RI3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withStart(null);        assertEquals(TEST_TIME_NOW, result.getStartMillis());        assertEquals(TEST_TIME2, result.getEndMillis());    }    //-----------------------------------------------------------------------    public void testWithEndMillis_long1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEndMillis(TEST_TIME2 - 1);        assertEquals(TEST_TIME1, result.getStartMillis());        assertEquals(TEST_TIME2 - 1, result.getEndMillis());    }    public void testWithEndMillis_long2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withEndMillis(TEST_TIME1 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithEndMillis_long3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEndMillis(TEST_TIME2);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithEndInstant_RI1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEnd(new Instant(TEST_TIME2 - 1));        assertEquals(TEST_TIME1, result.getStartMillis());        assertEquals(TEST_TIME2 - 1, result.getEndMillis());    }    public void testWithEndInstant_RI2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withEnd(new Instant(TEST_TIME1 - 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithEndInstant_RI3() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        Interval result = test.withEnd(null);        assertEquals(TEST_TIME1, result.getStartMillis());        assertEquals(TEST_TIME_NOW, result.getEndMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in Joda Time. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAllPackages extends TestCase {    public TestAllPackages(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(org.joda.time.TestAll.suite());        suite.addTest(org.joda.time.chrono.TestAll.suite());        suite.addTest(org.joda.time.chrono.gj.TestAll.suite());        suite.addTest(org.joda.time.convert.TestAll.suite());        suite.addTest(org.joda.time.format.TestAll.suite());        suite.addTest(org.joda.time.tz.TestAll.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAllPackages.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.BaseChronology;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Basics.class);    }    public TestDateTime_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet_DateTimeField() {        DateTime test = new DateTime();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get((DateTimeField) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGet_DateTimeFieldType() {        DateTime test = new DateTime();        assertEquals(1, test.get(DateTimeFieldType.era()));        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));        assertEquals(2002, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(60, test.get(DateTimeFieldType.minuteOfDay()));        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay()));        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay()));        try {            test.get((DateTimeFieldType) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        DateTime test = new DateTime();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(1, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(60, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(60 * 60, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(60 * 60 * 1000, test.getMillisOfDay());    }    public void testEqualsHashCode() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                DateTime test3 = new DateTime(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1, GregorianChronology.getInstance())));        assertEquals(true, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, new MockEqualsChronology())));        assertEquals(false, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, ISOChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    class MockEqualsChronology extends BaseChronology {        public boolean equals(Object obj) {            return obj instanceof MockEqualsChronology;        }        public DateTimeZone getZone() {            return null;        }        public Chronology withUTC() {            return this;        }        public Chronology withZone(DateTimeZone zone) {            return this;        }        public String toString() {            return "";        }    }    public void testCompareTo() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        //-----------------------------------------------------------------------    public void testIsEqual_long() {        assertEquals(false, new DateTime(TEST_TIME1).isEqual(TEST_TIME2));        assertEquals(true, new DateTime(TEST_TIME1).isEqual(TEST_TIME1));        assertEquals(false, new DateTime(TEST_TIME2).isEqual(TEST_TIME1));    }        public void testIsEqualNow() {        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqualNow());        assertEquals(true, new DateTime(TEST_TIME_NOW).isEqualNow());        assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqualNow());    }        public void testIsEqual_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new DateTime(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqual(null));    }        //-----------------------------------------------------------------------    public void testIsBefore_long() {        assertEquals(true, new DateTime(TEST_TIME1).isBefore(TEST_TIME2));        assertEquals(false, new DateTime(TEST_TIME1).isBefore(TEST_TIME1));        assertEquals(false, new DateTime(TEST_TIME2).isBefore(TEST_TIME1));    }        public void testIsBeforeNow() {        assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBeforeNow());        assertEquals(false, new DateTime(TEST_TIME_NOW).isBeforeNow());        assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBeforeNow());    }        public void testIsBefore_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new DateTime(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBefore(null));    }        //-----------------------------------------------------------------------    public void testIsAfter_long() {        assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME2));        assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME1));        assertEquals(true, new DateTime(TEST_TIME2).isAfter(TEST_TIME1));    }        public void testIsAfterNow() {        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfterNow());        assertEquals(false, new DateTime(TEST_TIME_NOW).isAfterNow());        assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfterNow());    }        public void testIsAfter_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new DateTime(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DateTime test = new DateTime(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTime result = (DateTime) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString());                test = new DateTime(TEST_TIME_NOW, PARIS);        assertEquals("2002-06-09T02:00:00.000+02:00", test.toString());    }    public void testToString_String() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("2002 01", test.toString("yyyy HH"));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null));    }    public void testToString_String_String() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        DateTime test = new DateTime(TEST_TIME1);        Instant result = test.toInstant();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTime() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime();        assertSame(test, result);    }    public void testToDateTimeISO() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTimeISO();        assertSame(test, result);                test = new DateTime(TEST_TIME1, ISOChronology.getInstance(PARIS));        result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);                test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);                test = new DateTime(TEST_TIME1, new MockNullZoneChronology());        result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);    }    public void testToDateTime_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime(LONDON);        assertSame(test, result);        test = new DateTime(TEST_TIME1);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(PARIS, result.getZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateTime(TEST_TIME1);        result = test.toDateTime((DateTimeZone) null);        assertSame(test, result);    }    public void testToDateTime_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertSame(test, result);        test = new DateTime(TEST_TIME1);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toDateTime((Chronology) null);        assertSame(test, result);    }    public void testToMutableDateTime() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        DateTime test = new DateTime(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        DateTime test = new DateTime(TEST_TIME1);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        DateTime test = new DateTime(TEST_TIME1);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withMillis(TEST_TIME1);        assertSame(test, result);    }    public void testWithChronology_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withChronology(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withChronology(ISOChronology.getInstance());        assertSame(test, result);    }    public void testWithZone_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withZone(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withZone(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withZone(null);        assertSame(test, result);    }    public void testWithZoneRetainFields_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withZoneRetainFields(PARIS);        assertEquals(test.getMillis() - DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);                test = new DateTime(TEST_TIME1);        result = test.withZoneRetainFields(null);        assertSame(test, result);                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withZoneRetainFields(null);        assertEquals(test.getMillis() + DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1, new MockNullZoneChronology());        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);    }        //-----------------------------------------------------------------------    public void testWithDate_int_int_int() {        DateTime test = new DateTime(2002, 4, 5, 1, 2, 3, 4, ISOChronology.getInstanceUTC());        DateTime result = test.withDate(2003, 5, 6);        DateTime expected = new DateTime(2003, 5, 6, 1, 2, 3, 4, ISOChronology.getInstanceUTC());        assertEquals(expected, result);                test = new DateTime(TEST_TIME1);        try {            test.withDate(2003, 13, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testWithTime_int_int_int() {        DateTime test = new DateTime(TEST_TIME1 - 12345L, BuddhistChronology.getInstanceUTC());        DateTime result = test.withTime(12, 24, 0, 0);        assertEquals(TEST_TIME1, result.getMillis());        assertEquals(BuddhistChronology.getInstanceUTC(), result.getChronology());                test = new DateTime(TEST_TIME1);        try {            test.withTime(25, 1, 1, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testWithFields_RPartial() {        DateTime test = new DateTime(2004, 5, 6, 7, 8, 9, 0);        DateTime result = test.withFields(new YearMonthDay(2003, 4, 5));        DateTime expected = new DateTime(2003, 4, 5, 7, 8, 9, 0);        assertEquals(expected, result);                test = new DateTime(TEST_TIME1);        result = test.withFields(null);        assertSame(test, result);    }        //-----------------------------------------------------------------------    public void testWithField1() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime result = test.withField(DateTimeFieldType.year(), 2006);                assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test);        assertEquals(new DateTime(2006, 6, 9, 0, 0, 0, 0), result);    }    public void testWithField2() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime result = test.withField(null, 6);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime result = test.withFieldAdded(DurationFieldType.years(), 6);                assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test);        assertEquals(new DateTime(2010, 6, 9, 0, 0, 0, 0), result);    }    public void testWithFieldAdded2() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime result = test.withFieldAdded(null, 6);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long_int() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(123456789L, 1);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, 0);        assertSame(test, result);                result = test.withDurationAdded(123456789L, 2);        expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, -3);        expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_RD_int() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(new Duration(123456789L), 1);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(null, 1);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 0);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 2);        expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(new Duration(123456789L), -3);        expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_RP_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1);        DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(null, 1);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3);        expected = new DateTime(2005, 11, 15, 16, 20, 24, 28, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1);        expected = new DateTime(2001, 3, 2, 0, 0, 0, 0, BuddhistChronology.getInstance());        assertEquals(expected, result);    }    //-----------------------------------------------------------------------        public void testPlus_long() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.plus(123456789L);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);    }        public void testPlus_RD() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.plus(new Duration(123456789L));        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadableDuration) null);        assertSame(test, result);    }        public void testPlus_RP() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));        DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadablePeriod) null);        assertSame(test, result);    }        //-----------------------------------------------------------------------        public void testMinus_long() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.minus(123456789L);        DateTime expected = new DateTime(TEST_TIME1 - 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);    }        public void testMinus_RD() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.minus(new Duration(123456789L));        DateTime expected = new DateTime(TEST_TIME1 - 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadableDuration) null);        assertSame(test, result);    }        public void testMinus_RP() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));        DateTime expected = new DateTime(2001, 3, 26, 0, 1, 2, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadablePeriod) null);        assertSame(test, result);    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */public class TestPeriod_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriod_Constructors.class);    }    public TestPeriod_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testConstructor1() throws Throwable {        Period test = new Period();        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long2() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long3() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Period test = new Period(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.millis());        assertEquals(PeriodType.millis(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(length, test.getMillis());    }    public void testConstructor_long_PeriodType3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType4() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, Chronology.getISO());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, Chronology.getISOUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.time().withMillisRemoved(), Chronology.getISO());        assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.standard(), Chronology.getISOUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.standard(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology4() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, (PeriodType) null, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (4ints)     */    public void testConstructor_4int1() throws Throwable {        Period test = new Period(5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int1() throws Throwable {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int__PeriodType1() throws Throwable {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType2() throws Throwable {        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType3() throws Throwable {        try {            new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testToPeriod_PeriodType3() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.yearWeekDayTime());                assertEquals(PeriodType.yearWeekDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());  // tests using years and not weekyears        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getCoptic());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getCoptic());        Period test = new Period(dt1.getMillis(), dt2.getMillis(), Chronology.getCoptic());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getCoptic());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getCoptic());        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, Chronology.getCoptic());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(-3, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        Period test = new Period(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        Period test = new Period(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        Period test = new Period(dt1, dur, PeriodType.yearDayTime());        assertEquals(PeriodType.yearDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        Period test = new Period(dt1, dur, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        Period test = new Period("P1Y2M3D");        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object2() throws Throwable {        Period test = new Period((Object) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object3() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()));        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object4() throws Throwable {        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard());        Period test = new Period(base);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object_PeriodType1() throws Throwable {        Period test = new Period("P1Y2M3D", PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType2() throws Throwable {        Period test = new Period((Object) null, PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType3() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object_PeriodType4() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null);        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for Chronology. * * @author Stephen Colebourne */public class TestDateTimeFieldType extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeFieldType.class);    }    public TestDateTimeFieldType(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void test_era() {        assertEquals(DateTimeFieldType.era(), DateTimeFieldType.era());        assertEquals("era", DateTimeFieldType.era().getName());        assertEquals(DurationFieldType.eras(), DateTimeFieldType.era().getDurationType());        assertEquals(null, DateTimeFieldType.era().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().era(), DateTimeFieldType.era().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().era().isSupported(), DateTimeFieldType.era().isSupported(Chronology.getCopticUTC()));    }    public void test_centuryOfEra() {        assertEquals(DateTimeFieldType.centuryOfEra(), DateTimeFieldType.centuryOfEra());        assertEquals("centuryOfEra", DateTimeFieldType.centuryOfEra().getName());        assertEquals(DurationFieldType.centuries(), DateTimeFieldType.centuryOfEra().getDurationType());        assertEquals(DurationFieldType.eras(), DateTimeFieldType.centuryOfEra().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().centuryOfEra(), DateTimeFieldType.centuryOfEra().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().centuryOfEra().isSupported(), DateTimeFieldType.centuryOfEra().isSupported(Chronology.getCopticUTC()));    }    public void test_yearOfCentury() {        assertEquals(DateTimeFieldType.yearOfCentury(), DateTimeFieldType.yearOfCentury());        assertEquals("yearOfCentury", DateTimeFieldType.yearOfCentury().getName());        assertEquals(DurationFieldType.years(), DateTimeFieldType.yearOfCentury().getDurationType());        assertEquals(DurationFieldType.centuries(), DateTimeFieldType.yearOfCentury().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().yearOfCentury(), DateTimeFieldType.yearOfCentury().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().yearOfCentury().isSupported(), DateTimeFieldType.yearOfCentury().isSupported(Chronology.getCopticUTC()));    }    public void test_yearOfEra() {        assertEquals(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfEra());        assertEquals("yearOfEra", DateTimeFieldType.yearOfEra().getName());        assertEquals(DurationFieldType.years(), DateTimeFieldType.yearOfEra().getDurationType());        assertEquals(DurationFieldType.eras(), DateTimeFieldType.yearOfEra().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().yearOfEra(), DateTimeFieldType.yearOfEra().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().yearOfEra().isSupported(), DateTimeFieldType.yearOfEra().isSupported(Chronology.getCopticUTC()));    }    public void test_year() {        assertEquals(DateTimeFieldType.year(), DateTimeFieldType.year());        assertEquals("year", DateTimeFieldType.year().getName());        assertEquals(DurationFieldType.years(), DateTimeFieldType.year().getDurationType());        assertEquals(null, DateTimeFieldType.year().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().year(), DateTimeFieldType.year().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().year().isSupported(), DateTimeFieldType.year().isSupported(Chronology.getCopticUTC()));    }    public void test_monthOfYear() {        assertEquals(DateTimeFieldType.monthOfYear(), DateTimeFieldType.monthOfYear());        assertEquals("monthOfYear", DateTimeFieldType.monthOfYear().getName());        assertEquals(DurationFieldType.months(), DateTimeFieldType.monthOfYear().getDurationType());        assertEquals(DurationFieldType.years(), DateTimeFieldType.monthOfYear().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().monthOfYear(), DateTimeFieldType.monthOfYear().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().monthOfYear().isSupported(), DateTimeFieldType.monthOfYear().isSupported(Chronology.getCopticUTC()));    }    public void test_weekyearOfCentury() {        assertEquals(DateTimeFieldType.weekyearOfCentury(), DateTimeFieldType.weekyearOfCentury());        assertEquals("weekyearOfCentury", DateTimeFieldType.weekyearOfCentury().getName());        assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekyearOfCentury().getDurationType());        assertEquals(DurationFieldType.centuries(), DateTimeFieldType.weekyearOfCentury().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().weekyearOfCentury(), DateTimeFieldType.weekyearOfCentury().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().weekyearOfCentury().isSupported(), DateTimeFieldType.weekyearOfCentury().isSupported(Chronology.getCopticUTC()));    }    public void test_weekyear() {        assertEquals(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyear());        assertEquals("weekyear", DateTimeFieldType.weekyear().getName());        assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekyear().getDurationType());        assertEquals(null, DateTimeFieldType.weekyear().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().weekyear(), DateTimeFieldType.weekyear().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().weekyear().isSupported(), DateTimeFieldType.weekyear().isSupported(Chronology.getCopticUTC()));    }    public void test_weekOfWeekyear() {        assertEquals(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekOfWeekyear());        assertEquals("weekOfWeekyear", DateTimeFieldType.weekOfWeekyear().getName());        assertEquals(DurationFieldType.weeks(), DateTimeFieldType.weekOfWeekyear().getDurationType());        assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekOfWeekyear().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().weekOfWeekyear(), DateTimeFieldType.weekOfWeekyear().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().weekOfWeekyear().isSupported(), DateTimeFieldType.weekOfWeekyear().isSupported(Chronology.getCopticUTC()));    }    public void test_dayOfYear() {        assertEquals(DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfYear());        assertEquals("dayOfYear", DateTimeFieldType.dayOfYear().getName());        assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfYear().getDurationType());        assertEquals(DurationFieldType.years(), DateTimeFieldType.dayOfYear().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().dayOfYear(), DateTimeFieldType.dayOfYear().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().dayOfYear().isSupported(), DateTimeFieldType.dayOfYear().isSupported(Chronology.getCopticUTC()));    }    public void test_dayOfMonth() {        assertEquals(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth());        assertEquals("dayOfMonth", DateTimeFieldType.dayOfMonth().getName());        assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfMonth().getDurationType());        assertEquals(DurationFieldType.months(), DateTimeFieldType.dayOfMonth().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().dayOfMonth(), DateTimeFieldType.dayOfMonth().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().dayOfMonth().isSupported(), DateTimeFieldType.dayOfMonth().isSupported(Chronology.getCopticUTC()));    }    public void test_dayOfWeek() {        assertEquals(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.dayOfWeek());        assertEquals("dayOfWeek", DateTimeFieldType.dayOfWeek().getName());        assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfWeek().getDurationType());        assertEquals(DurationFieldType.weeks(), DateTimeFieldType.dayOfWeek().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().dayOfWeek(), DateTimeFieldType.dayOfWeek().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().dayOfWeek().isSupported(), DateTimeFieldType.dayOfWeek().isSupported(Chronology.getCopticUTC()));    }    public void test_halfdayOfDay() {        assertEquals(DateTimeFieldType.halfdayOfDay(), DateTimeFieldType.halfdayOfDay());        assertEquals("halfdayOfDay", DateTimeFieldType.halfdayOfDay().getName());        assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.halfdayOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.halfdayOfDay().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().halfdayOfDay(), DateTimeFieldType.halfdayOfDay().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().halfdayOfDay().isSupported(), DateTimeFieldType.halfdayOfDay().isSupported(Chronology.getCopticUTC()));    }    public void test_clockhourOfDay() {        assertEquals(DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.clockhourOfDay());        assertEquals("clockhourOfDay", DateTimeFieldType.clockhourOfDay().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.clockhourOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.clockhourOfDay().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().clockhourOfDay(), DateTimeFieldType.clockhourOfDay().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().clockhourOfDay().isSupported(), DateTimeFieldType.clockhourOfDay().isSupported(Chronology.getCopticUTC()));    }    public void test_clockhourOfHalfday() {        assertEquals(DateTimeFieldType.clockhourOfHalfday(), DateTimeFieldType.clockhourOfHalfday());        assertEquals("clockhourOfHalfday", DateTimeFieldType.clockhourOfHalfday().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.clockhourOfHalfday().getDurationType());        assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.clockhourOfHalfday().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().clockhourOfHalfday(), DateTimeFieldType.clockhourOfHalfday().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().clockhourOfHalfday().isSupported(), DateTimeFieldType.clockhourOfHalfday().isSupported(Chronology.getCopticUTC()));    }    public void test_hourOfHalfday() {        assertEquals(DateTimeFieldType.hourOfHalfday(), DateTimeFieldType.hourOfHalfday());        assertEquals("hourOfHalfday", DateTimeFieldType.hourOfHalfday().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.hourOfHalfday().getDurationType());        assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.hourOfHalfday().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().hourOfHalfday(), DateTimeFieldType.hourOfHalfday().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().hourOfHalfday().isSupported(), DateTimeFieldType.hourOfHalfday().isSupported(Chronology.getCopticUTC()));    }    public void test_hourOfDay() {        assertEquals(DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfDay());        assertEquals("hourOfDay", DateTimeFieldType.hourOfDay().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.hourOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.hourOfDay().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().hourOfDay(), DateTimeFieldType.hourOfDay().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().hourOfDay().isSupported(), DateTimeFieldType.hourOfDay().isSupported(Chronology.getCopticUTC()));    }    public void test_minuteOfDay() {        assertEquals(DateTimeFieldType.minuteOfDay(), DateTimeFieldType.minuteOfDay());        assertEquals("minuteOfDay", DateTimeFieldType.minuteOfDay().getName());        assertEquals(DurationFieldType.minutes(), DateTimeFieldType.minuteOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.minuteOfDay().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().minuteOfDay(), DateTimeFieldType.minuteOfDay().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().minuteOfDay().isSupported(), DateTimeFieldType.minuteOfDay().isSupported(Chronology.getCopticUTC()));    }    public void test_minuteOfHour() {        assertEquals(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.minuteOfHour());        assertEquals("minuteOfHour", DateTimeFieldType.minuteOfHour().getName());        assertEquals(DurationFieldType.minutes(), DateTimeFieldType.minuteOfHour().getDurationType());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.minuteOfHour().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().minuteOfHour(), DateTimeFieldType.minuteOfHour().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().minuteOfHour().isSupported(), DateTimeFieldType.minuteOfHour().isSupported(Chronology.getCopticUTC()));    }    public void test_secondOfDay() {        assertEquals(DateTimeFieldType.secondOfDay(), DateTimeFieldType.secondOfDay());        assertEquals("secondOfDay", DateTimeFieldType.secondOfDay().getName());        assertEquals(DurationFieldType.seconds(), DateTimeFieldType.secondOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.secondOfDay().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().secondOfDay(), DateTimeFieldType.secondOfDay().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().secondOfDay().isSupported(), DateTimeFieldType.secondOfDay().isSupported(Chronology.getCopticUTC()));    }    public void test_secondOfMinute() {        assertEquals(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.secondOfMinute());        assertEquals("secondOfMinute", DateTimeFieldType.secondOfMinute().getName());        assertEquals(DurationFieldType.seconds(), DateTimeFieldType.secondOfMinute().getDurationType());        assertEquals(DurationFieldType.minutes(), DateTimeFieldType.secondOfMinute().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().secondOfMinute(), DateTimeFieldType.secondOfMinute().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().secondOfMinute().isSupported(), DateTimeFieldType.secondOfMinute().isSupported(Chronology.getCopticUTC()));    }    public void test_millisOfDay() {        assertEquals(DateTimeFieldType.millisOfDay(), DateTimeFieldType.millisOfDay());        assertEquals("millisOfDay", DateTimeFieldType.millisOfDay().getName());        assertEquals(DurationFieldType.millis(), DateTimeFieldType.millisOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.millisOfDay().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().millisOfDay(), DateTimeFieldType.millisOfDay().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().millisOfDay().isSupported(), DateTimeFieldType.millisOfDay().isSupported(Chronology.getCopticUTC()));    }    public void test_millisOfSecond() {        assertEquals(DateTimeFieldType.millisOfSecond(), DateTimeFieldType.millisOfSecond());        assertEquals("millisOfSecond", DateTimeFieldType.millisOfSecond().getName());        assertEquals(DurationFieldType.millis(), DateTimeFieldType.millisOfSecond().getDurationType());        assertEquals(DurationFieldType.seconds(), DateTimeFieldType.millisOfSecond().getRangeDurationType());        assertEquals(Chronology.getCopticUTC().millisOfSecond(), DateTimeFieldType.millisOfSecond().getField(Chronology.getCopticUTC()));        assertEquals(Chronology.getCopticUTC().millisOfSecond().isSupported(), DateTimeFieldType.millisOfSecond().isSupported(Chronology.getCopticUTC()));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Properties.class);    }    public TestMutableDateTime_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getReadableInstant());        assertSame(test, test.era().getMutableDateTime());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getReadableInstant());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getReadableInstant());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getReadableInstant());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getReadableInstant());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadableInstant());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyAddYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().add(9);        assertEquals("2013-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().addWrapField(9);        assertEquals("2013-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertySetYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().set(1960);        assertEquals("1960-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().set("1960");        assertEquals("1960-06-09T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadableInstant());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new MutableDateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyAddMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().add(6);        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    public void testPropertyAddWrapFieldMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().addWrapField(8);        assertEquals("2004-02-09T00:00:00.000Z", test.toString());    }    public void testPropertySetMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set(12);        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    public void testPropertySetTextMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("12");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("December");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("Dec");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadableInstant());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    public void testPropertyAddDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().add(9);        assertEquals("2004-06-18T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().addWrapField(22);        assertEquals("2004-06-01T00:00:00.000+01:00", test.toString());    }    public void testPropertySetDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().set(12);        assertEquals("2004-06-12T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().set("12");        assertEquals("2004-06-12T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getReadableInstant());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    public void testPropertyAddDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().add(9);        assertEquals("2004-06-18T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().addWrapField(206);        assertEquals("2004-01-01T00:00:00.000Z", test.toString());    }    public void testPropertySetDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().set(12);        assertEquals("2004-01-12T00:00:00.000Z", test.toString());    }    public void testPropertySetTextDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().set("12");        assertEquals("2004-01-12T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        // 2002-01-01 = Thu        // 2002-12-31 = Thu (+364 days)        // 2003-12-30 = Thu (+364 days)        // 2004-01-03 = Mon             W1        // 2004-01-31 = Mon (+28 days)  W5        // 2004-02-28 = Mon (+28 days)  W9        // 2004-03-27 = Mon (+28 days)  W13        // 2004-04-24 = Mon (+28 days)  W17        // 2004-05-23 = Mon (+28 days)  W21        // 2004-06-05 = Mon (+14 days)  W23        // 2004-06-09 = Fri        // 2004-12-25 = Mon             W52        // 2005-01-01 = Mon             W1        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getReadableInstant());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    public void testPropertyAddWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().add(1);        assertEquals("2004-06-14T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().addWrapField(30);        assertEquals("2003-12-29T00:00:00.000Z", test.toString());    }    public void testPropertySetWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().set(4);        assertEquals("2004-01-19T00:00:00.000Z", test.toString());    }    public void testPropertySetTextWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().set("4");        assertEquals("2004-01-19T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getReadableInstant());        assertEquals(3, test.dayOfWeek().get());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }    public void testPropertyAddDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().add(1);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddLongDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().add(1L);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);  // Wed        test.dayOfWeek().addWrapField(5);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());    }    public void testPropertySetDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set(4);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("4");        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("Mon");        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("Tuesday");        assertEquals("2004-06-08T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("lundi", Locale.FRENCH);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getReadableInstant());        assertEquals(13, test.hourOfDay().get());        assertEquals("13", test.hourOfDay().getAsText());        assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("13", test.hourOfDay().getAsShortText());        assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyRoundFloorHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundCeilingHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfFloorHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfCeilingHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfEvenHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 14, 30, 0, 0);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRemainderHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfHour() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getReadableInstant());        assertEquals(23, test.minuteOfHour().get());        assertEquals("23", test.minuteOfHour().getAsText());        assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("23", test.minuteOfHour().getAsShortText());        assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());        assertEquals("minuteOfDay", test.minuteOfDay().getName());        assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString());        assertSame(test, test.minuteOfDay().getReadableInstant());        assertEquals(803, test.minuteOfDay().get());        assertEquals("803", test.minuteOfDay().getAsText());        assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH));        assertEquals("803", test.minuteOfDay().getAsShortText());        assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());        assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));        assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfMinute() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getReadableInstant());        assertEquals(43, test.secondOfMinute().get());        assertEquals("43", test.secondOfMinute().getAsText());        assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("43", test.secondOfMinute().getAsShortText());        assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());        assertEquals("secondOfDay", test.secondOfDay().getName());        assertEquals("Property[secondOfDay]", test.secondOfDay().toString());        assertSame(test, test.secondOfDay().getReadableInstant());        assertEquals(48223, test.secondOfDay().get());        assertEquals("48223", test.secondOfDay().getAsText());        assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH));        assertEquals("48223", test.secondOfDay().getAsShortText());        assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());        assertEquals(5, test.secondOfDay().getMaximumTextLength(null));        assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfSecond() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getReadableInstant());        assertEquals(53, test.millisOfSecond().get());        assertEquals("53", test.millisOfSecond().getAsText());        assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("53", test.millisOfSecond().getAsShortText());        assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());        assertEquals("millisOfDay", test.millisOfDay().getName());        assertEquals("Property[millisOfDay]", test.millisOfDay().toString());        assertSame(test, test.millisOfDay().getReadableInstant());        assertEquals(48223053, test.millisOfDay().get());        assertEquals("48223053", test.millisOfDay().getAsText());        assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH));        assertEquals("48223053", test.millisOfDay().getAsShortText());        assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());        assertEquals(8, test.millisOfDay().getMaximumTextLength(null));        assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestMutableInterval_Updates extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Updates.class);    }    public TestMutableInterval_Updates(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testSetInterval_long_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(TEST_TIME1 - 1, TEST_TIME2 + 1);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_long_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(TEST_TIME1 - 1, TEST_TIME1 - 2);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetInterval_RI_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RI_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME1 - 2));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetInterval_RI_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(null, new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RI_RI4() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Instant(TEST_TIME1 - 1), null);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testSetInterval_RI_RI5() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(null, null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetInterval_RInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RInterval2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(new MockBadInterval());            fail();        } catch (IllegalArgumentException ex) {}    }        class MockBadInterval extends AbstractInterval {        public Chronology getChronology() {            return Chronology.getISO();        }        public long getStartMillis() {            return TEST_TIME1 - 1;        }        public long getEndMillis() {            return TEST_TIME1 - 2;        }    }    public void testSetInterval_RInterval3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testSetStartMillis_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStartMillis(TEST_TIME1 - 1);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSetStartMillis_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setStartMillis(TEST_TIME2 + 1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStart(new Instant(TEST_TIME1 - 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSetStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setStart(new Instant(TEST_TIME2 + 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStart(null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetEndMillis_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEndMillis(TEST_TIME2 + 1);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetEndMillis_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setEndMillis(TEST_TIME1 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEnd(new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setEnd(new Instant(TEST_TIME1 - 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEnd(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetDurationAfterStart_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(123L);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSeDurationAfterStart_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationAfterStart(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetDurationAfterStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(new Duration(123L));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSeDurationAfterStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationAfterStart(new Duration(-1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetDurationAfterStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetDurationBeforeEnd_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(123L);        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSeDurationBeforeEnd_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationBeforeEnd(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetDurationBeforeEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(new Duration(123L));        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSeDurationBeforeEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationBeforeEnd(new Duration(-1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetDurationBeforeEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(null);        assertEquals(TEST_TIME2, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriodAfterStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodAfterStart(new Period(123L));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSePeriodAfterStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setPeriodAfterStart(new Period(-1L));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetPeriodAfterStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodAfterStart(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriodBeforeEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodBeforeEnd(new Period(123L));        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSePeriodBeforeEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setPeriodBeforeEnd(new Period(-1L));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetPeriodBeforeEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodBeforeEnd(null);        assertEquals(TEST_TIME2, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */public class TestDateMidnight_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW_UTC =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private long TEST_TIME_NOW_LONDON =            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME_NOW_PARIS =            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;        // 2002-04-05    private long TEST_TIME1_UTC =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME1_LONDON =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME1_PARIS =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - 2*DateTimeConstants.MILLIS_PER_HOUR;        // 2003-05-06    private long TEST_TIME2_UTC =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME2_LONDON =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME2_PARIS =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - 2*DateTimeConstants.MILLIS_PER_HOUR;        private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Constructors.class);    }    public TestDateMidnight_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        DateMidnight test = new DateMidnight();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2_LONDON, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1_PARIS, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2_PARIS, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new DateMidnight(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        DateMidnight test = new DateMidnight((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1_PARIS, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new DateMidnight(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new DateMidnight(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31);            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31);        try {            new DateMidnight(2002, 7, 32);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31, PARIS);        try {            new DateMidnight(2002, 7, 32, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31, GregorianChronology.getInstance());        try {            new DateMidnight(2002, 7, 32, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestChronology.suite());        suite.addTest(TestDateTimeFieldType.suite());                suite.addTest(TestInstant_Constructors.suite());        suite.addTest(TestInstant_Basics.suite());                suite.addTest(TestDateTime_Constructors.suite());        suite.addTest(TestDateTime_Basics.suite());        suite.addTest(TestDateTime_Properties.suite());                suite.addTest(TestMutableDateTime_Constructors.suite());        suite.addTest(TestMutableDateTime_Basics.suite());        suite.addTest(TestMutableDateTime_Sets.suite());        suite.addTest(TestMutableDateTime_Adds.suite());        suite.addTest(TestMutableDateTime_Properties.suite());                suite.addTest(TestDateMidnight_Constructors.suite());        suite.addTest(TestDateMidnight_Basics.suite());        suite.addTest(TestDateMidnight_Properties.suite());                suite.addTest(TestDuration_Constructors.suite());        suite.addTest(TestDuration_Basics.suite());                suite.addTest(TestInterval_Constructors.suite());        suite.addTest(TestInterval_Basics.suite());                suite.addTest(TestMutableInterval_Constructors.suite());        suite.addTest(TestMutableInterval_Basics.suite());        suite.addTest(TestMutableInterval_Updates.suite());                suite.addTest(TestPeriod_Constructors.suite());        suite.addTest(TestPeriod_Basics.suite());                suite.addTest(TestMutablePeriod_Constructors.suite());        suite.addTest(TestMutablePeriod_Basics.suite());        suite.addTest(TestMutablePeriod_Updates.suite());                suite.addTest(TestAbstractPartial.suite());        suite.addTest(TestBasePartial.suite());        suite.addTest(TestTimeOfDay.suite());        suite.addTest(TestYearMonthDay.suite());                suite.addTest(TestDateTimeComparator.suite());        suite.addTest(TestDateTimeConstants.suite());        suite.addTest(TestDateTimeUtils.suite());        suite.addTest(TestDateTimeZone.suite());        suite.addTest(TestPeriodType.suite());//        suite.addTest(TestParseISO.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Updates extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Updates.class);    }    public TestMutablePeriod_Updates(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testAddYears() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(10);        assertEquals(11, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(-10);        assertEquals(-9, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(0);        assertEquals(1, test.getYears());    }    //-----------------------------------------------------------------------    public void testAddMonths() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(10);        assertEquals(12, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(-10);        assertEquals(-8, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(0);        assertEquals(2, test.getMonths());    }    //-----------------------------------------------------------------------    public void testAddWeeks() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(10);        assertEquals(13, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(-10);        assertEquals(-7, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(0);        assertEquals(3, test.getWeeks());    }    //-----------------------------------------------------------------------    public void testAddDays() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(10);        assertEquals(14, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(-10);        assertEquals(-6, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(0);        assertEquals(4, test.getDays());    }    //-----------------------------------------------------------------------    public void testAddHours() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(10);        assertEquals(15, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(-10);        assertEquals(-5, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(0);        assertEquals(5, test.getHours());    }    //-----------------------------------------------------------------------    public void testAddMinutes() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(10);        assertEquals(16, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(-10);        assertEquals(-4, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(0);        assertEquals(6, test.getMinutes());    }    //-----------------------------------------------------------------------    public void testAddSeconds() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(10);        assertEquals(17, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(-10);        assertEquals(-3, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(0);        assertEquals(7, test.getSeconds());    }    //-----------------------------------------------------------------------    public void testAddMillis() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(10);        assertEquals(18, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(-10);        assertEquals(-2, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(0);        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetYears() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(10);        assertEquals(10, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(-10);        assertEquals(-10, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(0);        assertEquals(0, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(1);        assertEquals(1, test.getYears());                test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis());        try {            test.setYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetMonths() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(10);        assertEquals(10, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(-10);        assertEquals(-10, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(0);        assertEquals(0, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(2);        assertEquals(2, test.getMonths());    }    //-----------------------------------------------------------------------    public void testSetWeeks() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(10);        assertEquals(10, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(-10);        assertEquals(-10, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(0);        assertEquals(0, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(3);        assertEquals(3, test.getWeeks());    }    //-----------------------------------------------------------------------    public void testSetDays() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(10);        assertEquals(10, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(-10);        assertEquals(-10, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(0);        assertEquals(0, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(4);        assertEquals(4, test.getDays());    }    //-----------------------------------------------------------------------    public void testSetHours() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(10);        assertEquals(10, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(-10);        assertEquals(-10, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(0);        assertEquals(0, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(5);        assertEquals(5, test.getHours());    }    //-----------------------------------------------------------------------    public void testSetMinutes() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(10);        assertEquals(10, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(-10);        assertEquals(-10, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(0);        assertEquals(0, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(6);        assertEquals(6, test.getMinutes());    }    //-----------------------------------------------------------------------    public void testSetSeconds() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(10);        assertEquals(10, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(-10);        assertEquals(-10, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(0);        assertEquals(0, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(7);        assertEquals(7, test.getSeconds());    }    //-----------------------------------------------------------------------    public void testSetMillis() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(10);        assertEquals(10, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(-10);        assertEquals(-10, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(0);        assertEquals(0, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(8);        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_8ints1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_8ints2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        try {            test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_8ints3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        test.setPeriod(0, 0, 0, 0, 0, 0, 0, 18);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_8ints4() {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RP1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        try {            test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_RP3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        test.setPeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP4() {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadablePeriod) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_long_long1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt2.getMillis(), dt1.getMillis());        assertEquals(-1, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(-1, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testSetPeriod_long_long3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        test.setPeriod(dt1.getMillis(), dt1.getMillis());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testSetPeriod_long_long_NoYears() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withYearsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(0, test.getYears());        assertEquals(13, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoMonths() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMonthsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(5, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoWeeks() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withWeeksRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(8, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoDays() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withDaysRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(25, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoHours() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withHoursRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(61, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoMinutes() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMinutesRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(61, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoSeconds() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withSecondsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(1001, test.getMillis());    }    public void testSetPeriod_long_long_NoMillis() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMillisRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RInterval1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(new Interval(dt1, dt2));        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_RInterval2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadableInterval) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_long1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(100L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_long2() {        MutablePeriod test = new MutablePeriod();        test.setPeriod(            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }//    public void testSetPeriod_long3() {//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType());//        test.setPeriod(//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//    }////    public void testSetPeriod_long4() {//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType());//        test.setPeriod(//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);//        assertEquals(1, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(12, test.getWeeks());//        assertEquals(1, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//    }////    public void testSetPeriod_long_NoYears() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());//        test.setPeriod(ms);//        assertEquals(0, test.getYears());//        assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30//        assertEquals(0, test.getWeeks());//        assertEquals(0, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoMonths() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(85, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoWeeks() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(85, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoDays() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(0, test.getDays());//        assertEquals(5 + 25 * 24, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoHours() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(0, test.getHours());//        assertEquals(6 + 5 * 60, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoMinutes() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(0, test.getMinutes());//        assertEquals(7 + 6 * 60, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoSeconds() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(0, test.getSeconds());//        assertEquals(8 + 7 * 1000, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoMillis() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(0, test.getMillis());//        assertEquals(ms - 8, test.toDurationMillis());//    }    //-----------------------------------------------------------------------    public void testSetPeriod_RD1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(new Duration(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_RD2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.setPeriod(new Duration(length));        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testSetPeriod_RD3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadableDuration) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_8ints1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_8ints2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        try {            test.add(1, 2, 3, 4, 5, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_long1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(100L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_long2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(ms);        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }//    public void testAdd_long3() {//        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        test.add(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(108, test.getMillis());//    }////    public void testAdd_long4() {//        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());//        long ms =0L;//        test.add(ms);//        assertEquals(0, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(0, test.getDays());//        assertEquals(0, test.getHours());//        assertEquals(0, test.getMinutes());//        assertEquals(0, test.getSeconds());//        assertEquals(100, test.getMillis());//    }    public void testAdd_long5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add(2100L);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(9, test.getSeconds());        assertEquals(108, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RD1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Duration(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_RD2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        long ms =            (4L + (3L * 7L)) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(new Duration(ms));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 + (3 * 7)) * 24 + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }//    public void testAdd_RD3() {//        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());//        long ms =0L;//        test.add(new Duration(ms));//        assertEquals(0, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(0, test.getDays());//        assertEquals(0, test.getHours());//        assertEquals(0, test.getMinutes());//        assertEquals(0, test.getSeconds());//        assertEquals(100, test.getMillis());//        assertEquals(100L, test.toDurationMillis());//    }////    public void testAdd_RD4() {//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        test.add(new Duration(2100L));//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(3, test.getWeeks());//        assertEquals(4, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(9, test.getSeconds());//        assertEquals(108, test.getMillis());//    }////    public void testAdd_RD5() {//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        test.add((ReadableDuration) null);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(3, test.getWeeks());//        assertEquals(4, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//    }    //-----------------------------------------------------------------------    public void testAdd_RP1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Period(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_RP2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());  // All type        test.add(new Period(1, 2, 3, 4, 5, 6, 7, 0, PeriodType.standard().withMillisRemoved()));        // add field value, ignore different types        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testAdd_RP3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());        test.add(new Period(0L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testAdd_RP4() {        MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime());        try {            test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testAdd_RP5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadablePeriod) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RInterval1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Interval(100L, 200L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_RInterval2() {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 12, 18, 0, 0, 0, 8);        MutablePeriod test = new MutablePeriod(100L);  // All type        test.add(new Interval(dt1, dt2));        assertEquals(1, test.getYears());  // add field value from interval        assertEquals(6, test.getMonths());  // add field value from interval        assertEquals(1, test.getWeeks());  // add field value from interval        assertEquals(2, test.getDays());  // add field value from interval        assertEquals(0, test.getHours());  // time zone OK        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RInterval3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        test.add(new Interval(0L, 0L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testAdd_RInterval4() {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8);        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        test.add(new Interval(dt1, dt2));        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());  // no weeks        assertEquals(8, test.getDays());  // week added to days        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RInterval5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadableInterval) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */public class TestDuration_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDuration_Constructors.class);    }    public TestDuration_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testZERO() throws Throwable {        Duration test = Duration.ZERO;        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Duration test = new Duration(length);        assertEquals(length, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration test = new Duration(dt1.getMillis(), dt2.getMillis());        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration test = new Duration(dt1, dt2);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Duration test = new Duration(dt1, dt2);        assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Duration test = new Duration(dt1, dt2);        assertEquals(TEST_TIME_NOW - dt1.getMillis(), test.getMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Duration test = new Duration(dt1, dt2);        assertEquals(0L, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        Duration test = new Duration("PT72.345S");        assertEquals(72345, test.getMillis());    }    public void testConstructor_Object2() throws Throwable {        Duration test = new Duration((Object) null);        assertEquals(0L, test.getMillis());    }    public void testConstructor_Object3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Long base = new Long(length);        Duration test = new Duration(base);        assertEquals(length, test.getMillis());    }    public void testConstructor_Object4() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration base = new Duration(dt1, dt2);        Duration test = new Duration(base);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    public void testConstructor_Object5() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);        Duration test = new Duration(base);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */public class TestDateMidnight_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");    private static final DateTimeZone NEWYORK = DateTimeZone.getInstance("America/New_York");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW_UTC =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private long TEST_TIME_NOW_LONDON =            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME_NOW_PARIS =            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;                // 2002-04-05    private long TEST_TIME1_UTC =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME1_LONDON =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME1_PARIS =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - 2*DateTimeConstants.MILLIS_PER_HOUR;            // 2003-05-06    private long TEST_TIME2_UTC =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME2_LONDON =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME2_PARIS =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - 2*DateTimeConstants.MILLIS_PER_HOUR;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Basics.class);    }    public TestDateMidnight_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString());    }    //-----------------------------------------------------------------------    public void testGet_DateTimeField() {        DateMidnight test = new DateMidnight();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(24, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(12, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(0, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get((DateTimeField) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGet_DateTimeFieldType() {        DateMidnight test = new DateMidnight();        assertEquals(1, test.get(DateTimeFieldType.era()));        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));        assertEquals(2002, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));        assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay()));        assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));        assertEquals(0, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfDay()));        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(0, test.get(DateTimeFieldType.secondOfDay()));        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));        assertEquals(0, test.get(DateTimeFieldType.millisOfDay()));        try {            test.get((DateTimeFieldType) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        DateMidnight test = new DateMidnight();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(0, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(0, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(0, test.getMillisOfDay());    }    public void testEqualsHashCode() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test2 = new DateMidnight(TEST_TIME1_UTC);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1_LONDON;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    public void testCompareTo() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(-1, test3.compareTo(test2));  // midnight paris before london                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        public void testIsEqual() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(false, test3.isEqual(test2));  // midnight paris before london                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isEqual(null));        assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isEqual(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isEqual(null));                assertEquals(false, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 8, 23, 59, 59, 999)));        assertEquals(true, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 9, 0, 0, 0, 0)));        assertEquals(false, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 9, 0, 0, 0, 1)));    }        public void testIsBefore() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(true, test3.isBefore(test2));  // midnight paris before london                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isBefore(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isBefore(null));        assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isBefore(null));                assertEquals(false, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 8, 23, 59, 59, 999)));        assertEquals(false, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 9, 0, 0, 0, 0)));        assertEquals(true, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 9, 0, 0, 0, 1)));    }        public void testIsAfter() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));  // midnight paris before london                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isAfter(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isAfter(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isAfter(null));                assertEquals(true, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 8, 23, 59, 59, 999)));        assertEquals(false, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 9, 0, 0, 0, 0)));        assertEquals(false, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 9, 0, 0, 0, 1)));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateMidnight result = (DateMidnight) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString());                test = new DateMidnight(TEST_TIME_NOW_UTC, PARIS);        assertEquals("2002-06-09T00:00:00.000+02:00", test.toString());                test = new DateMidnight(TEST_TIME_NOW_UTC, NEWYORK);        assertEquals("2002-06-08T00:00:00.000-04:00", test.toString());  // the 8th    }    public void testToString_String() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("2002 00", test.toString("yyyy HH"));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null));    }    public void testToString_String_String() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Instant result = test.toInstant();        assertEquals(TEST_TIME1_LONDON, result.getMillis());    }    public void testToDateMidnight() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());    }    public void testToDateTimeISO() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(PARIS, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());    }    public void testToDateTime_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withMillis(TEST_TIME2_UTC);        assertEquals(TEST_TIME2_LONDON, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withMillis(TEST_TIME2_UTC);        assertEquals(TEST_TIME2_PARIS, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withMillis(TEST_TIME1_UTC);        assertSame(test, result);    }    public void testWithChronology_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withChronology(GregorianChronology.getInstance(PARIS));        assertEquals(TEST_TIME1_LONDON, test.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withChronology(null);        assertEquals(TEST_TIME1_PARIS, test.getMillis());        // midnight Paris is previous day in London        assertEquals(TEST_TIME1_LONDON - DateTimeConstants.MILLIS_PER_DAY, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withChronology(ISOChronology.getInstance());        assertSame(test, result);    }    public void testWithZoneRetainFields_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withZoneRetainFields(PARIS);        assertEquals(TEST_TIME1_LONDON, test.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withZoneRetainFields(null);        assertEquals(TEST_TIME1_PARIS, test.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withZoneRetainFields(null);        assertSame(test, result);                test = new DateMidnight(TEST_TIME1_UTC, new MockNullZoneChronology());        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import org.joda.time.base.AbstractDateTime;import org.joda.time.base.AbstractInstant;/** * This class displays what the ClassLoader is up to. * Run using JVM -verbose:class. * * @author Stephen Colebourne */public class ClassLoadTest {    // run using JVM -verbose:class    public static void main(String[] args) {        System.out.println("-----------------------------------------------");        System.out.println("-----------AbstractInstant---------------------");        Class cls = AbstractInstant.class;        System.out.println("-----------ReadableDateTime--------------------");        cls = ReadableDateTime.class;        System.out.println("-----------AbstractDateTime--------------------");        cls = AbstractDateTime.class;        System.out.println("-----------DateTime----------------------------");        cls = DateTime.class;        System.out.println("-----------DateTimeZone------------------------");        cls = DateTimeZone.class;        System.out.println("-----------new DateTime()----------------------");        DateTime dt = new DateTime();        System.out.println("-----------new DateTime(ReadableInstant)-------");        dt = new DateTime(dt);        System.out.println("-----------new DateTime(Long)------------------");        dt = new DateTime(new Long(0));        System.out.println("-----------------------------------------------");    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */public class TestTimeOfDay extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestTimeOfDay.class);    }    public TestTimeOfDay(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        TimeOfDay test = new TimeOfDay();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        TimeOfDay test = new TimeOfDay(null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            TimeOfDay test = new TimeOfDay(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0, test.getHourOfDay());            assertEquals(0, test.getMinuteOfHour());            assertEquals(0, test.getSecondOfMinute());            assertEquals(0, test.getMillisOfSecond());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Object) null, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            TimeOfDay test = new TimeOfDay(new Integer(0), JulianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0, test.getHourOfDay());            assertEquals(0, test.getMinuteOfHour());            assertEquals(0, test.getSecondOfMinute());            assertEquals(0, test.getMillisOfSecond());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int)     */    public void testConstructor_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());    }    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());    }    /**     * Test constructor (int, int, int, int)     */    public void testConstructor_int_int_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, 1000);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testGet() {        TimeOfDay test = new TimeOfDay();        assertEquals(10, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(30, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(40, test.get(DateTimeFieldType.millisOfSecond()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(DateTimeFieldType.dayOfMonth());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSize() {        TimeOfDay test = new TimeOfDay();        assertEquals(4, test.size());    }    public void testGetFieldType() {        TimeOfDay test = new TimeOfDay();        assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0));        assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1));        assertSame(DateTimeFieldType.secondOfMinute(), test.getFieldType(2));        assertSame(DateTimeFieldType.millisOfSecond(), test.getFieldType(3));        try {            test.getFieldType(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getFieldType(5);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldTypes() {        TimeOfDay test = new TimeOfDay();        DateTimeFieldType[] fields = test.getFieldTypes();        assertSame(DateTimeFieldType.hourOfDay(), fields[0]);        assertSame(DateTimeFieldType.minuteOfHour(), fields[1]);        assertSame(DateTimeFieldType.secondOfMinute(), fields[2]);        assertSame(DateTimeFieldType.millisOfSecond(), fields[3]);        assertNotSame(test.getFieldTypes(), test.getFieldTypes());    }    public void testGetField() {        TimeOfDay test = new TimeOfDay();        assertSame(ISOChronology.getInstance().hourOfDay(), test.getField(0));        assertSame(ISOChronology.getInstance().minuteOfHour(), test.getField(1));        assertSame(ISOChronology.getInstance().secondOfMinute(), test.getField(2));        assertSame(ISOChronology.getInstance().millisOfSecond(), test.getField(3));        try {            test.getField(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getField(5);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFields() {        TimeOfDay test = new TimeOfDay();        DateTimeField[] fields = test.getFields();        assertSame(ISOChronology.getInstance().hourOfDay(), fields[0]);        assertSame(ISOChronology.getInstance().minuteOfHour(), fields[1]);        assertSame(ISOChronology.getInstance().secondOfMinute(), fields[2]);        assertSame(ISOChronology.getInstance().millisOfSecond(), fields[3]);        assertNotSame(test.getFields(), test.getFields());    }    public void testGetValue() {        TimeOfDay test = new TimeOfDay();        assertEquals(10, test.getValue(0));        assertEquals(20, test.getValue(1));        assertEquals(30, test.getValue(2));        assertEquals(40, test.getValue(3));        try {            test.getValue(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getValue(5);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetValues() {        TimeOfDay test = new TimeOfDay();        int[] values = test.getValues();        assertEquals(10, values[0]);        assertEquals(20, values[1]);        assertEquals(30, values[2]);        assertEquals(40, values[3]);        assertNotSame(test.getValues(), test.getValues());    }    public void testIsSupported() {        TimeOfDay test = new TimeOfDay();        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute()));        assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond()));        assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));    }    public void testEqualsHashCode() {        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                TimeOfDay test3 = new TimeOfDay(11, 20, 30, 40);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));    }        class MockInstant extends MockPartial {        public DateTimeField[] getFields() {            return new DateTimeField[] {                ISOChronology.getInstance().hourOfDay(),                ISOChronology.getInstance().minuteOfHour(),                ISOChronology.getInstance().secondOfMinute(),                ISOChronology.getInstance().millisOfSecond(),            };        }        public int[] getValues() {            return new int[] {10, 20, 30, 40};        }    }    //-----------------------------------------------------------------------    public void testResolveDateTime_RI() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        DateTime dt = new DateTime(0L);        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());                DateTime result = test.toDateTimeUsing(dt);        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        assertEquals("1970-01-01T00:00:00.000Z", dt.toString());        assertEquals("1970-01-01T10:20:30.040Z", result.toString());    }    public void testResolveDateTime_nullRI() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4);        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);                DateTime result = test.toDateTimeUsing(null);        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());        assertEquals("1970-01-02T01:02:03.004Z", result.toString());    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        TimeOfDay result = (TimeOfDay) ois.readObject();        ois.close();                assertEquals(test, result);        assertTrue(Arrays.equals(test.getValues(), result.getValues()));        assertTrue(Arrays.equals(test.getFields(), result.getFields()));        assertEquals(test.getChronology(), result.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals("T10:20:30.040", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getReadablePartial());        assertSame(test, test.hourOfDay().getTimeOfDay());        assertEquals(10, test.hourOfDay().get());        assertEquals("10", test.hourOfDay().getAsText());        assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("10", test.hourOfDay().getAsShortText());        assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.hourOfDay().getMinimumValue());        assertEquals(0, test.hourOfDay().getMinimumValueOverall());        assertEquals(23, test.hourOfDay().getMaximumValue());        assertEquals(23, test.hourOfDay().getMaximumValueOverall());    }    public void testPropertyAddHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.hourOfDay().addToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.hourOfDay().addToCopy(13);        check(copy, 23, 20, 30, 40);                try {            test.hourOfDay().addToCopy(14);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.hourOfDay().addToCopy(-10);        check(copy, 0, 20, 30, 40);                try {            test.hourOfDay().addToCopy(-11);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(18);        check(copy, 4, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(-15);        check(copy, 19, 20, 30, 40);    }    public void testPropertySetHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);                try {            test.hourOfDay().setCopy(24);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.hourOfDay().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);    }    public void testPropertyCompareToHour() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.hourOfDay().compareTo(test2) < 0);        assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);        assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);        try {            test1.hourOfDay().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0);        assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0);        assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0);        try {            test1.hourOfDay().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getReadablePartial());        assertSame(test, test.minuteOfHour().getTimeOfDay());        assertEquals(20, test.minuteOfHour().get());        assertEquals("20", test.minuteOfHour().getAsText());        assertEquals("20", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("20", test.minuteOfHour().getAsShortText());        assertEquals("20", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.minuteOfHour().getMinimumValue());        assertEquals(0, test.minuteOfHour().getMinimumValueOverall());        assertEquals(59, test.minuteOfHour().getMaximumValue());        assertEquals(59, test.minuteOfHour().getMaximumValueOverall());    }    public void testPropertyAddMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.minuteOfHour().addToCopy(39);        check(copy, 10, 59, 30, 40);                copy = test.minuteOfHour().addToCopy(40);        check(copy, 11, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(1 * 60 + 45);        check(copy, 12, 5, 30, 40);                copy = test.minuteOfHour().addToCopy(13 * 60 + 39);        check(copy, 23, 59, 30, 40);                try {            test.minuteOfHour().addToCopy(13 * 60 + 40);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.minuteOfHour().addToCopy(-9);        check(copy, 10, 11, 30, 40);                copy = test.minuteOfHour().addToCopy(-19);        check(copy, 10, 1, 30, 40);                copy = test.minuteOfHour().addToCopy(-20);        check(copy, 10, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(-21);        check(copy, 9, 59, 30, 40);                copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20));        check(copy, 0, 0, 30, 40);                try {            test.minuteOfHour().addToCopy(-(10 * 60 + 21));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.minuteOfHour().addWrapFieldToCopy(49);        check(copy, 10, 9, 30, 40);                copy = test.minuteOfHour().addWrapFieldToCopy(-47);        check(copy, 10, 33, 30, 40);    }    public void testPropertySetMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);                try {            test.minuteOfHour().setCopy(60);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.minuteOfHour().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);    }    public void testPropertyCompareToMinute() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0);        assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);        assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);        try {            test1.minuteOfHour().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0);        assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0);        assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0);        try {            test1.minuteOfHour().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getReadablePartial());        assertSame(test, test.secondOfMinute().getTimeOfDay());        assertEquals(30, test.secondOfMinute().get());        assertEquals("30", test.secondOfMinute().getAsText());        assertEquals("30", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("30", test.secondOfMinute().getAsShortText());        assertEquals("30", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.secondOfMinute().getMinimumValue());        assertEquals(0, test.secondOfMinute().getMinimumValueOverall());        assertEquals(59, test.secondOfMinute().getMaximumValue());        assertEquals(59, test.secondOfMinute().getMaximumValueOverall());    }    public void testPropertyAddSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 39, 40);                copy = test.secondOfMinute().addToCopy(29);        check(copy, 10, 20, 59, 40);                copy = test.secondOfMinute().addToCopy(30);        check(copy, 10, 21, 0, 40);                copy = test.secondOfMinute().addToCopy(39 * 60 + 29);        check(copy, 10, 59, 59, 40);                copy = test.secondOfMinute().addToCopy(39 * 60 + 30);        check(copy, 11, 0, 0, 40);                try {            test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.secondOfMinute().addToCopy(-9);        check(copy, 10, 20, 21, 40);                copy = test.secondOfMinute().addToCopy(-30);        check(copy, 10, 20, 0, 40);                copy = test.secondOfMinute().addToCopy(-31);        check(copy, 10, 19, 59, 40);                copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30));        check(copy, 0, 0, 0, 40);                try {            test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 39, 40);                copy = test.secondOfMinute().addWrapFieldToCopy(49);        check(copy, 10, 20, 19, 40);                copy = test.secondOfMinute().addWrapFieldToCopy(-47);        check(copy, 10, 20, 43, 40);    }    public void testPropertySetSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 12, 40);                try {            test.secondOfMinute().setCopy(60);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.secondOfMinute().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 12, 40);    }    public void testPropertyCompareToSecond() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0);        assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);        assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);        try {            test1.secondOfMinute().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0);        assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0);        assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0);        try {            test1.secondOfMinute().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getReadablePartial());        assertSame(test, test.millisOfSecond().getTimeOfDay());        assertEquals(40, test.millisOfSecond().get());        assertEquals("40", test.millisOfSecond().getAsText());        assertEquals("40", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("40", test.millisOfSecond().getAsShortText());        assertEquals("40", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.millisOfSecond().getMinimumValue());        assertEquals(0, test.millisOfSecond().getMinimumValueOverall());        assertEquals(999, test.millisOfSecond().getMaximumValue());        assertEquals(999, test.millisOfSecond().getMaximumValueOverall());    }    public void testPropertyAddMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 49);                copy = test.millisOfSecond().addToCopy(959);        check(copy, 10, 20, 30, 999);                copy = test.millisOfSecond().addToCopy(960);        check(copy, 10, 20, 31, 0);                copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);        check(copy, 23, 59, 59, 999);                try {            test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.millisOfSecond().addToCopy(-9);        check(copy, 10, 20, 30, 31);                copy = test.millisOfSecond().addToCopy(-40);        check(copy, 10, 20, 30, 0);                copy = test.millisOfSecond().addToCopy(-41);        check(copy, 10, 20, 29, 999);                copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));        check(copy, 0, 0, 0, 0);                try {            test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 49);                copy = test.millisOfSecond().addWrapFieldToCopy(995);        check(copy, 10, 20, 30, 35);                copy = test.millisOfSecond().addWrapFieldToCopy(-47);        check(copy, 10, 20, 30, 993);    }    public void testPropertySetMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 12);                try {            test.millisOfSecond().setCopy(1000);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.millisOfSecond().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 12);    }    public void testPropertyCompareToMilli() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0);        assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);        assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);        try {            test1.millisOfSecond().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0);        assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0);        assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0);        try {            test1.millisOfSecond().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {        assertEquals(hour, test.getHourOfDay());        assertEquals(min, test.getMinuteOfHour());        assertEquals(sec, test.getSecondOfMinute());        assertEquals(milli, test.getMillisOfSecond());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Constructors.class);    }    public TestMutableDateTime_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        MutableDateTime test = new MutableDateTime();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new MutableDateTime(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new MutableDateTime(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new MutableDateTime(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0);        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  // +02:00        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInstant_Constructors extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        // 1970-06-09    private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 1970-04-05    private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 1971-05-06    private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInstant_Constructors.class);    }    public TestInstant_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        Instant test = new Instant();        assertEquals(Chronology.getISOUTC(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        Instant test = new Instant(TEST_TIME1);        assertEquals(Chronology.getISOUTC(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        Instant test = new Instant(TEST_TIME2);        assertEquals(Chronology.getISOUTC(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        Instant test = new Instant(date);        assertEquals(Chronology.getISOUTC(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new Instant(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        Instant test = new Instant((Object) null);        assertEquals(Chronology.getISOUTC(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            Instant test = new Instant(new Integer(0));            assertEquals(Chronology.getISOUTC(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.PrintStream;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import java.util.HashSet;import java.util.Locale;import java.util.Set;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.tz.DefaultNameProvider;import org.joda.time.tz.NameProvider;import org.joda.time.tz.Provider;import org.joda.time.tz.UTCProvider;import org.joda.time.tz.ZoneInfoProvider;/** * This class is a JUnit test for DateTimeZone. * * @author Stephen Colebourne */public class TestDateTimeZone extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_SUMMER =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-01-09    private long TEST_TIME_WINTER =            (y2002days + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }        private DateTimeZone zone;    private Locale locale;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeZone.class);    }    public TestDateTimeZone(String name) {        super(name);    }    protected void setUp() throws Exception {        locale = Locale.getDefault();        zone = DateTimeZone.getDefault();        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        Locale.setDefault(locale);        DateTimeZone.setDefault(zone);    }    //-----------------------------------------------------------------------    public void testDefault() {        assertNotNull(DateTimeZone.getDefault());                DateTimeZone.setDefault(PARIS);        assertSame(PARIS, DateTimeZone.getDefault());                try {            DateTimeZone.setDefault(null);            fail();        } catch (IllegalArgumentException ex) {}    }                public void testDefaultSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setDefault(PARIS);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    //-----------------------------------------------------------------------    public void testGetInstance_String() {        assertEquals(DateTimeZone.getDefault(), DateTimeZone.getInstance((String) null));                DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("Europe/London", zone.getID());                zone = DateTimeZone.getInstance("UTC");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance("+00:00");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance("+00");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance("+01:23");        assertEquals("+01:23", zone.getID());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),                zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.getInstance("-02:00");        assertEquals("-02:00", zone.getID());        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR),                zone.getOffset(TEST_TIME_SUMMER));                try {            DateTimeZone.getInstance("SST");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance("Europe/UK");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance("+");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance("+0");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetInstance_int() {        assertEquals(DateTimeZone.UTC, DateTimeZone.getInstance(0));        assertEquals(DateTimeZone.getInstance("+03:00"), DateTimeZone.getInstance(3));        assertEquals(DateTimeZone.getInstance("-02:00"), DateTimeZone.getInstance(-2));        try {            DateTimeZone.getInstance(999999);            fail();        } catch (IllegalArgumentException ex) {}    }            //-----------------------------------------------------------------------    public void testGetInstance_int_int() {        assertEquals(DateTimeZone.UTC, DateTimeZone.getInstance(0));        assertEquals(DateTimeZone.getInstance("+03:15"), DateTimeZone.getInstance(3, 15));        assertEquals(DateTimeZone.getInstance("-02:00"), DateTimeZone.getInstance(-2, 0));        assertEquals(DateTimeZone.getInstance("-02:30"), DateTimeZone.getInstance(-2, 30));        try {            DateTimeZone.getInstance(2, 60);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance(-2, 60);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance(2, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance(-2, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.getInstance(999999, 0);            fail();        } catch (IllegalArgumentException ex) {}    }            //-----------------------------------------------------------------------    public void testGetInstance_TimeZone() {        assertEquals(DateTimeZone.getDefault(), DateTimeZone.getInstance((TimeZone) null));                DateTimeZone zone = DateTimeZone.getInstance(TimeZone.getTimeZone("Europe/London"));        assertEquals("Europe/London", zone.getID());        assertSame(DateTimeZone.UTC, DateTimeZone.getInstance(TimeZone.getTimeZone("UTC")));                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT+01:23"));        assertEquals("+01:23", zone.getID());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),                zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("GMT-02:00"));        assertEquals("-02:00", zone.getID());        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.getInstance(TimeZone.getTimeZone("EST"));        assertEquals("America/New_York", zone.getID());    }    //-----------------------------------------------------------------------    public void testGetAvailableIDs() {        assertTrue(DateTimeZone.getAvailableIDs().contains("UTC"));    }    //-----------------------------------------------------------------------    public void testProvider() {        try {            assertNotNull(DateTimeZone.getProvider());                    Provider provider = DateTimeZone.getProvider();            DateTimeZone.setProvider(null);            assertEquals(provider.getClass(), DateTimeZone.getProvider().getClass());                    try {                DateTimeZone.setProvider(new MockNullIDSProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockEmptyIDSProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockNoUTCProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockBadUTCProvider());                fail();            } catch (IllegalArgumentException ex) {}                    Provider prov = new MockOKProvider();            DateTimeZone.setProvider(prov);            assertSame(prov, DateTimeZone.getProvider());            assertEquals(2, DateTimeZone.getAvailableIDs().size());            assertTrue(DateTimeZone.getAvailableIDs().contains("UTC"));            assertTrue(DateTimeZone.getAvailableIDs().contains("Europe/London"));        } finally {            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }                try {            System.setProperty("org.joda.time.DateTimeZone.Provider", "org.joda.time.tz.UTCProvider");            DateTimeZone.setProvider(null);            assertEquals(UTCProvider.class, DateTimeZone.getProvider().getClass());        } finally {            System.getProperties().remove("org.joda.time.DateTimeZone.Provider");            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }                PrintStream syserr = System.err;        try {            System.setProperty("org.joda.time.DateTimeZone.Provider", "xxx");            ByteArrayOutputStream baos = new ByteArrayOutputStream();            System.setErr(new PrintStream(baos));                        DateTimeZone.setProvider(null);                        assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());            String str = new String(baos.toByteArray());            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);        } finally {            System.setErr(syserr);            System.getProperties().remove("org.joda.time.DateTimeZone.Provider");            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }    }        public void testProviderSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setProvider(new MockOKProvider());            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    static class MockNullIDSProvider implements Provider {        public Set getAvailableIDs() {            return null;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockEmptyIDSProvider implements Provider {        public Set getAvailableIDs() {            return new HashSet();        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockNoUTCProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockBadUTCProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("UTC");            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockOKProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("UTC");            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return DateTimeZone.UTC;        }    }    //-----------------------------------------------------------------------    public void testNameProvider() {        try {            assertNotNull(DateTimeZone.getNameProvider());                    NameProvider provider = DateTimeZone.getNameProvider();            DateTimeZone.setNameProvider(null);            assertEquals(provider.getClass(), DateTimeZone.getNameProvider().getClass());                    provider = new MockOKButNullNameProvider();            DateTimeZone.setNameProvider(provider);            assertSame(provider, DateTimeZone.getNameProvider());                        assertEquals("+00:00", DateTimeZone.UTC.getShortName(TEST_TIME_SUMMER));            assertEquals("+00:00", DateTimeZone.UTC.getName(TEST_TIME_SUMMER));        } finally {            DateTimeZone.setNameProvider(null);        }                try {            System.setProperty("org.joda.time.DateTimeZone.NameProvider", "org.joda.time.tz.DefaultNameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        } finally {            System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        }                PrintStream syserr = System.err;        try {            System.setProperty("org.joda.time.DateTimeZone.NameProvider", "xxx");            ByteArrayOutputStream baos = new ByteArrayOutputStream();            System.setErr(new PrintStream(baos));                        DateTimeZone.setNameProvider(null);                        assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());            String str = new String(baos.toByteArray());            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);        } finally {            System.setErr(syserr);            System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        }    }                public void testNameProviderSecurity() {        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setNameProvider(new MockOKButNullNameProvider());            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    static class MockOKButNullNameProvider implements NameProvider {        public String getShortName(Locale locale, String id, String nameKey) {            return null;        }        public String getName(Locale locale, String id, String nameKey) {            return null;        }    }    //-----------------------------------------------------------------------    public void testConstructor() {        assertEquals(1, DateTimeZone.class.getDeclaredConstructors().length);        assertTrue(Modifier.isProtected(DateTimeZone.class.getDeclaredConstructors()[0].getModifiers()));        try {            new DateTimeZone(null) {                public String getNameKey(long instant) {                    return null;                }                public int getOffset(long instant) {                    return 0;                }                public int getStandardOffset(long instant) {                    return 0;                }                public boolean isFixed() {                    return false;                }                public long nextTransition(long instant) {                    return 0;                }                public long previousTransition(long instant) {                    return 0;                }                public boolean equals(Object object) {                    return false;                }            };        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetID() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals("Europe/Paris", zone.getID());    }    public void testGetNameKey() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("BST", zone.getNameKey(TEST_TIME_SUMMER));        assertEquals("GMT", zone.getNameKey(TEST_TIME_WINTER));    }    public void testGetShortName() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER));        assertEquals("GMT", zone.getShortName(TEST_TIME_WINTER));        assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));    }                public void testGetShortNameProviderName() {        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, "Europe/London", "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, null, "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, "Europe/London", null));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, null, null));    }        public void testGetShortNameNullKey() {        DateTimeZone zone = new MockDateTimeZone("Europe/London");        assertEquals("Europe/London", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));    }        public void testGetName() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/London");        assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER));        assertEquals("Greenwich Mean Time", zone.getName(TEST_TIME_WINTER));        assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));            }        public void testGetNameProviderName() {        assertEquals(null, DateTimeZone.getNameProvider().getName(null, "Europe/London", "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, null, "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, "Europe/London", null));        assertEquals(null, DateTimeZone.getNameProvider().getName(null, null, null));    }        public void testGetNameNullKey() {        DateTimeZone zone = new MockDateTimeZone("Europe/London");        assertEquals("Europe/London", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));    }        static class MockDateTimeZone extends DateTimeZone {        public MockDateTimeZone(String id) {            super(id);        }        public String getNameKey(long instant) {            return null;  // null        }        public int getOffset(long instant) {            return 0;        }        public int getStandardOffset(long instant) {            return 0;        }        public boolean isFixed() {            return false;        }        public long nextTransition(long instant) {            return 0;        }        public long previousTransition(long instant) {            return 0;        }        public boolean equals(Object object) {            return false;        }    }    //-----------------------------------------------------------------------    public void testGetOffset() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));                assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));                assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));                assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));    }    public void testGetOffsetFixed() {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));                assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));    }    //-----------------------------------------------------------------------    public void testGetMillisKeepLocal() {        long millisLondon = TEST_TIME_SUMMER;        long millisParis = TEST_TIME_SUMMER - 1L * DateTimeConstants.MILLIS_PER_HOUR;                assertEquals(millisParis, LONDON.getMillisKeepLocal(PARIS, millisLondon));        assertEquals(millisLondon, PARIS.getMillisKeepLocal(LONDON, millisParis));                DateTimeZone zone = DateTimeZone.getDefault();        try {            DateTimeZone.setDefault(LONDON);            assertEquals(millisLondon, PARIS.getMillisKeepLocal(null, millisParis));        } finally {            DateTimeZone.setDefault(zone);        }    }    //-----------------------------------------------------------------------    public void testIsFixed() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals(false, zone.isFixed());        assertEquals(true, DateTimeZone.UTC.isFixed());    }    //-----------------------------------------------------------------------    public void testTransitionFixed() {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");        assertEquals(TEST_TIME_SUMMER, zone.nextTransition(TEST_TIME_SUMMER));        assertEquals(TEST_TIME_WINTER, zone.nextTransition(TEST_TIME_WINTER));        assertEquals(TEST_TIME_SUMMER, zone.previousTransition(TEST_TIME_SUMMER));        assertEquals(TEST_TIME_WINTER, zone.previousTransition(TEST_TIME_WINTER));    }    //-----------------------------------------------------------------------    public void testToTimeZone() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        TimeZone tz = zone.toTimeZone();        assertEquals("Europe/Paris", tz.getID());    }    //-----------------------------------------------------------------------    public void testEqualsHashCode() {        DateTimeZone zone1 = DateTimeZone.getInstance("Europe/Paris");        DateTimeZone zone2 = DateTimeZone.getInstance("Europe/Paris");        assertEquals(true, zone1.equals(zone1));        assertEquals(true, zone1.equals(zone2));        assertEquals(true, zone2.equals(zone1));        assertEquals(true, zone2.equals(zone2));        assertEquals(true, zone1.hashCode() == zone2.hashCode());                DateTimeZone zone3 = DateTimeZone.getInstance("Europe/London");        assertEquals(true, zone3.equals(zone3));        assertEquals(false, zone1.equals(zone3));        assertEquals(false, zone2.equals(zone3));        assertEquals(false, zone3.equals(zone1));        assertEquals(false, zone3.equals(zone2));        assertEquals(false, zone1.hashCode() == zone3.hashCode());        assertEquals(true, zone3.hashCode() == zone3.hashCode());                DateTimeZone zone4 = DateTimeZone.getInstance("+01:00");        assertEquals(true, zone4.equals(zone4));        assertEquals(false, zone1.equals(zone4));        assertEquals(false, zone2.equals(zone4));        assertEquals(false, zone3.equals(zone4));        assertEquals(false, zone4.equals(zone1));        assertEquals(false, zone4.equals(zone2));        assertEquals(false, zone4.equals(zone3));        assertEquals(false, zone1.hashCode() == zone4.hashCode());        assertEquals(true, zone4.hashCode() == zone4.hashCode());                DateTimeZone zone5 = DateTimeZone.getInstance("+02:00");        assertEquals(true, zone5.equals(zone5));        assertEquals(false, zone1.equals(zone5));        assertEquals(false, zone2.equals(zone5));        assertEquals(false, zone3.equals(zone5));        assertEquals(false, zone4.equals(zone5));        assertEquals(false, zone5.equals(zone1));        assertEquals(false, zone5.equals(zone2));        assertEquals(false, zone5.equals(zone3));        assertEquals(false, zone5.equals(zone4));        assertEquals(false, zone1.hashCode() == zone5.hashCode());        assertEquals(true, zone5.hashCode() == zone5.hashCode());    }    //-----------------------------------------------------------------------    public void testToString() {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");        assertEquals("Europe/Paris", zone.toString());        assertEquals("UTC", DateTimeZone.UTC.toString());    }    //-----------------------------------------------------------------------    public void testSerialization1() throws Exception {        DateTimeZone zone = DateTimeZone.getInstance("Europe/Paris");                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(zone);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeZone result = (DateTimeZone) ois.readObject();        ois.close();                assertSame(zone, result);    }    //-----------------------------------------------------------------------    public void testSerialization2() throws Exception {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(zone);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeZone result = (DateTimeZone) ois.readObject();        ois.close();                assertSame(zone, result);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for PeriodType. * * @author Stephen Colebourne */public class TestPeriodType extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodType.class);    }    public TestPeriodType(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    private void assertEqualsAfterSerialization(PeriodType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        PeriodType result = (PeriodType) ois.readObject();        ois.close();                assertEquals(type, result);    }    private void assertSameAfterSerialization(PeriodType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        PeriodType result = (PeriodType) ois.readObject();        ois.close();                assertEquals(type, result);    }    //-----------------------------------------------------------------------    public void testStandard() throws Exception {        PeriodType type = PeriodType.standard();        assertEquals(8, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));        assertEquals(DurationFieldType.seconds(), type.getFieldType(6));        assertEquals(DurationFieldType.millis(), type.getFieldType(7));        assertEquals("Standard", type.getName());        assertEquals("PeriodType[Standard]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.standard());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearMonthDayTime() throws Exception {        PeriodType type = PeriodType.yearMonthDayTime();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals("YearMonthDayTime", type.getName());        assertEquals("PeriodType[YearMonthDayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearMonthDayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearMonthDayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearWeekDayTime() throws Exception {        PeriodType type = PeriodType.yearWeekDayTime();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals("YearWeekDayTime", type.getName());        assertEquals("PeriodType[YearWeekDayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearWeekDayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearWeekDayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearDayTime() throws Exception {        PeriodType type = PeriodType.yearDayTime();        assertEquals(6, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.days(), type.getFieldType(1));        assertEquals(DurationFieldType.hours(), type.getFieldType(2));        assertEquals(DurationFieldType.minutes(), type.getFieldType(3));        assertEquals(DurationFieldType.seconds(), type.getFieldType(4));        assertEquals(DurationFieldType.millis(), type.getFieldType(5));        assertEquals("YearDayTime", type.getName());        assertEquals("PeriodType[YearDayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearDayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearDayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testDayTime() throws Exception {        PeriodType type = PeriodType.dayTime();        assertEquals(5, type.size());        assertEquals(DurationFieldType.days(), type.getFieldType(0));        assertEquals(DurationFieldType.hours(), type.getFieldType(1));        assertEquals(DurationFieldType.minutes(), type.getFieldType(2));        assertEquals(DurationFieldType.seconds(), type.getFieldType(3));        assertEquals(DurationFieldType.millis(), type.getFieldType(4));        assertEquals("DayTime", type.getName());        assertEquals("PeriodType[DayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.dayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.dayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testTime() throws Exception {        PeriodType type = PeriodType.time();        assertEquals(4, type.size());        assertEquals(DurationFieldType.hours(), type.getFieldType(0));        assertEquals(DurationFieldType.minutes(), type.getFieldType(1));        assertEquals(DurationFieldType.seconds(), type.getFieldType(2));        assertEquals(DurationFieldType.millis(), type.getFieldType(3));        assertEquals("Time", type.getName());        assertEquals("PeriodType[Time]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.time());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.time().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYears() throws Exception {        PeriodType type = PeriodType.years();        assertEquals(1, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals("Years", type.getName());        assertEquals("PeriodType[Years]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.years());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.years().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMonths() throws Exception {        PeriodType type = PeriodType.months();        assertEquals(1, type.size());        assertEquals(DurationFieldType.months(), type.getFieldType(0));        assertEquals("Months", type.getName());        assertEquals("PeriodType[Months]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.months());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.months().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testWeeks() throws Exception {        PeriodType type = PeriodType.weeks();        assertEquals(1, type.size());        assertEquals(DurationFieldType.weeks(), type.getFieldType(0));        assertEquals("Weeks", type.getName());        assertEquals("PeriodType[Weeks]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.weeks());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.weeks().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testDays() throws Exception {        PeriodType type = PeriodType.days();        assertEquals(1, type.size());        assertEquals(DurationFieldType.days(), type.getFieldType(0));        assertEquals("Days", type.getName());        assertEquals("PeriodType[Days]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.days());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.days().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testHours() throws Exception {        PeriodType type = PeriodType.hours();        assertEquals(1, type.size());        assertEquals(DurationFieldType.hours(), type.getFieldType(0));        assertEquals("Hours", type.getName());        assertEquals("PeriodType[Hours]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.hours());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.hours().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMinutes() throws Exception {        PeriodType type = PeriodType.minutes();        assertEquals(1, type.size());        assertEquals(DurationFieldType.minutes(), type.getFieldType(0));        assertEquals("Minutes", type.getName());        assertEquals("PeriodType[Minutes]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.minutes());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.minutes().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testSeconds() throws Exception {        PeriodType type = PeriodType.seconds();        assertEquals(1, type.size());        assertEquals(DurationFieldType.seconds(), type.getFieldType(0));        assertEquals("Seconds", type.getName());        assertEquals("PeriodType[Seconds]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.seconds());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.seconds().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMillis() throws Exception {        PeriodType type = PeriodType.millis();        assertEquals(1, type.size());        assertEquals(DurationFieldType.millis(), type.getFieldType(0));        assertEquals("Millis", type.getName());        assertEquals("PeriodType[Millis]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.millis());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.millis().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskYears() throws Exception {        PeriodType type = PeriodType.standard().withYearsRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.months(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withYearsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withYearsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoYears", type.getName());        assertEquals("PeriodType[StandardNoYears]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMonths() throws Exception {        PeriodType type = PeriodType.standard().withMonthsRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withMonthsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withMonthsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoMonths", type.getName());        assertEquals("PeriodType[StandardNoMonths]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskWeeks() throws Exception {        PeriodType type = PeriodType.standard().withWeeksRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withWeeksRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withWeeksRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoWeeks", type.getName());        assertEquals("PeriodType[StandardNoWeeks]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskDays() throws Exception {        PeriodType type = PeriodType.standard().withDaysRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withDaysRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withDaysRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoDays", type.getName());        assertEquals("PeriodType[StandardNoDays]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskHours() throws Exception {        PeriodType type = PeriodType.standard().withHoursRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoHours", type.getName());        assertEquals("PeriodType[StandardNoHours]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMinutes() throws Exception {        PeriodType type = PeriodType.standard().withMinutesRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withMinutesRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withMinutesRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoMinutes", type.getName());        assertEquals("PeriodType[StandardNoMinutes]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskSeconds() throws Exception {        PeriodType type = PeriodType.standard().withSecondsRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withSecondsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withSecondsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoSeconds", type.getName());        assertEquals("PeriodType[StandardNoSeconds]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMillis() throws Exception {        PeriodType type = PeriodType.standard().withMillisRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));        assertEquals(DurationFieldType.seconds(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withMillisRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withMillisRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoMillis", type.getName());        assertEquals("PeriodType[StandardNoMillis]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskHoursMinutesSeconds() throws Exception {        PeriodType type = PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();        assertEquals(5, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.millis(), type.getFieldType(4));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoHoursNoMinutesNoSeconds", type.getName());        assertEquals("PeriodType[StandardNoHoursNoMinutesNoSeconds]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskTwice1() throws Exception {        PeriodType type = PeriodType.standard().withYearsRemoved();        PeriodType type2 = type.withYearsRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withMonthsRemoved();        type2 = type.withMonthsRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withWeeksRemoved();        type2 = type.withWeeksRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withDaysRemoved();        type2 = type.withDaysRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withHoursRemoved();        type2 = type.withHoursRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withMinutesRemoved();        type2 = type.withMinutesRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withSecondsRemoved();        type2 = type.withSecondsRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withMillisRemoved();        type2 = type.withMillisRemoved();        assertEquals(true, type == type2);    }    //-----------------------------------------------------------------------    public void testMaskTwice2() throws Exception {        PeriodType type = PeriodType.dayTime();        PeriodType type2 = type.withYearsRemoved();        assertEquals(true, type == type2);                type = PeriodType.dayTime();        type2 = type.withMonthsRemoved();        assertEquals(true, type == type2);                type = PeriodType.dayTime();        type2 = type.withWeeksRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withDaysRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withHoursRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withMinutesRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withSecondsRemoved();        assertEquals(true, type == type2);    }    //-----------------------------------------------------------------------    public void testEquals() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.dayTime().withMillisRemoved()));        assertEquals(false, type.equals(null));        assertEquals(false, type.equals(""));    }    public void testHashCode() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(type.hashCode(), type.hashCode());    }    //-----------------------------------------------------------------------    public void testIsSupported() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(false, type.isSupported(DurationFieldType.years()));        assertEquals(false, type.isSupported(DurationFieldType.months()));        assertEquals(false, type.isSupported(DurationFieldType.weeks()));        assertEquals(true, type.isSupported(DurationFieldType.days()));        assertEquals(true, type.isSupported(DurationFieldType.hours()));        assertEquals(true, type.isSupported(DurationFieldType.minutes()));        assertEquals(true, type.isSupported(DurationFieldType.seconds()));        assertEquals(false, type.isSupported(DurationFieldType.millis()));    }    //-----------------------------------------------------------------------    public void testIndexOf() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(-1, type.indexOf(DurationFieldType.years()));        assertEquals(-1, type.indexOf(DurationFieldType.months()));        assertEquals(-1, type.indexOf(DurationFieldType.weeks()));        assertEquals(0, type.indexOf(DurationFieldType.days()));        assertEquals(1, type.indexOf(DurationFieldType.hours()));        assertEquals(2, type.indexOf(DurationFieldType.minutes()));        assertEquals(3, type.indexOf(DurationFieldType.seconds()));        assertEquals(-1, type.indexOf(DurationFieldType.millis()));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Constructors.class);    }    public TestMutablePeriod_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor1() throws Throwable {        MutablePeriod test = new MutablePeriod();        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (PeriodType)     */    public void testConstructor_PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod(PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod((PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long2() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long3() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.millis());        assertEquals(PeriodType.millis(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(length, test.getMillis());    }    public void testConstructor_long_PeriodType3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType4() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, Chronology.getISO());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, Chronology.getISOUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.time().withMillisRemoved(), Chronology.getISO());        assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), Chronology.getISOUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology4() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, (PeriodType) null, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (4ints)     */    public void testConstructor_4int1() throws Throwable {        MutablePeriod test = new MutablePeriod(5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int1() throws Throwable {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int__PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType3() throws Throwable {        try {            new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getCoptic());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getCoptic());        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), Chronology.getCoptic());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, Chronology.getCoptic());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, Chronology.getCoptic());        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, Chronology.getCoptic());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(-3, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        MutablePeriod test = new MutablePeriod(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        MutablePeriod test = new MutablePeriod(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        MutablePeriod test = new MutablePeriod(dt1, dur, PeriodType.yearDayTime());        assertEquals(PeriodType.yearDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        MutablePeriod test = new MutablePeriod(dt1, dur, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        MutablePeriod test = new MutablePeriod("P1Y2M3D");        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object2() throws Throwable {        MutablePeriod test = new MutablePeriod((Object) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object3() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()));        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object4() throws Throwable {        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard());        MutablePeriod test = new MutablePeriod(base);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object,PeriodType)     */    public void testConstructor_Object_PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod("P1Y2M3D", PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod((Object) null, PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType3() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object_PeriodType4() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null);        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test case. * * @author Stephen Colebourne */public class TestDateTimeConstants extends TestCase {    /**     * The main method for this test program.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return new TestSuite(TestDateTimeConstants.class);    }    /**     * TestDateTimeComparator constructor.     * @param name     */    public TestDateTimeConstants(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testConstructor() {        DateTimeConstants c = new DateTimeConstants() {        };        c.toString();    }    public void testHalfdaysOfDay() {        assertEquals(0, DateTimeConstants.AM);        assertEquals(1, DateTimeConstants.PM);    }    public void testDaysOfWeek() {        assertEquals(1, DateTimeConstants.MONDAY);        assertEquals(2, DateTimeConstants.TUESDAY);        assertEquals(3, DateTimeConstants.WEDNESDAY);        assertEquals(4, DateTimeConstants.THURSDAY);        assertEquals(5, DateTimeConstants.FRIDAY);        assertEquals(6, DateTimeConstants.SATURDAY);        assertEquals(7, DateTimeConstants.SUNDAY);    }    public void testMonthsOfYear() {        assertEquals(1, DateTimeConstants.JANUARY);        assertEquals(2, DateTimeConstants.FEBRUARY);        assertEquals(3, DateTimeConstants.MARCH);        assertEquals(4, DateTimeConstants.APRIL);        assertEquals(5, DateTimeConstants.MAY);        assertEquals(6, DateTimeConstants.JUNE);        assertEquals(7, DateTimeConstants.JULY);        assertEquals(8, DateTimeConstants.AUGUST);        assertEquals(9, DateTimeConstants.SEPTEMBER);        assertEquals(10, DateTimeConstants.OCTOBER);        assertEquals(11, DateTimeConstants.NOVEMBER);        assertEquals(12, DateTimeConstants.DECEMBER);    }    public void testEras() {        assertEquals(0, DateTimeConstants.BC);        assertEquals(0, DateTimeConstants.BCE);        assertEquals(1, DateTimeConstants.AD);        assertEquals(1, DateTimeConstants.CE);    }    public void testMaths() {        assertEquals(1000, DateTimeConstants.MILLIS_PER_SECOND);        assertEquals(60 * 1000, DateTimeConstants.MILLIS_PER_MINUTE);        assertEquals(60 * 60 * 1000, DateTimeConstants.MILLIS_PER_HOUR);        assertEquals(24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_DAY);        assertEquals(7 * 24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_WEEK);                assertEquals(60, DateTimeConstants.SECONDS_PER_MINUTE);        assertEquals(60 * 60, DateTimeConstants.SECONDS_PER_HOUR);        assertEquals(24 * 60 * 60, DateTimeConstants.SECONDS_PER_DAY);        assertEquals(7 * 24 * 60 * 60, DateTimeConstants.SECONDS_PER_WEEK);                assertEquals(60, DateTimeConstants.MINUTES_PER_HOUR);        assertEquals(24 * 60, DateTimeConstants.MINUTES_PER_DAY);        assertEquals(7 * 24 * 60, DateTimeConstants.MINUTES_PER_WEEK);                assertEquals(24, DateTimeConstants.HOURS_PER_DAY);        assertEquals(7 * 24, DateTimeConstants.HOURS_PER_WEEK);                assertEquals(7, DateTimeConstants.DAYS_PER_WEEK);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-2004 Stephen Colebourne.   * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer.  * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment:   *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally  * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestMutableInterval_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.getInstance("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.getInstance("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Basics.class);    }    public TestMutableInterval_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getStart().getMillis());        assertEquals(TEST_TIME2, test.getEndMillis());        assertEquals(TEST_TIME2, test.getEnd().getMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME1);        assertSame(Duration.ZERO, test.toDuration());    }    public void testEqualsHashCode() {        MutableInterval test1 = new MutableInterval(TEST_TIME1, TEST_TIME2);        MutableInterval test2 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutableInterval test3 = new MutableInterval(TEST_TIME_NOW, TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                MutableInterval test4 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test4));        assertEquals(true, test2.equals(test4));        assertEquals(false, test3.equals(test4));        assertEquals(true, test4.equals(test1));        assertEquals(true, test4.equals(test2));        assertEquals(false, test4.equals(test3));        assertEquals(true, test1.hashCode() == test4.hashCode());        assertEquals(true, test2.hashCode() == test4.hashCode());        assertEquals(false, test3.hashCode() == test4.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInterval()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInterval extends AbstractInterval {        public MockInterval() {            super();        }        public Chronology getChronology() {            return Chronology.getISO();        }        public long getStartMillis() {            return TEST_TIME1;        }        public long getEndMillis() {            return TEST_TIME2;        }    }    //-----------------------------------------------------------------------    public void testContains_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(TEST_TIME1));        assertEquals(false, test.contains(TEST_TIME1 - 1));        assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2));        assertEquals(false, test.contains(TEST_TIME2));        assertEquals(true, test.contains(TEST_TIME2 - 1));    }    public void testContainsNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(true, test.containsNow());    }    public void testContains_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(new Instant(TEST_TIME1)));        assertEquals(false, test.contains(new Instant(TEST_TIME1 - 1)));        assertEquals(true, test.contains(new Instant(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2)));        assertEquals(false, test.contains(new Instant(TEST_TIME2)));        assertEquals(true, test.contains(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.contains((ReadableInstant) null));    }    //-----------------------------------------------------------------------    public void testContains_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1)));                assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));                assertEquals(true, test.contains((ReadableInterval) null));    }    public void testOverlaps_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));                assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));                assertEquals(true, test.overlaps((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testIsBefore_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(TEST_TIME1 - 1));        assertEquals(false, test.isBefore(TEST_TIME1));        assertEquals(false, test.isBefore(TEST_TIME1 + 1));                assertEquals(false, test.isBefore(TEST_TIME2 - 1));        assertEquals(true, test.isBefore(TEST_TIME2));        assertEquals(true, test.isBefore(TEST_TIME2 + 1));    }    public void testIsBeforeNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(false, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(true, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 + 1);        assertEquals(true, test.isBeforeNow());    }    public void testIsBefore_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isBefore((ReadableInstant) null));    }    public void testIsBefore_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isBefore((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testIsAfter_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(TEST_TIME1 - 1));        assertEquals(false, test.isAfter(TEST_TIME1));        assertEquals(false, test.isAfter(TEST_TIME1 + 1));                assertEquals(false, test.isAfter(TEST_TIME2 - 1));        assertEquals(false, test.isAfter(TEST_TIME2));        assertEquals(false, test.isAfter(TEST_TIME2 + 1));    }    public void testIsAfterNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(true, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(false, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + 1);        assertEquals(false, test.isAfterNow());    }    public void testIsAfter_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Instant(TEST_TIME2 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isAfter((ReadableInstant) null));    }    public void testIsAfter_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isAfter((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testToInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        Interval result = test.toInterval();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToMutableInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        MutableInterval result = test.toMutableInterval();        assertEquals(test, result);        assertNotSame(test, result);    }    //-----------------------------------------------------------------------    public void testToPeriod() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod();        assertEquals(PeriodType.standard(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType1() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod(null);        assertEquals(PeriodType.standard(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType2() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod(PeriodType.yearWeekDayTime());        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(9, result.getWeeks());        assertEquals(2, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    public void testToPeriod_PeriodType3() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);        MutableInterval test = new MutableInterval(dt1, dt2);                Period result = test.toPeriod(PeriodType.yearWeekDayTime());        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(0, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(0, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutableInterval result = (MutableInterval) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals("2004-06-09T07:08:09.010/2005-08-13T12:14:16.018", test.toString());    }    //-----------------------------------------------------------------------    public void testCopy() {        MutableInterval test = new MutableInterval(123L, 456L);        MutableInterval cloned = test.copy();        assertEquals(test, cloned);        assertNotSame(test, cloned);    }    public void testClone() {        MutableInterval test = new MutableInterval(123L, 456L);        MutableInterval cloned = (MutableInterval) test.clone();        assertEquals(test, cloned);        assertNotSame(test, cloned);    }}