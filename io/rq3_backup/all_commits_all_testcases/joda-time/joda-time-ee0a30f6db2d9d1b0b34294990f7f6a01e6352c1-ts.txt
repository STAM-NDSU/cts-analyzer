package org.joda.time.contrib.hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;import org.joda.time.YearMonthDay;import java.io.File;import java.sql.SQLException;public class TestPersistentYearMonthDay extends HibernateTestCase{    private YearMonthDay[] writeReadTimes = new YearMonthDay[]    {        new YearMonthDay(2004, 2, 25),        new YearMonthDay(1980, 3, 11)    };    public void testSimpleStore() throws SQLException    {        SessionFactory factory = getSessionFactory();        Session session = factory.openSession();        for (int i = 0; i<writeReadTimes.length; i++)        {            YearMonthDay writeReadTime = writeReadTimes[i];            Schedule event = new Schedule();            event.setId(i);            event.setStartDate(writeReadTime);            session.save(event);        }        session.flush();        session.connection().commit();        session.close();        for (int i = 0; i<writeReadTimes.length; i++)        {            YearMonthDay writeReadTime = writeReadTimes[i];            session = factory.openSession();            Schedule eventReread = (Schedule) session.get(Schedule.class, new Integer(i));            assertNotNull("get failed - event#'" + i + "'not found", eventReread);            assertNotNull("get failed - returned null", eventReread.getStartDate());            assertEquals("get failed - returned different date", writeReadTime, eventReread.getStartDate());        }session.close();    }protected void setupConfiguration(Configuration cfg){cfg.addFile(new File("src/test/org/joda/time/contrib/hibernate/schedule.hbm.xml"));}}
package org.joda.time.contrib.hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import java.io.File;import java.sql.SQLException;public class TestPersistentDateTime extends HibernateTestCase{    private DateTime[] writeReadTimes = new DateTime[]    {        new DateTime(2004, 2, 25, 17, 3, 45, 760),        new DateTime(1980, 3, 11,  2, 3, 45,   0, DateTimeZone.forOffsetHours(2))    };    public void testSimpleStore() throws SQLException    {        SessionFactory factory = getSessionFactory();        Session session = factory.openSession();        for (int i = 0; i<writeReadTimes.length; i++)        {            DateTime writeReadTime = writeReadTimes[i];            Event event = new Event();            event.setId(i);            event.setDateTime(writeReadTime);            session.save(event);        }        session.flush();        session.connection().commit();        session.close();        for (int i = 0; i<writeReadTimes.length; i++)        {            DateTime writeReadTime = writeReadTimes[i];            session = factory.openSession();            Event eventReread = (Event) session.get(Event.class, new Integer(i));            assertNotNull("get failed - event#'" + i + "'not found", eventReread);            assertNotNull("get failed - returned null", eventReread.getDateTime());            // we loose the timezone, so we have to normalize both to offset=0            assertEquals("get failed - returned different time",                writeReadTime.toDateTime(DateTimeZone.forOffsetHours(0)),                eventReread.getDateTime().toDateTime(DateTimeZone.forOffsetHours(0)));            session.close();        }    }    public void testStoreWithTimezone() throws SQLException    {        SessionFactory factory = getSessionFactory();        Session session = factory.openSession();        for (int i = 0; i<writeReadTimes.length; i++)        {            DateTime writeReadTime = writeReadTimes[i];            EventTZ event = new EventTZ();            event.setId(i);            event.setDateTime(writeReadTime);            session.save(event);        }        session.flush();        session.connection().commit();        session.close();        for (int i = 0; i<writeReadTimes.length; i++)        {            DateTime writeReadTime = writeReadTimes[i];            session = factory.openSession();            EventTZ eventReread = (EventTZ) session.get(EventTZ.class, new Integer(i));            assertNotNull("get failed - event#'" + i + "'not found", eventReread);            assertNotNull("get failed - returned null", eventReread.getDateTime());            assertEquals("get failed - returned different time",                writeReadTime, eventReread.getDateTime());        }session.close();    }protected void setupConfiguration(Configuration cfg){cfg.addFile(new File("src/test/org/joda/time/contrib/hibernate/event.hbm.xml"));cfg.addFile(new File("src/test/org/joda/time/contrib/hibernate/eventTZ.hbm.xml"));}}
package org.joda.time.contrib.hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;import org.joda.time.TimeOfDay;import java.io.File;import java.sql.SQLException;public class TestPersistentTimeOfDay extends HibernateTestCase{    private TimeOfDay[] writeReadTimes = new TimeOfDay[]    {        new TimeOfDay(12, 10, 31),        new TimeOfDay(23,  7, 43, 120)    };    public void testSimpleStore() throws SQLException    {        SessionFactory factory = getSessionFactory();        Session session = factory.openSession();        for (int i = 0; i<writeReadTimes.length; i++)        {            TimeOfDay writeReadTime = writeReadTimes[i];            Schedule event = new Schedule();            event.setId(i);            event.setNextTime(writeReadTime);            session.save(event);        }        session.flush();        session.connection().commit();        session.close();        for (int i = 0; i<writeReadTimes.length; i++)        {            TimeOfDay writeReadTime = writeReadTimes[i];            session = factory.openSession();            Schedule eventReread = (Schedule) session.get(Schedule.class, new Integer(i));            assertNotNull("get failed - event#'" + i + "'not found", eventReread);            assertNotNull("get failed - returned null", eventReread.getNextTime());TimeOfDay reReadTime = eventReread.getNextTime();if (writeReadTime.getHourOfDay() != reReadTime.getHourOfDay() ||writeReadTime.getMinuteOfHour() != reReadTime.getMinuteOfHour() ||writeReadTime.getSecondOfMinute() != reReadTime.getSecondOfMinute()){fail("get failed - returned different date. expected " + writeReadTime + " was " + eventReread.getNextTime());}if (writeReadTime.getMillisOfSecond() != reReadTime.getMillisOfSecond()){System.out.println("millis different, might happen?");}}session.close();    }protected void setupConfiguration(Configuration cfg){cfg.addFile(new File("src/test/org/joda/time/contrib/hibernate/schedule.hbm.xml"));}}
package org.joda.time.contrib.hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;import org.joda.time.TimeOfDay;import java.io.File;import java.sql.SQLException;public class TestPersistentTimeOfDayExact extends HibernateTestCase{    private TimeOfDay[] writeReadTimes = new TimeOfDay[]    {        new TimeOfDay(12, 10, 31),        new TimeOfDay(23,  7, 43, 120)    };    public void testSimpleStore() throws SQLException    {        SessionFactory factory = getSessionFactory();        Session session = factory.openSession();        for (int i = 0; i<writeReadTimes.length; i++)        {            TimeOfDay writeReadTime = writeReadTimes[i];            Schedule event = new Schedule();            event.setId(i);            event.setNextTimeMillis(writeReadTime);            session.save(event);        }        session.flush();        session.connection().commit();        session.close();        for (int i = 0; i<writeReadTimes.length; i++)        {            TimeOfDay writeReadTime = writeReadTimes[i];            session = factory.openSession();            Schedule eventReread = (Schedule) session.get(Schedule.class, new Integer(i));            assertNotNull("get failed - event#'" + i + "'not found", eventReread);            assertNotNull("get failed - returned null", eventReread.getNextTimeMillis());assertEquals("get failed - returned different date.", writeReadTime, eventReread.getNextTimeMillis());}session.close();    }protected void setupConfiguration(Configuration cfg){cfg.addFile(new File("src/test/org/joda/time/contrib/hibernate/schedule.hbm.xml"));}}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.contrib.holiday.anniversary;import junit.framework.TestCase;import org.joda.time.DateMidnight;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.contrib.holiday.anniversary.CommonAnniversaries;public class TestCommonAnniversaries extends TestCase {    /**     * NB: tests for good friday are automatically tests for Easter and Easter     * Monday.     */    public void testGoodFriday0() {        DateTime ymd = CommonAnniversaries.GOOD_FRIDAY.create(2005);        assertEquals(ymd, new DateMidnight(2005, DateTimeConstants.MARCH, 25));    }    public void testGoodFriday1() {        DateTime ymd = CommonAnniversaries.GOOD_FRIDAY.create(1993);        assertEquals(ymd, new DateMidnight(1993, DateTimeConstants.APRIL, 9));    }    public void testGoodFriday2() {        DateTime ymd = CommonAnniversaries.GOOD_FRIDAY.create(1997);        assertEquals(ymd, new DateMidnight(1997, DateTimeConstants.MARCH, 28));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.contrib.holiday.anniversary;import junit.framework.TestCase;import org.joda.time.DateMidnight;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.contrib.holiday.anniversary.CommonAnniversaries;import org.joda.time.contrib.holiday.anniversary.USAnniversaries;public class TestUSAnniversaries extends TestCase {    public void testNewYearHoliday0() {        DateTime ymd = USAnniversaries.NEW_YEAR_HOLIDAY.create(2005);        assertEquals(ymd,                new DateMidnight(2004, DateTimeConstants.DECEMBER, 31));    }    public void testNewYearHoliday1() {        DateTime ymd = USAnniversaries.NEW_YEAR_HOLIDAY.create(1993);        assertEquals(ymd, new DateMidnight(1993, DateTimeConstants.JANUARY, 1));    }    public void testMartinLutherKingDay() {        DateTime ymd = USAnniversaries.MARTIN_LUTHER_KING_DAY.create(2005);        assertEquals(ymd, new DateMidnight(2005, DateTimeConstants.JANUARY, 17));    }    public void testWashingtonsBirthdayHoliday() {        DateTime ymd = USAnniversaries.WASHINGTONS_BIRTHDAY_HOLIDAY                .create(2005);        assertEquals(ymd,                new DateMidnight(2005, DateTimeConstants.FEBRUARY, 21));    }    public void testMemorialDay0() {        DateTime ymd = USAnniversaries.MEMORIAL_DAY.create(2005);        assertEquals(ymd, new DateMidnight(2005, DateTimeConstants.MAY, 30));    }    public void testMemorialDay1() {        DateTime ymd = USAnniversaries.MEMORIAL_DAY.create(1995);        assertEquals(ymd, new DateMidnight(1995, DateTimeConstants.MAY, 29));    }    public void testMemorialDay2() {        DateTime ymd = USAnniversaries.MEMORIAL_DAY.create(1997);        assertEquals(ymd, new DateMidnight(1997, DateTimeConstants.MAY, 26));    }    public void testIndependenceDayHoliday0() {        DateTime ymd = USAnniversaries.INDEPENDENCE_DAY_HOLIDAY.create(2005);        assertEquals(ymd, new DateMidnight(2005, DateTimeConstants.JULY, 4));    }    public void testIndependenceDayHoliday1() {        DateTime ymd = USAnniversaries.INDEPENDENCE_DAY_HOLIDAY.create(1993);        assertEquals(ymd, new DateMidnight(1993, DateTimeConstants.JULY, 5));    }    public void testLaborDay() {        DateTime ymd = CommonAnniversaries.LABOR_DAY.create(2005);        assertEquals(ymd,                new DateMidnight(2005, DateTimeConstants.SEPTEMBER, 5));    }    public void testThanksgiving0() {        DateTime ymd = USAnniversaries.THANKSGIVING.create(2005);        assertEquals(ymd,                new DateMidnight(2005, DateTimeConstants.NOVEMBER, 24));    }    public void testThanksgiving1() {        DateTime ymd = USAnniversaries.THANKSGIVING.create(1995);        assertEquals(ymd,                new DateMidnight(1995, DateTimeConstants.NOVEMBER, 23));    }    public void testColumbusDay0() {        DateTime ymd = USAnniversaries.COLUMBUS_DAY.create(2005);        assertEquals(ymd, new DateMidnight(2005, DateTimeConstants.OCTOBER, 10));    }    public void testColumbusDay1() {        DateTime ymd = USAnniversaries.COLUMBUS_DAY.create(1998);        assertEquals(ymd, new DateMidnight(1998, DateTimeConstants.OCTOBER, 12));    }    public void testChristmasHoliday0() {        DateTime ymd = USAnniversaries.CHRISTMAS_HOLIDAY.create(2005);        assertEquals(ymd,                new DateMidnight(2005, DateTimeConstants.DECEMBER, 26));    }    public void testChristmasHoliday1() {        DateTime ymd = USAnniversaries.CHRISTMAS_HOLIDAY.create(1995);        assertEquals(ymd,                new DateMidnight(1995, DateTimeConstants.DECEMBER, 25));    }    public void testElectionDay0() {        DateTime ymd = USAnniversaries.ELECTION_DAY.create(1996);        assertEquals(ymd, new DateMidnight(1996, DateTimeConstants.NOVEMBER, 5));    }    public void testElectionDay1() {        // no election in 1997        DateTime ymd = USAnniversaries.ELECTION_DAY.create(1997);        assertEquals(ymd, null);    }    public void testElectionDay2() {        DateTime ymd = USAnniversaries.ELECTION_DAY.create(2000);        assertEquals(ymd, new DateMidnight(2000, DateTimeConstants.NOVEMBER, 7));    }    public void testElectionDay3() {        DateTime ymd = USAnniversaries.ELECTION_DAY.create(2004);        assertEquals(ymd, new DateMidnight(2004, DateTimeConstants.NOVEMBER, 2));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.contrib.holiday;import java.util.List;import junit.framework.TestCase;import org.joda.time.contrib.holiday.USGovtHolidays;import org.joda.time.contrib.holiday.anniversary.CommonAnniversaries;import org.joda.time.contrib.holiday.anniversary.USAnniversaries;import org.joda.time.contrib.holiday.anniversary.NamedAnniversaryFactory.NamedAnniversary;/*  * This is basically a test to make sure that the holiday list mechanism * works correctly. individual dates are tested in the anniversary tests. */public class TestUSHolidays extends TestCase {    public void testFederalHolidays() {        List<NamedAnniversary> holidays = USGovtHolidays.FEDERAL.getHolidaysForYear(1995);        assertEquals(holidays.size(), 10);        assertEquals(holidays.get(0).getDate(),                USAnniversaries.NEW_YEAR_HOLIDAY.create(1995));        assertEquals(holidays.get(1).getDate(),                USAnniversaries.MARTIN_LUTHER_KING_DAY.create(1995));        assertEquals(holidays.get(2).getDate(),                USAnniversaries.WASHINGTONS_BIRTHDAY_HOLIDAY.create(1995));        assertEquals(holidays.get(3).getDate(),                USAnniversaries.MEMORIAL_DAY.create(1995));        assertEquals(holidays.get(4).getDate(),                USAnniversaries.INDEPENDENCE_DAY_HOLIDAY.create(1995));        assertEquals(holidays.get(5).getDate(),                CommonAnniversaries.LABOR_DAY.create(1995));        assertEquals(holidays.get(6).getDate(),                USAnniversaries.COLUMBUS_DAY.create(1995));        assertEquals(holidays.get(7).getDate(),                USAnniversaries.VETERANS_DAY_HOLIDAY.create(1995));        assertEquals(holidays.get(8).getDate(),                USAnniversaries.THANKSGIVING.create(1995));        assertEquals(holidays.get(9).getDate(),                USAnniversaries.CHRISTMAS_HOLIDAY.create(1995));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.tz;import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeZone;/** * Test cases for ZoneInfoCompiler. * * @author Brian S O'Neill */public class TestCompiler extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestCompiler.class);    }    static final String AMERICA_LOS_ANGELES_FILE =        "# Rules for building just America/Los_Angeles time zone.\n" +         "\n" +         "Rule    US  1918    1919    -   Mar lastSun 2:00    1:00    D\n" +         "Rule    US  1918    1919    -   Oct lastSun 2:00    0   S\n" +         "Rule    US  1942    only    -   Feb 9   2:00    1:00    W # War\n" +         "Rule    US  1945    only    -   Aug 14  23:00u  1:00    P # Peace\n" +         "Rule    US  1945    only    -   Sep 30  2:00    0   S\n" +         "Rule    US  1967    max -   Oct lastSun 2:00    0   S\n" +         "Rule    US  1967    1973    -   Apr lastSun 2:00    1:00    D\n" +         "Rule    US  1974    only    -   Jan 6   2:00    1:00    D\n" +         "Rule    US  1975    only    -   Feb 23  2:00    1:00    D\n" +         "Rule    US  1976    1986    -   Apr lastSun 2:00    1:00    D\n" +         "Rule    US  1987    max -   Apr Sun>=1  2:00    1:00    D\n" +         "\n" +         "Rule    CA  1948    only    -   Mar 14  2:00    1:00    D\n" +         "Rule    CA  1949    only    -   Jan  1  2:00    0   S\n" +         "Rule    CA  1950    1966    -   Apr lastSun 2:00    1:00    D\n" +         "Rule    CA  1950    1961    -   Sep lastSun 2:00    0   S\n" +         "Rule    CA  1962    1966    -   Oct lastSun 2:00    0   S\n" +         "\n" +         "Zone America/Los_Angeles -7:52:58 - LMT 1883 Nov 18 12:00\n" +         "            -8:00   US  P%sT    1946\n" +         "            -8:00   CA  P%sT    1967\n" +         "            -8:00   US  P%sT";    private DateTimeZone originalDateTimeZone = null;    public TestCompiler(String name) {        super(name);    }    protected void setUp() throws Exception {        originalDateTimeZone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeZone.setDefault(originalDateTimeZone);    }    public void testCompile() throws Exception {        Provider provider = compileAndLoad(AMERICA_LOS_ANGELES_FILE);        DateTimeZone tz = provider.getZone("America/Los_Angeles");        assertEquals("America/Los_Angeles", tz.getID());        assertEquals(false, tz.isFixed());        TestBuilder.testForwardTransitions(tz, TestBuilder.AMERICA_LOS_ANGELES_DATA);        TestBuilder.testReverseTransitions(tz, TestBuilder.AMERICA_LOS_ANGELES_DATA);    }    private Provider compileAndLoad(String data) throws Exception {        File tempDir = createDataFile(data);        File destDir = makeTempDir();        ZoneInfoCompiler.main(new String[] {            "-src", tempDir.getAbsolutePath(),            "-dst", destDir.getAbsolutePath(),            "tzdata"        });        // Mark all files to be deleted on exit.        deleteOnExit(destDir);        return new ZoneInfoProvider(destDir);    }    private File createDataFile(String data) throws IOException {        File tempDir = makeTempDir();        File tempFile = new File(tempDir, "tzdata");        tempFile.deleteOnExit();        InputStream in = new ByteArrayInputStream(data.getBytes("UTF-8"));        FileOutputStream out = new FileOutputStream(tempFile);        byte[] buf = new byte[1000];        int amt;        while ((amt = in.read(buf)) > 0) {            out.write(buf, 0, amt);        }        out.close();        in.close();        return tempDir;    }    private File makeTempDir() {        File tempDir = new File(System.getProperty("java.io.tmpdir"));        tempDir = new File(tempDir, "joda-test-" + (new java.util.Random().nextInt() & 0xffffff));        tempDir.mkdirs();        tempDir.deleteOnExit();        return tempDir;    }    private void deleteOnExit(File tempFile) {        tempFile.deleteOnExit();        if (tempFile.isDirectory()) {            File[] files = tempFile.listFiles();            for (int i=0; i<files.length; i++) {                deleteOnExit(files[i]);            }        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.tz;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;import java.util.Set;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeZone;/** * This class is a JUnit test for UTCProvider. * * @author Stephen Colebourne */public class TestUTCProvider extends TestCase {    private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestUTCProvider.class);    }    public TestUTCProvider(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testClass() throws Exception {        Class cls = UTCProvider.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isPublic(con.getModifiers()));    }    //-----------------------------------------------------------------------    public void testGetAvailableIDs() throws Exception {        Provider p = new UTCProvider();        Set set = p.getAvailableIDs();        assertEquals(1, set.size());        assertEquals("UTC", set.iterator().next());    }    //-----------------------------------------------------------------------    public void testGetZone_String() throws Exception {        Provider p = new UTCProvider();        assertSame(DateTimeZone.UTC, p.getZone("UTC"));        assertEquals(null, p.getZone(null));        assertEquals(null, p.getZone("Europe/London"));        assertEquals(null, p.getZone("Blah"));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.tz;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestUTCProvider.suite());        suite.addTest(TestBuilder.suite());        suite.addTest(TestCompiler.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.tz;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.format.DateTimeFormatter;import org.joda.time.format.DateTimeFormatterBuilder;/** * Test cases for DateTimeZoneBuilder. * * @author Brian S O'Neill */public class TestBuilder extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBuilder.class);    }    static final DateTimeFormatter OFFSET_FORMATTER = new DateTimeFormatterBuilder()        .appendTimeZoneOffset(null, true, 2, 4)        .toFormatter();    // Each row is {transition, nameKey, standardOffset, offset}    static final String[][] AMERICA_LOS_ANGELES_DATA = {        {null,                            "LMT", "-07:52:58", "-07:52:58"},        {"1883-11-18T19:52:58.000Z",      "PST", "-08:00", "-08:00"},        {"1918-03-31T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1918-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1919-03-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1919-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1942-02-09T02:00:00.000-08:00", "PWT", "-08:00", "-07:00"},        {"1945-08-14T23:00:00.000Z",      "PPT", "-08:00", "-07:00"},        {"1945-09-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1948-03-14T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1949-01-01T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1950-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1950-09-24T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1951-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1951-09-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1952-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1952-09-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1953-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1953-09-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1954-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1954-09-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1955-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1955-09-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1956-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1956-09-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1957-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1957-09-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1958-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1958-09-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1959-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1959-09-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1960-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1960-09-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1961-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1961-09-24T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1962-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1962-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1963-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1963-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1964-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1964-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1965-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1965-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1966-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1966-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1967-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1967-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1968-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1968-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1969-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1969-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1970-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1970-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1971-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1971-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1972-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1972-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1973-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1973-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1974-01-06T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1974-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1975-02-23T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1975-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1976-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1976-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1977-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1977-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1978-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1978-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1979-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1979-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1980-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1980-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1981-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1981-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1982-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1982-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1983-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1983-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1984-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1984-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1985-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1985-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1986-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1986-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1987-04-05T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1987-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1988-04-03T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1988-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1989-04-02T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1989-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1990-04-01T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1990-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1991-04-07T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1991-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1992-04-05T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1992-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1993-04-04T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1993-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1994-04-03T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1994-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1995-04-02T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1995-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1996-04-07T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1996-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1997-04-06T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1997-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1998-04-05T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1998-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"1999-04-04T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"1999-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},        {"2000-04-02T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"},        {"2000-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"},    };    static DateTimeZoneBuilder buildAmericaLosAngelesBuilder() {        return new DateTimeZoneBuilder()            .addCutover(-2147483648, 'w', 1, 1, 0, false, 0)            .setStandardOffset(-28378000)            .setFixedSavings("LMT", 0)            .addCutover(1883, 'w', 11, 18, 0, false, 43200000)            .setStandardOffset(-28800000)            .addRecurringSavings("PDT", 3600000, 1918, 1919, 'w',  3, -1, 7, false, 7200000)            .addRecurringSavings("PST",       0, 1918, 1919, 'w', 10, -1, 7, false, 7200000)            .addRecurringSavings("PWT", 3600000, 1942, 1942, 'w',  2,  9, 0, false, 7200000)            .addRecurringSavings("PPT", 3600000, 1945, 1945, 'u',  8, 14, 0, false, 82800000)            .addRecurringSavings("PST",       0, 1945, 1945, 'w',  9, 30, 0, false, 7200000)            .addRecurringSavings("PDT", 3600000, 1948, 1948, 'w',  3, 14, 0, false, 7200000)            .addRecurringSavings("PST",       0, 1949, 1949, 'w',  1,  1, 0, false, 7200000)            .addRecurringSavings("PDT", 3600000, 1950, 1966, 'w',  4, -1, 7, false, 7200000)            .addRecurringSavings("PST",       0, 1950, 1961, 'w',  9, -1, 7, false, 7200000)            .addRecurringSavings("PST",       0, 1962, 1966, 'w', 10, -1, 7, false, 7200000)            .addRecurringSavings("PST",       0, 1967, 2147483647, 'w', 10, -1, 7, false, 7200000)            .addRecurringSavings("PDT", 3600000, 1967, 1973, 'w', 4, -1,  7, false, 7200000)            .addRecurringSavings("PDT", 3600000, 1974, 1974, 'w', 1,  6,  0, false, 7200000)            .addRecurringSavings("PDT", 3600000, 1975, 1975, 'w', 2, 23,  0, false, 7200000)            .addRecurringSavings("PDT", 3600000, 1976, 1986, 'w', 4, -1,  7, false, 7200000)            .addRecurringSavings("PDT", 3600000, 1987, 2147483647, 'w', 4, 1, 7, true, 7200000);    }    static DateTimeZone buildAmericaLosAngeles() {        return buildAmericaLosAngelesBuilder().toDateTimeZone("America/Los_Angeles");    }    private DateTimeZone originalDateTimeZone = null;    public TestBuilder(String name) {        super(name);    }    protected void setUp() throws Exception {        originalDateTimeZone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeZone.setDefault(originalDateTimeZone);    }    public void testID() {        DateTimeZone tz = buildAmericaLosAngeles();        assertEquals("America/Los_Angeles", tz.getID());        assertEquals(false, tz.isFixed());    }    public void testForwardTransitions() {        DateTimeZone tz = buildAmericaLosAngeles();        testForwardTransitions(tz, AMERICA_LOS_ANGELES_DATA);    }    static void testForwardTransitions(DateTimeZone tz, String[][] data) {        long instant = Long.MIN_VALUE;        for (int i=0; i<data.length; i++) {            String[] row = data[i];            long expectedInstant = instant;            if (row[0] != null) {                instant = tz.nextTransition(instant);                expectedInstant = new DateTime(row[0]).getMillis();            }            String expectedKey = row[1];            int expectedStandardOffset = -(int) OFFSET_FORMATTER.parseMillis(row[2]);            int expectedOffset = -(int) OFFSET_FORMATTER.parseMillis(row[3]);            assertEquals(expectedInstant, instant);            assertEquals(expectedKey, tz.getNameKey(instant));            assertEquals(expectedStandardOffset, tz.getStandardOffset(instant));            assertEquals(expectedOffset, tz.getOffset(instant));            // Sample a few instants between transitions.            if (i < data.length - 1) {                long nextInstant = new DateTime(data[i + 1][0]).getMillis();                long span = (nextInstant - instant) / 10;                for (int j=1; j<10; j++) {                    long between = instant + j * span;                    assertEquals(expectedKey, tz.getNameKey(between));                    assertEquals(expectedStandardOffset, tz.getStandardOffset(between));                    assertEquals(expectedOffset, tz.getOffset(between));                }            }        }    }    public void testReverseTransitions() {        DateTimeZone tz = buildAmericaLosAngeles();        testReverseTransitions(tz, AMERICA_LOS_ANGELES_DATA);    }    static void testReverseTransitions(DateTimeZone tz, String[][] data) {        long instant = new DateTime(data[data.length - 1][0]).getMillis();        for (int i=data.length; --i>=1; ) {            String[] row = data[i];            String[] prevRow = data[i - 1];            instant = tz.previousTransition(instant);            long expectedInstant = new DateTime(row[0]).getMillis() - 1;            String expectedKey = prevRow[1];            int expectedStandardOffset = -(int) OFFSET_FORMATTER.parseMillis(prevRow[2]);            int expectedOffset = -(int) OFFSET_FORMATTER.parseMillis(prevRow[3]);            assertEquals(expectedInstant, instant);            assertEquals(expectedKey, tz.getNameKey(instant));            assertEquals(expectedStandardOffset, tz.getStandardOffset(instant));            assertEquals(expectedOffset, tz.getOffset(instant));        }    }    public void testSerialization() throws IOException {        DateTimeZone tz = testSerialization            (buildAmericaLosAngelesBuilder(), "America/Los_Angeles");        assertEquals(false, tz.isFixed());        testForwardTransitions(tz, AMERICA_LOS_ANGELES_DATA);        testReverseTransitions(tz, AMERICA_LOS_ANGELES_DATA);    }    static DateTimeZone testSerialization(DateTimeZoneBuilder builder, String id)        throws IOException    {        ByteArrayOutputStream out = new ByteArrayOutputStream();        builder.writeTo(out);        ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());        DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);        assertEquals(id, tz.getID());        return tz;    }    public void testFixed() throws IOException {        DateTimeZoneBuilder builder = new DateTimeZoneBuilder()            .setStandardOffset(3600000)            .setFixedSavings("LMT", 0);        DateTimeZone tz = builder.toDateTimeZone("Test");        for (int i=0; i<2; i++) {            assertEquals("Test", tz.getID());            assertEquals(true, tz.isFixed());            assertEquals(3600000, tz.getOffset(0));            assertEquals(3600000, tz.getStandardOffset(0));            assertEquals(0, tz.nextTransition(0));            assertEquals(0, tz.previousTransition(0));            tz = testSerialization(builder, "Test");        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import java.util.Arrays;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.TimeOfDay;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for PreciseDateTimeField. * * @author Stephen Colebourne */public class TestOffsetDateTimeField extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestOffsetDateTimeField.class);    }    public TestOffsetDateTimeField(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_constructor1() {        OffsetDateTimeField field = new OffsetDateTimeField(            ISOChronology.getInstance().secondOfMinute(), 3        );        assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());        assertEquals(3, field.getOffset());                try {            field = new OffsetDateTimeField(null, 3);            fail();        } catch (IllegalArgumentException ex) {}                try {            field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), 0);            fail();        } catch (IllegalArgumentException ex) {}                try {            field = new OffsetDateTimeField(UnsupportedDateTimeField.getInstance(                DateTimeFieldType.secondOfMinute(), UnsupportedDurationField.getInstance(DurationFieldType.seconds())), 0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void test_constructor2() {        OffsetDateTimeField field = new OffsetDateTimeField(            ISOChronology.getInstance().secondOfMinute(), DateTimeFieldType.secondOfDay(), 3        );        assertEquals(DateTimeFieldType.secondOfDay(), field.getType());        assertEquals(3, field.getOffset());                try {            field = new OffsetDateTimeField(null, DateTimeFieldType.secondOfDay(), 3);            fail();        } catch (IllegalArgumentException ex) {}                try {            field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), null, 3);            fail();        } catch (IllegalArgumentException ex) {}                try {            field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), DateTimeFieldType.secondOfDay(), 0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void test_getType() {        OffsetDateTimeField field = new OffsetDateTimeField(            ISOChronology.getInstance().secondOfMinute(), 3        );        assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());    }    public void test_getName() {        OffsetDateTimeField field = new OffsetDateTimeField(            ISOChronology.getInstance().secondOfMinute(), 3        );        assertEquals("secondOfMinute", field.getName());    }    public void test_toString() {        OffsetDateTimeField field = new OffsetDateTimeField(            ISOChronology.getInstance().secondOfMinute(), 3        );        assertEquals("DateTimeField[secondOfMinute]", field.toString());    }    public void test_isSupported() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(true, field.isSupported());    }    public void test_isLenient() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(false, field.isLenient());    }    public void test_getOffset() {        OffsetDateTimeField field = new OffsetDateTimeField(            ISOChronology.getInstance().secondOfMinute(), 5        );        assertEquals(5, field.getOffset());    }    public void test_get() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(0 + 3, field.get(0));        assertEquals(6 + 3, field.get(6000));    }    //-----------------------------------------------------------------------    public void test_getAsText_long_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("32", field.getAsText(1000L * 29, Locale.ENGLISH));        assertEquals("32", field.getAsText(1000L * 29, null));    }    public void test_getAsText_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("32", field.getAsText(1000L * 29));    }    public void test_getAsText_RP_int_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsText_RP_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsText_int_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("80", field.getAsText(80, Locale.ENGLISH));        assertEquals("80", field.getAsText(80, null));    }    //-----------------------------------------------------------------------    public void test_getAsShortText_long_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("32", field.getAsShortText(1000L * 29, Locale.ENGLISH));        assertEquals("32", field.getAsShortText(1000L * 29, null));    }    public void test_getAsShortText_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("32", field.getAsShortText(1000L * 29));    }    public void test_getAsShortText_RP_int_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsShortText_RP_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsShortText_int_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals("80", field.getAsShortText(80, Locale.ENGLISH));        assertEquals("80", field.getAsShortText(80, null));    }    //-----------------------------------------------------------------------    public void test_add_long_int() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(1001, field.add(1L, 1));    }    public void test_add_long_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(1001, field.add(1L, 1L));    }    public void test_add_RP_int_intarray_int() {        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        OffsetDateTimeField field = new MockStandardDateTimeField();        int[] result = field.add(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 31, 40};        result = field.add(new TimeOfDay(), 2, values, 1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 62, 40};        result = field.add(new TimeOfDay(), 2, values, 32);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 21, 3, 40};        result = field.add(new TimeOfDay(), 2, values, 33);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {23, 59, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, 33);            fail();        } catch (IllegalArgumentException ex) {}                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.add(new TimeOfDay(), 2, values, -1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 19, 59, 40};        result = field.add(new TimeOfDay(), 2, values, -31);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {0, 0, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, -31);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void test_addWrapField_long_int() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(29 * 1000L, field.addWrapField(1000L * 29, 0));        assertEquals(59 * 1000L, field.addWrapField(1000L * 29, 30));        assertEquals(0L, field.addWrapField(1000L * 29, 31));    }    public void test_addWrapField_RP_int_intarray_int() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 59, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 3, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 33);        assertEquals(true, Arrays.equals(result, expected));    }    //-----------------------------------------------------------------------    public void test_getDifference_long_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(-21, field.getDifference(20000L, 41000L));    }    public void test_getDifferenceAsLong_long_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(-21L, field.getDifferenceAsLong(20000L, 41000L));    }    //-----------------------------------------------------------------------    public void test_set_long_int() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(3120L, field.set(2120L, 6));        assertEquals(26120L, field.set(120L, 29));        assertEquals(57120L, field.set(2120L, 60));    }    public void test_set_RP_int_intarray_int() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, 63);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, 2);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_set_long_String_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(3050L, field.set(50L, "6", null));        assertEquals(26050L, field.set(50L, "29", Locale.ENGLISH));    }    public void test_set_long_String() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(3050L, field.set(50L, "6"));        assertEquals(26050L, field.set(50L, "29"));    }    public void test_set_RP_int_intarray_String_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, "30", null);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "63", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "2", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_convertText() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(0, field.convertText("0", null));        assertEquals(29, field.convertText("29", null));        try {            field.convertText("2A", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            field.convertText(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //------------------------------------------------------------------------//    public abstract DurationField getDurationField();////    public abstract DurationField getRangeDurationField();    public void test_isLeap_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(false, field.isLeap(0L));    }    public void test_getLeapAmount_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(0, field.getLeapAmount(0L));    }    public void test_getLeapDurationField() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(null, field.getLeapDurationField());    }    //-----------------------------------------------------------------------    public void test_getMinimumValue() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(3, field.getMinimumValue());    }    public void test_getMinimumValue_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(3, field.getMinimumValue(0L));    }    public void test_getMinimumValue_RP() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(3, field.getMinimumValue(new TimeOfDay()));    }    public void test_getMinimumValue_RP_intarray() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(3, field.getMinimumValue(new TimeOfDay(), new int[4]));    }    public void test_getMaximumValue() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(62, field.getMaximumValue());    }    public void test_getMaximumValue_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(62, field.getMaximumValue(0L));    }    public void test_getMaximumValue_RP() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(62, field.getMaximumValue(new TimeOfDay()));    }    public void test_getMaximumValue_RP_intarray() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(62, field.getMaximumValue(new TimeOfDay(), new int[4]));    }    //-----------------------------------------------------------------------    public void test_getMaximumTextLength_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));    }    public void test_getMaximumShortTextLength_Locale() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH));    }    //------------------------------------------------------------------------    public void test_roundFloor_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(-2000L, field.roundFloor(-1001L));        assertEquals(-1000L, field.roundFloor(-1000L));        assertEquals(-1000L, field.roundFloor(-999L));        assertEquals(-1000L, field.roundFloor(-1L));        assertEquals(0L, field.roundFloor(0L));        assertEquals(0L, field.roundFloor(1L));        assertEquals(0L, field.roundFloor(499L));        assertEquals(0L, field.roundFloor(500L));        assertEquals(0L, field.roundFloor(501L));        assertEquals(1000L, field.roundFloor(1000L));    }    public void test_roundCeiling_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(-1000L, field.roundCeiling(-1001L));        assertEquals(-1000L, field.roundCeiling(-1000L));        assertEquals(0L, field.roundCeiling(-999L));        assertEquals(0L, field.roundCeiling(-1L));        assertEquals(0L, field.roundCeiling(0L));        assertEquals(1000L, field.roundCeiling(1L));        assertEquals(1000L, field.roundCeiling(499L));        assertEquals(1000L, field.roundCeiling(500L));        assertEquals(1000L, field.roundCeiling(501L));        assertEquals(1000L, field.roundCeiling(1000L));    }    public void test_roundHalfFloor_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(0L, field.roundHalfFloor(0L));        assertEquals(0L, field.roundHalfFloor(499L));        assertEquals(0L, field.roundHalfFloor(500L));        assertEquals(1000L, field.roundHalfFloor(501L));        assertEquals(1000L, field.roundHalfFloor(1000L));    }    public void test_roundHalfCeiling_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(0L, field.roundHalfCeiling(0L));        assertEquals(0L, field.roundHalfCeiling(499L));        assertEquals(1000L, field.roundHalfCeiling(500L));        assertEquals(1000L, field.roundHalfCeiling(501L));        assertEquals(1000L, field.roundHalfCeiling(1000L));    }    public void test_roundHalfEven_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(0L, field.roundHalfEven(0L));        assertEquals(0L, field.roundHalfEven(499L));        assertEquals(0L, field.roundHalfEven(500L));        assertEquals(1000L, field.roundHalfEven(501L));        assertEquals(1000L, field.roundHalfEven(1000L));        assertEquals(1000L, field.roundHalfEven(1499L));        assertEquals(2000L, field.roundHalfEven(1500L));        assertEquals(2000L, field.roundHalfEven(1501L));    }    public void test_remainder_long() {        OffsetDateTimeField field = new MockOffsetDateTimeField();        assertEquals(0L, field.remainder(0L));        assertEquals(499L, field.remainder(499L));        assertEquals(500L, field.remainder(500L));        assertEquals(501L, field.remainder(501L));        assertEquals(0L, field.remainder(1000L));    }    //-----------------------------------------------------------------------    static class MockOffsetDateTimeField extends OffsetDateTimeField {        protected MockOffsetDateTimeField() {            super(ISOChronology.getInstance().secondOfMinute(), 3);        }    }    static class MockStandardDateTimeField extends MockOffsetDateTimeField {        protected MockStandardDateTimeField() {            super();        }        public DurationField getDurationField() {            return ISOChronology.getInstanceUTC().seconds();        }        public DurationField getRangeDurationField() {            return ISOChronology.getInstanceUTC().minutes();        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import junit.framework.TestCase;import junit.framework.TestSuite;/** *  * * @author Brian S O'Neill */public class TestFieldUtils extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestFieldUtils.class);    }    public TestFieldUtils(String name) {        super(name);    }    public void testSafeAddInt() {        assertEquals(0, FieldUtils.safeAdd(0, 0));        assertEquals(5, FieldUtils.safeAdd(2, 3));        assertEquals(-1, FieldUtils.safeAdd(2, -3));        assertEquals(1, FieldUtils.safeAdd(-2, 3));        assertEquals(-5, FieldUtils.safeAdd(-2, -3));        assertEquals(Integer.MAX_VALUE - 1, FieldUtils.safeAdd(Integer.MAX_VALUE, -1));        assertEquals(Integer.MIN_VALUE + 1, FieldUtils.safeAdd(Integer.MIN_VALUE, 1));        assertEquals(-1, FieldUtils.safeAdd(Integer.MIN_VALUE, Integer.MAX_VALUE));        assertEquals(-1, FieldUtils.safeAdd(Integer.MAX_VALUE, Integer.MIN_VALUE));        try {            FieldUtils.safeAdd(Integer.MAX_VALUE, 1);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Integer.MAX_VALUE, 100);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Integer.MAX_VALUE, Integer.MAX_VALUE);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Integer.MIN_VALUE, -1);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Integer.MIN_VALUE, -100);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Integer.MIN_VALUE, Integer.MIN_VALUE);            fail();        } catch (ArithmeticException e) {        }    }    public void testSafeAddLong() {        assertEquals(0L, FieldUtils.safeAdd(0L, 0L));        assertEquals(5L, FieldUtils.safeAdd(2L, 3L));        assertEquals(-1L, FieldUtils.safeAdd(2L, -3L));        assertEquals(1L, FieldUtils.safeAdd(-2L, 3L));        assertEquals(-5L, FieldUtils.safeAdd(-2L, -3L));        assertEquals(Long.MAX_VALUE - 1, FieldUtils.safeAdd(Long.MAX_VALUE, -1L));        assertEquals(Long.MIN_VALUE + 1, FieldUtils.safeAdd(Long.MIN_VALUE, 1L));        assertEquals(-1, FieldUtils.safeAdd(Long.MIN_VALUE, Long.MAX_VALUE));        assertEquals(-1, FieldUtils.safeAdd(Long.MAX_VALUE, Long.MIN_VALUE));        try {            FieldUtils.safeAdd(Long.MAX_VALUE, 1L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Long.MAX_VALUE, 100L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Long.MAX_VALUE, Long.MAX_VALUE);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Long.MIN_VALUE, -1L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Long.MIN_VALUE, -100L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeAdd(Long.MIN_VALUE, Long.MIN_VALUE);            fail();        } catch (ArithmeticException e) {        }    }    public void testSafeSubtractLong() {        assertEquals(0L, FieldUtils.safeSubtract(0L, 0L));        assertEquals(-1L, FieldUtils.safeSubtract(2L, 3L));        assertEquals(5L, FieldUtils.safeSubtract(2L, -3L));        assertEquals(-5L, FieldUtils.safeSubtract(-2L, 3L));        assertEquals(1L, FieldUtils.safeSubtract(-2L, -3L));        assertEquals(Long.MAX_VALUE - 1, FieldUtils.safeSubtract(Long.MAX_VALUE, 1L));        assertEquals(Long.MIN_VALUE + 1, FieldUtils.safeSubtract(Long.MIN_VALUE, -1L));        assertEquals(0, FieldUtils.safeSubtract(Long.MIN_VALUE, Long.MIN_VALUE));        assertEquals(0, FieldUtils.safeSubtract(Long.MAX_VALUE, Long.MAX_VALUE));        try {            FieldUtils.safeSubtract(Long.MIN_VALUE, 1L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeSubtract(Long.MIN_VALUE, 100L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeSubtract(Long.MIN_VALUE, Long.MAX_VALUE);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeSubtract(Long.MAX_VALUE, -1L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeSubtract(Long.MAX_VALUE, -100L);            fail();        } catch (ArithmeticException e) {        }        try {            FieldUtils.safeSubtract(Long.MAX_VALUE, Long.MIN_VALUE);            fail();        } catch (ArithmeticException e) {        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for PreciseDurationField. * * @author Stephen Colebourne */public class TestScaledDurationField extends TestCase {        private static final long LONG_INTEGER_MAX = Integer.MAX_VALUE;    private static final int INTEGER_MAX = Integer.MAX_VALUE;    private static final long LONG_MAX = Long.MAX_VALUE;        private ScaledDurationField iField;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestScaledDurationField.class);    }    public TestScaledDurationField(String name) {        super(name);    }    protected void setUp() throws Exception {        DurationField base = MillisDurationField.INSTANCE;        iField = new ScaledDurationField(base, DurationFieldType.minutes(), 90);    }    protected void tearDown() throws Exception {        iField = null;    }    //-----------------------------------------------------------------------    public void test_constructor() {        try {            new ScaledDurationField(null, DurationFieldType.minutes(), 10);            fail();        } catch (IllegalArgumentException ex) {}        try {            new ScaledDurationField(MillisDurationField.INSTANCE, null, 10);            fail();        } catch (IllegalArgumentException ex) {}        try {            new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void test_getScalar() {        assertEquals(90, iField.getScalar());    }    //-----------------------------------------------------------------------    public void test_getType() {        assertEquals(DurationFieldType.minutes(), iField.getType());    }    public void test_getName() {        assertEquals("minutes", iField.getName());    }        public void test_isSupported() {        assertEquals(true, iField.isSupported());    }    public void test_isPrecise() {        assertEquals(true, iField.isPrecise());    }    public void test_getUnitMillis() {        assertEquals(90, iField.getUnitMillis());    }    public void test_toString() {        assertEquals("DurationField[minutes]", iField.toString());    }    //-----------------------------------------------------------------------    public void test_getValue_long() {        assertEquals(0, iField.getValue(0L));        assertEquals(12345678 / 90, iField.getValue(12345678L));        assertEquals(-1234 / 90, iField.getValue(-1234L));        assertEquals(INTEGER_MAX / 90, iField.getValue(LONG_INTEGER_MAX));        try {            iField.getValue(LONG_INTEGER_MAX + 1L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getValueAsLong_long() {        assertEquals(0L, iField.getValueAsLong(0L));        assertEquals(12345678L / 90, iField.getValueAsLong(12345678L));        assertEquals(-1234 / 90L, iField.getValueAsLong(-1234L));        assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 90L + 90L));    }    public void test_getValue_long_long() {        assertEquals(0, iField.getValue(0L, 567L));        assertEquals(12345678 / 90, iField.getValue(12345678L, 567L));        assertEquals(-1234 / 90, iField.getValue(-1234L, 567L));        assertEquals(INTEGER_MAX / 90, iField.getValue(LONG_INTEGER_MAX, 567L));        try {            iField.getValue(LONG_INTEGER_MAX + 1L, 567L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getValueAsLong_long_long() {        assertEquals(0L, iField.getValueAsLong(0L, 567L));        assertEquals(12345678 / 90L, iField.getValueAsLong(12345678L, 567L));        assertEquals(-1234 / 90L, iField.getValueAsLong(-1234L, 567L));        assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 90L + 90L, 567L));    }    //-----------------------------------------------------------------------    public void test_getMillis_int() {        assertEquals(0, iField.getMillis(0));        assertEquals(1234L * 90L, iField.getMillis(1234));        assertEquals(-1234L * 90L, iField.getMillis(-1234));        assertEquals(LONG_INTEGER_MAX * 90L, iField.getMillis(INTEGER_MAX));    }    public void test_getMillis_long() {        assertEquals(0L, iField.getMillis(0L));        assertEquals(1234L * 90L, iField.getMillis(1234L));        assertEquals(-1234L * 90L, iField.getMillis(-1234L));        try {            iField.getMillis(LONG_MAX);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getMillis_int_long() {        assertEquals(0L, iField.getMillis(0, 567L));        assertEquals(1234L * 90L, iField.getMillis(1234, 567L));        assertEquals(-1234L * 90L, iField.getMillis(-1234, 567L));        assertEquals(LONG_INTEGER_MAX * 90L, iField.getMillis(INTEGER_MAX, 567L));    }    public void test_getMillis_long_long() {        assertEquals(0L, iField.getMillis(0L, 567L));        assertEquals(1234L * 90L, iField.getMillis(1234L, 567L));        assertEquals(-1234L * 90L, iField.getMillis(-1234L, 567L));        try {            iField.getMillis(LONG_MAX, 567L);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_add_long_int() {        assertEquals(567L, iField.add(567L, 0));        assertEquals(567L + 1234L * 90L, iField.add(567L, 1234));        assertEquals(567L - 1234L * 90L, iField.add(567L, -1234));        try {            iField.add(LONG_MAX, 1);            fail();        } catch (ArithmeticException ex) {}    }    public void test_add_long_long() {        assertEquals(567L, iField.add(567L, 0L));        assertEquals(567L + 1234L * 90L, iField.add(567L, 1234L));        assertEquals(567L - 1234L * 90L, iField.add(567L, -1234L));        try {            iField.add(LONG_MAX, 1L);            fail();        } catch (ArithmeticException ex) {}        try {            iField.add(1L, LONG_MAX);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_getDifference_long_int() {        assertEquals(0, iField.getDifference(1L, 0L));        assertEquals(567, iField.getDifference(567L * 90L, 0L));        assertEquals(567 - 1234, iField.getDifference(567L * 90L, 1234L * 90L));        assertEquals(567 + 1234, iField.getDifference(567L * 90L, -1234L * 90L));        try {            iField.getDifference(LONG_MAX, -1L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getDifferenceAsLong_long_long() {        assertEquals(0L, iField.getDifferenceAsLong(1L, 0L));        assertEquals(567L, iField.getDifferenceAsLong(567L * 90L, 0L));        assertEquals(567L - 1234L, iField.getDifferenceAsLong(567L * 90L, 1234L * 90L));        assertEquals(567L + 1234L, iField.getDifferenceAsLong(567L * 90L, -1234L * 90L));        try {            iField.getDifferenceAsLong(LONG_MAX, -1L);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_equals() {        assertEquals(true, iField.equals(iField));        assertEquals(false, iField.equals(ISOChronology.getInstance().minutes()));        DurationField dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 2);        assertEquals(false, iField.equals(dummy));        dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 90);        assertEquals(true, iField.equals(dummy));        dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.millis(), 90);        assertEquals(false, iField.equals(dummy));        assertEquals(false, iField.equals(""));        assertEquals(false, iField.equals(null));    }    public void test_hashCode() {        assertEquals(iField.hashCode(), iField.hashCode());        assertEquals(false, iField.hashCode() == ISOChronology.getInstance().minutes().hashCode());        DurationField dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 2);        assertEquals(false, iField.hashCode() == dummy.hashCode());        dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 90);        assertEquals(true, iField.hashCode() == dummy.hashCode());        dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.millis(), 90);        assertEquals(false, iField.hashCode() == dummy.hashCode());    }    //-----------------------------------------------------------------------    public void test_compareTo() {        assertEquals(0, iField.compareTo(iField));        assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes()));        DurationField dummy = new PreciseDurationField(DurationFieldType.minutes(), 0);        assertEquals(1, iField.compareTo(dummy));        try {            iField.compareTo("");            fail();        } catch (ClassCastException ex) {}        try {            iField.compareTo(null);            fail();        } catch (NullPointerException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DurationField test = iField;                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DurationField result = (DurationField) ois.readObject();        ois.close();                assertEquals(test, result);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for PeriodFormatterBuilder. * * @author Stephen Colebourne */public class TestMillisDurationField extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMillisDurationField.class);    }    public TestMillisDurationField(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_getType() {        assertEquals(DurationFieldType.millis(), MillisDurationField.INSTANCE.getType());    }    public void test_getName() {        assertEquals("millis", MillisDurationField.INSTANCE.getName());    }        public void test_isSupported() {        assertEquals(true, MillisDurationField.INSTANCE.isSupported());    }    public void test_isPrecise() {        assertEquals(true, MillisDurationField.INSTANCE.isPrecise());    }    public void test_getUnitMillis() {        assertEquals(1, MillisDurationField.INSTANCE.getUnitMillis());    }    public void test_toString() {        assertEquals("DurationField[millis]", MillisDurationField.INSTANCE.toString());    }        //-----------------------------------------------------------------------    public void test_getValue_long() {        assertEquals(0, MillisDurationField.INSTANCE.getValue(0L));        assertEquals(1234, MillisDurationField.INSTANCE.getValue(1234L));        assertEquals(-1234, MillisDurationField.INSTANCE.getValue(-1234L));        try {            MillisDurationField.INSTANCE.getValue(((long) (Integer.MAX_VALUE)) + 1L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getValueAsLong_long() {        assertEquals(0L, MillisDurationField.INSTANCE.getValueAsLong(0L));        assertEquals(1234L, MillisDurationField.INSTANCE.getValueAsLong(1234L));        assertEquals(-1234L, MillisDurationField.INSTANCE.getValueAsLong(-1234L));        assertEquals(((long) (Integer.MAX_VALUE)) + 1L, MillisDurationField.INSTANCE.getValueAsLong(((long) (Integer.MAX_VALUE)) + 1L));    }    public void test_getValue_long_long() {        assertEquals(0, MillisDurationField.INSTANCE.getValue(0L, 567L));        assertEquals(1234, MillisDurationField.INSTANCE.getValue(1234L, 567L));        assertEquals(-1234, MillisDurationField.INSTANCE.getValue(-1234L, 567L));        try {            MillisDurationField.INSTANCE.getValue(((long) (Integer.MAX_VALUE)) + 1L, 567L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getValueAsLong_long_long() {        assertEquals(0L, MillisDurationField.INSTANCE.getValueAsLong(0L, 567L));        assertEquals(1234L, MillisDurationField.INSTANCE.getValueAsLong(1234L, 567L));        assertEquals(-1234L, MillisDurationField.INSTANCE.getValueAsLong(-1234L, 567L));        assertEquals(((long) (Integer.MAX_VALUE)) + 1L, MillisDurationField.INSTANCE.getValueAsLong(((long) (Integer.MAX_VALUE)) + 1L, 567L));    }    //-----------------------------------------------------------------------    public void test_getMillis_int() {        assertEquals(0, MillisDurationField.INSTANCE.getMillis(0));        assertEquals(1234, MillisDurationField.INSTANCE.getMillis(1234));        assertEquals(-1234, MillisDurationField.INSTANCE.getMillis(-1234));    }    public void test_getMillis_long() {        assertEquals(0L, MillisDurationField.INSTANCE.getMillis(0L));        assertEquals(1234L, MillisDurationField.INSTANCE.getMillis(1234L));        assertEquals(-1234L, MillisDurationField.INSTANCE.getMillis(-1234L));    }    public void test_getMillis_int_long() {        assertEquals(0, MillisDurationField.INSTANCE.getMillis(0, 567L));        assertEquals(1234, MillisDurationField.INSTANCE.getMillis(1234, 567L));        assertEquals(-1234, MillisDurationField.INSTANCE.getMillis(-1234, 567L));    }    public void test_getMillis_long_long() {        assertEquals(0L, MillisDurationField.INSTANCE.getMillis(0L, 567L));        assertEquals(1234L, MillisDurationField.INSTANCE.getMillis(1234L, 567L));        assertEquals(-1234L, MillisDurationField.INSTANCE.getMillis(-1234L, 567L));    }    //-----------------------------------------------------------------------    public void test_add_long_int() {        assertEquals(567L, MillisDurationField.INSTANCE.add(567L, 0));        assertEquals(567L + 1234L, MillisDurationField.INSTANCE.add(567L, 1234));        assertEquals(567L - 1234L, MillisDurationField.INSTANCE.add(567L, -1234));        try {            MillisDurationField.INSTANCE.add(Long.MAX_VALUE, 1);            fail();        } catch (ArithmeticException ex) {}    }    public void test_add_long_long() {        assertEquals(567L, MillisDurationField.INSTANCE.add(567L, 0L));        assertEquals(567L + 1234L, MillisDurationField.INSTANCE.add(567L, 1234L));        assertEquals(567L - 1234L, MillisDurationField.INSTANCE.add(567L, -1234L));        try {            MillisDurationField.INSTANCE.add(Long.MAX_VALUE, 1L);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_getDifference_long_int() {        assertEquals(567, MillisDurationField.INSTANCE.getDifference(567L, 0L));        assertEquals(567 - 1234, MillisDurationField.INSTANCE.getDifference(567L, 1234L));        assertEquals(567 + 1234, MillisDurationField.INSTANCE.getDifference(567L, -1234L));        try {            MillisDurationField.INSTANCE.getDifference(Long.MAX_VALUE, 1L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getDifferenceAsLong_long_long() {        assertEquals(567L, MillisDurationField.INSTANCE.getDifferenceAsLong(567L, 0L));        assertEquals(567L - 1234L, MillisDurationField.INSTANCE.getDifferenceAsLong(567L, 1234L));        assertEquals(567L + 1234L, MillisDurationField.INSTANCE.getDifferenceAsLong(567L, -1234L));        try {            MillisDurationField.INSTANCE.getDifferenceAsLong(Long.MAX_VALUE, -1L);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_compareTo() {        assertEquals(0, MillisDurationField.INSTANCE.compareTo(MillisDurationField.INSTANCE));        assertEquals(-1, MillisDurationField.INSTANCE.compareTo(ISOChronology.getInstance().seconds()));        DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);        assertEquals(1, MillisDurationField.INSTANCE.compareTo(dummy));        try {            MillisDurationField.INSTANCE.compareTo("");            fail();        } catch (ClassCastException ex) {}        try {            MillisDurationField.INSTANCE.compareTo(null);            fail();        } catch (NullPointerException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DurationField test = MillisDurationField.INSTANCE;                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DurationField result = (DurationField) ois.readObject();        ois.close();                assertSame(test, result);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for PreciseDurationField. * * @author Stephen Colebourne */public class TestPreciseDurationField extends TestCase {        private static final long LONG_INTEGER_MAX = Integer.MAX_VALUE;    private static final int INTEGER_MAX = Integer.MAX_VALUE;    private static final long LONG_MAX = Long.MAX_VALUE;        private PreciseDurationField iField;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPreciseDurationField.class);    }    public TestPreciseDurationField(String name) {        super(name);    }    protected void setUp() throws Exception {        iField = new PreciseDurationField(DurationFieldType.seconds(), 1000);    }    protected void tearDown() throws Exception {        iField = null;    }    //-----------------------------------------------------------------------    public void test_constructor() {        try {            new PreciseDurationField(null, 10);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void test_getType() {        assertEquals(DurationFieldType.seconds(), iField.getType());    }    public void test_getName() {        assertEquals("seconds", iField.getName());    }        public void test_isSupported() {        assertEquals(true, iField.isSupported());    }    public void test_isPrecise() {        assertEquals(true, iField.isPrecise());    }    public void test_getUnitMillis() {        assertEquals(1000, iField.getUnitMillis());    }    public void test_toString() {        assertEquals("DurationField[seconds]", iField.toString());    }    //-----------------------------------------------------------------------    public void test_getValue_long() {        assertEquals(0, iField.getValue(0L));        assertEquals(12345, iField.getValue(12345678L));        assertEquals(-1, iField.getValue(-1234L));        assertEquals(INTEGER_MAX, iField.getValue(LONG_INTEGER_MAX * 1000L + 999L));        try {            iField.getValue(LONG_INTEGER_MAX * 1000L + 1000L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getValueAsLong_long() {        assertEquals(0L, iField.getValueAsLong(0L));        assertEquals(12345L, iField.getValueAsLong(12345678L));        assertEquals(-1L, iField.getValueAsLong(-1234L));        assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 1000L + 1000L));    }    public void test_getValue_long_long() {        assertEquals(0, iField.getValue(0L, 567L));        assertEquals(12345, iField.getValue(12345678L, 567L));        assertEquals(-1, iField.getValue(-1234L, 567L));        assertEquals(INTEGER_MAX, iField.getValue(LONG_INTEGER_MAX * 1000L + 999L, 567L));        try {            iField.getValue(LONG_INTEGER_MAX * 1000L + 1000L, 567L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getValueAsLong_long_long() {        assertEquals(0L, iField.getValueAsLong(0L, 567L));        assertEquals(12345L, iField.getValueAsLong(12345678L, 567L));        assertEquals(-1L, iField.getValueAsLong(-1234L, 567L));        assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 1000L + 1000L, 567L));    }    //-----------------------------------------------------------------------    public void test_getMillis_int() {        assertEquals(0, iField.getMillis(0));        assertEquals(1234000L, iField.getMillis(1234));        assertEquals(-1234000L, iField.getMillis(-1234));        assertEquals(LONG_INTEGER_MAX * 1000L, iField.getMillis(INTEGER_MAX));    }    public void test_getMillis_long() {        assertEquals(0L, iField.getMillis(0L));        assertEquals(1234000L, iField.getMillis(1234L));        assertEquals(-1234000L, iField.getMillis(-1234L));        try {            iField.getMillis(LONG_MAX);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getMillis_int_long() {        assertEquals(0L, iField.getMillis(0, 567L));        assertEquals(1234000L, iField.getMillis(1234, 567L));        assertEquals(-1234000L, iField.getMillis(-1234, 567L));        assertEquals(LONG_INTEGER_MAX * 1000L, iField.getMillis(INTEGER_MAX, 567L));    }    public void test_getMillis_long_long() {        assertEquals(0L, iField.getMillis(0L, 567L));        assertEquals(1234000L, iField.getMillis(1234L, 567L));        assertEquals(-1234000L, iField.getMillis(-1234L, 567L));        try {            iField.getMillis(LONG_MAX, 567L);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_add_long_int() {        assertEquals(567L, iField.add(567L, 0));        assertEquals(567L + 1234000L, iField.add(567L, 1234));        assertEquals(567L - 1234000L, iField.add(567L, -1234));        try {            iField.add(LONG_MAX, 1);            fail();        } catch (ArithmeticException ex) {}    }    public void test_add_long_long() {        assertEquals(567L, iField.add(567L, 0L));        assertEquals(567L + 1234000L, iField.add(567L, 1234L));        assertEquals(567L - 1234000L, iField.add(567L, -1234L));        try {            iField.add(LONG_MAX, 1L);            fail();        } catch (ArithmeticException ex) {}        try {            iField.add(1L, LONG_MAX);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_getDifference_long_int() {        assertEquals(0, iField.getDifference(1L, 0L));        assertEquals(567, iField.getDifference(567000L, 0L));        assertEquals(567 - 1234, iField.getDifference(567000L, 1234000L));        assertEquals(567 + 1234, iField.getDifference(567000L, -1234000L));        try {            iField.getDifference(LONG_MAX, -1L);            fail();        } catch (ArithmeticException ex) {}    }    public void test_getDifferenceAsLong_long_long() {        assertEquals(0L, iField.getDifferenceAsLong(1L, 0L));        assertEquals(567L, iField.getDifferenceAsLong(567000L, 0L));        assertEquals(567L - 1234L, iField.getDifferenceAsLong(567000L, 1234000L));        assertEquals(567L + 1234L, iField.getDifferenceAsLong(567000L, -1234000L));        try {            iField.getDifferenceAsLong(LONG_MAX, -1L);            fail();        } catch (ArithmeticException ex) {}    }    //-----------------------------------------------------------------------    public void test_equals() {        assertEquals(true, iField.equals(iField));        assertEquals(false, iField.equals(ISOChronology.getInstance().minutes()));        DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);        assertEquals(false, iField.equals(dummy));        dummy = new PreciseDurationField(DurationFieldType.seconds(), 1000);        assertEquals(true, iField.equals(dummy));        dummy = new PreciseDurationField(DurationFieldType.millis(), 1000);        assertEquals(false, iField.equals(dummy));        assertEquals(false, iField.equals(""));        assertEquals(false, iField.equals(null));    }    public void test_hashCode() {        assertEquals(true, iField.hashCode() == iField.hashCode());        assertEquals(false, iField.hashCode() == ISOChronology.getInstance().minutes().hashCode());        DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);        assertEquals(false, iField.hashCode() == dummy.hashCode());        dummy = new PreciseDurationField(DurationFieldType.seconds(), 1000);        assertEquals(true, iField.hashCode() == dummy.hashCode());        dummy = new PreciseDurationField(DurationFieldType.millis(), 1000);        assertEquals(false, iField.hashCode() == dummy.hashCode());    }    //-----------------------------------------------------------------------    public void test_compareTo() {        assertEquals(0, iField.compareTo(iField));        assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes()));        DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);        assertEquals(1, iField.compareTo(dummy));        try {            iField.compareTo("");            fail();        } catch (ClassCastException ex) {}        try {            iField.compareTo(null);            fail();        } catch (NullPointerException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DurationField test = iField;                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DurationField result = (DurationField) ois.readObject();        ois.close();                assertEquals(test, result);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import java.util.Arrays;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.TimeOfDay;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for PreciseDateTimeField. * * @author Stephen Colebourne */public class TestPreciseDateTimeField extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPreciseDateTimeField.class);    }    public TestPreciseDateTimeField(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_constructor() {        BaseDateTimeField field = new PreciseDateTimeField(            DateTimeFieldType.secondOfMinute(),            ISOChronology.getInstanceUTC().millis(),            ISOChronology.getInstanceUTC().hours()        );        assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());        try {            field = new PreciseDateTimeField(null, null, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            field = new PreciseDateTimeField(                DateTimeFieldType.minuteOfHour(),                new MockImpreciseDurationField(DurationFieldType.minutes()),                ISOChronology.getInstanceUTC().hours());            fail();        } catch (IllegalArgumentException ex) {}        try {            field = new PreciseDateTimeField(                DateTimeFieldType.minuteOfHour(),                ISOChronology.getInstanceUTC().hours(),                new MockImpreciseDurationField(DurationFieldType.minutes()));            fail();        } catch (IllegalArgumentException ex) {}        try {            field = new PreciseDateTimeField(                DateTimeFieldType.minuteOfHour(),                ISOChronology.getInstanceUTC().hours(),                ISOChronology.getInstanceUTC().hours());            fail();        } catch (IllegalArgumentException ex) {}        try {            field = new PreciseDateTimeField(                DateTimeFieldType.minuteOfHour(),                new MockZeroDurationField(DurationFieldType.minutes()),                ISOChronology.getInstanceUTC().hours());            fail();        } catch (IllegalArgumentException ex) {}    }    public void test_getType() {        BaseDateTimeField field = new PreciseDateTimeField(            DateTimeFieldType.secondOfDay(),            ISOChronology.getInstanceUTC().millis(),            ISOChronology.getInstanceUTC().hours()        );        assertEquals(DateTimeFieldType.secondOfDay(), field.getType());    }    public void test_getName() {        BaseDateTimeField field = new PreciseDateTimeField(            DateTimeFieldType.secondOfDay(),            ISOChronology.getInstanceUTC().millis(),            ISOChronology.getInstanceUTC().hours()        );        assertEquals("secondOfDay", field.getName());    }    public void test_toString() {        BaseDateTimeField field = new PreciseDateTimeField(            DateTimeFieldType.secondOfDay(),            ISOChronology.getInstanceUTC().millis(),            ISOChronology.getInstanceUTC().hours()        );        assertEquals("DateTimeField[secondOfDay]", field.toString());    }    public void test_isSupported() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(true, field.isSupported());    }    public void test_getRange() {        PreciseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(60, field.getRange());    }    public void test_get() {        PreciseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.get(0));        assertEquals(1, field.get(60));        assertEquals(2, field.get(123));    }    //-----------------------------------------------------------------------    public void test_getAsText_long_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("29", field.getAsText(60L * 29, Locale.ENGLISH));        assertEquals("29", field.getAsText(60L * 29, null));    }    public void test_getAsText_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("29", field.getAsText(60L * 29));    }    public void test_getAsText_RP_int_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsText_RP_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsText_int_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("80", field.getAsText(80, Locale.ENGLISH));        assertEquals("80", field.getAsText(80, null));    }    //-----------------------------------------------------------------------    public void test_getAsShortText_long_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("29", field.getAsShortText(60L * 29, Locale.ENGLISH));        assertEquals("29", field.getAsShortText(60L * 29, null));    }    public void test_getAsShortText_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("29", field.getAsShortText(60L * 29));    }    public void test_getAsShortText_RP_int_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsShortText_RP_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsShortText_int_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals("80", field.getAsShortText(80, Locale.ENGLISH));        assertEquals("80", field.getAsShortText(80, null));    }    //-----------------------------------------------------------------------    public void test_add_long_int() {        MockCountingDurationField.add_int = 0;        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(61, field.add(1L, 1));        assertEquals(1, MockCountingDurationField.add_int);    }    public void test_add_long_long() {        MockCountingDurationField.add_long = 0;        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(61, field.add(1L, 1L));        assertEquals(1, MockCountingDurationField.add_long);    }    public void test_add_RP_int_intarray_int() {        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        BaseDateTimeField field = new MockStandardDateTimeField();        int[] result = field.add(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 31, 40};        result = field.add(new TimeOfDay(), 2, values, 1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 21, 0, 40};        result = field.add(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {23, 59, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, 30);            fail();        } catch (IllegalArgumentException ex) {}                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.add(new TimeOfDay(), 2, values, -1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 19, 59, 40};        result = field.add(new TimeOfDay(), 2, values, -31);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {0, 0, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, -31);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void test_addWrapField_long_int() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(29 * 60L, field.addWrapField(60L * 29, 0));        assertEquals(59 * 60L, field.addWrapField(60L * 29, 30));        assertEquals(0 * 60L, field.addWrapField(60L * 29, 31));    }    public void test_addWrapField_RP_int_intarray_int() {        BaseDateTimeField field = new MockPreciseDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 59, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 0, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 1, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 31);        assertEquals(true, Arrays.equals(result, expected));    }    //-----------------------------------------------------------------------    public void test_getDifference_long_long() {        MockCountingDurationField.difference_long = 0;        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(30, field.getDifference(0L, 0L));        assertEquals(1, MockCountingDurationField.difference_long);    }    public void test_getDifferenceAsLong_long_long() {        MockCountingDurationField.difference_long = 0;        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(30, field.getDifferenceAsLong(0L, 0L));        assertEquals(1, MockCountingDurationField.difference_long);    }    //-----------------------------------------------------------------------    public void test_set_long_int() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.set(120L, 0));        assertEquals(29 * 60, field.set(120L, 29));    }    public void test_set_RP_int_intarray_int() {        BaseDateTimeField field = new MockPreciseDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, -1);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_set_long_String_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.set(0L, "0", null));        assertEquals(29 * 60, field.set(0L, "29", Locale.ENGLISH));    }    public void test_set_long_String() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.set(0L, "0"));        assertEquals(29 * 60, field.set(0L, "29"));    }    public void test_set_RP_int_intarray_String_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, "30", null);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "60", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "-1", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_convertText() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.convertText("0", null));        assertEquals(29, field.convertText("29", null));        try {            field.convertText("2A", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            field.convertText(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //------------------------------------------------------------------------//    public abstract DurationField getDurationField();////    public abstract DurationField getRangeDurationField();    public void test_isLeap_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(false, field.isLeap(0L));    }    public void test_getLeapAmount_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.getLeapAmount(0L));    }    public void test_getLeapDurationField() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(null, field.getLeapDurationField());    }    //-----------------------------------------------------------------------    public void test_getMinimumValue() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.getMinimumValue());    }    public void test_getMinimumValue_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.getMinimumValue(0L));    }    public void test_getMinimumValue_RP() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.getMinimumValue(new TimeOfDay()));    }    public void test_getMinimumValue_RP_intarray() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0, field.getMinimumValue(new TimeOfDay(), new int[4]));    }    public void test_getMaximumValue() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(59, field.getMaximumValue());    }    public void test_getMaximumValue_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(59, field.getMaximumValue(0L));    }    public void test_getMaximumValue_RP() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(59, field.getMaximumValue(new TimeOfDay()));    }    public void test_getMaximumValue_RP_intarray() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(59, field.getMaximumValue(new TimeOfDay(), new int[4]));    }    //-----------------------------------------------------------------------    public void test_getMaximumTextLength_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));    }    public void test_getMaximumShortTextLength_Locale() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH));    }    //------------------------------------------------------------------------    public void test_roundFloor_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(-120L, field.roundFloor(-61L));        assertEquals(-60L, field.roundFloor(-60L));        assertEquals(-60L, field.roundFloor(-59L));        assertEquals(-60L, field.roundFloor(-1L));        assertEquals(0L, field.roundFloor(0L));        assertEquals(0L, field.roundFloor(1L));        assertEquals(0L, field.roundFloor(29L));        assertEquals(0L, field.roundFloor(30L));        assertEquals(0L, field.roundFloor(31L));        assertEquals(60L, field.roundFloor(60L));    }    public void test_roundCeiling_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(-60L, field.roundCeiling(-61L));        assertEquals(-60L, field.roundCeiling(-60L));        assertEquals(0L, field.roundCeiling(-59L));        assertEquals(0L, field.roundCeiling(-1L));        assertEquals(0L, field.roundCeiling(0L));        assertEquals(60L, field.roundCeiling(1L));        assertEquals(60L, field.roundCeiling(29L));        assertEquals(60L, field.roundCeiling(30L));        assertEquals(60L, field.roundCeiling(31L));        assertEquals(60L, field.roundCeiling(60L));    }    public void test_roundHalfFloor_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0L, field.roundHalfFloor(0L));        assertEquals(0L, field.roundHalfFloor(29L));        assertEquals(0L, field.roundHalfFloor(30L));        assertEquals(60L, field.roundHalfFloor(31L));        assertEquals(60L, field.roundHalfFloor(60L));    }    public void test_roundHalfCeiling_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0L, field.roundHalfCeiling(0L));        assertEquals(0L, field.roundHalfCeiling(29L));        assertEquals(60L, field.roundHalfCeiling(30L));        assertEquals(60L, field.roundHalfCeiling(31L));        assertEquals(60L, field.roundHalfCeiling(60L));    }    public void test_roundHalfEven_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0L, field.roundHalfEven(0L));        assertEquals(0L, field.roundHalfEven(29L));        assertEquals(0L, field.roundHalfEven(30L));        assertEquals(60L, field.roundHalfEven(31L));        assertEquals(60L, field.roundHalfEven(60L));        assertEquals(60L, field.roundHalfEven(89L));        assertEquals(120L, field.roundHalfEven(90L));        assertEquals(120L, field.roundHalfEven(91L));    }    public void test_remainder_long() {        BaseDateTimeField field = new MockPreciseDateTimeField();        assertEquals(0L, field.remainder(0L));        assertEquals(29L, field.remainder(29L));        assertEquals(30L, field.remainder(30L));        assertEquals(31L, field.remainder(31L));        assertEquals(0L, field.remainder(60L));    }    //-----------------------------------------------------------------------    static class MockPreciseDateTimeField extends PreciseDateTimeField {        protected MockPreciseDateTimeField() {            super(DateTimeFieldType.secondOfMinute(),                new MockCountingDurationField(DurationFieldType.seconds(), 60),                new MockCountingDurationField(DurationFieldType.minutes(), 60 * 60));        }        protected MockPreciseDateTimeField(                DateTimeFieldType type, DurationField dur, DurationField range) {            super(type, dur, range);        }    }    static class MockStandardDateTimeField extends MockPreciseDateTimeField {        protected MockStandardDateTimeField() {            super();        }        public DurationField getDurationField() {            return ISOChronology.getInstanceUTC().seconds();        }        public DurationField getRangeDurationField() {            return ISOChronology.getInstanceUTC().minutes();        }    }    //-----------------------------------------------------------------------    static class MockCountingDurationField extends BaseDurationField {        static int add_int = 0;        static int add_long = 0;        static int difference_long = 0;        int unit;                protected MockCountingDurationField(DurationFieldType type, int unit) {            super(type);            this.unit = unit;        }        public boolean isPrecise() {            return true;        }        public long getUnitMillis() {            return unit;        }        public long getValueAsLong(long duration, long instant) {            return 0;        }        public long getMillis(int value, long instant) {            return 0;        }        public long getMillis(long value, long instant) {            return 0;        }        public long add(long instant, int value) {            add_int++;            return instant + (value * 60L);        }        public long add(long instant, long value) {            add_long++;            return instant + (value * 60L);        }        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {            difference_long++;            return 30;        }    }    //-----------------------------------------------------------------------    static class MockZeroDurationField extends BaseDurationField {        protected MockZeroDurationField(DurationFieldType type) {            super(type);        }        public boolean isPrecise() {            return true;        }        public long getUnitMillis() {            return 0;  // this is zero        }        public long getValueAsLong(long duration, long instant) {            return 0;        }        public long getMillis(int value, long instant) {            return 0;        }        public long getMillis(long value, long instant) {            return 0;        }        public long add(long instant, int value) {            return 0;        }        public long add(long instant, long value) {            return 0;        }        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {            return 0;        }    }    //-----------------------------------------------------------------------    static class MockImpreciseDurationField extends BaseDurationField {        protected MockImpreciseDurationField(DurationFieldType type) {            super(type);        }        public boolean isPrecise() {            return false;  // this is false        }        public long getUnitMillis() {            return 0;        }        public long getValueAsLong(long duration, long instant) {            return 0;        }        public long getMillis(int value, long instant) {            return 0;        }        public long getMillis(long value, long instant) {            return 0;        }        public long add(long instant, int value) {            return 0;        }        public long add(long instant, long value) {            return 0;        }        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {            return 0;        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Id$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }    public static Test suite() {        TestSuite suite = new TestSuite();                suite.addTest(TestFieldUtils.suite());        suite.addTest(TestBaseDateTimeField.suite());        suite.addTest(TestOffsetDateTimeField.suite());        suite.addTest(TestPreciseDurationDateTimeField.suite());        suite.addTest(TestPreciseDateTimeField.suite());                suite.addTest(TestMillisDurationField.suite());        suite.addTest(TestPreciseDurationField.suite());        suite.addTest(TestScaledDurationField.suite());                return suite;    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import java.util.Arrays;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.TimeOfDay;import org.joda.time.base.BasePartial;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for BaseDateTimeField. * * @author Stephen Colebourne */public class TestBaseDateTimeField extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBaseDateTimeField.class);    }    public TestBaseDateTimeField(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_constructor() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());        try {            field = new MockBaseDateTimeField(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void test_getType() {        BaseDateTimeField field = new MockBaseDateTimeField(DateTimeFieldType.secondOfDay());        assertEquals(DateTimeFieldType.secondOfDay(), field.getType());    }    public void test_getName() {        BaseDateTimeField field = new MockBaseDateTimeField(DateTimeFieldType.secondOfDay());        assertEquals("secondOfDay", field.getName());    }    public void test_toString() {        BaseDateTimeField field = new MockBaseDateTimeField(DateTimeFieldType.secondOfDay());        assertEquals("DateTimeField[secondOfDay]", field.toString());    }    public void test_isSupported() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(true, field.isSupported());    }    public void test_get() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0, field.get(0));        assertEquals(1, field.get(60));        assertEquals(2, field.get(123));    }    //-----------------------------------------------------------------------    public void test_getAsText_long_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("29", field.getAsText(60L * 29, Locale.ENGLISH));        assertEquals("29", field.getAsText(60L * 29, null));    }    public void test_getAsText_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("29", field.getAsText(60L * 29));    }    public void test_getAsText_RP_int_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsText_RP_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsText_int_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("80", field.getAsText(80, Locale.ENGLISH));        assertEquals("80", field.getAsText(80, null));    }    //-----------------------------------------------------------------------    public void test_getAsShortText_long_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("29", field.getAsShortText(60L * 29, Locale.ENGLISH));        assertEquals("29", field.getAsShortText(60L * 29, null));    }    public void test_getAsShortText_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("29", field.getAsShortText(60L * 29));    }    public void test_getAsShortText_RP_int_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsShortText_RP_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsShortText_int_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals("80", field.getAsShortText(80, Locale.ENGLISH));        assertEquals("80", field.getAsShortText(80, null));    }    //-----------------------------------------------------------------------    public void test_add_long_int() {        MockCountingDurationField.add_int = 0;        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(61, field.add(1L, 1));        assertEquals(1, MockCountingDurationField.add_int);    }    public void test_add_long_long() {        MockCountingDurationField.add_long = 0;        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(61, field.add(1L, 1L));        assertEquals(1, MockCountingDurationField.add_long);    }    public void test_add_RP_int_intarray_int() {        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        BaseDateTimeField field = new MockStandardBaseDateTimeField();        int[] result = field.add(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 31, 40};        result = field.add(new TimeOfDay(), 2, values, 1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 21, 0, 40};        result = field.add(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {23, 59, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, 30);            fail();        } catch (IllegalArgumentException ex) {}                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.add(new TimeOfDay(), 2, values, -1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 19, 59, 40};        result = field.add(new TimeOfDay(), 2, values, -31);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {0, 0, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, -31);            fail();        } catch (IllegalArgumentException ex) {}                values = new int[] {0, 0};        try {            field.add(new MockPartial(), 0, values, 1000);            fail();        } catch (IllegalArgumentException ex) {}                values = new int[] {1, 0};        try {            field.add(new MockPartial(), 0, values, -1000);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void test_addWrapField_long_int() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(1029, field.addWrapField(60L * 29, 0));        assertEquals(1059, field.addWrapField(60L * 29, 30));        assertEquals(1000, field.addWrapField(60L * 29, 31));    }    public void test_addWrapField_RP_int_intarray_int() {        BaseDateTimeField field = new MockBaseDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 59, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 0, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 1, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 31);        assertEquals(true, Arrays.equals(result, expected));    }    //-----------------------------------------------------------------------    public void test_getDifference_long_long() {        MockCountingDurationField.difference_long = 0;        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(30, field.getDifference(0L, 0L));        assertEquals(1, MockCountingDurationField.difference_long);    }    public void test_getDifferenceAsLong_long_long() {        MockCountingDurationField.difference_long = 0;        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(30, field.getDifferenceAsLong(0L, 0L));        assertEquals(1, MockCountingDurationField.difference_long);    }    //-----------------------------------------------------------------------    public void test_set_long_int() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(1000, field.set(0L, 0));        assertEquals(1029, field.set(0L, 29));    }    public void test_set_RP_int_intarray_int() {        BaseDateTimeField field = new MockBaseDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, -1);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_set_long_String_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(1000, field.set(0L, "0", null));        assertEquals(1029, field.set(0L, "29", Locale.ENGLISH));    }    public void test_set_long_String() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(1000, field.set(0L, "0"));        assertEquals(1029, field.set(0L, "29"));    }    public void test_set_RP_int_intarray_String_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, "30", null);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "60", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "-1", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_convertText() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0, field.convertText("0", null));        assertEquals(29, field.convertText("29", null));        try {            field.convertText("2A", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            field.convertText(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //------------------------------------------------------------------------//    public abstract DurationField getDurationField();////    public abstract DurationField getRangeDurationField();    public void test_isLeap_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(false, field.isLeap(0L));    }    public void test_getLeapAmount_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0, field.getLeapAmount(0L));    }    public void test_getLeapDurationField() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(null, field.getLeapDurationField());    }    //-----------------------------------------------------------------------    public void test_getMinimumValue() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0, field.getMinimumValue());    }    public void test_getMinimumValue_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0, field.getMinimumValue(0L));    }    public void test_getMinimumValue_RP() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0, field.getMinimumValue(new TimeOfDay()));    }    public void test_getMinimumValue_RP_intarray() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0, field.getMinimumValue(new TimeOfDay(), new int[4]));    }    public void test_getMaximumValue() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(59, field.getMaximumValue());    }    public void test_getMaximumValue_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(59, field.getMaximumValue(0L));    }    public void test_getMaximumValue_RP() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(59, field.getMaximumValue(new TimeOfDay()));    }    public void test_getMaximumValue_RP_intarray() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(59, field.getMaximumValue(new TimeOfDay(), new int[4]));    }    //-----------------------------------------------------------------------    public void test_getMaximumTextLength_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));        field = new MockBaseDateTimeField() {            public int getMaximumValue() {                return 5;            }        };        assertEquals(1, field.getMaximumTextLength(Locale.ENGLISH));                field = new MockBaseDateTimeField() {            public int getMaximumValue() {                return 555;            }        };        assertEquals(3, field.getMaximumTextLength(Locale.ENGLISH));                field = new MockBaseDateTimeField() {            public int getMaximumValue() {                return 5555;            }        };        assertEquals(4, field.getMaximumTextLength(Locale.ENGLISH));                field = new MockBaseDateTimeField() {            public int getMaximumValue() {                return -1;            }        };        assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));    }    public void test_getMaximumShortTextLength_Locale() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH));    }    //------------------------------------------------------------------------    public void test_roundFloor_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0L, field.roundFloor(0L));        assertEquals(0L, field.roundFloor(29L));        assertEquals(0L, field.roundFloor(30L));        assertEquals(0L, field.roundFloor(31L));        assertEquals(60L, field.roundFloor(60L));    }    public void test_roundCeiling_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0L, field.roundCeiling(0L));        assertEquals(60L, field.roundCeiling(29L));        assertEquals(60L, field.roundCeiling(30L));        assertEquals(60L, field.roundCeiling(31L));        assertEquals(60L, field.roundCeiling(60L));    }    public void test_roundHalfFloor_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0L, field.roundHalfFloor(0L));        assertEquals(0L, field.roundHalfFloor(29L));        assertEquals(0L, field.roundHalfFloor(30L));        assertEquals(60L, field.roundHalfFloor(31L));        assertEquals(60L, field.roundHalfFloor(60L));    }    public void test_roundHalfCeiling_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0L, field.roundHalfCeiling(0L));        assertEquals(0L, field.roundHalfCeiling(29L));        assertEquals(60L, field.roundHalfCeiling(30L));        assertEquals(60L, field.roundHalfCeiling(31L));        assertEquals(60L, field.roundHalfCeiling(60L));    }    public void test_roundHalfEven_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0L, field.roundHalfEven(0L));        assertEquals(0L, field.roundHalfEven(29L));        assertEquals(0L, field.roundHalfEven(30L));        assertEquals(60L, field.roundHalfEven(31L));        assertEquals(60L, field.roundHalfEven(60L));        assertEquals(60L, field.roundHalfEven(89L));        assertEquals(120L, field.roundHalfEven(90L));        assertEquals(120L, field.roundHalfEven(91L));    }    public void test_remainder_long() {        BaseDateTimeField field = new MockBaseDateTimeField();        assertEquals(0L, field.remainder(0L));        assertEquals(29L, field.remainder(29L));        assertEquals(30L, field.remainder(30L));        assertEquals(31L, field.remainder(31L));        assertEquals(0L, field.remainder(60L));    }    //-----------------------------------------------------------------------    static class MockBaseDateTimeField extends BaseDateTimeField {        protected MockBaseDateTimeField() {            super(DateTimeFieldType.secondOfMinute());        }        protected MockBaseDateTimeField(DateTimeFieldType type) {            super(type);        }        public int get(long instant) {            return (int) (instant / 60L);        }        public long set(long instant, int value) {            return 1000 + value;        }        public DurationField getDurationField() {            return new MockCountingDurationField(DurationFieldType.seconds());        }        public DurationField getRangeDurationField() {            return new MockCountingDurationField(DurationFieldType.minutes());        }        public int getMinimumValue() {            return 0;        }        public int getMaximumValue() {            return 59;        }        public long roundFloor(long instant) {            return (instant / 60L) * 60L;        }        public boolean isLenient() {            return false;        }    }    static class MockStandardBaseDateTimeField extends MockBaseDateTimeField {        protected MockStandardBaseDateTimeField() {            super();        }        public DurationField getDurationField() {            return ISOChronology.getInstanceUTC().seconds();        }        public DurationField getRangeDurationField() {            return ISOChronology.getInstanceUTC().minutes();        }    }    //-----------------------------------------------------------------------    static class MockCountingDurationField extends BaseDurationField {        static int add_int = 0;        static int add_long = 0;        static int difference_long = 0;                protected MockCountingDurationField(DurationFieldType type) {            super(type);        }        public boolean isPrecise() {            return false;        }        public long getUnitMillis() {            return 0;        }        public long getValueAsLong(long duration, long instant) {            return 0;        }        public long getMillis(int value, long instant) {            return 0;        }        public long getMillis(long value, long instant) {            return 0;        }        public long add(long instant, int value) {            add_int++;            return instant + (value * 60L);        }        public long add(long instant, long value) {            add_long++;            return instant + (value * 60L);        }        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {            difference_long++;            return 30;        }    }    static class MockPartial extends BasePartial {        protected DateTimeField getField(int index, Chronology chrono) {            if (index == 0) {                return ISOChronology.getInstanceUTC().minuteOfHour();            }            if (index == 1) {                return ISOChronology.getInstanceUTC().millisOfSecond();            }            return null;        }        public int size() {            return 2;        }            }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.field;import java.util.Arrays;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.TimeOfDay;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for PreciseDurationDateTimeField. * * @author Stephen Colebourne */public class TestPreciseDurationDateTimeField extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPreciseDurationDateTimeField.class);    }    public TestPreciseDurationDateTimeField(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_constructor() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());        try {            field = new MockPreciseDurationDateTimeField(null, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            field = new MockPreciseDurationDateTimeField(                DateTimeFieldType.minuteOfHour(),                new MockImpreciseDurationField(DurationFieldType.minutes()));            fail();        } catch (IllegalArgumentException ex) {}        try {            field = new MockPreciseDurationDateTimeField(                DateTimeFieldType.minuteOfHour(),                new MockZeroDurationField(DurationFieldType.minutes()));            fail();        } catch (IllegalArgumentException ex) {}    }    public void test_getType() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField(            DateTimeFieldType.secondOfDay(), new MockCountingDurationField(DurationFieldType.minutes()));        assertEquals(DateTimeFieldType.secondOfDay(), field.getType());    }    public void test_getName() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField(            DateTimeFieldType.secondOfDay(), new MockCountingDurationField(DurationFieldType.minutes()));        assertEquals("secondOfDay", field.getName());    }    public void test_toString() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField(            DateTimeFieldType.secondOfDay(), new MockCountingDurationField(DurationFieldType.minutes()));        assertEquals("DateTimeField[secondOfDay]", field.toString());    }    public void test_isSupported() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(true, field.isSupported());    }    public void test_isLenient() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(false, field.isLenient());    }    public void test_get() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.get(0));        assertEquals(1, field.get(60));        assertEquals(2, field.get(123));    }    //-----------------------------------------------------------------------    public void test_getAsText_long_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("29", field.getAsText(60L * 29, Locale.ENGLISH));        assertEquals("29", field.getAsText(60L * 29, null));    }    public void test_getAsText_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("29", field.getAsText(60L * 29));    }    public void test_getAsText_RP_int_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsText_RP_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsText_int_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("80", field.getAsText(80, Locale.ENGLISH));        assertEquals("80", field.getAsText(80, null));    }    //-----------------------------------------------------------------------    public void test_getAsShortText_long_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("29", field.getAsShortText(60L * 29, Locale.ENGLISH));        assertEquals("29", field.getAsShortText(60L * 29, null));    }    public void test_getAsShortText_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("29", field.getAsShortText(60L * 29));    }    public void test_getAsShortText_RP_int_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH));        assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null));    }    public void test_getAsShortText_RP_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH));        assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null));    }    public void test_getAsShortText_int_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals("80", field.getAsShortText(80, Locale.ENGLISH));        assertEquals("80", field.getAsShortText(80, null));    }    //-----------------------------------------------------------------------    public void test_add_long_int() {        MockCountingDurationField.add_int = 0;        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(61, field.add(1L, 1));        assertEquals(1, MockCountingDurationField.add_int);    }    public void test_add_long_long() {        MockCountingDurationField.add_long = 0;        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(61, field.add(1L, 1L));        assertEquals(1, MockCountingDurationField.add_long);    }    public void test_add_RP_int_intarray_int() {        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        BaseDateTimeField field = new MockStandardBaseDateTimeField();        int[] result = field.add(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 31, 40};        result = field.add(new TimeOfDay(), 2, values, 1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 21, 0, 40};        result = field.add(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {23, 59, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, 30);            fail();        } catch (IllegalArgumentException ex) {}                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.add(new TimeOfDay(), 2, values, -1);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 19, 59, 40};        result = field.add(new TimeOfDay(), 2, values, -31);        assertEquals(true, Arrays.equals(expected, result));                values = new int[] {0, 0, 30, 40};        try {            field.add(new TimeOfDay(), 2, values, -31);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void test_addWrapField_long_int() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(29 * 60L, field.addWrapField(60L * 29, 0));        assertEquals(59 * 60L, field.addWrapField(60L * 29, 30));        assertEquals(0 * 60L, field.addWrapField(60L * 29, 31));    }    public void test_addWrapField_RP_int_intarray_int() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 59, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 0, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 1, 40};        result = field.addWrapField(new TimeOfDay(), 2, values, 31);        assertEquals(true, Arrays.equals(result, expected));    }    //-----------------------------------------------------------------------    public void test_getDifference_long_long() {        MockCountingDurationField.difference_long = 0;        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(30, field.getDifference(0L, 0L));        assertEquals(1, MockCountingDurationField.difference_long);    }    public void test_getDifferenceAsLong_long_long() {        MockCountingDurationField.difference_long = 0;        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(30, field.getDifferenceAsLong(0L, 0L));        assertEquals(1, MockCountingDurationField.difference_long);    }    //-----------------------------------------------------------------------    public void test_set_long_int() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.set(120L, 0));        assertEquals(29 * 60, field.set(120L, 29));    }    public void test_set_RP_int_intarray_int() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, 30);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, 29);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, -1);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_set_long_String_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.set(0L, "0", null));        assertEquals(29 * 60, field.set(0L, "29", Locale.ENGLISH));    }    public void test_set_long_String() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.set(0L, "0"));        assertEquals(29 * 60, field.set(0L, "29"));    }    public void test_set_RP_int_intarray_String_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        int[] values = new int[] {10, 20, 30, 40};        int[] expected = new int[] {10, 20, 30, 40};        int[] result = field.set(new TimeOfDay(), 2, values, "30", null);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 29, 40};        result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH);        assertEquals(true, Arrays.equals(result, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "60", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));                values = new int[] {10, 20, 30, 40};        expected = new int[] {10, 20, 30, 40};        try {            field.set(new TimeOfDay(), 2, values, "-1", null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, Arrays.equals(values, expected));    }    public void test_convertText() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.convertText("0", null));        assertEquals(29, field.convertText("29", null));        try {            field.convertText("2A", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            field.convertText(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //------------------------------------------------------------------------//    public abstract DurationField getDurationField();////    public abstract DurationField getRangeDurationField();    public void test_isLeap_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(false, field.isLeap(0L));    }    public void test_getLeapAmount_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.getLeapAmount(0L));    }    public void test_getLeapDurationField() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(null, field.getLeapDurationField());    }    //-----------------------------------------------------------------------    public void test_getMinimumValue() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.getMinimumValue());    }    public void test_getMinimumValue_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.getMinimumValue(0L));    }    public void test_getMinimumValue_RP() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.getMinimumValue(new TimeOfDay()));    }    public void test_getMinimumValue_RP_intarray() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0, field.getMinimumValue(new TimeOfDay(), new int[4]));    }    public void test_getMaximumValue() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(59, field.getMaximumValue());    }    public void test_getMaximumValue_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(59, field.getMaximumValue(0L));    }    public void test_getMaximumValue_RP() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(59, field.getMaximumValue(new TimeOfDay()));    }    public void test_getMaximumValue_RP_intarray() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(59, field.getMaximumValue(new TimeOfDay(), new int[4]));    }    //-----------------------------------------------------------------------    public void test_getMaximumTextLength_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));        field = new MockPreciseDurationDateTimeField() {            public int getMaximumValue() {                return 5;            }        };        assertEquals(1, field.getMaximumTextLength(Locale.ENGLISH));                field = new MockPreciseDurationDateTimeField() {            public int getMaximumValue() {                return 555;            }        };        assertEquals(3, field.getMaximumTextLength(Locale.ENGLISH));                field = new MockPreciseDurationDateTimeField() {            public int getMaximumValue() {                return 5555;            }        };        assertEquals(4, field.getMaximumTextLength(Locale.ENGLISH));                field = new MockPreciseDurationDateTimeField() {            public int getMaximumValue() {                return -1;            }        };        assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));    }    public void test_getMaximumShortTextLength_Locale() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH));    }    //------------------------------------------------------------------------    public void test_roundFloor_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(-120L, field.roundFloor(-61L));        assertEquals(-60L, field.roundFloor(-60L));        assertEquals(-60L, field.roundFloor(-59L));        assertEquals(-60L, field.roundFloor(-1L));        assertEquals(0L, field.roundFloor(0L));        assertEquals(0L, field.roundFloor(1L));        assertEquals(0L, field.roundFloor(29L));        assertEquals(0L, field.roundFloor(30L));        assertEquals(0L, field.roundFloor(31L));        assertEquals(60L, field.roundFloor(60L));    }    public void test_roundCeiling_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(-60L, field.roundCeiling(-61L));        assertEquals(-60L, field.roundCeiling(-60L));        assertEquals(0L, field.roundCeiling(-59L));        assertEquals(0L, field.roundCeiling(-1L));        assertEquals(0L, field.roundCeiling(0L));        assertEquals(60L, field.roundCeiling(1L));        assertEquals(60L, field.roundCeiling(29L));        assertEquals(60L, field.roundCeiling(30L));        assertEquals(60L, field.roundCeiling(31L));        assertEquals(60L, field.roundCeiling(60L));    }    public void test_roundHalfFloor_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0L, field.roundHalfFloor(0L));        assertEquals(0L, field.roundHalfFloor(29L));        assertEquals(0L, field.roundHalfFloor(30L));        assertEquals(60L, field.roundHalfFloor(31L));        assertEquals(60L, field.roundHalfFloor(60L));    }    public void test_roundHalfCeiling_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0L, field.roundHalfCeiling(0L));        assertEquals(0L, field.roundHalfCeiling(29L));        assertEquals(60L, field.roundHalfCeiling(30L));        assertEquals(60L, field.roundHalfCeiling(31L));        assertEquals(60L, field.roundHalfCeiling(60L));    }    public void test_roundHalfEven_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0L, field.roundHalfEven(0L));        assertEquals(0L, field.roundHalfEven(29L));        assertEquals(0L, field.roundHalfEven(30L));        assertEquals(60L, field.roundHalfEven(31L));        assertEquals(60L, field.roundHalfEven(60L));        assertEquals(60L, field.roundHalfEven(89L));        assertEquals(120L, field.roundHalfEven(90L));        assertEquals(120L, field.roundHalfEven(91L));    }    public void test_remainder_long() {        BaseDateTimeField field = new MockPreciseDurationDateTimeField();        assertEquals(0L, field.remainder(0L));        assertEquals(29L, field.remainder(29L));        assertEquals(30L, field.remainder(30L));        assertEquals(31L, field.remainder(31L));        assertEquals(0L, field.remainder(60L));    }    //-----------------------------------------------------------------------    static class MockPreciseDurationDateTimeField extends PreciseDurationDateTimeField {        protected MockPreciseDurationDateTimeField() {            super(DateTimeFieldType.secondOfMinute(),                new MockCountingDurationField(DurationFieldType.seconds()));        }        protected MockPreciseDurationDateTimeField(DateTimeFieldType type, DurationField dur) {            super(type, dur);        }        public int get(long instant) {            return (int) (instant / 60L);        }        public DurationField getRangeDurationField() {            return new MockCountingDurationField(DurationFieldType.minutes());        }        public int getMaximumValue() {            return 59;        }    }    static class MockStandardBaseDateTimeField extends MockPreciseDurationDateTimeField {        protected MockStandardBaseDateTimeField() {            super();        }        public DurationField getDurationField() {            return ISOChronology.getInstanceUTC().seconds();        }        public DurationField getRangeDurationField() {            return ISOChronology.getInstanceUTC().minutes();        }    }    //-----------------------------------------------------------------------    static class MockCountingDurationField extends BaseDurationField {        static int add_int = 0;        static int add_long = 0;        static int difference_long = 0;                protected MockCountingDurationField(DurationFieldType type) {            super(type);        }        public boolean isPrecise() {            return true;        }        public long getUnitMillis() {            return 60;        }        public long getValueAsLong(long duration, long instant) {            return 0;        }        public long getMillis(int value, long instant) {            return 0;        }        public long getMillis(long value, long instant) {            return 0;        }        public long add(long instant, int value) {            add_int++;            return instant + (value * 60L);        }        public long add(long instant, long value) {            add_long++;            return instant + (value * 60L);        }        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {            difference_long++;            return 30;        }    }    //-----------------------------------------------------------------------    static class MockZeroDurationField extends BaseDurationField {        protected MockZeroDurationField(DurationFieldType type) {            super(type);        }        public boolean isPrecise() {            return true;        }        public long getUnitMillis() {            return 0;  // this is zero        }        public long getValueAsLong(long duration, long instant) {            return 0;        }        public long getMillis(int value, long instant) {            return 0;        }        public long getMillis(long value, long instant) {            return 0;        }        public long add(long instant, int value) {            return 0;        }        public long add(long instant, long value) {            return 0;        }        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {            return 0;        }    }    //-----------------------------------------------------------------------    static class MockImpreciseDurationField extends BaseDurationField {        protected MockImpreciseDurationField(DurationFieldType type) {            super(type);        }        public boolean isPrecise() {            return false;  // this is false        }        public long getUnitMillis() {            return 0;        }        public long getValueAsLong(long duration, long instant) {            return 0;        }        public long getMillis(int value, long instant) {            return 0;        }        public long getMillis(long value, long instant) {            return 0;        }        public long add(long instant, int value) {            return 0;        }        public long add(long instant, long value) {            return 0;        }        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {            return 0;        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;import org.joda.time.PeriodType;/** * This class is a Junit unit test for PeriodFormat. * * @author Stephen Colebourne */public class TestPeriodFormat extends TestCase {        private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);    private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());    private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);    private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodFormat.class);    }    public TestPeriodFormat(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testSubclassableConstructor() {        PeriodFormat f = new PeriodFormat() {            // test constructor is protected        };        assertNotNull(f);    }    //-----------------------------------------------------------------------    public void testFormatStandard() {        Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8);        assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat.getDefault().print(p));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;import org.joda.time.PeriodType;/** * This class is a Junit unit test for PeriodFormat. * * @author Stephen Colebourne */public class TestPeriodFormatParsing extends TestCase {    private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);    private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());    private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);    private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L - 1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodFormatParsing.class);    }    public TestPeriodFormatParsing(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testParseStandard1() {        PeriodFormatter parser = PeriodFormat.getDefault();        Period p = parser.parsePeriod("6 years, 3 months and 2 days");        assertEquals(new Period(6, 3, 0, 2, 0, 0, 0, 0), p);    }    public void testParseCustom1() {        PeriodFormatter formatter = new PeriodFormatterBuilder()            .printZeroAlways()            .appendHours()            .appendSuffix(":")            .minimumPrintedDigits(2)            .appendMinutes()            .toFormatter();        Period p;        p = new Period(47, 55, 0, 0);        assertEquals("47:55", formatter.print(p));        assertEquals(p, formatter.parsePeriod("47:55"));        assertEquals(p, formatter.parsePeriod("047:055"));        p = new Period(7, 5, 0, 0);        assertEquals("7:05", formatter.print(p));        assertEquals(p, formatter.parsePeriod("7:05"));        assertEquals(p, formatter.parsePeriod("7:5"));        assertEquals(p, formatter.parsePeriod("07:05"));        p = new Period(0, 5, 0, 0);        assertEquals("0:05", formatter.print(p));        assertEquals(p, formatter.parsePeriod("0:05"));        assertEquals(p, formatter.parsePeriod("0:5"));        assertEquals(p, formatter.parsePeriod("00:005"));        assertEquals(p, formatter.parsePeriod("0:005"));        p = new Period(0, 0, 0, 0);        assertEquals("0:00", formatter.print(p));        assertEquals(p, formatter.parsePeriod("0:00"));        assertEquals(p, formatter.parsePeriod("0:0"));        assertEquals(p, formatter.parsePeriod("00:00"));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.io.CharArrayWriter;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.MutablePeriod;import org.joda.time.Period;import org.joda.time.PeriodType;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Period Formating. * * @author Stephen Colebourne */public class TestPeriodFormatter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York");    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    private PeriodFormatter f = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodFormatter.class);    }    public TestPeriodFormatter(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);        f = ISOPeriodFormat.standard();    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;        f = null;    }    //-----------------------------------------------------------------------    public void testPrint_simple() {        Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", f.print(p));    }    //-----------------------------------------------------------------------    public void testPrint_bufferMethods() throws Exception {        Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);        StringBuffer buf = new StringBuffer();        f.printTo(buf, p);        assertEquals("P1Y2M3W4DT5H6M7.008S", buf.toString());                buf = new StringBuffer();        try {            f.printTo(buf, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPrint_writerMethods() throws Exception {        Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);        CharArrayWriter out = new CharArrayWriter();        f.printTo(out, p);        assertEquals("P1Y2M3W4DT5H6M7.008S", out.toString());                out = new CharArrayWriter();        try {            f.printTo(out, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testWithGetLocaleMethods() {        PeriodFormatter f2 = f.withLocale(Locale.FRENCH);        assertEquals(Locale.FRENCH, f2.getLocale());        assertSame(f2, f2.withLocale(Locale.FRENCH));                f2 = f.withLocale(null);        assertEquals(null, f2.getLocale());        assertSame(f2, f2.withLocale(null));    }    public void testWithGetParseTypeMethods() {        PeriodFormatter f2 = f.withParseType(PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), f2.getParseType());        assertSame(f2, f2.withParseType(PeriodType.dayTime()));                f2 = f.withParseType(null);        assertEquals(null, f2.getParseType());        assertSame(f2, f2.withParseType(null));    }    public void testPrinterParserMethods() {        Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);        PeriodFormatter f2 = new PeriodFormatter(f.getPrinter(), f.getParser());        assertEquals(f.getPrinter(), f2.getPrinter());        assertEquals(f.getParser(), f2.getParser());        assertEquals(true, f2.isPrinter());        assertEquals(true, f2.isParser());        assertNotNull(f2.print(p));        assertNotNull(f2.parsePeriod("P1Y2M3W4DT5H6M7.008S"));                f2 = new PeriodFormatter(f.getPrinter(), null);        assertEquals(f.getPrinter(), f2.getPrinter());        assertEquals(null, f2.getParser());        assertEquals(true, f2.isPrinter());        assertEquals(false, f2.isParser());        assertNotNull(f2.print(p));        try {            assertNotNull(f2.parsePeriod("P1Y2M3W4DT5H6M7.008S"));            fail();        } catch (UnsupportedOperationException ex) {}                f2 = new PeriodFormatter(null, f.getParser());        assertEquals(null, f2.getPrinter());        assertEquals(f.getParser(), f2.getParser());        assertEquals(false, f2.isPrinter());        assertEquals(true, f2.isParser());        try {            f2.print(p);            fail();        } catch (UnsupportedOperationException ex) {}        assertNotNull(f2.parsePeriod("P1Y2M3W4DT5H6M7.008S"));    }    //-----------------------------------------------------------------------    public void testParsePeriod_simple() {        Period expect = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(expect, f.parsePeriod("P1Y2M3W4DT5H6M7.008S"));                try {            f.parsePeriod("ABC");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testParsePeriod_parseType() {        Period expect = new Period(0, 0, 0, 4, 5, 6, 7, 8, PeriodType.dayTime());        assertEquals(expect, f.withParseType(PeriodType.dayTime()).parsePeriod("P4DT5H6M7.008S"));        try {            f.withParseType(PeriodType.dayTime()).parsePeriod("P3W4DT5H6M7.008S");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testParseMutablePeriod_simple() {        MutablePeriod expect = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(expect, f.parseMutablePeriod("P1Y2M3W4DT5H6M7.008S"));                try {            f.parseMutablePeriod("ABC");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testParseInto_simple() {        MutablePeriod expect = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        MutablePeriod result = new MutablePeriod();        assertEquals(20, f.parseInto(result, "P1Y2M3W4DT5H6M7.008S", 0));        assertEquals(expect, result);                try {            f.parseInto(null, "P1Y2M3W4DT5H6M7.008S", 0);            fail();        } catch (IllegalArgumentException ex) {}                assertEquals(~0, f.parseInto(result, "ABC", 0));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.MutableDateTime;import org.joda.time.chrono.ISOChronology;/** * Makes sure that text fields are correct for English. * * @author Brian S O'Neill */public class TestTextFields extends TestCase {    private static final DateTimeZone[] ZONES = {        DateTimeZone.UTC,        DateTimeZone.forID("Europe/Paris"),        DateTimeZone.forID("Europe/London"),        DateTimeZone.forID("Asia/Tokyo"),        DateTimeZone.forID("America/Los_Angeles"),    };    private static final String[] MONTHS = {        null,        "January", "February", "March", "April", "May", "June",        "July", "August", "September", "October", "November", "December"    };    private static final String[] WEEKDAYS = {        null,        "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"    };    private static final String[] HALFDAYS = {        "AM", "PM"    };    private DateTimeZone originalDateTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestTextFields.class);    }    public TestTextFields(String name) {        super(name);    }    protected void setUp() throws Exception {        originalDateTimeZone = DateTimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(ZONES[0]);        Locale.setDefault(Locale.ENGLISH);    }    protected void tearDown() throws Exception {        DateTimeZone.setDefault(originalDateTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testMonthNames_monthStart() {        DateTimeFormatter printer = DateTimeFormat.forPattern("MMMM");        for (int i=0; i<ZONES.length; i++) {            for (int month=1; month<=12; month++) {                DateTime dt = new DateTime(2004, month, 1, 1, 20, 30, 40, ZONES[i]);                String monthText = printer.print(dt);                assertEquals(MONTHS[month], monthText);            }        }    }    public void testMonthNames_monthMiddle() {        DateTimeFormatter printer = DateTimeFormat.forPattern("MMMM");        for (int i=0; i<ZONES.length; i++) {            for (int month=1; month<=12; month++) {                DateTime dt = new DateTime(2004, month, 15, 12, 20, 30, 40, ZONES[i]);                String monthText = printer.print(dt);                assertEquals(MONTHS[month], monthText);            }        }    }    public void testMonthNames_monthEnd() {        DateTimeFormatter printer = DateTimeFormat.forPattern("MMMM");        for (int i=0; i<ZONES.length; i++) {            Chronology chrono = ISOChronology.getInstance(ZONES[i]);            for (int month=1; month<=12; month++) {                DateTime dt = new DateTime(2004, month, 1, 23, 20, 30, 40, chrono);                int lastDay = chrono.dayOfMonth().getMaximumValue(dt.getMillis());                dt = new DateTime(2004, month, lastDay, 23, 20, 30, 40, chrono);                String monthText = printer.print(dt);                assertEquals(MONTHS[month], monthText);            }        }    }    public void testWeekdayNames() {        DateTimeFormatter printer = DateTimeFormat.forPattern("EEEE");        for (int i=0; i<ZONES.length; i++) {            MutableDateTime mdt = new MutableDateTime(2004, 1, 1, 1, 20, 30, 40, ZONES[i]);            for (int day=1; day<=366; day++) {                mdt.setDayOfYear(day);                int weekday = mdt.getDayOfWeek();                String weekdayText = printer.print(mdt);                assertEquals(WEEKDAYS[weekday], weekdayText);            }        }    }    public void testHalfdayNames() {        DateTimeFormatter printer = DateTimeFormat.forPattern("a");        for (int i=0; i<ZONES.length; i++) {            Chronology chrono = ISOChronology.getInstance(ZONES[i]);            MutableDateTime mdt = new MutableDateTime(2004, 5, 30, 0, 20, 30, 40, chrono);            for (int hour=0; hour<24; hour++) {                mdt.setHourOfDay(hour);                int halfday = mdt.get(chrono.halfdayOfDay());                String halfdayText = printer.print(mdt);                assertEquals(HALFDAYS[halfday], halfdayText);            }        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.text.DateFormat;import java.util.Locale;import java.util.SimpleTimeZone;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for DateTimeFormat styles. * * @author Stephen Colebourne */public class TestDateTimeFormatStyle extends TestCase {    private static final Locale UK = Locale.UK;    private static final Locale US = Locale.US;    private static final Locale FRANCE = Locale.FRANCE;    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeFormatStyle.class);    }    public TestDateTimeFormatStyle(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testForStyle_stringLengths() {        try {            DateTimeFormat.forStyle(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forStyle("");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forStyle("S");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forStyle("SSS");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testForStyle_invalidStrings() {        try {            DateTimeFormat.forStyle("AA");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forStyle("--");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forStyle("ss");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForStyle_shortDate() throws Exception {        DateTimeFormatter f = DateTimeFormat.shortDate();        DateTimeFormatter g = DateTimeFormat.forStyle("S-");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateInstance(DateFormat.SHORT, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateInstance(DateFormat.SHORT, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));                DateTime date = new DateTime(                DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).parse(expect));        assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));    }    public void testForStyle_shortTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.shortTime();        DateTimeFormatter g = DateTimeFormat.forStyle("-S");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getTimeInstance(DateFormat.SHORT, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getTimeInstance(DateFormat.SHORT, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getTimeInstance(DateFormat.SHORT, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));                if (TimeZone.getDefault() instanceof SimpleTimeZone) {            // skip test, as it needs historical time zone info        } else {            DateTime date = new DateTime(                DateFormat.getTimeInstance(DateFormat.SHORT, FRANCE).parse(expect));            assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));        }    }    public void testForStyle_shortDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.shortDateTime();        DateTimeFormatter g = DateTimeFormat.forStyle("SS");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));                DateTime date = new DateTime(            DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, FRANCE).parse(expect));        assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));    }    //-----------------------------------------------------------------------    public void testForStyle_mediumDate() throws Exception {        DateTimeFormatter f = DateTimeFormat.mediumDate();        DateTimeFormatter g = DateTimeFormat.forStyle("M-");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateInstance(DateFormat.MEDIUM, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateInstance(DateFormat.MEDIUM, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateInstance(DateFormat.MEDIUM, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_mediumTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.mediumTime();        DateTimeFormatter g = DateTimeFormat.forStyle("-M");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_mediumDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.mediumDateTime();        DateTimeFormatter g = DateTimeFormat.forStyle("MM");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    //-----------------------------------------------------------------------    public void testForStyle_longDate() throws Exception {        DateTimeFormatter f = DateTimeFormat.longDate();        DateTimeFormatter g = DateTimeFormat.forStyle("L-");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateInstance(DateFormat.LONG, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateInstance(DateFormat.LONG, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateInstance(DateFormat.LONG, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_longTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.longTime();        DateTimeFormatter g = DateTimeFormat.forStyle("-L");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getTimeInstance(DateFormat.LONG, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getTimeInstance(DateFormat.LONG, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getTimeInstance(DateFormat.LONG, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_longDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.longDateTime();        DateTimeFormatter g = DateTimeFormat.forStyle("LL");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    //-----------------------------------------------------------------------    public void testForStyle_fullDate() throws Exception {        DateTimeFormatter f = DateTimeFormat.fullDate();        DateTimeFormatter g = DateTimeFormat.forStyle("F-");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateInstance(DateFormat.FULL, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateInstance(DateFormat.FULL, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateInstance(DateFormat.FULL, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_fullTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.fullTime();        DateTimeFormatter g = DateTimeFormat.forStyle("-F");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getTimeInstance(DateFormat.FULL, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getTimeInstance(DateFormat.FULL, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getTimeInstance(DateFormat.FULL, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_fullDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.fullDateTime();        DateTimeFormatter g = DateTimeFormat.forStyle("FF");        assertSame(g, f);        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    //-----------------------------------------------------------------------    public void testForStyle_shortMediumDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.forStyle("SM");        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_shortLongDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.forStyle("SL");        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_shortFullDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.forStyle("SF");        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    //-----------------------------------------------------------------------    public void testForStyle_mediumShortDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.forStyle("MS");        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_mediumLongDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.forStyle("ML");        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }    public void testForStyle_mediumFullDateTime() throws Exception {        DateTimeFormatter f = DateTimeFormat.forStyle("MF");        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, UK).format(dt.toDate());        assertEquals(expect, f.print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, US).format(dt.toDate());        assertEquals(expect, f.withLocale(US).print(dt));        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, FRANCE).format(dt.toDate());        assertEquals(expect, f.withLocale(FRANCE).print(dt));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;import org.joda.time.PeriodType;/** * This class is a Junit unit test for PeriodFormatterBuilder. * * @author Stephen Colebourne */public class TestPeriodFormatterBuilder extends TestCase {        private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);    private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());    private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);    private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;        private PeriodFormatterBuilder builder;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodFormatterBuilder.class);    }    public TestPeriodFormatterBuilder(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);                builder = new PeriodFormatterBuilder();    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFormatYears() {        PeriodFormatter f = builder.appendYears().toFormatter();        assertEquals("1", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatMonths() {        PeriodFormatter f = builder.appendMonths().toFormatter();        assertEquals("2", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatWeeks() {        PeriodFormatter f = builder.appendWeeks().toFormatter();        assertEquals("3", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatDays() {        PeriodFormatter f = builder.appendDays().toFormatter();        assertEquals("4", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatHours() {        PeriodFormatter f = builder.appendHours().toFormatter();        assertEquals("5", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatMinutes() {        PeriodFormatter f = builder.appendMinutes().toFormatter();        assertEquals("6", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSeconds() {        PeriodFormatter f = builder.appendSeconds().toFormatter();        assertEquals("7", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSecondsWithMillis() {        PeriodFormatter f = builder.appendSecondsWithMillis().toFormatter();        Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0);        assertEquals("7.000", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1);        assertEquals("7.001", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 999);        assertEquals("7.999", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1000);        assertEquals("8.000", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1001);        assertEquals("8.001", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, -1);        assertEquals("6.999", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, -7, 1);        assertEquals("-6.999", f.print(p));        assertEquals(6, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, -7, -1);        assertEquals("-7.001", f.print(p));        assertEquals(6, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));    }    public void testFormatSecondsWithOptionalMillis() {        PeriodFormatter f = builder.appendSecondsWithOptionalMillis().toFormatter();        Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0);        assertEquals("7", f.print(p));        assertEquals(1, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1);        assertEquals("7.001", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 999);        assertEquals("7.999", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1000);        assertEquals("8", f.print(p));        assertEquals(1, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, 1001);        assertEquals("8.001", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, 7, -1);        assertEquals("6.999", f.print(p));        assertEquals(5, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, -7, 1);        assertEquals("-6.999", f.print(p));        assertEquals(6, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));                p = new Period(0, 0, 0, 0, 0, 0, -7, -1);        assertEquals("-7.001", f.print(p));        assertEquals(6, f.getPrinter().calculatePrintedLength(p, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));    }    public void testFormatMillis() {        PeriodFormatter f = builder.appendMillis().toFormatter();        assertEquals("8", f.print(PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatMillis3Digit() {        PeriodFormatter f = builder.appendMillis3Digit().toFormatter();        assertEquals("008", f.print(PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    //-----------------------------------------------------------------------    public void testFormatPrefixSimple1() {        PeriodFormatter f = builder.appendPrefix("Years:").appendYears().toFormatter();        assertEquals("Years:1", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrefixSimple2() {        PeriodFormatter f = builder.appendPrefix("Hours:").appendHours().toFormatter();        assertEquals("Hours:5", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrefixSimple3() {        try {            builder.appendPrefix(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormatPrefixPlural1() {        PeriodFormatter f = builder.appendPrefix("Year:", "Years:").appendYears().toFormatter();        assertEquals("Year:1", f.print(PERIOD));        assertEquals(6, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrefixPlural2() {        PeriodFormatter f = builder.appendPrefix("Hour:", "Hours:").appendHours().toFormatter();        assertEquals("Hours:5", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrefixPlural3() {        try {            builder.appendPrefix(null, "");            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendPrefix("", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendPrefix(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testFormatSuffixSimple1() {        PeriodFormatter f = builder.appendYears().appendSuffix(" years").toFormatter();        assertEquals("1 years", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSuffixSimple2() {        PeriodFormatter f = builder.appendHours().appendSuffix(" hours").toFormatter();        assertEquals("5 hours", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSuffixSimple3() {        try {            builder.appendSuffix(null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormatSuffixSimple4() {        try {            builder.appendSuffix(" hours");            fail();        } catch (IllegalStateException ex) {}    }    public void testFormatSuffixPlural1() {        PeriodFormatter f = builder.appendYears().appendSuffix(" year", " years").toFormatter();        assertEquals("1 year", f.print(PERIOD));        assertEquals(6, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSuffixPlural2() {        PeriodFormatter f = builder.appendHours().appendSuffix(" hour", " hours").toFormatter();        assertEquals("5 hours", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSuffixPlural3() {        try {            builder.appendSuffix(null, "");            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendSuffix("", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            builder.appendSuffix(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormatSuffixPlural4() {        try {            builder.appendSuffix(" hour", " hours");            fail();        } catch (IllegalStateException ex) {}    }    //-----------------------------------------------------------------------    public void testFormatPrefixSuffix() {        PeriodFormatter f = builder.appendPrefix("P").appendYears().appendSuffix("Y").toFormatter();        assertEquals("P1Y", f.print(PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    //-----------------------------------------------------------------------    public void testFormatSeparatorSimple() {        PeriodFormatter f = builder.appendYears().appendSeparator("T").appendHours().toFormatter();        assertEquals("1T5", f.print(PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("5", f.print(TIME_PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1", f.print(DATE_PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSeparatorComplex() {        PeriodFormatter f = builder            .appendYears().appendSeparator(", ", " and ")            .appendHours().appendSeparator(", ", " and ")            .appendMinutes().appendSeparator(", ", " and ")            .toFormatter();        assertEquals("1, 5 and 6", f.print(PERIOD));        assertEquals(10, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(3, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("5 and 6", f.print(TIME_PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1", f.print(DATE_PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSeparatorIfFieldsAfter() {        PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsAfter("T").appendHours().toFormatter();        assertEquals("1T5", f.print(PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("T5", f.print(TIME_PERIOD));        assertEquals(2, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1", f.print(DATE_PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatSeparatorIfFieldsBefore() {        PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsBefore("T").appendHours().toFormatter();        assertEquals("1T5", f.print(PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("5", f.print(TIME_PERIOD));        assertEquals(1, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1T", f.print(DATE_PERIOD));        assertEquals(2, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null));    }    //-----------------------------------------------------------------------    public void testFormatLiteral() {        PeriodFormatter f = builder.appendLiteral("HELLO").toFormatter();        assertEquals("HELLO", f.print(PERIOD));        assertEquals(5, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(0, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatAppendFormatter() {        PeriodFormatter base = builder.appendYears().appendLiteral("-").toFormatter();        PeriodFormatter f = new PeriodFormatterBuilder().append(base).appendYears().toFormatter();        assertEquals("1-1", f.print(PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatMinDigits() {        PeriodFormatter f = new PeriodFormatterBuilder().minimumPrintedDigits(4).appendYears().toFormatter();        assertEquals("0001", f.print(PERIOD));        assertEquals(4, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));    }    //-----------------------------------------------------------------------    public void testFormatPrintZeroDefault() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("---0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("---0", f.print(EMPTY_PERIOD));        assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));                // test only last instance of same field is output        f = new PeriodFormatterBuilder()                .appendYears().appendLiteral("-")                .appendYears().toFormatter();        assertEquals("-0", f.print(EMPTY_PERIOD));        assertEquals(2, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrintZeroRarelyLast() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroRarelyLast()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("---0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("---0", f.print(EMPTY_PERIOD));        assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrintZeroRarelyFirst() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroRarelyFirst()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("0---", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("0---", f.print(EMPTY_PERIOD));        assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));        assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrintZeroIfSupported() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroIfSupported()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("0---0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(5, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("0-0-0-0", f.print(EMPTY_PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrintZeroAlways() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroAlways()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("0-0-0-0", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1-0-0-4", f.print(YEAR_DAY_PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("0-0-0-0", f.print(EMPTY_PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));    }    public void testFormatPrintZeroNever() {        PeriodFormatter f =            new PeriodFormatterBuilder()                .printZeroNever()                .appendYears().appendLiteral("-")                .appendMonths().appendLiteral("-")                .appendWeeks().appendLiteral("-")                .appendDays().toFormatter();        assertEquals("1-2-3-4", f.print(PERIOD));        assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));        assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));                assertEquals("---", f.print(EMPTY_YEAR_DAY_PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null));        assertEquals(0, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("1---4", f.print(YEAR_DAY_PERIOD));        assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null));        assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));                assertEquals("---", f.print(EMPTY_PERIOD));        assertEquals(3, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));        assertEquals(0, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.io.CharArrayWriter;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.MutableDateTime;import org.joda.time.ReadablePartial;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for DateTime Formating. * * @author Stephen Colebourne */public class TestDateTimeFormatter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York");    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    private DateTimeFormatter f = null;    private DateTimeFormatter g = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeFormatter.class);    }    public TestDateTimeFormatter(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);        f = new DateTimeFormatterBuilder()                .appendDayOfWeekShortText()                .appendLiteral(' ')                .append(ISODateTimeFormat.dateTimeNoMillis())                .toFormatter();        g = ISODateTimeFormat.dateTimeNoMillis();    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;        f = null;        g = null;    }    //-----------------------------------------------------------------------    public void testPrint_simple() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("Wed 2004-06-09T10:20:30Z", f.print(dt));                dt = dt.withZone(PARIS);        assertEquals("Wed 2004-06-09T12:20:30+02:00", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals("Wed 2004-06-09T06:20:30-04:00", f.print(dt));                dt = dt.withChronology(BUDDHIST_PARIS);        assertEquals("Wed 2547-06-09T12:20:30+02:00", f.print(dt));    }    //-----------------------------------------------------------------------    public void testPrint_locale() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("mer. 2004-06-09T10:20:30Z", f.withLocale(Locale.FRENCH).print(dt));        assertEquals("Wed 2004-06-09T10:20:30Z", f.withLocale(null).print(dt));    }    //-----------------------------------------------------------------------    public void testPrint_zone() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withZone(NEWYORK).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withZone(PARIS).print(dt));        assertEquals("Wed 2004-06-09T10:20:30Z", f.withZone(null).print(dt));                dt = dt.withZone(NEWYORK);        assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withZone(NEWYORK).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withZone(PARIS).print(dt));        assertEquals("Wed 2004-06-09T10:20:30Z", f.withZone(UTC).print(dt));        assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withZone(null).print(dt));    }    //-----------------------------------------------------------------------    public void testPrint_chrono() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).print(dt));        assertEquals("Wed 2547-06-09T12:20:30+02:00", f.withChronology(BUDDHIST_PARIS).print(dt));        assertEquals("Wed 2004-06-09T10:20:30Z", f.withChronology(null).print(dt));                dt = dt.withChronology(BUDDHIST_PARIS);        assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).print(dt));        assertEquals("Wed 2547-06-09T12:20:30+02:00", f.withChronology(BUDDHIST_PARIS).print(dt));        assertEquals("Wed 2004-06-09T10:20:30Z", f.withChronology(ISO_UTC).print(dt));        assertEquals("Wed 2547-06-09T12:20:30+02:00", f.withChronology(null).print(dt));    }    //-----------------------------------------------------------------------    public void testPrint_bufferMethods() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        StringBuffer buf = new StringBuffer();        f.printTo(buf, dt);        assertEquals("Wed 2004-06-09T10:20:30Z", buf.toString());                buf = new StringBuffer();        f.printTo(buf, dt.getMillis());        assertEquals("Wed 2004-06-09T11:20:30+01:00", buf.toString());                buf = new StringBuffer();        ISODateTimeFormat.yearMonthDay().printTo(buf, dt.toYearMonthDay());        assertEquals("2004-06-09", buf.toString());                buf = new StringBuffer();        try {            ISODateTimeFormat.yearMonthDay().printTo(buf, (ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPrint_writerMethods() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        CharArrayWriter out = new CharArrayWriter();        f.printTo(out, dt);        assertEquals("Wed 2004-06-09T10:20:30Z", out.toString());                out = new CharArrayWriter();        f.printTo(out, dt.getMillis());        assertEquals("Wed 2004-06-09T11:20:30+01:00", out.toString());                out = new CharArrayWriter();        ISODateTimeFormat.yearMonthDay().printTo(out, dt.toYearMonthDay());        assertEquals("2004-06-09", out.toString());                out = new CharArrayWriter();        try {            ISODateTimeFormat.yearMonthDay().printTo(out, (ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPrint_chrono_and_zone() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("Wed 2004-06-09T10:20:30Z",                f.withChronology(null).withZone(null).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00",                f.withChronology(ISO_PARIS).withZone(null).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00",                f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));        assertEquals("Wed 2004-06-09T06:20:30-04:00",                f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));        assertEquals("Wed 2004-06-09T06:20:30-04:00",                f.withChronology(null).withZone(NEWYORK).print(dt));                dt = dt.withChronology(ISO_PARIS);        assertEquals("Wed 2004-06-09T12:20:30+02:00",                f.withChronology(null).withZone(null).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00",                f.withChronology(ISO_PARIS).withZone(null).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00",                f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));        assertEquals("Wed 2004-06-09T06:20:30-04:00",                f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));        assertEquals("Wed 2004-06-09T06:20:30-04:00",                f.withChronology(null).withZone(NEWYORK).print(dt));                dt = dt.withChronology(BUDDHIST_PARIS);        assertEquals("Wed 2547-06-09T12:20:30+02:00",                f.withChronology(null).withZone(null).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00",                f.withChronology(ISO_PARIS).withZone(null).print(dt));        assertEquals("Wed 2004-06-09T12:20:30+02:00",                f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));        assertEquals("Wed 2004-06-09T06:20:30-04:00",                f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));        assertEquals("Wed 2547-06-09T06:20:30-04:00",                f.withChronology(null).withZone(NEWYORK).print(dt));    }    public void testWithGetLocale() {        DateTimeFormatter f2 = f.withLocale(Locale.FRENCH);        assertEquals(Locale.FRENCH, f2.getLocale());        assertSame(f2, f2.withLocale(Locale.FRENCH));                f2 = f.withLocale(null);        assertEquals(null, f2.getLocale());        assertSame(f2, f2.withLocale(null));    }    public void testWithGetZone() {        DateTimeFormatter f2 = f.withZone(PARIS);        assertEquals(PARIS, f2.getZone());        assertSame(f2, f2.withZone(PARIS));                f2 = f.withZone(null);        assertEquals(null, f2.getZone());        assertSame(f2, f2.withZone(null));    }    public void testWithGetChronology() {        DateTimeFormatter f2 = f.withChronology(BUDDHIST_PARIS);        assertEquals(BUDDHIST_PARIS, f2.getChronolgy());        assertSame(f2, f2.withChronology(BUDDHIST_PARIS));                f2 = f.withChronology(null);        assertEquals(null, f2.getChronolgy());        assertSame(f2, f2.withChronology(null));    }    public void testWithGetPivotYear() {        DateTimeFormatter f2 = f.withPivotYear(13);        assertEquals(new Integer(13), f2.getPivotYear());        assertSame(f2, f2.withPivotYear(13));                f2 = f.withPivotYear(new Integer(14));        assertEquals(new Integer(14), f2.getPivotYear());        assertSame(f2, f2.withPivotYear(new Integer(14)));                f2 = f.withPivotYear(null);        assertEquals(null, f2.getPivotYear());        assertSame(f2, f2.withPivotYear(null));    }    public void testWithGetOffsetParsedMethods() {        DateTimeFormatter f2 = f;        assertEquals(false, f2.isOffsetParsed());        assertEquals(null, f2.getZone());                f2 = f.withOffsetParsed();        assertEquals(true, f2.isOffsetParsed());        assertEquals(null, f2.getZone());                f2 = f2.withZone(PARIS);        assertEquals(false, f2.isOffsetParsed());        assertEquals(PARIS, f2.getZone());                f2 = f2.withOffsetParsed();        assertEquals(true, f2.isOffsetParsed());        assertEquals(null, f2.getZone());                f2 = f.withOffsetParsed();        assertNotSame(f, f2);        DateTimeFormatter f3 = f2.withOffsetParsed();        assertSame(f2, f3);    }    public void testPrinterParserMethods() {        DateTimeFormatter f2 = new DateTimeFormatter(f.getPrinter(), f.getParser());        assertEquals(f.getPrinter(), f2.getPrinter());        assertEquals(f.getParser(), f2.getParser());        assertEquals(true, f2.isPrinter());        assertEquals(true, f2.isParser());        assertNotNull(f2.print(0L));        assertNotNull(f2.parseDateTime("Thu 1970-01-01T00:00:00Z"));                f2 = new DateTimeFormatter(f.getPrinter(), null);        assertEquals(f.getPrinter(), f2.getPrinter());        assertEquals(null, f2.getParser());        assertEquals(true, f2.isPrinter());        assertEquals(false, f2.isParser());        assertNotNull(f2.print(0L));        try {            f2.parseDateTime("Thu 1970-01-01T00:00:00Z");            fail();        } catch (UnsupportedOperationException ex) {}                f2 = new DateTimeFormatter(null, f.getParser());        assertEquals(null, f2.getPrinter());        assertEquals(f.getParser(), f2.getParser());        assertEquals(false, f2.isPrinter());        assertEquals(true, f2.isParser());        try {            f2.print(0L);            fail();        } catch (UnsupportedOperationException ex) {}        assertNotNull(f2.parseDateTime("Thu 1970-01-01T00:00:00Z"));    }    //-----------------------------------------------------------------------    public void testParseDateTime_simple() {        DateTime expect = null;        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.parseDateTime("2004-06-09T10:20:30Z"));                try {            g.parseDateTime("ABC");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testParseDateTime_zone() {        DateTime expect = null;        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(LONDON).parseDateTime("2004-06-09T10:20:30Z"));                expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(null).parseDateTime("2004-06-09T10:20:30Z"));                expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withZone(PARIS).parseDateTime("2004-06-09T10:20:30Z"));    }    public void testParseDateTime_zone2() {        DateTime expect = null;        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(LONDON).parseDateTime("2004-06-09T06:20:30-04:00"));                expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(null).parseDateTime("2004-06-09T06:20:30-04:00"));                expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withZone(PARIS).parseDateTime("2004-06-09T06:20:30-04:00"));    }    public void testParseDateTime_zone3() {        DateTimeFormatter h = new DateTimeFormatterBuilder()        .append(ISODateTimeFormat.date())        .appendLiteral('T')        .append(ISODateTimeFormat.timeElementParser())        .toFormatter();                DateTime expect = null;        expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);        assertEquals(expect, h.withZone(LONDON).parseDateTime("2004-06-09T10:20:30"));                expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);        assertEquals(expect, h.withZone(null).parseDateTime("2004-06-09T10:20:30"));                expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, PARIS);        assertEquals(expect, h.withZone(PARIS).parseDateTime("2004-06-09T10:20:30"));    }    public void testParseDateTime_simple_precedence() {        DateTime expect = null;        // use correct day of week        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, f.parseDateTime("Wed 2004-06-09T10:20:30Z"));                // use wrong day of week        expect = new DateTime(2004, 6, 7, 11, 20, 30, 0, LONDON);        // DayOfWeek takes precedence, because week < month in length        assertEquals(expect, f.parseDateTime("Mon 2004-06-09T10:20:30Z"));    }    public void testParseDateTime_offsetParsed() {        DateTime expect = null;        expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC);        assertEquals(expect, g.withOffsetParsed().parseDateTime("2004-06-09T10:20:30Z"));                expect = new DateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4));        assertEquals(expect, g.withOffsetParsed().parseDateTime("2004-06-09T06:20:30-04:00"));                expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC);        assertEquals(expect, g.withZone(PARIS).withOffsetParsed().parseDateTime("2004-06-09T10:20:30Z"));        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withOffsetParsed().withZone(PARIS).parseDateTime("2004-06-09T10:20:30Z"));    }    public void testParseDateTime_chrono() {        DateTime expect = null;        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withChronology(ISO_PARIS).parseDateTime("2004-06-09T10:20:30Z"));                expect = new DateTime(2004, 6, 9, 11, 20, 30, 0,LONDON);        assertEquals(expect, g.withChronology(null).parseDateTime("2004-06-09T10:20:30Z"));                expect = new DateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime("2547-06-09T10:20:30Z"));                expect = new DateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime("2004-06-09T10:20:30Z"));    }    //-----------------------------------------------------------------------    public void testParseMutableDateTime_simple() {        MutableDateTime expect = null;        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.parseMutableDateTime("2004-06-09T10:20:30Z"));                try {            g.parseMutableDateTime("ABC");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testParseMutableDateTime_zone() {        MutableDateTime expect = null;        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(LONDON).parseMutableDateTime("2004-06-09T10:20:30Z"));                expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(null).parseMutableDateTime("2004-06-09T10:20:30Z"));                expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withZone(PARIS).parseMutableDateTime("2004-06-09T10:20:30Z"));    }    public void testParseMutableDateTime_zone2() {        MutableDateTime expect = null;        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(LONDON).parseMutableDateTime("2004-06-09T06:20:30-04:00"));                expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, g.withZone(null).parseMutableDateTime("2004-06-09T06:20:30-04:00"));                expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withZone(PARIS).parseMutableDateTime("2004-06-09T06:20:30-04:00"));    }    public void testParseMutableDateTime_zone3() {        DateTimeFormatter h = new DateTimeFormatterBuilder()        .append(ISODateTimeFormat.date())        .appendLiteral('T')        .append(ISODateTimeFormat.timeElementParser())        .toFormatter();                MutableDateTime expect = null;        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);        assertEquals(expect, h.withZone(LONDON).parseMutableDateTime("2004-06-09T10:20:30"));                expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);        assertEquals(expect, h.withZone(null).parseMutableDateTime("2004-06-09T10:20:30"));                expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, PARIS);        assertEquals(expect, h.withZone(PARIS).parseMutableDateTime("2004-06-09T10:20:30"));    }    public void testParseMutableDateTime_simple_precedence() {        MutableDateTime expect = null;        // use correct day of week        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(expect, f.parseDateTime("Wed 2004-06-09T10:20:30Z"));                // use wrong day of week        expect = new MutableDateTime(2004, 6, 7, 11, 20, 30, 0, LONDON);        // DayOfWeek takes precedence, because week < month in length        assertEquals(expect, f.parseDateTime("Mon 2004-06-09T10:20:30Z"));    }    public void testParseMutableDateTime_offsetParsed() {        MutableDateTime expect = null;        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);        assertEquals(expect, g.withOffsetParsed().parseMutableDateTime("2004-06-09T10:20:30Z"));                expect = new MutableDateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4));        assertEquals(expect, g.withOffsetParsed().parseMutableDateTime("2004-06-09T06:20:30-04:00"));                expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);        assertEquals(expect, g.withZone(PARIS).withOffsetParsed().parseMutableDateTime("2004-06-09T10:20:30Z"));        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withOffsetParsed().withZone(PARIS).parseMutableDateTime("2004-06-09T10:20:30Z"));    }    public void testParseMutableDateTime_chrono() {        MutableDateTime expect = null;        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withChronology(ISO_PARIS).parseMutableDateTime("2004-06-09T10:20:30Z"));                expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0,LONDON);        assertEquals(expect, g.withChronology(null).parseMutableDateTime("2004-06-09T10:20:30Z"));                expect = new MutableDateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseMutableDateTime("2547-06-09T10:20:30Z"));                expect = new MutableDateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseMutableDateTime("2004-06-09T10:20:30Z"));    }    //-----------------------------------------------------------------------    public void testParseInto_simple() {        MutableDateTime expect = null;        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        MutableDateTime result = new MutableDateTime(0L);        assertEquals(20, g.parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);                try {            g.parseInto(null, "2004-06-09T10:20:30Z", 0);            fail();        } catch (IllegalArgumentException ex) {}                assertEquals(~0, g.parseInto(result, "ABC", 0));        assertEquals(~10, g.parseInto(result, "2004-06-09", 0));        assertEquals(~13, g.parseInto(result, "XX2004-06-09T", 2));    }    public void testParseInto_zone() {        MutableDateTime expect = null;        MutableDateTime result = null;        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        result = new MutableDateTime(0L);        assertEquals(20, g.withZone(LONDON).parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        result = new MutableDateTime(0L);        assertEquals(20, g.withZone(null).parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        result = new MutableDateTime(0L);        assertEquals(20, g.withZone(PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);    }    public void testParseInto_zone2() {        MutableDateTime expect = null;        MutableDateTime result = null;        expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        result = new MutableDateTime(0L);        assertEquals(25, g.withZone(LONDON).parseInto(result, "2004-06-09T06:20:30-04:00", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        assertEquals(25, g.withZone(null).parseInto(result, "2004-06-09T06:20:30-04:00", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(25, g.withZone(PARIS).parseInto(result, "2004-06-09T06:20:30-04:00", 0));        assertEquals(expect, result);    }    public void testParseInto_zone3() {        DateTimeFormatter h = new DateTimeFormatterBuilder()        .append(ISODateTimeFormat.date())        .appendLiteral('T')        .append(ISODateTimeFormat.timeElementParser())        .toFormatter();                MutableDateTime expect = null;        MutableDateTime result = null;        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);        result = new MutableDateTime(0L);        assertEquals(19, h.withZone(LONDON).parseInto(result, "2004-06-09T10:20:30", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON);        result = new MutableDateTime(0L);        assertEquals(19, h.withZone(null).parseInto(result, "2004-06-09T10:20:30", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, PARIS);        result = new MutableDateTime(0L);        assertEquals(19, h.withZone(PARIS).parseInto(result, "2004-06-09T10:20:30", 0));        assertEquals(expect, result);    }    public void testParseInto_simple_precedence() {        MutableDateTime expect = null;        MutableDateTime result = null;        expect = new MutableDateTime(2004, 6, 7, 11, 20, 30, 0, LONDON);        result = new MutableDateTime(0L);        // DayOfWeek takes precedence, because week < month in length        assertEquals(24, f.parseInto(result, "Mon 2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);    }    public void testParseInto_offsetParsed() {        MutableDateTime expect = null;        MutableDateTime result = null;        expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);        result = new MutableDateTime(0L);        assertEquals(20, g.withOffsetParsed().parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4));        result = new MutableDateTime(0L);        assertEquals(25, g.withOffsetParsed().parseInto(result, "2004-06-09T06:20:30-04:00", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC);        result = new MutableDateTime(0L);        assertEquals(20, g.withZone(PARIS).withOffsetParsed().parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        result = new MutableDateTime(0L);        assertEquals(20, g.withOffsetParsed().withZone(PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);    }    public void testParseInto_chrono() {        MutableDateTime expect = null;        MutableDateTime result = null;        expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        result = new MutableDateTime(0L);        assertEquals(20, g.withChronology(ISO_PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);        result = new MutableDateTime(0L);        assertEquals(20, g.withChronology(null).parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);        result = new MutableDateTime(0L);        assertEquals(20, g.withChronology(BUDDHIST_PARIS).parseInto(result, "2547-06-09T10:20:30Z", 0));        assertEquals(expect, result);                expect = new MutableDateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS);        result = new MutableDateTime(0L);        assertEquals(20, g.withChronology(BUDDHIST_PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0));        assertEquals(expect, result);    }    // Ensure time zone name switches properly at the zone DST transition.    public void testZoneNameNearTransition() {        DateTime inDST_1  = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK);        DateTime inDST_2  = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK);        DateTime onDST    = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK);        DateTime outDST   = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK);        DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK);        DateTimeFormatter fmt = DateTimeFormat.forPattern("yyy-MM-dd HH:mm:ss.S zzzz");        assertEquals("2005-10-30 01:00:00.0 Eastern Daylight Time", fmt.print(inDST_1));        assertEquals("2005-10-30 01:59:59.9 Eastern Daylight Time", fmt.print(inDST_2));        assertEquals("2005-10-30 02:00:00.0 Eastern Standard Time", fmt.print(onDST));        assertEquals("2005-10-30 02:00:00.0 Eastern Standard Time", fmt.print(outDST));        assertEquals("2005-10-30 02:00:01.0 Eastern Standard Time", fmt.print(outDST_2));    }    // Ensure time zone name switches properly at the zone DST transition.    public void testZoneShortNameNearTransition() {        DateTime inDST_1  = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK);        DateTime inDST_2  = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK);        DateTime onDST    = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK);        DateTime outDST   = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK);        DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK);        DateTimeFormatter fmt = DateTimeFormat.forPattern("yyy-MM-dd HH:mm:ss.S z");        assertEquals("2005-10-30 01:00:00.0 EDT", fmt.print(inDST_1));        assertEquals("2005-10-30 01:59:59.9 EDT", fmt.print(inDST_2));        assertEquals("2005-10-30 02:00:00.0 EST", fmt.print(onDST));        assertEquals("2005-10-30 02:00:00.0 EST", fmt.print(outDST));        assertEquals("2005-10-30 02:00:01.0 EST", fmt.print(outDST_2));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.List;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeFieldType;import org.joda.time.Partial;/** * This class is a Junit unit test for ISODateTimeFormat. * * @author Stephen Colebourne */public class TestISODateTimeFormat_Fields extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODateTimeFormat_Fields.class);    }    public TestISODateTimeFormat_Fields(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void testForFields_null() {        try {            ISODateTimeFormat.forFields((Collection) null, true, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForFields_empty() {        try {            ISODateTimeFormat.forFields(new ArrayList(), true, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void testForFields_calBased_YMD() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),                DateTimeFieldType.monthOfYear(),                DateTimeFieldType.dayOfMonth(),        };        int[] values = new int[] {2005, 6, 25};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005-06-25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005-06-25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("20050625", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("20050625", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_calBased_Y() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),        };        int[] values = new int[] {2005};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_calBased_M() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.monthOfYear(),        };        int[] values = new int[] {6};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("--06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("--06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("--06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("--06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_calBased_D() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.dayOfMonth(),        };        int[] values = new int[] {25};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("---25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("---25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("---25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("---25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_calBased_YM() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),                DateTimeFieldType.monthOfYear(),        };        int[] values = new int[] {2005, 6};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005-06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005-06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("2005-06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005-06", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_calBased_MD() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.monthOfYear(),                DateTimeFieldType.dayOfMonth(),        };        int[] values = new int[] {6, 25};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("--06-25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("--06-25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("--0625", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("--0625", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_calBased_YD() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),                DateTimeFieldType.dayOfMonth(),        };        int[] values = new int[] {2005, 25};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005--25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005--25", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void testForFields_weekBased_YWD() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.weekyear(),                DateTimeFieldType.weekOfWeekyear(),                DateTimeFieldType.dayOfWeek(),        };        int[] values = new int[] {2005, 8, 5};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005-W08-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005-W08-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("2005W085", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005W085", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_weekBased_Y() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.weekyear(),        };        int[] values = new int[] {2005};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_weekBased_W() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.weekOfWeekyear(),        };        int[] values = new int[] {8};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("-W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("-W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_weekBased_D() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.dayOfWeek(),        };        int[] values = new int[] {5};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("-W-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-W-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("-W-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-W-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_weekBased_YW() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.weekyear(),                DateTimeFieldType.weekOfWeekyear(),        };        int[] values = new int[] {2005, 8};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005-W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005-W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("2005W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005W08", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_weekBased_WD() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.weekOfWeekyear(),                DateTimeFieldType.dayOfWeek(),        };        int[] values = new int[] {8, 5};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("-W08-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-W08-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("-W085", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-W085", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_weekBased_YD() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.weekyear(),                DateTimeFieldType.dayOfWeek(),        };        int[] values = new int[] {2005, 5};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005-W-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005W-5", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void testForFields_ordinalBased_YD() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),                DateTimeFieldType.dayOfYear(),        };        int[] values = new int[] {2005, 177};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005-177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005-177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("2005177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_ordinalBased_Y() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),        };        int[] values = new int[] {2005};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_ordinalBased_D() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.dayOfYear(),        };        int[] values = new int[] {177};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("-177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("-177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-177", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void testForFields_time_HMSm() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),                DateTimeFieldType.minuteOfHour(),                DateTimeFieldType.secondOfMinute(),                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {10, 20, 30, 40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("10:20:30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10:20:30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("102030.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("102030.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_HMS() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),                DateTimeFieldType.minuteOfHour(),                DateTimeFieldType.secondOfMinute(),        };        int[] values = new int[] {10, 20, 30};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("10:20:30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10:20:30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("102030", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("102030", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_HM() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),                DateTimeFieldType.minuteOfHour(),        };        int[] values = new int[] {10, 20};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("10:20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10:20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("1020", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("1020", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_H() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),        };        int[] values = new int[] {10};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("10", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("10", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("10", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_MSm() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.minuteOfHour(),                DateTimeFieldType.secondOfMinute(),                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {20, 30, 40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("-20:30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-20:30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("-2030.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-2030.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_MS() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.minuteOfHour(),                DateTimeFieldType.secondOfMinute(),        };        int[] values = new int[] {20, 30};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("-20:30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-20:30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("-2030", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-2030", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_M() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.minuteOfHour(),        };        int[] values = new int[] {20};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("-20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("-20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_Sm() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.secondOfMinute(),                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {30, 40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("--30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("--30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("--30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("--30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_S() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.secondOfMinute(),        };        int[] values = new int[] {30};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("--30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("--30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("--30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("--30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_time_m() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("---.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("---.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForFields_time_Hm() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {10, 40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10--.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("10--.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForFields_time_HS() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),                DateTimeFieldType.secondOfMinute(),        };        int[] values = new int[] {10, 30};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10-30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("10-30", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForFields_time_Mm() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.minuteOfHour(),                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {20, 40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("-20-.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("-20-.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForFields_time_HSm() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),                DateTimeFieldType.secondOfMinute(),                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {10, 30, 40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10-30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("10-30.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForFields_time_HMm() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.hourOfDay(),                DateTimeFieldType.minuteOfHour(),                DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {10, 20, 40};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("10:20-.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("1020-.040", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void testForFields_datetime_YMDH() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),                DateTimeFieldType.monthOfYear(),                DateTimeFieldType.dayOfMonth(),                DateTimeFieldType.hourOfDay(),        };        int[] values = new int[] {2005, 6, 25, 12};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("2005-06-25T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005-06-25T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("20050625T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("20050625T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_datetime_DH() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.dayOfMonth(),                DateTimeFieldType.hourOfDay(),        };        int[] values = new int[] {25, 12};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);        assertEquals("---25T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("---25T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, true);        assertEquals("---25T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("---25T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());    }    //-----------------------------------------------------------------------    public void testForFields_datetime_YH() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.year(),                DateTimeFieldType.hourOfDay(),        };        int[] values = new int[] {2005, 12};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("2005T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("2005T12", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForFields_datetime_DM() {        DateTimeFieldType[] fields = new DateTimeFieldType[] {                DateTimeFieldType.dayOfMonth(),                DateTimeFieldType.minuteOfHour(),        };        int[] values = new int[] {25, 20};        List types = new ArrayList(Arrays.asList(fields));        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);        assertEquals("---25T-20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        f = ISODateTimeFormat.forFields(types, false, false);        assertEquals("---25T-20", f.print(new Partial(fields, values)));        assertEquals(0, types.size());                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, true, true);            fail();        } catch (IllegalArgumentException ex) {}                types = new ArrayList(Arrays.asList(fields));        try {            ISODateTimeFormat.forFields(types, false, true);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;import org.joda.time.PeriodType;/** * This class is a Junit unit test for ISOPeriodFormat. * * @author Stephen Colebourne */public class TestISOPeriodFormat extends TestCase {        private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);    private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());    private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);    private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOPeriodFormat.class);    }    public TestISOPeriodFormat(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testSubclassableConstructor() {        ISOPeriodFormat f = new ISOPeriodFormat() {            // test constructor is protected        };        assertNotNull(f);    }    //-----------------------------------------------------------------------    public void testFormatStandard() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", ISOPeriodFormat.standard().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P1Y2M3W4DT5H6M7S", ISOPeriodFormat.standard().print(p));                p = new Period(0);        assertEquals("PT0S", ISOPeriodFormat.standard().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("PT0M", ISOPeriodFormat.standard().print(p));                assertEquals("P1Y4DT5H6M7.008S", ISOPeriodFormat.standard().print(YEAR_DAY_PERIOD));        assertEquals("PT0S", ISOPeriodFormat.standard().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P1Y2M3W4D", ISOPeriodFormat.standard().print(DATE_PERIOD));        assertEquals("PT5H6M7.008S", ISOPeriodFormat.standard().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternate() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P00010204T050607.008", ISOPeriodFormat.alternate().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P00010204T050607", ISOPeriodFormat.alternate().print(p));                p = new Period(0);        assertEquals("P00000000T000000", ISOPeriodFormat.alternate().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P00000000T000000", ISOPeriodFormat.alternate().print(p));                assertEquals("P00010004T050607.008", ISOPeriodFormat.alternate().print(YEAR_DAY_PERIOD));        assertEquals("P00000000T000000", ISOPeriodFormat.alternate().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P00010204T000000", ISOPeriodFormat.alternate().print(DATE_PERIOD));        assertEquals("P00000000T050607.008", ISOPeriodFormat.alternate().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternateExtended() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P0001-02-04T05:06:07.008", ISOPeriodFormat.alternateExtended().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P0001-02-04T05:06:07", ISOPeriodFormat.alternateExtended().print(p));                p = new Period(0);        assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.alternateExtended().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.alternateExtended().print(p));                assertEquals("P0001-00-04T05:06:07.008", ISOPeriodFormat.alternateExtended().print(YEAR_DAY_PERIOD));        assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.alternateExtended().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P0001-02-04T00:00:00", ISOPeriodFormat.alternateExtended().print(DATE_PERIOD));        assertEquals("P0000-00-00T05:06:07.008", ISOPeriodFormat.alternateExtended().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternateWithWeeks() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P0001W0304T050607.008", ISOPeriodFormat.alternateWithWeeks().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P0001W0304T050607", ISOPeriodFormat.alternateWithWeeks().print(p));                p = new Period(0);        assertEquals("P0000W0000T000000", ISOPeriodFormat.alternateWithWeeks().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P0000W0000T000000", ISOPeriodFormat.alternateWithWeeks().print(p));                assertEquals("P0001W0004T050607.008", ISOPeriodFormat.alternateWithWeeks().print(YEAR_DAY_PERIOD));        assertEquals("P0000W0000T000000", ISOPeriodFormat.alternateWithWeeks().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P0001W0304T000000", ISOPeriodFormat.alternateWithWeeks().print(DATE_PERIOD));        assertEquals("P0000W0000T050607.008", ISOPeriodFormat.alternateWithWeeks().print(TIME_PERIOD));    }    //-----------------------------------------------------------------------    public void testFormatAlternateExtendedWithWeeks() {        Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8);        assertEquals("P0001-W03-04T05:06:07.008", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));        p = new Period(1, 2, 3, 4, 5, 6 ,7, 0);        assertEquals("P0001-W03-04T05:06:07", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));                p = new Period(0);        assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());        assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));                assertEquals("P0001-W00-04T05:06:07.008", ISOPeriodFormat.alternateExtendedWithWeeks().print(YEAR_DAY_PERIOD));        assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(EMPTY_YEAR_DAY_PERIOD));        assertEquals("P0001-W03-04T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(DATE_PERIOD));        assertEquals("P0000-W00-00T05:06:07.008", ISOPeriodFormat.alternateExtendedWithWeeks().print(TIME_PERIOD));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for ISODateTimeFormat. * * @author Stephen Colebourne */public class TestISODateTimeFormat extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODateTimeFormat.class);    }    public TestISODateTimeFormat(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testSubclassableConstructor() {        ISODateTimeFormat f = new ISODateTimeFormat() {            // test constructor is protected        };        assertNotNull(f);    }    //-----------------------------------------------------------------------    public void testFormat_date() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09", ISODateTimeFormat.date().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09", ISODateTimeFormat.date().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09", ISODateTimeFormat.date().print(dt));    }    public void testFormat_time() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("10:20:30.040Z", ISODateTimeFormat.time().print(dt));                dt = dt.withZone(LONDON);        assertEquals("11:20:30.040+01:00", ISODateTimeFormat.time().print(dt));                dt = dt.withZone(PARIS);        assertEquals("12:20:30.040+02:00", ISODateTimeFormat.time().print(dt));    }    public void testFormat_timeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("10:20:30Z", ISODateTimeFormat.timeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("11:20:30+01:00", ISODateTimeFormat.timeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("12:20:30+02:00", ISODateTimeFormat.timeNoMillis().print(dt));    }    public void testFormat_tTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("T10:20:30.040Z", ISODateTimeFormat.tTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("T11:20:30.040+01:00", ISODateTimeFormat.tTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("T12:20:30.040+02:00", ISODateTimeFormat.tTime().print(dt));    }    public void testFormat_tTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("T10:20:30Z", ISODateTimeFormat.tTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("T11:20:30+01:00", ISODateTimeFormat.tTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("T12:20:30+02:00", ISODateTimeFormat.tTimeNoMillis().print(dt));    }    public void testFormat_dateTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09T10:20:30.040Z", ISODateTimeFormat.dateTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09T11:20:30.040+01:00", ISODateTimeFormat.dateTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09T12:20:30.040+02:00", ISODateTimeFormat.dateTime().print(dt));        //        dt = dt.withZone(LONDON);//        assertEquals("2004-06-09T11:20:30.040+01:00", ISODateTimeFormat.getInstance(PARIS).dateTime().print(dt));//        //        dt = dt.withZone(LONDON);//        assertEquals("2004-06-09T12:20:30.040+02:00", ISODateTimeFormat.dateTime().print(dt.getMillis(), PARIS));//        //        dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, CopticChronology.getInstance());//        assertEquals("2288-02-19T10:20:30.040Z", ISODateTimeFormat.dateTime().print(dt));//        //        dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, CopticChronology.getInstance());//        assertEquals("2004-06-09T10:20:30.040Z", ISODateTimeFormat.getInstance(CopticChronology.getInstance()).dateTime().print(dt));    }    public void testFormat_dateTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09T10:20:30Z", ISODateTimeFormat.dateTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09T11:20:30+01:00", ISODateTimeFormat.dateTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09T12:20:30+02:00", ISODateTimeFormat.dateTimeNoMillis().print(dt));    }    public void testFormat_ordinalDate() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-161", ISODateTimeFormat.ordinalDate().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-161", ISODateTimeFormat.ordinalDate().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-161", ISODateTimeFormat.ordinalDate().print(dt));    }    public void testFormat_ordinalDateTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-161T10:20:30.040Z", ISODateTimeFormat.ordinalDateTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-161T11:20:30.040+01:00", ISODateTimeFormat.ordinalDateTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-161T12:20:30.040+02:00", ISODateTimeFormat.ordinalDateTime().print(dt));    }    public void testFormat_ordinalDateTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-161T10:20:30Z", ISODateTimeFormat.ordinalDateTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-161T11:20:30+01:00", ISODateTimeFormat.ordinalDateTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-161T12:20:30+02:00", ISODateTimeFormat.ordinalDateTimeNoMillis().print(dt));    }    public void testFormat_weekDate() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-W24-3", ISODateTimeFormat.weekDate().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-W24-3", ISODateTimeFormat.weekDate().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-W24-3", ISODateTimeFormat.weekDate().print(dt));    }    public void testFormat_weekDateTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-W24-3T10:20:30.040Z", ISODateTimeFormat.weekDateTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-W24-3T11:20:30.040+01:00", ISODateTimeFormat.weekDateTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-W24-3T12:20:30.040+02:00", ISODateTimeFormat.weekDateTime().print(dt));    }    public void testFormat_weekDateTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-W24-3T10:20:30Z", ISODateTimeFormat.weekDateTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-W24-3T11:20:30+01:00", ISODateTimeFormat.weekDateTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-W24-3T12:20:30+02:00", ISODateTimeFormat.weekDateTimeNoMillis().print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_basicDate() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("20040609", ISODateTimeFormat.basicDate().print(dt));                dt = dt.withZone(LONDON);        assertEquals("20040609", ISODateTimeFormat.basicDate().print(dt));                dt = dt.withZone(PARIS);        assertEquals("20040609", ISODateTimeFormat.basicDate().print(dt));    }    public void testFormat_basicTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("102030.040Z", ISODateTimeFormat.basicTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("112030.040+0100", ISODateTimeFormat.basicTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("122030.040+0200", ISODateTimeFormat.basicTime().print(dt));    }    public void testFormat_basicTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("102030Z", ISODateTimeFormat.basicTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("112030+0100", ISODateTimeFormat.basicTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("122030+0200", ISODateTimeFormat.basicTimeNoMillis().print(dt));    }    public void testFormat_basicTTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("T102030.040Z", ISODateTimeFormat.basicTTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("T112030.040+0100", ISODateTimeFormat.basicTTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("T122030.040+0200", ISODateTimeFormat.basicTTime().print(dt));    }    public void testFormat_basicTTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("T102030Z", ISODateTimeFormat.basicTTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("T112030+0100", ISODateTimeFormat.basicTTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("T122030+0200", ISODateTimeFormat.basicTTimeNoMillis().print(dt));    }    public void testFormat_basicDateTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("20040609T102030.040Z", ISODateTimeFormat.basicDateTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("20040609T112030.040+0100", ISODateTimeFormat.basicDateTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("20040609T122030.040+0200", ISODateTimeFormat.basicDateTime().print(dt));    }    public void testFormat_basicDateTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("20040609T102030Z", ISODateTimeFormat.basicDateTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("20040609T112030+0100", ISODateTimeFormat.basicDateTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("20040609T122030+0200", ISODateTimeFormat.basicDateTimeNoMillis().print(dt));    }    public void testFormat_basicOrdinalDate() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004161", ISODateTimeFormat.basicOrdinalDate().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004161", ISODateTimeFormat.basicOrdinalDate().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004161", ISODateTimeFormat.basicOrdinalDate().print(dt));    }    public void testFormat_basicOrdinalDateTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004161T102030.040Z", ISODateTimeFormat.basicOrdinalDateTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004161T112030.040+0100", ISODateTimeFormat.basicOrdinalDateTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004161T122030.040+0200", ISODateTimeFormat.basicOrdinalDateTime().print(dt));    }    public void testFormat_basicOrdinalDateTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004161T102030Z", ISODateTimeFormat.basicOrdinalDateTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004161T112030+0100", ISODateTimeFormat.basicOrdinalDateTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004161T122030+0200", ISODateTimeFormat.basicOrdinalDateTimeNoMillis().print(dt));    }    public void testFormat_basicWeekDate() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004W243", ISODateTimeFormat.basicWeekDate().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004W243", ISODateTimeFormat.basicWeekDate().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004W243", ISODateTimeFormat.basicWeekDate().print(dt));    }    public void testFormat_basicWeekDateTime() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004W243T102030.040Z", ISODateTimeFormat.basicWeekDateTime().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004W243T112030.040+0100", ISODateTimeFormat.basicWeekDateTime().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004W243T122030.040+0200", ISODateTimeFormat.basicWeekDateTime().print(dt));    }    public void testFormat_basicWeekDateTimeNoMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004W243T102030Z", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004W243T112030+0100", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004W243T122030+0200", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_year() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004", ISODateTimeFormat.year().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004", ISODateTimeFormat.year().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004", ISODateTimeFormat.year().print(dt));    }    public void testFormat_yearMonth() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06", ISODateTimeFormat.yearMonth().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06", ISODateTimeFormat.yearMonth().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06", ISODateTimeFormat.yearMonth().print(dt));    }    public void testFormat_yearMonthDay() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09", ISODateTimeFormat.yearMonthDay().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09", ISODateTimeFormat.yearMonthDay().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09", ISODateTimeFormat.yearMonthDay().print(dt));    }    public void testFormat_weekyear() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004", ISODateTimeFormat.weekyear().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004", ISODateTimeFormat.weekyear().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004", ISODateTimeFormat.weekyear().print(dt));    }    public void testFormat_weekyearWeek() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-W24", ISODateTimeFormat.weekyearWeek().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-W24", ISODateTimeFormat.weekyearWeek().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-W24", ISODateTimeFormat.weekyearWeek().print(dt));    }    public void testFormat_weekyearWeekDay() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-W24-3", ISODateTimeFormat.weekyearWeekDay().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-W24-3", ISODateTimeFormat.weekyearWeekDay().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-W24-3", ISODateTimeFormat.weekyearWeekDay().print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_hour() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("10", ISODateTimeFormat.hour().print(dt));                dt = dt.withZone(LONDON);        assertEquals("11", ISODateTimeFormat.hour().print(dt));                dt = dt.withZone(PARIS);        assertEquals("12", ISODateTimeFormat.hour().print(dt));    }    public void testFormat_hourMinute() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("10:20", ISODateTimeFormat.hourMinute().print(dt));                dt = dt.withZone(LONDON);        assertEquals("11:20", ISODateTimeFormat.hourMinute().print(dt));                dt = dt.withZone(PARIS);        assertEquals("12:20", ISODateTimeFormat.hourMinute().print(dt));    }    public void testFormat_hourMinuteSecond() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("10:20:30", ISODateTimeFormat.hourMinuteSecond().print(dt));                dt = dt.withZone(LONDON);        assertEquals("11:20:30", ISODateTimeFormat.hourMinuteSecond().print(dt));                dt = dt.withZone(PARIS);        assertEquals("12:20:30", ISODateTimeFormat.hourMinuteSecond().print(dt));    }    public void testFormat_hourMinuteSecondMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("10:20:30.040", ISODateTimeFormat.hourMinuteSecondMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("11:20:30.040", ISODateTimeFormat.hourMinuteSecondMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("12:20:30.040", ISODateTimeFormat.hourMinuteSecondMillis().print(dt));    }    public void testFormat_hourMinuteSecondFraction() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("10:20:30.040", ISODateTimeFormat.hourMinuteSecondFraction().print(dt));                dt = dt.withZone(LONDON);        assertEquals("11:20:30.040", ISODateTimeFormat.hourMinuteSecondFraction().print(dt));                dt = dt.withZone(PARIS);        assertEquals("12:20:30.040", ISODateTimeFormat.hourMinuteSecondFraction().print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_dateHour() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09T10", ISODateTimeFormat.dateHour().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09T11", ISODateTimeFormat.dateHour().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09T12", ISODateTimeFormat.dateHour().print(dt));    }    public void testFormat_dateHourMinute() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09T10:20", ISODateTimeFormat.dateHourMinute().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09T11:20", ISODateTimeFormat.dateHourMinute().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09T12:20", ISODateTimeFormat.dateHourMinute().print(dt));    }    public void testFormat_dateHourMinuteSecond() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09T10:20:30", ISODateTimeFormat.dateHourMinuteSecond().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09T11:20:30", ISODateTimeFormat.dateHourMinuteSecond().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09T12:20:30", ISODateTimeFormat.dateHourMinuteSecond().print(dt));    }    public void testFormat_dateHourMinuteSecondMillis() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09T10:20:30.040", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09T11:20:30.040", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09T12:20:30.040", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt));    }    public void testFormat_dateHourMinuteSecondFraction() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        assertEquals("2004-06-09T10:20:30.040", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt));                dt = dt.withZone(LONDON);        assertEquals("2004-06-09T11:20:30.040", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt));                dt = dt.withZone(PARIS);        assertEquals("2004-06-09T12:20:30.040", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.chrono.GJChronology;/** * This class is a Junit unit test for DateTime Formating. * * @author Stephen Colebourne * @author Fredrik Borgh */public class TestDateTimeFormat extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeFormat.class);    }    public TestDateTimeFormat(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testSubclassableConstructor() {        DateTimeFormat f = new DateTimeFormat() {            // test constructor is protected        };        assertNotNull(f);    }    //-----------------------------------------------------------------------    public void testFormat_era() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("G").withLocale(Locale.UK);        assertEquals(dt.toString(), "AD", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "AD", f.print(dt));                dt = dt.withZone(PARIS);        assertEquals(dt.toString(), "AD", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_centuryOfEra() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("C").withLocale(Locale.UK);        assertEquals(dt.toString(), "20", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "20", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "20", f.print(dt));                dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);        assertEquals(dt.toString(), "1", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_yearOfEra() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("Y").withLocale(Locale.UK);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);        assertEquals(dt.toString(), "124", f.print(dt));  // 124th year of BCE    }            public void testFormat_yearOfEra_twoDigit() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("YY").withLocale(Locale.UK);        assertEquals(dt.toString(), "04", f.print(dt));                dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);        assertEquals(dt.toString(), "23", f.print(dt));                // current time set to 2002-06-09        f = f.withZone(UTC);        DateTime expect = null;        expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("04"));                expect = new DateTime(1922, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("22"));                expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("21"));        // Added tests to ensure single sign digit parse fails properly        try {            f.parseDateTime("-");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+");            fail();        } catch (IllegalArgumentException ex) {}        // Added tests for pivot year setting        f = f.withPivotYear(new Integer(2050));        expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("00"));        expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("99"));        // Added tests to ensure two digit parsing is lenient for DateTimeFormat        f = DateTimeFormat.forPattern("YY").withLocale(Locale.UK);        f = f.withZone(UTC);        f.parseDateTime("5");        f.parseDateTime("005");        f.parseDateTime("+50");        f.parseDateTime("-50");    }    public void testFormat_yearOfEraParse() {        Chronology chrono = GJChronology.getInstanceUTC();        DateTimeFormatter f = DateTimeFormat            .forPattern("YYYY-MM GG")            .withChronology(chrono)            .withLocale(Locale.UK);        DateTime dt = new DateTime(2005, 10, 1, 0, 0, 0, 0, chrono);        assertEquals(dt, f.parseDateTime("2005-10 AD"));        assertEquals(dt, f.parseDateTime("2005-10 CE"));        dt = new DateTime(-2005, 10, 1, 0, 0, 0, 0, chrono);        assertEquals(dt, f.parseDateTime("2005-10 BC"));        assertEquals(dt, f.parseDateTime("2005-10 BCE"));    }            //-----------------------------------------------------------------------    public void testFormat_year() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("y").withLocale(Locale.UK);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);        assertEquals(dt.toString(), "-123", f.print(dt));        // Added tests to ensure single sign digit parse fails properly        try {            f.parseDateTime("-");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormat_year_twoDigit() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("yy").withLocale(Locale.UK);        assertEquals(dt.toString(), "04", f.print(dt));                dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);        assertEquals(dt.toString(), "23", f.print(dt));                // current time set to 2002-06-09        f = f.withZone(UTC);        DateTime expect = null;        expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("04"));                expect = new DateTime(1922, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("22"));                expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("21"));        // Added tests to ensure single sign digit parse fails properly        try {            f.parseDateTime("-");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+");            fail();        } catch (IllegalArgumentException ex) {}        // Added tests for pivot year setting        f = f.withPivotYear(new Integer(2050));        expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("00"));        expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("99"));        // Added tests to ensure two digit parsing is strict by default for        // DateTimeFormatterBuilder        f = new DateTimeFormatterBuilder().appendTwoDigitYear(2000).toFormatter();        f = f.withZone(UTC);        try {            f.parseDateTime("5");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("005");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+50");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("-50");            fail();        } catch (IllegalArgumentException ex) {}        // Added tests to ensure two digit parsing is lenient for DateTimeFormat        f = DateTimeFormat.forPattern("yy").withLocale(Locale.UK);        f = f.withZone(UTC);        f.parseDateTime("5");        f.parseDateTime("005");        f.parseDateTime("+50");        f.parseDateTime("-50");        // Added tests for lenient two digit parsing        f = new DateTimeFormatterBuilder().appendTwoDigitYear(2000, true).toFormatter();        f = f.withZone(UTC);        expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("04"));        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("+04"));        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-04"));        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("4"));        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-4"));        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("004"));        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("+004"));        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-004"));        expect = new DateTime(3004, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("3004"));        expect = new DateTime(3004, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("+3004"));        expect = new DateTime(-3004, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-3004"));        try {            f.parseDateTime("-");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormat_year_long() {        DateTime dt = new DateTime(278004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy");        assertEquals(dt.toString(), "278004", f.print(dt));                // for coverage        f = DateTimeFormat.forPattern("yyyyMMdd");        assertEquals(dt.toString(), "2780040609", f.print(dt));                // for coverage        f = DateTimeFormat.forPattern("yyyyddMM");        assertEquals(dt.toString(), "2780040906", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_weekyear() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("x").withLocale(Locale.UK);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "2004", f.print(dt));                dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);        assertEquals(dt.toString(), "-123", f.print(dt));    }    public void testFormat_weekyearOfEra_twoDigit() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("xx").withLocale(Locale.UK);        assertEquals(dt.toString(), "04", f.print(dt));                dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);        assertEquals(dt.toString(), "23", f.print(dt));                // current time set to 2002-06-09        f = f.withZone(UTC);        DateTime expect = null;        expect = new DateTime(2003, 12, 29, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("04"));                expect = new DateTime(1922, 1, 2, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("22"));                expect = new DateTime(2021, 1, 4, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("21"));        // Added tests to ensure single sign digit parse fails properly        try {            f.parseDateTime("-");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+");            fail();        } catch (IllegalArgumentException ex) {}        // Added tests for pivot year setting        f = f.withPivotYear(new Integer(2050));        expect = new DateTime(2000, 1, 3, 0, 0, 0, 0, DateTimeZone.UTC);        assertEquals(expect, f.parseDateTime("00"));        expect = new DateTime(2098, 12, 29, 0, 0, 0, 0, DateTimeZone.UTC);        assertEquals(expect, f.parseDateTime("99"));        // Added tests to ensure two digit parsing is strict by default for        // DateTimeFormatterBuilder        f = new DateTimeFormatterBuilder().appendTwoDigitWeekyear(2000).toFormatter();        f = f.withZone(UTC);        try {            f.parseDateTime("5");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("005");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+50");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("-50");            fail();        } catch (IllegalArgumentException ex) {}        // Added tests to ensure two digit parsing is lenient for DateTimeFormat        f = DateTimeFormat.forPattern("xx").withLocale(Locale.UK);        f = f.withZone(UTC);        f.parseDateTime("5");        f.parseDateTime("005");        f.parseDateTime("+50");        f.parseDateTime("-50");        // Added tests for lenient two digit parsing        f = new DateTimeFormatterBuilder().appendTwoDigitWeekyear(2000, true).toFormatter();        f = f.withZone(UTC);        expect = new DateTime(2003, 12, 29, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("04"));        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("+04"));        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-04"));        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("4"));        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-4"));        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("004"));        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("+004"));        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-004"));        expect = new DateTime(3004, 1, 2, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("3004"));        expect = new DateTime(3004, 1, 2, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("+3004"));        expect = new DateTime(-3004, 1, 4, 0, 0, 0, 0, UTC);        assertEquals(expect, f.parseDateTime("-3004"));        try {            f.parseDateTime("-");            fail();        } catch (IllegalArgumentException ex) {}        try {            f.parseDateTime("+");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testFormat_weekOfWeekyear() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("w").withLocale(Locale.UK);        assertEquals(dt.toString(), "24", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "24", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "24", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_dayOfWeek() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("e").withLocale(Locale.UK);        assertEquals(dt.toString(), "3", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "3", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "3", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_dayOfWeekShortText() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("E").withLocale(Locale.UK);        assertEquals(dt.toString(), "Wed", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "Wed", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "Wed", f.print(dt));                f = f.withLocale(Locale.FRENCH);        assertEquals(dt.toString(), "mer.", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_dayOfWeekText() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("EEEE").withLocale(Locale.UK);        assertEquals(dt.toString(), "Wednesday", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "Wednesday", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "Wednesday", f.print(dt));                f = f.withLocale(Locale.FRENCH);        assertEquals(dt.toString(), "mercredi", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_dayOfYearText() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("D").withLocale(Locale.UK);        assertEquals(dt.toString(), "161", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "161", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "161", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_monthOfYear() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK);        assertEquals(dt.toString(), "6", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "6", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "6", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_monthOfYearShortText() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("MMM").withLocale(Locale.UK);        assertEquals(dt.toString(), "Jun", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "Jun", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "Jun", f.print(dt));                f = f.withLocale(Locale.FRENCH);        assertEquals(dt.toString(), "juin", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_monthOfYearText() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("MMMM").withLocale(Locale.UK);        assertEquals(dt.toString(), "June", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "June", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "June", f.print(dt));                f = f.withLocale(Locale.FRENCH);        assertEquals(dt.toString(), "juin", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_dayOfMonth() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("d").withLocale(Locale.UK);        assertEquals(dt.toString(), "9", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "9", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "9", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_halfdayOfDay() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("a").withLocale(Locale.UK);        assertEquals(dt.toString(), "AM", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "AM", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "PM", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_hourOfHalfday() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("K").withLocale(Locale.UK);        assertEquals(dt.toString(), "10", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "6", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "7", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_clockhourOfHalfday() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("h").withLocale(Locale.UK);        assertEquals(dt.toString(), "10", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "6", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "7", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_hourOfDay() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("H").withLocale(Locale.UK);        assertEquals(dt.toString(), "10", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "6", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "19", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_clockhourOfDay() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("k").withLocale(Locale.UK);        assertEquals(dt.toString(), "10", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "6", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "19", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_minute() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("m").withLocale(Locale.UK);        assertEquals(dt.toString(), "20", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "20", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "20", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_second() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("s").withLocale(Locale.UK);        assertEquals(dt.toString(), "30", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "30", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "30", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_fractionOfSecond() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("SSS").withLocale(Locale.UK);        assertEquals(dt.toString(), "040", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "040", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "040", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_zoneText() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("z").withLocale(Locale.UK);        assertEquals(dt.toString(), "UTC", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "EDT", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "JST", f.print(dt));    }    public void testFormat_zoneLongText() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("zzzz").withLocale(Locale.UK);        assertEquals(dt.toString(), "Coordinated Universal Time", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "Eastern Daylight Time", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "Japan Standard Time", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_zoneAmount() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("Z").withLocale(Locale.UK);        assertEquals(dt.toString(), "+0000", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "-0400", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "+0900", f.print(dt));    }    public void testFormat_zoneAmountColon() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("ZZ").withLocale(Locale.UK);        assertEquals(dt.toString(), "+00:00", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "-04:00", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "+09:00", f.print(dt));    }    public void testFormat_zoneAmountID() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("ZZZ").withLocale(Locale.UK);        assertEquals(dt.toString(), "UTC", f.print(dt));                dt = dt.withZone(NEWYORK);        assertEquals(dt.toString(), "America/New_York", f.print(dt));                dt = dt.withZone(TOKYO);        assertEquals(dt.toString(), "Asia/Tokyo", f.print(dt));    }    //-----------------------------------------------------------------------    public void testFormat_other() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("'Hello' ''");        assertEquals("Hello '", f.print(dt));    }    public void testFormat_invalid() {        try {            DateTimeFormat.forPattern(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forPattern("");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forPattern("A");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeFormat.forPattern("dd/mm/AA");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFormat_samples() {        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-dd HH.mm.ss");        assertEquals("2004-06-09 10.20.30", f.print(dt));    }    public void testFormat_shortBasicParse() {        // Tests special two digit parse to make sure it properly switches        // between lenient and strict parsing.        DateTime dt = new DateTime(2004, 3, 9, 0, 0, 0, 0);        DateTimeFormatter f = DateTimeFormat.forPattern("yyMMdd");        assertEquals(dt, f.parseDateTime("040309"));        try {            assertEquals(dt, f.parseDateTime("20040309"));            fail();        } catch (IllegalArgumentException ex) {}        f = DateTimeFormat.forPattern("yy/MM/dd");        assertEquals(dt, f.parseDateTime("04/03/09"));        assertEquals(dt, f.parseDateTime("2004/03/09"));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTimeFormatterBuilder. * * @author Stephen Colebourne */public class TestDateTimeFormatterBuilder extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeFormatterBuilder.class);    }    public TestDateTimeFormatterBuilder(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_toFormatter() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        try {            bld.toFormatter();            fail();        } catch (UnsupportedOperationException ex) {}        bld.appendLiteral('X');        assertNotNull(bld.toFormatter());    }    public void test_toPrinter() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        try {            bld.toPrinter();            fail();        } catch (UnsupportedOperationException ex) {}        bld.appendLiteral('X');        assertNotNull(bld.toPrinter());    }    public void test_toParser() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        try {            bld.toParser();            fail();        } catch (UnsupportedOperationException ex) {}        bld.appendLiteral('X');        assertNotNull(bld.toParser());    }    //-----------------------------------------------------------------------    public void test_canBuildFormatter() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        assertEquals(false, bld.canBuildFormatter());        bld.appendLiteral('X');        assertEquals(true, bld.canBuildFormatter());    }    public void test_canBuildPrinter() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        assertEquals(false, bld.canBuildPrinter());        bld.appendLiteral('X');        assertEquals(true, bld.canBuildPrinter());    }    public void test_canBuildParser() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        assertEquals(false, bld.canBuildParser());        bld.appendLiteral('X');        assertEquals(true, bld.canBuildParser());    }    //-----------------------------------------------------------------------    public void test_append_Formatter() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        bld.appendLiteral('Y');        DateTimeFormatter f = bld.toFormatter();                DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder();        bld2.appendLiteral('X');        bld2.append(f);        bld2.appendLiteral('Z');        assertEquals("XYZ", bld2.toFormatter().print(0L));    }    //-----------------------------------------------------------------------    public void test_append_Printer() {        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();        bld.appendLiteral('Y');        DateTimePrinter p = bld.toPrinter();                DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder();        bld2.appendLiteral('X');        bld2.append(p);        bld2.appendLiteral('Z');        assertEquals("XYZ", bld2.toFormatter().print(0L));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();                suite.addTest(TestDateTimeFormatter.suite());        suite.addTest(TestDateTimeFormat.suite());        suite.addTest(TestDateTimeFormatStyle.suite());        suite.addTest(TestISODateTimeFormat.suite());        suite.addTest(TestISODateTimeFormat_Fields.suite());        suite.addTest(TestDateTimeFormatterBuilder.suite());                suite.addTest(TestPeriodFormatter.suite());        suite.addTest(TestPeriodFormat.suite());        suite.addTest(TestISOPeriodFormat.suite());        suite.addTest(TestISOPeriodFormatParsing.suite());        suite.addTest(TestPeriodFormatParsing.suite());        suite.addTest(TestPeriodFormatterBuilder.suite());        suite.addTest(TestTextFields.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.format;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;import org.joda.time.PeriodType;/** * This class is a Junit unit test for ISOPeriodFormat. * * @author Stephen Colebourne */public class TestISOPeriodFormatParsing extends TestCase {    private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);    private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());    private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);    private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L - 1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOPeriodFormatParsing.class);    }    public TestISOPeriodFormatParsing(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testParseStandard1() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P1Y2M3W4DT5H6M7.008S");        assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), p);    }    //-----------------------------------------------------------------------    public void testParseStandard2() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P0Y0M0W0DT5H6M7.008S");        assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p);    }    //-----------------------------------------------------------------------    public void testParseStandard3() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P0DT5H6M7.008S");        assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p);    }    //-----------------------------------------------------------------------    public void testParseStandard4() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P2Y3DT5H6M7.008S");        assertEquals(new Period(2, 0, 0, 3, 5, 6, 7, 8), p);    }    //-----------------------------------------------------------------------    public void testParseStandard5() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P2YT5H6M7.008S");        assertEquals(new Period(2, 0, 0, 0, 5, 6, 7, 8), p);    }    //-----------------------------------------------------------------------    public void testParseStandard6() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("PT5H6M7.008S");        assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p);    }    //-----------------------------------------------------------------------    public void testParseStandard7() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P1Y2M3W4D");        assertEquals(new Period(1, 2, 3, 4, 0, 0, 0, 0), p);    }    //-----------------------------------------------------------------------    public void testParseStandard8() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("PT5H6M7S");        assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 0), p);    }    //-----------------------------------------------------------------------    public void testParseStandard9() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("PT0S");        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p);    }    //-----------------------------------------------------------------------    public void testParseStandard10() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P0D");        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p);    }    //-----------------------------------------------------------------------    public void testParseStandard11() {        PeriodFormatter parser = ISOPeriodFormat.standard();        Period p = parser.parsePeriod("P0Y");        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p);    }    //-----------------------------------------------------------------------    public void testParseStandardFail1() {        PeriodFormatter parser = ISOPeriodFormat.standard();        try {            parser.parsePeriod("P1Y2S");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testParseStandardFail2() {        PeriodFormatter parser = ISOPeriodFormat.standard();        try {            parser.parsePeriod("PS");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testParseStandardFail3() {        PeriodFormatter parser = ISOPeriodFormat.standard();        try {            parser.parsePeriod("PTS");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testParseStandardFail4() {        PeriodFormatter parser = ISOPeriodFormat.standard();        try {            parser.parsePeriod("PXS");            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.ReadablePeriod;import org.joda.time.Period;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadablePeriodConverter. * * @author Stephen Colebourne */public class TestReadablePeriodConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology JULIAN;    private static Chronology ISO;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadablePeriodConverter.class);    }    public TestReadablePeriodConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadablePeriodConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadablePeriod.class, ReadablePeriodConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.standard())));        assertEquals(PeriodType.yearMonthDayTime(),            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.yearMonthDayTime())));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());        ReadablePeriodConverter.INSTANCE.setInto(m, new Period(0, 0, 0, 3, 0, 4, 0, 5), null);        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(0, m.getHours());        assertEquals(4, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(5, m.getMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadablePeriod]", ReadablePeriodConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.Interval;import org.joda.time.MutableInterval;import org.joda.time.MutablePeriod;import org.joda.time.PeriodType;import org.joda.time.ReadableInterval;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a JUnit test for ReadableIntervalConverter. * * @author Stephen Colebourne */public class TestReadableIntervalConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology JULIAN;    private static Chronology ISO;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableIntervalConverter.class);    }    public TestReadableIntervalConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableIntervalConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableInterval.class, ReadableIntervalConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        Interval i = new Interval(100L, 223L);        assertEquals(123L, ReadableIntervalConverter.INSTANCE.getDurationMillis(i));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        Interval i = new Interval(100L, 223L);        assertEquals(PeriodType.standard(),            ReadableIntervalConverter.INSTANCE.getPeriodType(i));    }    public void testSetIntoPeriod_Object1() throws Exception {        Interval i = new Interval(100L, 223L);        MutablePeriod m = new MutablePeriod(PeriodType.millis());        ReadableIntervalConverter.INSTANCE.setInto(m, i, null);        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(0, m.getDays());        assertEquals(0, m.getHours());        assertEquals(0, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(123, m.getMillis());    }    public void testSetIntoPeriod_Object2() throws Exception {        Interval i = new Interval(100L, 223L);        MutablePeriod m = new MutablePeriod(PeriodType.millis());        ReadableIntervalConverter.INSTANCE.setInto(m, i, CopticChronology.getInstance());        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(0, m.getDays());        assertEquals(0, m.getHours());        assertEquals(0, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(123, m.getMillis());    }    //-----------------------------------------------------------------------    public void testIsReadableInterval_Object_Chronology() throws Exception {        Interval i = new Interval(1234L, 5678L);        assertEquals(true, ReadableIntervalConverter.INSTANCE.isReadableInterval(i, null));    }    public void testSetIntoInterval_Object1() throws Exception {        Interval i = new Interval(0L, 123L, CopticChronology.getInstance());        MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance());        ReadableIntervalConverter.INSTANCE.setInto(m, i, null);        assertEquals(0L, m.getStartMillis());        assertEquals(123L, m.getEndMillis());        assertEquals(CopticChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object2() throws Exception {        Interval i = new Interval(0L, 123L, CopticChronology.getInstance());        MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance());        ReadableIntervalConverter.INSTANCE.setInto(m, i, GJChronology.getInstance());        assertEquals(0L, m.getStartMillis());        assertEquals(123L, m.getEndMillis());        assertEquals(GJChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object3() throws Exception {        MutableInterval i = new MutableInterval(0L, 123L) {            public Chronology getChronology() {                return null; // bad            }        };        MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance());        ReadableIntervalConverter.INSTANCE.setInto(m, i, GJChronology.getInstance());        assertEquals(0L, m.getStartMillis());        assertEquals(123L, m.getEndMillis());        assertEquals(GJChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object4() throws Exception {        MutableInterval i = new MutableInterval(0L, 123L) {            public Chronology getChronology() {                return null; // bad            }        };        MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance());        ReadableIntervalConverter.INSTANCE.setInto(m, i, null);        assertEquals(0L, m.getStartMillis());        assertEquals(123L, m.getEndMillis());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableInterval]", ReadableIntervalConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeZone;import org.joda.time.Duration;import org.joda.time.PeriodType;import org.joda.time.MutablePeriod;import org.joda.time.ReadableDuration;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadableDurationConverter. * * @author Stephen Colebourne */public class TestReadableDurationConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology JULIAN;    private static Chronology ISO;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableDurationConverter.class);    }    public TestReadableDurationConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableDurationConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableDuration.class, ReadableDurationConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(123L)));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L)));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());        ReadableDurationConverter.INSTANCE.setInto(m, new Duration(            3L * DateTimeConstants.MILLIS_PER_DAY +            4L * DateTimeConstants.MILLIS_PER_MINUTE + 5L        ), null);        assertEquals(0, m.getYears());        assertEquals(0, m.getMonths());        assertEquals(0, m.getWeeks());        assertEquals(0, m.getDays());        assertEquals(3 * 24, m.getHours());        assertEquals(4, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(5, m.getMillis());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableDuration]", ReadableDurationConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Arrays;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;import org.joda.time.ReadablePartial;import org.joda.time.TimeOfDay;import org.joda.time.YearMonthDay;import org.joda.time.base.BasePartial;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadablePartialConverter. * * @author Stephen Colebourne */public class TestReadablePartialConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology JULIAN;    private static Chronology ISO;    private static Chronology BUDDHIST;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadablePartialConverter.class);    }    public TestReadablePartialConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();        BUDDHIST = BuddhistChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadablePartialConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadablePartial.class, ReadablePartialConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), PARIS));        assertEquals(ISO, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), DateTimeZone.getDefault()));        assertEquals(ISO, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L, BUDDHIST), JULIAN));        assertEquals(JULIAN, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), JULIAN));        assertEquals(BUDDHIST.withUTC(), ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L, BUDDHIST), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetPartialValues() throws Exception {        TimeOfDay tod = new TimeOfDay();        int[] expected = new int[] {1, 2, 3, 4};        int[] actual = ReadablePartialConverter.INSTANCE.getPartialValues(tod, new TimeOfDay(1, 2, 3, 4), ISOChronology.getInstance(PARIS));        assertEquals(true, Arrays.equals(expected, actual));                try {            ReadablePartialConverter.INSTANCE.getPartialValues(tod, new YearMonthDay(2005, 6, 9), JULIAN);            fail();        } catch (IllegalArgumentException ex) {}        try {            ReadablePartialConverter.INSTANCE.getPartialValues(tod, new MockTOD(), JULIAN);            fail();        } catch (IllegalArgumentException ex) {}    }    static class MockTOD extends BasePartial {        protected DateTimeField getField(int index, Chronology chrono) {            switch (index) {                case 0:                return chrono.hourOfDay();                case 1:                return chrono.minuteOfHour();                case 2:                return chrono.year();                case 3:                return chrono.era();            }            return null;        }        public int size() {            return 4;        }    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadablePartial]", ReadablePartialConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Arrays;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.MutableInterval;import org.joda.time.MutablePeriod;import org.joda.time.PeriodType;import org.joda.time.TimeOfDay;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for NullConverter. * * @author Stephen Colebourne */public class TestNullConverter extends TestCase {    private long TEST_TIME_NOW =            20 * DateTimeConstants.MILLIS_PER_DAY            + 10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology ISO;    private static Chronology JULIAN;        private DateTimeZone zone = null;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestNullConverter.class);    }    public TestNullConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(DateTimeZone.forID("Europe/London"));        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);                ISO = ISOChronology.getInstance();        JULIAN = JulianChronology.getInstance();    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = NullConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(null, NullConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, JULIAN));        assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, NullConverter.INSTANCE.getChronology(null, PARIS));        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, NullConverter.INSTANCE.getChronology(null, JULIAN));        assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetPartialValues() throws Exception {        TimeOfDay tod = new TimeOfDay();        int[] expected = new int[] {10 + 1, 20, 30, 40}; // now        int[] actual = NullConverter.INSTANCE.getPartialValues(tod, null, ISOChronology.getInstance());        assertEquals(true, Arrays.equals(expected, actual));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(0L, NullConverter.INSTANCE.getDurationMillis(null));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            NullConverter.INSTANCE.getPeriodType(null));    }    public void testSetInto_Object() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.millis());        NullConverter.INSTANCE.setInto(m, null, null);        assertEquals(0L, m.getMillis());    }    //-----------------------------------------------------------------------    public void testIsReadableInterval_Object_Chronology() throws Exception {        assertEquals(false, NullConverter.INSTANCE.isReadableInterval(null, null));    }    public void testSetInto_Object_Chronology1() throws Exception {        MutableInterval m = new MutableInterval(1000L, 2000L, GJChronology.getInstance());        NullConverter.INSTANCE.setInto(m, null, null);        assertEquals(TEST_TIME_NOW, m.getStartMillis());        assertEquals(TEST_TIME_NOW, m.getEndMillis());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    public void testSetInto_Object_Chronology2() throws Exception {        MutableInterval m = new MutableInterval(1000L, 2000L, GJChronology.getInstance());        NullConverter.INSTANCE.setInto(m, null, CopticChronology.getInstance());        assertEquals(TEST_TIME_NOW, m.getStartMillis());        assertEquals(TEST_TIME_NOW, m.getEndMillis());        assertEquals(CopticChronology.getInstance(), m.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[null]", NullConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Arrays;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.TimeOfDay;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for CalendarConverter. * * @author Stephen Colebourne */public class TestCalendarConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone MOSCOW = DateTimeZone.forID("Europe/Moscow");    private static Chronology JULIAN;    private static Chronology ISO;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestCalendarConverter.class);    }    public TestCalendarConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = CalendarConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Calendar.class, CalendarConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object_Chronology() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(123L));        long millis = CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN);        long expected = 123L + cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET);        expected = expected - DateTimeZone.getDefault().getOffsetFromLocal(expected);        assertEquals(expected, millis);        assertEquals(cal.get(Calendar.DAY_OF_MONTH), new DateTime(millis).getDayOfMonth());        assertEquals(cal.get(Calendar.HOUR_OF_DAY), new DateTime(millis).getHourOfDay());        assertEquals(cal.get(Calendar.MINUTE), new DateTime(millis).getMinuteOfHour());                assertEquals(123L, cal.getTime().getTime());    }    //-----------------------------------------------------------------------    public void testGetChronology_Object_Zone() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(GJChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (DateTimeZone) null));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(0L));        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MAX_VALUE));        assertEquals(JulianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MIN_VALUE));        assertEquals(GregorianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));                Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(ISOChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(uc, PARIS));                try {            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            assertEquals(BuddhistChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(bc, PARIS));        } catch (ClassNotFoundException ex) {            // ignore        }    }    public void testGetChronology_Object_nullChronology() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(GJChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(0L));        assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MAX_VALUE));        assertEquals(JulianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));                cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow"));        cal.setGregorianChange(new Date(Long.MIN_VALUE));        assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));                cal = new GregorianCalendar(new MockUnknownTimeZone());        assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null));                Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow"));        assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc, (Chronology) null));                try {            Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance();            bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            assertEquals(BuddhistChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(bc, (Chronology) null));        } catch (ClassNotFoundException ex) {            // ignore        }    }    public void testGetChronology_Object_Chronology() throws Exception {        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris"));        assertEquals(JULIAN, CalendarConverter.INSTANCE.getChronology(cal, JULIAN));    }    //-----------------------------------------------------------------------    public void testGetPartialValues() throws Exception {        GregorianCalendar cal = new GregorianCalendar();        cal.setTime(new Date(70, 2, 3, 4, 5, 6));        TimeOfDay tod = new TimeOfDay();        int[] expected = new int[] {4, 5, 6, 0};        int[] actual = CalendarConverter.INSTANCE.getPartialValues(tod, cal, ISOChronology.getInstance());        assertEquals(true, Arrays.equals(expected, actual));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.util.Calendar]", CalendarConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Arrays;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.Instant;import org.joda.time.MutableDateTime;import org.joda.time.ReadableInstant;import org.joda.time.TimeOfDay;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for ReadableInstantConverter. * * @author Stephen Colebourne */public class TestReadableInstantConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology JULIAN;    private static Chronology ISO;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestReadableInstantConverter.class);    }    public TestReadableInstantConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ReadableInstantConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(ReadableInstant.class, ReadableInstantConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), JULIAN));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), JULIAN));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (Chronology) null));        assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), PARIS));        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), DateTimeZone.getDefault()));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), DateTimeZone.getDefault()));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (DateTimeZone) null));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (DateTimeZone) null));                assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L, new MockBadChronology()), PARIS));                MutableDateTime mdt = new MutableDateTime() {            public Chronology getChronology() {                return null; // bad            }        };        assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(mdt, PARIS));    }    public void testGetChronology_Object_nullChronology() throws Exception {        assertEquals(ISO.withUTC(), ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (Chronology) null));        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (Chronology) null));                MutableDateTime mdt = new MutableDateTime() {            public Chronology getChronology() {                return null; // bad            }        };        assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(mdt, (Chronology) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), JULIAN));        assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), JULIAN));    }    //-----------------------------------------------------------------------    public void testGetPartialValues() throws Exception {        TimeOfDay tod = new TimeOfDay();        int[] expected = ISOChronology.getInstance().get(tod, 12345678L);        int[] actual = ReadableInstantConverter.INSTANCE.getPartialValues(tod, new Instant(12345678L), ISOChronology.getInstance());        assertEquals(true, Arrays.equals(expected, actual));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[org.joda.time.ReadableInstant]", ReadableInstantConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestConverterManager.suite());        suite.addTest(TestConverterSet.suite());                suite.addTest(TestCalendarConverter.suite());        suite.addTest(TestDateConverter.suite());        suite.addTest(TestLongConverter.suite());        suite.addTest(TestNullConverter.suite());        suite.addTest(TestReadableDurationConverter.suite());        suite.addTest(TestReadableIntervalConverter.suite());        suite.addTest(TestReadableInstantConverter.suite());        suite.addTest(TestReadablePartialConverter.suite());        suite.addTest(TestReadablePeriodConverter.suite());        suite.addTest(TestStringConverter.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Arrays;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.MutableInterval;import org.joda.time.MutablePeriod;import org.joda.time.PeriodType;import org.joda.time.TimeOfDay;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for StringConverter. * * @author Stephen Colebourne */public class TestStringConverter extends TestCase {    private static final DateTimeZone ONE_HOUR = DateTimeZone.forOffsetHours(1);    private static final DateTimeZone SIX = DateTimeZone.forOffsetHours(6);    private static final DateTimeZone SEVEN = DateTimeZone.forOffsetHours(7);    private static final DateTimeZone EIGHT = DateTimeZone.forOffsetHours(8);    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final Chronology ISO_EIGHT = ISOChronology.getInstance(EIGHT);    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);    private static Chronology ISO;    private static Chronology JULIAN;        private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestStringConverter.class);    }    public TestStringConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);                JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    protected void tearDown() throws Exception {        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = StringConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(String.class, StringConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+08:00", ISO_EIGHT));                dt = new DateTime(2004, 1, 1, 0, 0, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004T+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 1, 0, 0, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06T+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-161T+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24-3T+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 7, 0, 0, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24T+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 12, 24, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 12, 30, 0, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12.5+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 12, 24, 30, 0, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24.5+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, EIGHT);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.5+08:00", ISO_EIGHT));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", ISO));    }    public void testGetInstantMillis_Object_Zone() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+02:00", ISO_PARIS));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", ISO_PARIS));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", ISO_LONDON));                dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON);        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", ISO_LONDON));    }    public void testGetInstantMillis_Object_Chronology() throws Exception {        DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, JulianChronology.getInstance(LONDON));        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", JULIAN));    }    public void testGetInstantMillisInvalid() {        try {            StringConverter.INSTANCE.getInstantMillis("", (Chronology) null);            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getInstantMillis("X", (Chronology) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", PARIS));        assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", PARIS));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (DateTimeZone) null));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", JULIAN));        assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", JULIAN));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (Chronology) null));        assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetPartialValues() throws Exception {        TimeOfDay tod = new TimeOfDay();        int[] expected = new int[] {3, 4, 5, 6};        int[] actual = StringConverter.INSTANCE.getPartialValues(tod, "T03:04:05.006", ISOChronology.getInstance());        assertEquals(true, Arrays.equals(expected, actual));    }    //-----------------------------------------------------------------------    public void testGetDateTime() throws Exception {        DateTime base = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);        DateTime test = new DateTime(base.toString(), PARIS);        assertEquals(base, test);    }    public void testGetDateTime1() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+01:00");        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(LONDON, test.getZone());    }    public void testGetDateTime2() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501");        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(LONDON, test.getZone());    }    public void testGetDateTime3() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", PARIS);        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime4() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501", PARIS);        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime5() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", JulianChronology.getInstance(PARIS));        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    public void testGetDateTime6() throws Exception {        DateTime test = new DateTime("2004-06-09T12:24:48.501", JulianChronology.getInstance(PARIS));        assertEquals(2004, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());        assertEquals(PARIS, test.getZone());    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object1() throws Exception {        long millis = StringConverter.INSTANCE.getDurationMillis("PT12.345S");        assertEquals(12345, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12.345s");        assertEquals(12345, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12s");        assertEquals(12000, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12.s");        assertEquals(12000, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt-12.32s");        assertEquals(-12320, millis);                millis = StringConverter.INSTANCE.getDurationMillis("pt12.3456s");        assertEquals(12345, millis);    }    public void testGetDurationMillis_Object2() throws Exception {        try {            StringConverter.INSTANCE.getDurationMillis("P2Y6M9DXYZ");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PTS");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("XT0S");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PX0S");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PT0X");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PTXS");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PT0.0.0S");            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.getDurationMillis("PT0-00S");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetPeriodType_Object() throws Exception {        assertEquals(PeriodType.standard(),            StringConverter.INSTANCE.getPeriodType("P2Y6M9D"));    }    public void testSetIntoPeriod_Object1() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y6M9DT12H24M48S", null);        assertEquals(2, m.getYears());        assertEquals(6, m.getMonths());        assertEquals(9, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(48, m.getSeconds());        assertEquals(0, m.getMillis());    }    public void testSetIntoPeriod_Object2() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48S", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(48, m.getSeconds());        assertEquals(0, m.getMillis());    }            public void testSetIntoPeriod_Object3() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48.034S", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(48, m.getSeconds());        assertEquals(34, m.getMillis());    }            public void testSetIntoPeriod_Object4() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M.056S", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(56, m.getMillis());    }            public void testSetIntoPeriod_Object5() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M56.S", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(56, m.getSeconds());        assertEquals(0, m.getMillis());    }            public void testSetIntoPeriod_Object6() throws Exception {        MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M56.1234567S", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(12, m.getHours());        assertEquals(24, m.getMinutes());        assertEquals(56, m.getSeconds());        assertEquals(123, m.getMillis());    }            public void testSetIntoPeriod_Object7() throws Exception {        MutablePeriod m = new MutablePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.yearWeekDayTime());        StringConverter.INSTANCE.setInto(m, "P2Y4W3D", null);        assertEquals(2, m.getYears());        assertEquals(4, m.getWeeks());        assertEquals(3, m.getDays());        assertEquals(0, m.getHours());        assertEquals(0, m.getMinutes());        assertEquals(0, m.getSeconds());        assertEquals(0, m.getMillis());    }            public void testSetIntoPeriod_Object8() throws Exception {        MutablePeriod m = new MutablePeriod();        try {            StringConverter.INSTANCE.setInto(m, "", null);            fail();        } catch (IllegalArgumentException ex) {}                try {            StringConverter.INSTANCE.setInto(m, "PXY", null);            fail();        } catch (IllegalArgumentException ex) {}                try {            StringConverter.INSTANCE.setInto(m, "PT0SXY", null);            fail();        } catch (IllegalArgumentException ex) {}        try {            StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48SX", null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testIsReadableInterval_Object_Chronology() throws Exception {        assertEquals(false, StringConverter.INSTANCE.isReadableInterval("", null));    }    public void testSetIntoInterval_Object_Chronology1() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2004-06-09/P1Y2M", null);        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getStart());        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0), m.getEnd());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology2() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "P1Y2M/2004-06-09", null);        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology3() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2003-08-09/2004-06-09", null);        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology4() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2004-06-09T+06:00/P1Y2M", null);        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getStart());        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getEnd());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology5() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "P1Y2M/2004-06-09T+06:00", null);        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getEnd());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology6() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2003-08-09T+06:00/2004-06-09T+07:00", null);        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, SEVEN).withChronology(null), m.getEnd());        assertEquals(ISOChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology7() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2003-08-09/2004-06-09", BuddhistChronology.getInstance());        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, BuddhistChronology.getInstance()), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, BuddhistChronology.getInstance()), m.getEnd());        assertEquals(BuddhistChronology.getInstance(), m.getChronology());    }    public void testSetIntoInterval_Object_Chronology8() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        StringConverter.INSTANCE.setInto(m, "2003-08-09T+06:00/2004-06-09T+07:00", BuddhistChronology.getInstance(EIGHT));        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, BuddhistChronology.getInstance(SIX)).withZone(EIGHT), m.getStart());        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, BuddhistChronology.getInstance(SEVEN)).withZone(EIGHT), m.getEnd());        assertEquals(BuddhistChronology.getInstance(EIGHT), m.getChronology());    }    public void testSetIntoIntervalEx_Object_Chronology1() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology2() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "/", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology3() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "P1Y/", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology4() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "/P1Y", null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetIntoIntervalEx_Object_Chronology5() throws Exception {        MutableInterval m = new MutableInterval(-1000L, 1000L);        try {            StringConverter.INSTANCE.setInto(m, "P1Y/P2Y", null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.lang.String]", StringConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.Duration;import org.joda.time.ReadablePartial;import org.joda.time.ReadablePeriod;import org.joda.time.Period;import org.joda.time.PeriodType;import org.joda.time.Interval;import org.joda.time.JodaTimePermission;import org.joda.time.ReadWritablePeriod;import org.joda.time.ReadWritableInterval;import org.joda.time.ReadableDateTime;import org.joda.time.ReadableDuration;import org.joda.time.ReadableInstant;import org.joda.time.ReadableInterval;import org.joda.time.TimeOfDay;/** * This class is a JUnit test for ConverterManager. * * @author Stephen Colebourne */public class TestConverterManager extends TestCase {    private static final boolean OLD_JDK;    static {        String str = System.getProperty("java.version");        boolean old = true;        if (str.length() > 3 &&            str.charAt(0) == '1' &&            str.charAt(1) == '.' &&            (str.charAt(2) == '4' || str.charAt(2) == '5' || str.charAt(2) == '6')) {            old = false;        }        OLD_JDK = old;    }    private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return true;//                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestConverterManager.class);    }    public TestConverterManager(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = ConverterManager.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(true, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testGetInstantConverter() {        InstantConverter c = ConverterManager.getInstance().getInstantConverter(new Long(0L));        assertEquals(Long.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new DateTime());        assertEquals(ReadableInstant.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new Date());        assertEquals(Date.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(new GregorianCalendar());        assertEquals(Calendar.class, c.getSupportedType());                c = ConverterManager.getInstance().getInstantConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getInstantConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetInstantConverterRemovedNull() {        try {            ConverterManager.getInstance().removeInstantConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getInstantConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addInstantConverter(NullConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testGetInstantConverterOKMultipleMatches() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return ReadableDateTime.class;}        };        try {            ConverterManager.getInstance().addInstantConverter(c);            InstantConverter ok = ConverterManager.getInstance().getInstantConverter(new DateTime());            // ReadableDateTime and ReadableInstant both match, but RI discarded as less specific            assertEquals(ReadableDateTime.class, ok.getSupportedType());        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testGetInstantConverterBadMultipleMatches() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Serializable.class;}        };        try {            ConverterManager.getInstance().addInstantConverter(c);            try {                ConverterManager.getInstance().getInstantConverter(new DateTime());                fail();            } catch (IllegalStateException ex) {                // Serializable and ReadableInstant both match, so cannot pick            }        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    public void testGetInstantConverters() {        InstantConverter[] array = ConverterManager.getInstance().getInstantConverters();        assertEquals(6, array.length);    }    //-----------------------------------------------------------------------    public void testAddInstantConverter1() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        try {            InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getInstantConverter(Boolean.TRUE).getSupportedType());            assertEquals(7, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().removeInstantConverter(c);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter2() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return String.class;}        };        try {            InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getInstantConverter("").getSupportedType());            assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter3() {        InstantConverter removed = ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverter4() {        InstantConverter removed = ConverterManager.getInstance().addInstantConverter(null);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testAddInstantConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveInstantConverter1() {        try {            InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(5, ConverterManager.getInstance().getInstantConverters().length);        } finally {            ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverter2() {        InstantConverter c = new InstantConverter() {            public long getInstantMillis(Object object) { return 0;}            public long getInstantMillis(Object object, DateTimeZone zone) {return 0;}            public long getInstantMillis(Object object, Chronology chrono) {return 0;}            public Chronology getChronology(Object object) {return null;}            public Chronology getChronology(Object object, DateTimeZone zone) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(c);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverter3() {        InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(null);        assertEquals(null, removed);        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    public void testRemoveInstantConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static final int PARTIAL_SIZE = 7;        public void testGetPartialConverter() {        PartialConverter c = ConverterManager.getInstance().getPartialConverter(new Long(0L));        assertEquals(Long.class, c.getSupportedType());                c = ConverterManager.getInstance().getPartialConverter(new TimeOfDay());        assertEquals(ReadablePartial.class, c.getSupportedType());                c = ConverterManager.getInstance().getPartialConverter(new DateTime());        assertEquals(ReadableInstant.class, c.getSupportedType());                c = ConverterManager.getInstance().getPartialConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getPartialConverter(new Date());        assertEquals(Date.class, c.getSupportedType());                c = ConverterManager.getInstance().getPartialConverter(new GregorianCalendar());        assertEquals(Calendar.class, c.getSupportedType());                c = ConverterManager.getInstance().getPartialConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getPartialConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetPartialConverterRemovedNull() {        try {            ConverterManager.getInstance().removePartialConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getPartialConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addPartialConverter(NullConverter.INSTANCE);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testGetPartialConverterOKMultipleMatches() {        PartialConverter c = new PartialConverter() {            public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return ReadableDateTime.class;}        };        try {            ConverterManager.getInstance().addPartialConverter(c);            PartialConverter ok = ConverterManager.getInstance().getPartialConverter(new DateTime());            // ReadableDateTime and ReadablePartial both match, but RI discarded as less specific            assertEquals(ReadableDateTime.class, ok.getSupportedType());        } finally {            ConverterManager.getInstance().removePartialConverter(c);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testGetPartialConverterBadMultipleMatches() {        PartialConverter c = new PartialConverter() {            public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Serializable.class;}        };        try {            ConverterManager.getInstance().addPartialConverter(c);            try {                ConverterManager.getInstance().getPartialConverter(new DateTime());                fail();            } catch (IllegalStateException ex) {                // Serializable and ReadablePartial both match, so cannot pick            }        } finally {            ConverterManager.getInstance().removePartialConverter(c);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    //-----------------------------------------------------------------------    public void testGetPartialConverters() {        PartialConverter[] array = ConverterManager.getInstance().getPartialConverters();        assertEquals(PARTIAL_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddPartialConverter1() {        PartialConverter c = new PartialConverter() {            public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        try {            PartialConverter removed = ConverterManager.getInstance().addPartialConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getPartialConverter(Boolean.TRUE).getSupportedType());            assertEquals(PARTIAL_SIZE + 1, ConverterManager.getInstance().getPartialConverters().length);        } finally {            ConverterManager.getInstance().removePartialConverter(c);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testAddPartialConverter2() {        PartialConverter c = new PartialConverter() {            public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return String.class;}        };        try {            PartialConverter removed = ConverterManager.getInstance().addPartialConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getPartialConverter("").getSupportedType());            assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);        } finally {            ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testAddPartialConverter3() {        PartialConverter removed = ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE);        assertEquals(null, removed);        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testAddPartialConverter4() {        PartialConverter removed = ConverterManager.getInstance().addPartialConverter(null);        assertEquals(null, removed);        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testAddPartialConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    //-----------------------------------------------------------------------    public void testRemovePartialConverter1() {        try {            PartialConverter removed = ConverterManager.getInstance().removePartialConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(PARTIAL_SIZE - 1, ConverterManager.getInstance().getPartialConverters().length);        } finally {            ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testRemovePartialConverter2() {        PartialConverter c = new PartialConverter() {            public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;}            public Chronology getChronology(Object object, Chronology chrono) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        PartialConverter removed = ConverterManager.getInstance().removePartialConverter(c);        assertEquals(null, removed);        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testRemovePartialConverter3() {        PartialConverter removed = ConverterManager.getInstance().removePartialConverter(null);        assertEquals(null, removed);        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    public void testRemovePartialConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int DURATION_SIZE = 5;        public void testGetDurationConverter() {        DurationConverter c = ConverterManager.getInstance().getDurationConverter(new Long(0L));        assertEquals(Long.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(new Duration(123L));        assertEquals(ReadableDuration.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getDurationConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getDurationConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetDurationConverterRemovedNull() {        try {            ConverterManager.getInstance().removeDurationConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getDurationConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addDurationConverter(NullConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    public void testGetDurationConverters() {        DurationConverter[] array = ConverterManager.getInstance().getDurationConverters();        assertEquals(DURATION_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddDurationConverter1() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return Boolean.class;}        };        try {            DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getDurationConverter(Boolean.TRUE).getSupportedType());            assertEquals(DURATION_SIZE + 1, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().removeDurationConverter(c);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverter2() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return String.class;}        };        try {            DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getDurationConverter("").getSupportedType());            assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverter3() {        DurationConverter removed = ConverterManager.getInstance().addDurationConverter(null);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testAddDurationConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveDurationConverter1() {        try {            DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(DURATION_SIZE - 1, ConverterManager.getInstance().getDurationConverters().length);        } finally {            ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverter2() {        DurationConverter c = new DurationConverter() {            public long getDurationMillis(Object object) {return 0;}            public Class getSupportedType() {return Boolean.class;}        };        DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(c);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverter3() {        DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(null);        assertEquals(null, removed);        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    public void testRemoveDurationConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int PERIOD_SIZE = 5;        public void testGetPeriodConverter() {        PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8));        assertEquals(ReadablePeriod.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(new Duration(123L));        assertEquals(ReadableDuration.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getPeriodConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetPeriodConverterRemovedNull() {        try {            ConverterManager.getInstance().removePeriodConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getPeriodConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addPeriodConverter(NullConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    public void testGetPeriodConverters() {        PeriodConverter[] array = ConverterManager.getInstance().getPeriodConverters();        assertEquals(PERIOD_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddPeriodConverter1() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}            public PeriodType getPeriodType(Object object) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        try {            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE).getSupportedType());            assertEquals(PERIOD_SIZE + 1, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().removePeriodConverter(c);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverter2() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}            public PeriodType getPeriodType(Object object) {return null;}            public Class getSupportedType() {return String.class;}        };        try {            PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getPeriodConverter("").getSupportedType());            assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverter3() {        PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(null);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testAddPeriodConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    public void testRemovePeriodConverter1() {        try {            PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(PERIOD_SIZE - 1, ConverterManager.getInstance().getPeriodConverters().length);        } finally {            ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverter2() {        PeriodConverter c = new PeriodConverter() {            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}            public PeriodType getPeriodType(Object object) {return null;}            public Class getSupportedType() {return Boolean.class;}        };        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(c);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverter3() {        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(null);        assertEquals(null, removed);        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    public void testRemovePeriodConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    private static int INTERVAL_SIZE = 3;    public void testGetIntervalConverter() {        IntervalConverter c = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 1000L));        assertEquals(ReadableInterval.class, c.getSupportedType());                c = ConverterManager.getInstance().getIntervalConverter("");        assertEquals(String.class, c.getSupportedType());                c = ConverterManager.getInstance().getIntervalConverter(null);        assertEquals(null, c.getSupportedType());                try {            ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE);            fail();        } catch (IllegalArgumentException ex) {}        try {            ConverterManager.getInstance().getIntervalConverter(new Long(0));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetIntervalConverterRemovedNull() {        try {            ConverterManager.getInstance().removeIntervalConverter(NullConverter.INSTANCE);            try {                ConverterManager.getInstance().getIntervalConverter(null);                fail();            } catch (IllegalArgumentException ex) {}        } finally {            ConverterManager.getInstance().addIntervalConverter(NullConverter.INSTANCE);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testGetIntervalConverters() {        IntervalConverter[] array = ConverterManager.getInstance().getIntervalConverters();        assertEquals(INTERVAL_SIZE, array.length);    }    //-----------------------------------------------------------------------    public void testAddIntervalConverter1() {        IntervalConverter c = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}            public Class getSupportedType() {return Boolean.class;}        };        try {            IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);            assertEquals(null, removed);            assertEquals(Boolean.class, ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE).getSupportedType());            assertEquals(INTERVAL_SIZE + 1, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().removeIntervalConverter(c);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverter2() {        IntervalConverter c = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}            public Class getSupportedType() {return String.class;}        };        try {            IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(String.class, ConverterManager.getInstance().getIntervalConverter("").getSupportedType());            assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverter3() {        IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(null);        assertEquals(null, removed);        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testAddIntervalConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testRemoveIntervalConverter1() {        try {            IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);            assertEquals(StringConverter.INSTANCE, removed);            assertEquals(INTERVAL_SIZE - 1, ConverterManager.getInstance().getIntervalConverters().length);        } finally {            ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverter2() {        IntervalConverter c = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {return false;}            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {}            public Class getSupportedType() {return Boolean.class;}        };        IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(c);        assertEquals(null, removed);        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverter3() {        IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(null);        assertEquals(null, removed);        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    public void testRemoveIntervalConverterSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }        assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("ConverterManager[6 instant,7 partial,5 duration,5 period,3 interval]", ConverterManager.getInstance().toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;import java.util.Calendar;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateMidnight;import org.joda.time.DateTime;import org.joda.time.ReadWritableDateTime;import org.joda.time.ReadWritableInstant;import org.joda.time.ReadableDateTime;import org.joda.time.ReadableInstant;/** * This class is a JUnit test for ConverterSet. * Mostly for coverage. * * @author Stephen Colebourne */public class TestConverterSet extends TestCase {    private static final Converter c1 = new Converter() {        public Class getSupportedType() {return Boolean.class;}    };    private static final Converter c2 = new Converter() {        public Class getSupportedType() {return Character.class;}    };    private static final Converter c3 = new Converter() {        public Class getSupportedType() {return Byte.class;}    };    private static final Converter c4 = new Converter() {        public Class getSupportedType() {return Short.class;}    };    private static final Converter c4a = new Converter() {        public Class getSupportedType() {return Short.class;}    };    private static final Converter c5 = new Converter() {        public Class getSupportedType() {return Integer.class;}    };        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestConverterSet.class);    }    public TestConverterSet(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testClass() throws Exception {        Class cls = ConverterSet.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                assertEquals(1, cls.getDeclaredConstructors().length);        Constructor con = cls.getDeclaredConstructors()[0];        assertEquals(false, Modifier.isPublic(con.getModifiers()));        assertEquals(false, Modifier.isProtected(con.getModifiers()));        assertEquals(false, Modifier.isPrivate(con.getModifiers()));    }    //-----------------------------------------------------------------------    public void testBigHashtable() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        set.select(Boolean.class);        set.select(Character.class);        set.select(Byte.class);        set.select(Short.class);        set.select(Integer.class);        set.select(Long.class);        set.select(Float.class);        set.select(Double.class);        set.select(null);        set.select(Calendar.class);        set.select(GregorianCalendar.class);        set.select(DateTime.class);        set.select(DateMidnight.class);        set.select(ReadableInstant.class);        set.select(ReadableDateTime.class);        set.select(ReadWritableInstant.class);  // 16        set.select(ReadWritableDateTime.class);        set.select(DateTime.class);        assertEquals(4, set.size());    }    //-----------------------------------------------------------------------    public void testAddNullRemoved1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c5, null);        assertEquals(4, set.size());        assertEquals(5, result.size());    }    public void testAddNullRemoved2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c4, null);        assertSame(set, result);    }    public void testAddNullRemoved3() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.add(c4a, null);        assertTrue(set != result);        assertEquals(4, set.size());        assertEquals(4, result.size());    }    //-----------------------------------------------------------------------    public void testRemoveNullRemoved1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.remove(c3, null);        assertEquals(4, set.size());        assertEquals(3, result.size());    }    public void testRemoveNullRemoved2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        ConverterSet result = set.remove(c5, null);        assertSame(set, result);    }    //-----------------------------------------------------------------------    public void testRemoveBadIndex1() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        try {            set.remove(200, null);            fail();        } catch (IndexOutOfBoundsException ex) {}        assertEquals(4, set.size());    }    public void testRemoveBadIndex2() {        Converter[] array = new Converter[] {            c1, c2, c3, c4,        };        ConverterSet set = new ConverterSet(array);        try {            set.remove(-1, null);            fail();        } catch (IndexOutOfBoundsException ex) {}        assertEquals(4, set.size());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Arrays;import java.util.Date;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.TimeOfDay;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for DateConverter. * * @author Stephen Colebourne */public class TestDateConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology ISO;    private static Chronology JULIAN;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateConverter.class);    }    public TestDateConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = DateConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Date.class, DateConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object_Chronology() throws Exception {        Date date = new Date(123L);        long millis = DateConverter.INSTANCE.getInstantMillis(date, JULIAN);        long expected = 123L - date.getTimezoneOffset() * 60000;        expected = expected - DateTimeZone.getDefault().getOffsetFromLocal(expected);        assertEquals(expected, millis);        assertEquals(date.getDate(), new DateTime(millis).getDayOfMonth());        assertEquals(date.getHours(), new DateTime(millis).getHourOfDay());        assertEquals(date.getMinutes(), new DateTime(millis).getMinuteOfHour());                assertEquals(expected, DateConverter.INSTANCE.getInstantMillis(date, (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, DateConverter.INSTANCE.getChronology(new Date(123L), PARIS));        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, DateConverter.INSTANCE.getChronology(new Date(123L), JULIAN));        assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetPartialValues() throws Exception {        Date date = new Date(70, 2, 3, 4, 5, 6);        TimeOfDay tod = new TimeOfDay();        int[] expected = new int[] {4, 5, 6, 0};        int[] actual = DateConverter.INSTANCE.getPartialValues(tod, date, ISOChronology.getInstance());        assertEquals(true, Arrays.equals(expected, actual));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.util.Date]", DateConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.convert;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Arrays;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeZone;import org.joda.time.TimeOfDay;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for LongConverter. * * @author Stephen Colebourne */public class TestLongConverter extends TestCase {    private static final DateTimeZone UTC = DateTimeZone.UTC;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static Chronology JULIAN;    private static Chronology ISO;        private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestLongConverter.class);    }    public TestLongConverter(String name) {        super(name);    }    protected void setUp() throws Exception {        JULIAN = JulianChronology.getInstance();        ISO = ISOChronology.getInstance();    }    //-----------------------------------------------------------------------    public void testSingleton() throws Exception {        Class cls = LongConverter.class;        assertEquals(false, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isProtected(cls.getModifiers()));        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));                Constructor con = cls.getDeclaredConstructor(null);        assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(con.getModifiers()));                Field fld = cls.getDeclaredField("INSTANCE");        assertEquals(false, Modifier.isPublic(fld.getModifiers()));        assertEquals(false, Modifier.isProtected(fld.getModifiers()));        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));    }    //-----------------------------------------------------------------------    public void testSupportedType() throws Exception {        assertEquals(Long.class, LongConverter.INSTANCE.getSupportedType());    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_Object_Chronology() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), JULIAN));        assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetChronology_Object_Zone() throws Exception {        assertEquals(ISO_PARIS, LongConverter.INSTANCE.getChronology(new Long(123L), PARIS));        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (DateTimeZone) null));    }    public void testGetChronology_Object_Chronology() throws Exception {        assertEquals(JULIAN, LongConverter.INSTANCE.getChronology(new Long(123L), JULIAN));        assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (Chronology) null));    }    //-----------------------------------------------------------------------    public void testGetPartialValues() throws Exception {        TimeOfDay tod = new TimeOfDay();        int[] expected = ISOChronology.getInstance().get(tod, 12345678L);        int[] actual = LongConverter.INSTANCE.getPartialValues(tod, new Long(12345678L), ISOChronology.getInstance());        assertEquals(true, Arrays.equals(expected, actual));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_Object() throws Exception {        assertEquals(123L, LongConverter.INSTANCE.getDurationMillis(new Long(123L)));    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("Converter[java.lang.Long]", LongConverter.INSTANCE.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import java.util.Random;import junit.framework.TestCase;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeField;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.JulianChronology;/** * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj * against the implementations in this package. It tests all the date fields * against their principal methods. * <p> * Randomly generated values are fed into the DateTimeField methods and the * results are compared between the two chronologies. If any result doesn't * match, an error report is generated and the program exits. Each time this * test program is run, the pseudo random number generator is seeded with the * same value. This ensures consistent results between test runs. * <p> * The main method accepts three optional arguments: iterations, mode, seed. By * default, iterations is set to 1,000,000. The test will take several minutes * to run, depending on the computer's performance. Every 5 seconds a progress * message is printed. * <p> * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for * proleptic julian. To override the default random number generator seed, pass * in a third argument which accepts a long signed integer. * * @author Brian S O'Neill */public class MainTest extends TestCase {    public static final int GREGORIAN_MODE = 0;    public static final int JULIAN_MODE = 1;    private static final long MILLIS_PER_YEAR = (long)365.2425 * 24 * 60 * 60 * 1000;    private static final long _1000_YEARS = 1000 * MILLIS_PER_YEAR;    private static final long _500_YEARS = 500 * MILLIS_PER_YEAR;    private static final long MAX_MILLIS = (10000 - 1970) * MILLIS_PER_YEAR;    private static final long MIN_MILLIS = (-10000 - 1970) * MILLIS_PER_YEAR;    // Show progess reports every 5 seconds.    private static final long UPDATE_INTERVAL = 5000;    /**     * Arguments: iterations [mode [seed]]     */    public static void main(String[] args) throws Exception {        int iterations = 1000000;        int mode = GREGORIAN_MODE;        long seed = 1345435247779935L;        if (args.length > 0) {            iterations = Integer.parseInt(args[0]);            if (args.length > 1) {                if (args[1].startsWith("g")) {                    mode = GREGORIAN_MODE;                } else if (args[1].startsWith("j")) {                    mode = JULIAN_MODE;                } else {                    throw new IllegalArgumentException                        ("Unknown mode: " + args[1]);                }                if (args.length > 2) {                    seed = Long.parseLong(args[2]);                }            }        }        new MainTest(iterations, mode, seed).testChronology();    }    //-----------------------------------------------------------------------    private final int iIterations;    private final int iMode;    private final long iSeed;    private final Chronology iTest;    private final Chronology iActual;    /**     * @param iterations number of test iterations to perform     * @param mode GREGORIAN_MODE or JULIAN_MODE,0=Gregorian, 1=Julian     * @param seed seed for random number generator     */    public MainTest(int iterations, int mode, long seed) {        super("testChronology");        iIterations = iterations;        iMode = mode;        iSeed = seed;        if (mode == GREGORIAN_MODE) {            iTest = new TestGregorianChronology();            iActual = GregorianChronology.getInstanceUTC();        } else {            iTest = new TestJulianChronology();            iActual = JulianChronology.getInstanceUTC();        }    }    //-----------------------------------------------------------------------    /**     * Main junit test     */    public void testChronology() {        int iterations = iIterations;        long seed = iSeed;        String modeStr;        if (iMode == GREGORIAN_MODE) {            modeStr = "Gregorian";        } else {            modeStr = "Julian";        }        System.out.println("\nTesting " + modeStr + " chronology over " + iterations + " iterations");        Random rnd = new Random(seed);        long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;        for (int i=0; i<iterations; i++) {            long now = System.currentTimeMillis();            if (now >= updateMillis) {                updateMillis = now + UPDATE_INTERVAL;                double complete = ((int)((double)i / iterations * 1000.0)) / 10d;                if (complete < 100) {                    System.out.println("" + complete + "% complete (i=" + i + ")");                }            }            long millis = randomMillis(rnd);            int value = rnd.nextInt(200) - 100;            // millis2 is used for difference tests.            long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;            try {                testFields(millis, value, millis2);            } catch (RuntimeException e) {                System.out.println("Failure index: " + i);                System.out.println("Test millis: " + millis);                System.out.println("Test value: " + value);                System.out.println("Test millis2: " + millis2);                fail(e.getMessage());            }        }        System.out.println("100% complete (i=" + iterations + ")");    }    //-----------------------------------------------------------------------    private void testFields(long millis, int value, long millis2) {        testField(iTest.year(), iActual.year(), millis, value, millis2);        testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);        testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);        testField(iTest.weekyear(), iActual.weekyear(), millis, value, millis2);        testField(iTest.weekOfWeekyear(),                  iActual.weekOfWeekyear(), millis, value, millis2);        testField(iTest.dayOfWeek(), iActual.dayOfWeek(), millis, value, millis2);        testField(iTest.dayOfYear(), iActual.dayOfYear(), millis, value, millis2);    }    private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,                           int value, long millis2)    {        int a, b;        long x, y;        boolean m, n;        // get test        a = fieldA.get(millis);        b = fieldB.get(millis);        testValue(fieldA, fieldB, "get", millis, a, b);        // getMaximumValue test        // Restrict this test to the fields that matter.        Class fieldClass = fieldA.getClass();        if (fieldClass == TestGJDayOfYearField.class ||            fieldClass == TestGJDayOfMonthField.class ||            fieldClass == TestGJWeekOfWeekyearField.class) {                        a = fieldA.getMaximumValue(millis);            b = fieldB.getMaximumValue(millis);            testValue(fieldA, fieldB, "getMaximumValue", millis, a, b);        }        // set test        a = getWrappedValue            (value, fieldA.getMinimumValue(millis), fieldA.getMaximumValue(millis));        b = getWrappedValue            (value, fieldB.getMinimumValue(millis), fieldB.getMaximumValue(millis));        if (iMode == JULIAN_MODE && a == 0            && (fieldA.getName().equals("year") || fieldA.getName().equals("weekyear"))) {            // Exclude setting Julian year of zero.        } else {            x = fieldA.set(millis, a);            y = fieldB.set(millis, b);            testMillis(fieldA, fieldB, "set", millis, x, y, a, b);        }        // roundFloor test        x = fieldA.roundFloor(millis);        y = fieldB.roundFloor(millis);        testMillis(fieldA, fieldB, "roundFloor", millis, x, y);        // roundCeiling test        x = fieldA.roundCeiling(millis);        y = fieldB.roundCeiling(millis);        testMillis(fieldA, fieldB, "roundCeiling", millis, x, y);        // roundHalfFloor test        x = fieldA.roundHalfFloor(millis);        y = fieldB.roundHalfFloor(millis);        testMillis(fieldA, fieldB, "roundHalfFloor", millis, x, y);        // roundHalfEven test        x = fieldA.roundHalfEven(millis);        y = fieldB.roundHalfEven(millis);        testMillis(fieldA, fieldB, "roundHalfEven", millis, x, y);        // remainder test        x = fieldA.remainder(millis);        y = fieldB.remainder(millis);        testMillis(fieldA, fieldB, "remainder", millis, x, y);        // add test        x = fieldA.add(millis, value);        y = fieldB.add(millis, value);        testMillis(fieldA, fieldB, "add", millis, x, y);        // addWrapField test        x = fieldA.addWrapField(millis, value);        y = fieldB.addWrapField(millis, value);        testMillis(fieldA, fieldB, "addWrapField", millis, x, y);        // getDifference test        x = fieldA.getDifference(millis, millis2);        y = fieldB.getDifference(millis, millis2);        try {            testValue(fieldA, fieldB, "getDifference", millis, x, y);        } catch (RuntimeException e) {            System.out.println("Test datetime 2: " + makeDatetime(millis2));            throw e;        }        // isLeap test        m = fieldA.isLeap(millis);        n = fieldB.isLeap(millis);        testBoolean(fieldA, fieldB, "isLeap", millis, m, n);        // getLeapAmount test        a = fieldA.getLeapAmount(millis);        b = fieldB.getLeapAmount(millis);        testValue(fieldA, fieldB, "getLeapAmount", millis, a, b);    }    private int getWrappedValue(int value, int minValue, int maxValue) {        if (minValue >= maxValue) {            throw new IllegalArgumentException("MIN > MAX");        }        int wrapRange = maxValue - minValue + 1;        value -= minValue;        if (value >= 0) {            return (value % wrapRange) + minValue;        }        int remByRange = (-value) % wrapRange;        if (remByRange == 0) {            return 0 + minValue;        }        return (wrapRange - remByRange) + minValue;    }    private void testValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        if (valueA != valueB) {            failValue(fieldA, fieldB, method, millis, valueA, valueB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB, valueA, valueB);        }    }    private void testBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        if (boolA != boolB) {            failBoolean(fieldA, fieldB, method, millis, boolA, boolB);        }    }    private void failValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(valueA + " != " + valueB);        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        System.out.println("Value to set for first field: " + valueA);        System.out.println("Value to set for second field: " + valueB);        throw new RuntimeException();    }    private void failBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(boolA + " != " + boolB);        throw new RuntimeException();    }    private String makeName(DateTimeField fieldA, DateTimeField fieldB) {        if (fieldA.getName().equals(fieldB.getName())) {            return fieldA.getName();        } else {            return fieldA.getName() + "/" + fieldB.getName();        }    }    private String makeDatetime(long millis) {        return makeDatetime(millis, iActual);    }    private String makeDatetime(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString() + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }    private String makeDate(long millis) {        return makeDate(millis, iActual);    }    private String makeDate(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString("yyyy-MM-dd") + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }    //-----------------------------------------------------------------------    private static long randomMillis(Random rnd) {        long millis = rnd.nextLong();        if (millis >= 0) {            millis = millis % MAX_MILLIS;        } else {            millis = millis % -MIN_MILLIS;        }        return millis;    }    private static void dump(Chronology chrono, long millis) {        System.out.println("year:           " + chrono.year().get(millis));        System.out.println("monthOfYear:    " + chrono.monthOfYear().get(millis));        System.out.println("dayOfMonth:     " + chrono.dayOfMonth().get(millis));        System.out.println("weekyear:       " + chrono.weekyear().get(millis));        System.out.println("weekOfWeekyear: " + chrono.weekOfWeekyear().get(millis));        System.out.println("dayOfWeek:      " + chrono.dayOfWeek().get(millis));        System.out.println("dayOfYear:      " + chrono.dayOfYear().get(millis));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianMonthOfYearField extends TestGJMonthOfYearField {    public TestJulianMonthOfYearField(TestJulianChronology chrono) {        super(chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long add(long millis, long value) {        int year = iChronology.year().get(millis);        int newYear = year + (int)TestGJChronology.div(value, 12);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        int newMonth = get(millis) + (int)TestGJChronology.mod(value, 12);        if (newMonth > 12) {            if (newYear == -1) {                newYear = 1;            } else {                newYear++;            }            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;import org.joda.time.DurationField;import org.joda.time.chrono.BaseChronology;/** * A reference Gregorian/Julian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * <p>In theory, this class can be used to test any other Gregorian/Julian * chronology as long as almost all datetime fields are implemented differently * between the two. Fields that would most likely be implemented the same are * not supported by this class. * * <p>Unsupported features * <ul> * <li>time zones * <li>time of day * <li>year of era * <li>year of century * <li>century of era * <li>era * </ul> * * @author Brian S O'Neill */abstract class TestGJChronology extends BaseChronology {    static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;    /**     * Divide with round-negative behavior.     *     * @param divisor must be positive     */    static long div(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend / divisor;        } else {            return (dividend + 1) / divisor - 1;        }    }    /**     * Modulus with round-negative behavior, result is always positive.     *     * @param divisor must be positive     */    static long mod(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend % divisor;        } else {            return (dividend + 1) % divisor - 1 + divisor;        }    }    static long amod(long dividend, long divisor) {        long mod = mod(dividend, divisor);        return (mod == 0) ? divisor : mod;    }    /** Milliseconds from 0001-01-01 to the epoch. */    private final long iEpochMillis;    public TestGJChronology(int epochYear, int epochMonth, int epochDay) {        iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;    }    public DateTimeZone getZone() {        return null;    }    public Chronology withUTC() {        return this;    }    /**     * Unsupported.     */    public Chronology withZone(DateTimeZone zone) {        throw new UnsupportedOperationException();    }    long getTimeOnlyMillis(long millis) {        return mod(millis, MILLIS_PER_DAY);    }    long getDateOnlyMillis(long millis) {        return millis - mod(millis, MILLIS_PER_DAY);    }    public DurationField days() {        return dayOfWeek().getDurationField();    }    public DateTimeField dayOfWeek() {        return new TestGJDayOfWeekField(this);    }    public DateTimeField dayOfMonth() {        return new TestGJDayOfMonthField(this);     }    public DateTimeField dayOfYear() {        return new TestGJDayOfYearField(this);    }    public DurationField weeks() {        return weekOfWeekyear().getDurationField();    }    public DateTimeField weekOfWeekyear() {        return new TestGJWeekOfWeekyearField(this);    }    public DurationField weekyears() {        return weekyear().getDurationField();    }    public DateTimeField weekyear() {        return new TestGJWeekyearField(this);    }    public DurationField months() {        return monthOfYear().getDurationField();    }    public DateTimeField monthOfYear() {        return new TestGJMonthOfYearField(this);    }    public DurationField years() {        return year().getDurationField();    }    public DateTimeField year() {        return new TestGJYearField(this);    }    abstract long millisPerYear();    abstract long millisPerMonth();    abstract boolean isLeapYear(int year);    /**     * @return days from 0001-01-01     */    abstract long fixedFromGJ(int year, int monthOfYear, int dayOfMonth);    /**     * @param date days from 0001-01-01     * @return gj year     */    abstract int gjYearFromFixed(long date);    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    abstract int[] gjFromFixed(long date);    abstract long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek);    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    abstract int[] isoFromFixed(long date);    /**     * @param millis milliseconds from epoch     * @return days from 0001-01-01     */    long fixedFromMillis(long millis) {        return div(millis + iEpochMillis, MILLIS_PER_DAY);    }    /**     * @param fixed days from 0001-01-01     * @return milliseconds from epoch     */    long millisFromFixed(long fixed) {        return fixed * MILLIS_PER_DAY - iEpochMillis;    }    /**     * @return milliseconds from epoch     */    long millisFromGJ(int year, int monthOfYear, int dayOfMonth) {        return millisFromFixed(fixedFromGJ(year, monthOfYear, dayOfMonth));    }    /**     * @param millis milliseconds from epoch     * @return gj year     */    int gjYearFromMillis(long millis) {        return gjYearFromFixed(fixedFromMillis(millis));    }    /**     * @param millis milliseconds from epoch     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromMillis(long millis) {        return gjFromFixed(fixedFromMillis(millis));    }    /**     * @return milliseconds from epoch     */    long millisFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return millisFromFixed(fixedFromISO(weekyear, weekOfWeekyear, dayOfWeek));    }    /**     * @param millis milliseconds from epoch     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromMillis(long millis) {        return isoFromFixed(fixedFromMillis(millis));    }    /**     * @param date days from 0001-01-01     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday     * @param date days from 0001-01-01, on or before weekday     */    long weekdayOnOrBefore(long date, int weekday) {        return date - mod(date - mod(weekday, 7), 7);    }    long weekdayOnOrAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 6, weekday);    }    long weekdayNearest(long date, int weekday) {        return weekdayOnOrBefore(date + 3, weekday);    }    long weekdayBefore(long date, int weekday) {        return weekdayOnOrBefore(date - 1, weekday);    }    long weekdayAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 7, weekday);    }    long nthWeekday(int n, int weekday,                    int year, int monthOfYear, int dayOfMonth)    {        if (n > 0) {            return 7 * n + weekdayBefore                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        } else {            return 7 * n + weekdayAfter                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        }    }    long firstWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(1, weekday, year, monthOfYear, dayOfMonth);    }    long lastWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(-1, weekday, year, monthOfYear, dayOfMonth);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfMonthField extends TestGJDateTimeField {    public TestGJDayOfMonthField(TestGJChronology chrono) {        super(DateTimeFieldType.dayOfMonth(), TestGJChronology.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[2];    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(ymd[0], ymd[1], value);    }    public long add(long millis, long value) {        return millis + value * TestGJChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.months();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 31;    }    public int getMaximumValue(long millis) {        int[] lengths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};        if (iChronology.year().isLeap(millis)) {            lengths[2] = 29;        }        return lengths[iChronology.monthOfYear().get(millis)];    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.field.FieldUtils;/** *  * @author Brian S O'Neill */class TestJulianWeekyearField extends TestGJWeekyearField {    public TestJulianWeekyearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapField(long millis, int value) {        int weekyear = get(millis);        int wrapped = FieldUtils.getWrappedValue            (weekyear, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - weekyear);    }    public long add(long millis, long value) {        int weekyear = get(millis);        int newWeekyear = weekyear + FieldUtils.safeToInt(value);        if (weekyear < 0) {            if (newWeekyear >= 0) {                newWeekyear++;            }        } else {            if (newWeekyear <= 0) {                newWeekyear--;            }        }        return set(millis, newWeekyear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekOfWeekyearField extends TestGJDateTimeField {    public TestGJWeekOfWeekyearField(TestGJChronology chrono) {        super(DateTimeFieldType.weekOfWeekyear(),              (long)(TestGJChronology.MILLIS_PER_DAY * 7), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[1];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(wwd[0], value, wwd[2]);    }    public long add(long millis, long value) {        return iChronology.dayOfYear().add(millis, value * 7);    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 53;    }    public int getMaximumValue(long millis) {        // Move millis to end of weekyear.        millis = iChronology.weekyear().roundFloor(millis);        millis = iChronology.weekyear().add(millis, 1);        millis = iChronology.dayOfYear().add(millis, -1);        return get(millis);    }    public long roundFloor(long millis) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.millisFromISO(wwd[0], wwd[1], 1);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfYearField extends TestGJDateTimeField {    public TestGJDayOfYearField(TestGJChronology chrono) {        super(DateTimeFieldType.dayOfYear(), TestGJChronology.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int year = iChronology.gjYearFromMillis(millis);        return (int)(iChronology.fixedFromMillis(millis)                     - iChronology.fixedFromGJ(year, 1, 1)) + 1;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * TestGJChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 366;    }    public int getMaximumValue(long millis) {        return iChronology.year().isLeap(millis) ? 366 : 365;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.field.FieldUtils;/** *  * @author Brian S O'Neill */class TestJulianYearField extends TestGJYearField {    public TestJulianYearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapField(long millis, int value) {        int year = get(millis);        int wrapped = FieldUtils.getWrappedValue            (year, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - year);    }    public long add(long millis, long value) {        int year = get(millis);        int newYear = year + FieldUtils.safeToInt(value);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        return set(millis, newYear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJMonthOfYearField extends TestGJDateTimeField {    public TestGJMonthOfYearField(TestGJChronology chrono) {        super(DateTimeFieldType.monthOfYear(), chrono.millisPerMonth(), chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long set(long millis, int value) {        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);        int[] ymd = iChronology.gjFromMillis(millis);        // First set to start of month...        millis = iChronology.millisFromGJ(ymd[0], value, 1);        // ...and use dayOfMonth field to check range.        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);        if (ymd[2] > maxDay) {            ymd[2] = maxDay;        }        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);    }    public long add(long millis, long value) {        int newYear = iChronology.year().get(millis)            + (int)TestGJChronology.div(value, 12);        int newMonth = get(millis) + (int)TestGJChronology.mod(value, 12);        if (newMonth > 12) {            newYear++;            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public boolean isLeap(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return ymd[1] == 2 && iChronology.isLeapYear(ymd[0]);    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 12;    }    public long roundFloor(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.millisFromGJ(ymd[0], ymd[1], 1);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfWeekField extends TestGJDateTimeField {    public TestGJDayOfWeekField(TestGJChronology chrono) {        super(DateTimeFieldType.dayOfWeek(), TestGJChronology.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int dayOfWeek = (int) TestGJChronology.mod(iChronology.fixedFromMillis(millis), 7);        if (dayOfWeek == 0) {            dayOfWeek = 7;        }        return dayOfWeek;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * TestGJChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 7;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianDayOfMonthField extends TestGJDayOfMonthField {    public TestJulianDayOfMonthField(TestJulianChronology chrono) {        super(chrono);    }    public long getRangeMillis() {        return iChronology.millisPerMonth();    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJYearField extends TestGJDateTimeField {    public TestGJYearField(TestGJChronology chrono) {        super(DateTimeFieldType.year(), chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.gjYearFromMillis(millis);    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(value, ymd[1], ymd[2]);        if (ymd[1] == 2 && ymd[2] == 29 && !iChronology.isLeapYear(value)) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public boolean isLeap(long millis) {        return iChronology.isLeapYear(get(millis));    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromGJ(get(millis), 1, 1);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeField;/** * A reference Julian chronology implementation, intended for testing purposes * only. Correctness is favored over performance. The key functions for date * calculations are based on ones provided in "Calendrical Calculations", ISBN * 0-521-77752-6. * * @author Brian S O'Neill */public final class TestJulianChronology extends TestGJChronology {    private static final long JULIAN_EPOCH;    static {        // Constant as defined in book.        JULIAN_EPOCH = new TestGregorianChronology().fixedFromGJ(0, 12, 30);    }    /**     * Constructs with an epoch of 1969-12-19.     */    public TestJulianChronology() {        super(1969, 12, 19);    }    public TestJulianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public DateTimeField dayOfMonth() {        return new TestJulianDayOfMonthField(this);     }    public DateTimeField weekyear() {        return new TestJulianWeekyearField(this);    }    public DateTimeField monthOfYear() {        return new TestJulianMonthOfYearField(this);    }    public DateTimeField year() {        return new TestJulianYearField(this);    }    public String toString() {        return "TestJulianChronology";    }    long millisPerYear() {        return (long)(365.25 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.25 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        return mod(year, 4) == (year > 0 ? 0 : 3);    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        int y = (year < 0) ? year + 1 : year;        long y_m1 = y - 1;        long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4)            + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        return gjFromFixed(date)[0];    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);        long year = (approx <= 0) ? approx - 1 : approx;        int year_i = (int)year;        if (year_i != year) {            throw new RuntimeException("year cannot be cast to an int: " + year);        }        long priorDays = date - fixedFromGJ(year_i, 1, 1);        long correction;        if (date < fixedFromGJ(year_i, 3, 1)) {            correction = 0;        } else if (isLeapYear(year_i)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year_i, monthOfYear, 1) + 1);        return new int[]{year_i, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        if (weekyear == 0) {            throw new IllegalArgumentException("Illegal weekyear: " + weekyear);        }        if (weekyear == 1) {            weekyear = -1;        } else {            weekyear--;        }        return nthWeekday(weekOfWeekyear, 0, weekyear, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        int nextWeekyear;        if (weekyear == -1) {            nextWeekyear = 1;        } else {            nextWeekyear = weekyear + 1;        }        if (date >= fixedFromISO(nextWeekyear, 1, 1)) {            weekyear = nextWeekyear;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(new MainTest(1000, 0, 1345435247779935L));        suite.addTest(new MainTest(1000, 1, 1345435247779935L));        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.field.ImpreciseDateTimeField;/** *  * @author Brian S O'Neill */abstract class TestGJDateTimeField extends ImpreciseDateTimeField {    protected final TestGJChronology iChronology;    public TestGJDateTimeField(DateTimeFieldType type, long unitMillis, TestGJChronology chrono) {        super(type, unitMillis);        iChronology = chrono;    }    public boolean isLenient() {        return false;    }    public long add(long instant, int value) {        return add(instant, (long)value);    }    public abstract long add(long instant, long value);}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;import org.joda.time.DateTimeFieldType;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekyearField extends TestGJDateTimeField {    public TestGJWeekyearField(TestGJChronology chrono) {        super(DateTimeFieldType.weekyear(), chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[0];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(value, wwd[1], wwd[2]);        if (wwd[1] == 53) {            int[] wwd2 = iChronology.isoFromMillis(millis);            if (wwd2[0] != value) {                // Set year doesn't have 53 weeks, so back off a week.                millis = iChronology.dayOfYear().add(millis, -7);            }        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public boolean isLeap(long millis) {        return iChronology.weekOfWeekyear().getMaximumValue(millis) > 52;    }    public int getLeapAmount(long millis) {        return iChronology.weekOfWeekyear().getMaximumValue(millis) - 52;    }     public DurationField getLeapDurationField() {        return iChronology.weeks();    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromISO(get(millis), 1, 1);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono.gj;/** * A reference Gregorian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * @author Brian S O'Neill */public final class TestGregorianChronology extends TestGJChronology {    /**     * Constructs with an epoch of 1970-01-01.     */    public TestGregorianChronology() {        super(1970, 1, 1);    }    public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public String toString() {        return "TestGregorianChronology";    }    long millisPerYear() {        return (long)(365.2425 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.2425 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (mod(year, 4) == 0) {            int t = (int)mod(year, 400);            if (t != 100 && t != 200 & t != 300) {                return true;            }        }        return false;    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        long year_m1 = year - 1;        long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100)            + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        long d0 = date - 1;        long n400 = div(d0, 146097);        long d1 = mod(d0, 146097);        long n100 = div(d1, 36524);        long d2 = mod(d1, 36524);        long n4 = div(d2, 1461);        long d3 = mod(d2, 1461);        long n1 = div(d3, 365);        long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;        if (!(n100 == 4 || n1 == 4)) {            year += 1;        }        int year_i = (int)year;        if (year_i == year) {            return year_i;        } else {            throw new RuntimeException("year cannot be cast to an int: " + year);        }    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        int year = gjYearFromFixed(date);        long priorDays = date - fixedFromGJ(year, 1, 1);        long correction;        if (date < fixedFromGJ(year, 3, 1)) {            correction = 0;        } else if (isLeapYear(year)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year, monthOfYear, 1) + 1);        return new int[]{year, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return nthWeekday(weekOfWeekyear, 0, weekyear - 1, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        if (date >= fixedFromISO(weekyear + 1, 1, 1)) {            weekyear += 1;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.DateTime.Property;/** * This class is a Junit unit test for EthiopicChronology. * * @author Stephen Colebourne */public class TestEthiopicChronology extends TestCase {    private static final int MILLIS_PER_DAY = DateTimeConstants.MILLIS_PER_DAY;    private static long SKIP = 1 * MILLIS_PER_DAY;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final Chronology ETHIOPIC_UTC = EthiopicChronology.getInstanceUTC();    private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC();    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        SKIP = 1 * MILLIS_PER_DAY;        return new TestSuite(TestEthiopicChronology.class);    }    public TestEthiopicChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, EthiopicChronology.getInstanceUTC().getZone());        assertSame(EthiopicChronology.class, EthiopicChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, EthiopicChronology.getInstance().getZone());        assertSame(EthiopicChronology.class, EthiopicChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, EthiopicChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, EthiopicChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, EthiopicChronology.getInstance(null).getZone());        assertSame(EthiopicChronology.class, EthiopicChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(EthiopicChronology.getInstance(TOKYO), EthiopicChronology.getInstance(TOKYO));        assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(LONDON));        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance(PARIS));        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstanceUTC());        assertSame(EthiopicChronology.getInstance(), EthiopicChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance(LONDON).withUTC());        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance(TOKYO).withUTC());        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstanceUTC().withUTC());        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(EthiopicChronology.getInstance(TOKYO), EthiopicChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(TOKYO).withZone(null));        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance().withZone(PARIS));        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("EthiopicChronology[Europe/London]", EthiopicChronology.getInstance(LONDON).toString());        assertEquals("EthiopicChronology[Asia/Tokyo]", EthiopicChronology.getInstance(TOKYO).toString());        assertEquals("EthiopicChronology[Europe/London]", EthiopicChronology.getInstance().toString());        assertEquals("EthiopicChronology[UTC]", EthiopicChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", EthiopicChronology.getInstance().eras().getName());        assertEquals("centuries", EthiopicChronology.getInstance().centuries().getName());        assertEquals("years", EthiopicChronology.getInstance().years().getName());        assertEquals("weekyears", EthiopicChronology.getInstance().weekyears().getName());        assertEquals("months", EthiopicChronology.getInstance().months().getName());        assertEquals("weeks", EthiopicChronology.getInstance().weeks().getName());        assertEquals("days", EthiopicChronology.getInstance().days().getName());        assertEquals("halfdays", EthiopicChronology.getInstance().halfdays().getName());        assertEquals("hours", EthiopicChronology.getInstance().hours().getName());        assertEquals("minutes", EthiopicChronology.getInstance().minutes().getName());        assertEquals("seconds", EthiopicChronology.getInstance().seconds().getName());        assertEquals("millis", EthiopicChronology.getInstance().millis().getName());                assertEquals(false, EthiopicChronology.getInstance().eras().isSupported());        assertEquals(true, EthiopicChronology.getInstance().centuries().isSupported());        assertEquals(true, EthiopicChronology.getInstance().years().isSupported());        assertEquals(true, EthiopicChronology.getInstance().weekyears().isSupported());        assertEquals(true, EthiopicChronology.getInstance().months().isSupported());        assertEquals(true, EthiopicChronology.getInstance().weeks().isSupported());        assertEquals(true, EthiopicChronology.getInstance().days().isSupported());        assertEquals(true, EthiopicChronology.getInstance().halfdays().isSupported());        assertEquals(true, EthiopicChronology.getInstance().hours().isSupported());        assertEquals(true, EthiopicChronology.getInstance().minutes().isSupported());        assertEquals(true, EthiopicChronology.getInstance().seconds().isSupported());        assertEquals(true, EthiopicChronology.getInstance().millis().isSupported());                assertEquals(false, EthiopicChronology.getInstance().centuries().isPrecise());        assertEquals(false, EthiopicChronology.getInstance().years().isPrecise());        assertEquals(false, EthiopicChronology.getInstance().weekyears().isPrecise());        assertEquals(false, EthiopicChronology.getInstance().months().isPrecise());        assertEquals(false, EthiopicChronology.getInstance().weeks().isPrecise());        assertEquals(false, EthiopicChronology.getInstance().days().isPrecise());        assertEquals(false, EthiopicChronology.getInstance().halfdays().isPrecise());        assertEquals(true, EthiopicChronology.getInstance().hours().isPrecise());        assertEquals(true, EthiopicChronology.getInstance().minutes().isPrecise());        assertEquals(true, EthiopicChronology.getInstance().seconds().isPrecise());        assertEquals(true, EthiopicChronology.getInstance().millis().isPrecise());                assertEquals(false, EthiopicChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, EthiopicChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, EthiopicChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, EthiopicChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, EthiopicChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, EthiopicChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, EthiopicChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, EthiopicChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, EthiopicChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, EthiopicChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, EthiopicChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", EthiopicChronology.getInstance().era().getName());        assertEquals("centuryOfEra", EthiopicChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", EthiopicChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", EthiopicChronology.getInstance().yearOfEra().getName());        assertEquals("year", EthiopicChronology.getInstance().year().getName());        assertEquals("monthOfYear", EthiopicChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", EthiopicChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", EthiopicChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", EthiopicChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", EthiopicChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", EthiopicChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", EthiopicChronology.getInstance().dayOfWeek().getName());                assertEquals(true, EthiopicChronology.getInstance().era().isSupported());        assertEquals(true, EthiopicChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, EthiopicChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, EthiopicChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, EthiopicChronology.getInstance().year().isSupported());        assertEquals(true, EthiopicChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, EthiopicChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, EthiopicChronology.getInstance().weekyear().isSupported());        assertEquals(true, EthiopicChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, EthiopicChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, EthiopicChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, EthiopicChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", EthiopicChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", EthiopicChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", EthiopicChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", EthiopicChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", EthiopicChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", EthiopicChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", EthiopicChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", EthiopicChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", EthiopicChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", EthiopicChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", EthiopicChronology.getInstance().millisOfSecond().getName());                assertEquals(true, EthiopicChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, EthiopicChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, EthiopicChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, EthiopicChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, EthiopicChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, EthiopicChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, EthiopicChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, EthiopicChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, EthiopicChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, EthiopicChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, EthiopicChronology.getInstance().millisOfSecond().isSupported());    }    //-----------------------------------------------------------------------    public void testEpoch() {        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC);        assertEquals(new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC));    }    public void testEra() {        assertEquals(1, EthiopicChronology.EE);        try {            new DateTime(-1, 13, 5, 0, 0, 0, 0, ETHIOPIC_UTC);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    /**     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.     */    public void testCalendar() {        if (TestAll.FAST) {            return;        }        System.out.println("\nTestEthiopicChronology.testCalendar");        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC);        long millis = epoch.getMillis();        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();        DateTimeField dayOfWeek = ETHIOPIC_UTC.dayOfWeek();        DateTimeField dayOfYear = ETHIOPIC_UTC.dayOfYear();        DateTimeField dayOfMonth = ETHIOPIC_UTC.dayOfMonth();        DateTimeField monthOfYear = ETHIOPIC_UTC.monthOfYear();        DateTimeField year = ETHIOPIC_UTC.year();        DateTimeField yearOfEra = ETHIOPIC_UTC.yearOfEra();        DateTimeField era = ETHIOPIC_UTC.era();        int expectedDOW = new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();        int expectedDOY = 1;        int expectedDay = 1;        int expectedMonth = 1;        int expectedYear = 1;        while (millis < end) {            int dowValue = dayOfWeek.get(millis);            int doyValue = dayOfYear.get(millis);            int dayValue = dayOfMonth.get(millis);            int monthValue = monthOfYear.get(millis);            int yearValue = year.get(millis);            int yearOfEraValue = yearOfEra.get(millis);            int monthLen = dayOfMonth.getMaximumValue(millis);            if (monthValue < 1 || monthValue > 13) {                fail("Bad month: " + millis);            }                        // test era            assertEquals(1, era.get(millis));            assertEquals("EE", era.getAsText(millis));            assertEquals("EE", era.getAsShortText(millis));                        // test date            assertEquals(expectedYear, yearValue);            assertEquals(expectedYear, yearOfEraValue);            assertEquals(expectedMonth, monthValue);            assertEquals(expectedDay, dayValue);            assertEquals(expectedDOW, dowValue);            assertEquals(expectedDOY, doyValue);                        // test leap year            assertEquals(yearValue % 4 == 3, year.isLeap(millis));                        // test month length            if (monthValue == 13) {                assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis));                if (yearValue % 4 == 3) {                    assertEquals(6, monthLen);                } else {                    assertEquals(5, monthLen);                }            } else {                assertEquals(30, monthLen);            }                        // recalculate date            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;            expectedDay++;            expectedDOY++;            if (expectedDay == 31 && expectedMonth < 13) {                expectedDay = 1;                expectedMonth++;            } else if (expectedMonth == 13) {                if (expectedYear % 4 == 3 && expectedDay == 7) {                    expectedDay = 1;                    expectedMonth = 1;                    expectedYear++;                    expectedDOY = 1;                } else if (expectedYear % 4 != 3 && expectedDay == 6) {                    expectedDay = 1;                    expectedMonth = 1;                    expectedYear++;                    expectedDOY = 1;                }            }            millis += SKIP;        }    }    public void testSampleDate() {        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ISO_UTC).withChronology(ETHIOPIC_UTC);        assertEquals(EthiopicChronology.EE, dt.getEra());        assertEquals(20, dt.getCenturyOfEra());  // TODO confirm        assertEquals(96, dt.getYearOfCentury());        assertEquals(1996, dt.getYearOfEra());                assertEquals(1996, dt.getYear());        Property fld = dt.year();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(new DateTime(1997, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1));                assertEquals(10, dt.getMonthOfYear());        fld = dt.monthOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(13, fld.getMaximumValue());        assertEquals(13, fld.getMaximumValueOverall());        assertEquals(new DateTime(1997, 1, 2, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(4));        assertEquals(new DateTime(1996, 1, 2, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addWrapFieldToCopy(4));                assertEquals(2, dt.getDayOfMonth());        fld = dt.dayOfMonth();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(30, fld.getMaximumValue());        assertEquals(30, fld.getMaximumValueOverall());        assertEquals(new DateTime(1996, 10, 3, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1));                assertEquals(DateTimeConstants.WEDNESDAY, dt.getDayOfWeek());        fld = dt.dayOfWeek();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(7, fld.getMaximumValue());        assertEquals(7, fld.getMaximumValueOverall());        assertEquals(new DateTime(1996, 10, 3, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1));                assertEquals(9 * 30 + 2, dt.getDayOfYear());        fld = dt.dayOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(365, fld.getMaximumValue());        assertEquals(366, fld.getMaximumValueOverall());        assertEquals(new DateTime(1996, 10, 3, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1));                assertEquals(0, dt.getHourOfDay());        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void testSampleDateWithZone() {        DateTime dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, PARIS).withChronology(ETHIOPIC_UTC);        assertEquals(EthiopicChronology.EE, dt.getEra());        assertEquals(1996, dt.getYear());        assertEquals(1996, dt.getYearOfEra());        assertEquals(10, dt.getMonthOfYear());        assertEquals(2, dt.getDayOfMonth());        assertEquals(10, dt.getHourOfDay());  // PARIS is UTC+2 in summer (12-2=10)        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void testDurationYear() {        // Leap 1999, NotLeap 1996,97,98        DateTime dt96 = new DateTime(1996, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC);        DateTime dt97 = new DateTime(1997, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC);        DateTime dt98 = new DateTime(1998, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC);        DateTime dt99 = new DateTime(1999, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC);        DateTime dt00 = new DateTime(2000, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC);                DurationField fld = dt96.year().getDurationField();        assertEquals(ETHIOPIC_UTC.years(), fld);        assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1, dt96.getMillis()));        assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2, dt96.getMillis()));        assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3, dt96.getMillis()));        assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4, dt96.getMillis()));                assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1));        assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2));                assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1L, dt96.getMillis()));        assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2L, dt96.getMillis()));        assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3L, dt96.getMillis()));        assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4L, dt96.getMillis()));                assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1L));        assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2L));                assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getUnitMillis());                assertEquals(0, fld.getValue(1L * 365L * MILLIS_PER_DAY - 1L, dt96.getMillis()));        assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY, dt96.getMillis()));        assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY + 1L, dt96.getMillis()));        assertEquals(1, fld.getValue(2L * 365L * MILLIS_PER_DAY - 1L, dt96.getMillis()));        assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY, dt96.getMillis()));        assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY + 1L, dt96.getMillis()));        assertEquals(2, fld.getValue(3L * 365L * MILLIS_PER_DAY - 1L, dt96.getMillis()));        assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY, dt96.getMillis()));        assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY + 1L, dt96.getMillis()));        assertEquals(3, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY - 1L, dt96.getMillis()));        assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY, dt96.getMillis()));        assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY + 1L, dt96.getMillis()));                assertEquals(dt97.getMillis(), fld.add(dt96.getMillis(), 1));        assertEquals(dt98.getMillis(), fld.add(dt96.getMillis(), 2));        assertEquals(dt99.getMillis(), fld.add(dt96.getMillis(), 3));        assertEquals(dt00.getMillis(), fld.add(dt96.getMillis(), 4));                assertEquals(dt97.getMillis(), fld.add(dt96.getMillis(), 1L));        assertEquals(dt98.getMillis(), fld.add(dt96.getMillis(), 2L));        assertEquals(dt99.getMillis(), fld.add(dt96.getMillis(), 3L));        assertEquals(dt00.getMillis(), fld.add(dt96.getMillis(), 4L));    }    public void testDurationMonth() {        // Leap 1999, NotLeap 1996,97,98        DateTime dt11 = new DateTime(1999, 11, 2, 0, 0, 0, 0, ETHIOPIC_UTC);        DateTime dt12 = new DateTime(1999, 12, 2, 0, 0, 0, 0, ETHIOPIC_UTC);        DateTime dt13 = new DateTime(1999, 13, 2, 0, 0, 0, 0, ETHIOPIC_UTC);        DateTime dt01 = new DateTime(2000, 1, 2, 0, 0, 0, 0, ETHIOPIC_UTC);                DurationField fld = dt11.monthOfYear().getDurationField();        assertEquals(ETHIOPIC_UTC.months(), fld);        assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1, dt11.getMillis()));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2, dt11.getMillis()));        assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3, dt11.getMillis()));        assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4, dt11.getMillis()));                assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2));        assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13));                assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L, dt11.getMillis()));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L, dt11.getMillis()));        assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3L, dt11.getMillis()));        assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4L, dt11.getMillis()));                assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L));        assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13L));                assertEquals(0, fld.getValue(1L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis()));        assertEquals(1, fld.getValue(2L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis()));        assertEquals(2, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis()));        assertEquals(3, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis()));                assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1));        assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2));        assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3));                assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1L));        assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2L));        assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3L));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.Instant;import org.joda.time.Period;import org.joda.time.YearMonthDay;/** * This class is a Junit unit test for GJChronology. * * @author Stephen Colebourne */public class TestGJChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJChronology.class);    }    public TestGJChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, GJChronology.getInstanceUTC().getZone());        assertSame(GJChronology.class, GJChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, GJChronology.getInstance().getZone());        assertSame(GJChronology.class, GJChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, GJChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, GJChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, GJChronology.getInstance(null).getZone());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO).getClass());    }    public void testFactory_Zone_long_int() {        GJChronology chrono = GJChronology.getInstance(TOKYO, 0L, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(new Instant(0L), chrono.getGregorianCutover());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, 0L, 2).getClass());                try {            GJChronology.getInstance(TOKYO, 0L, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            GJChronology.getInstance(TOKYO, 0L, 8);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFactory_Zone_RI() {        GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L));        assertEquals(TOKYO, chrono.getZone());        assertEquals(new Instant(0L), chrono.getGregorianCutover());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L)).getClass());                DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC);        chrono = GJChronology.getInstance(TOKYO, null);        assertEquals(TOKYO, chrono.getZone());        assertEquals(cutover.toInstant(), chrono.getGregorianCutover());    }    public void testFactory_Zone_RI_int() {        GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L), 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(new Instant(0L), chrono.getGregorianCutover());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());        assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L), 2).getClass());                DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC);        chrono = GJChronology.getInstance(TOKYO, null, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(cutover.toInstant(), chrono.getGregorianCutover());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());                try {            GJChronology.getInstance(TOKYO, new Instant(0L), 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            GJChronology.getInstance(TOKYO, new Instant(0L), 8);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO));        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(LONDON));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(PARIS));        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC());        assertSame(GJChronology.getInstance(), GJChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(LONDON).withUTC());        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(TOKYO).withUTC());        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC().withUTC());        assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(null));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance().withZone(PARIS));        assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("GJChronology[Europe/London]", GJChronology.getInstance(LONDON).toString());        assertEquals("GJChronology[Asia/Tokyo]", GJChronology.getInstance(TOKYO).toString());        assertEquals("GJChronology[Europe/London]", GJChronology.getInstance().toString());        assertEquals("GJChronology[UTC]", GJChronology.getInstanceUTC().toString());        assertEquals("GJChronology[UTC,cutover=1970-01-01]", GJChronology.getInstance(DateTimeZone.UTC, 0L, 4).toString());        assertEquals("GJChronology[UTC,cutover=1970-01-01T00:00:00.001Z,mdfw=2]", GJChronology.getInstance(DateTimeZone.UTC, 1L, 2).toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", GJChronology.getInstance().eras().getName());        assertEquals("centuries", GJChronology.getInstance().centuries().getName());        assertEquals("years", GJChronology.getInstance().years().getName());        assertEquals("weekyears", GJChronology.getInstance().weekyears().getName());        assertEquals("months", GJChronology.getInstance().months().getName());        assertEquals("weeks", GJChronology.getInstance().weeks().getName());        assertEquals("halfdays", GJChronology.getInstance().halfdays().getName());        assertEquals("days", GJChronology.getInstance().days().getName());        assertEquals("hours", GJChronology.getInstance().hours().getName());        assertEquals("minutes", GJChronology.getInstance().minutes().getName());        assertEquals("seconds", GJChronology.getInstance().seconds().getName());        assertEquals("millis", GJChronology.getInstance().millis().getName());                assertEquals(false, GJChronology.getInstance().eras().isSupported());        assertEquals(true, GJChronology.getInstance().centuries().isSupported());        assertEquals(true, GJChronology.getInstance().years().isSupported());        assertEquals(true, GJChronology.getInstance().weekyears().isSupported());        assertEquals(true, GJChronology.getInstance().months().isSupported());        assertEquals(true, GJChronology.getInstance().weeks().isSupported());        assertEquals(true, GJChronology.getInstance().days().isSupported());        assertEquals(true, GJChronology.getInstance().halfdays().isSupported());        assertEquals(true, GJChronology.getInstance().hours().isSupported());        assertEquals(true, GJChronology.getInstance().minutes().isSupported());        assertEquals(true, GJChronology.getInstance().seconds().isSupported());        assertEquals(true, GJChronology.getInstance().millis().isSupported());                assertEquals(false, GJChronology.getInstance().centuries().isPrecise());        assertEquals(false, GJChronology.getInstance().years().isPrecise());        assertEquals(false, GJChronology.getInstance().weekyears().isPrecise());        assertEquals(false, GJChronology.getInstance().months().isPrecise());        assertEquals(false, GJChronology.getInstance().weeks().isPrecise());        assertEquals(false, GJChronology.getInstance().days().isPrecise());        assertEquals(false, GJChronology.getInstance().halfdays().isPrecise());        assertEquals(true, GJChronology.getInstance().hours().isPrecise());        assertEquals(true, GJChronology.getInstance().minutes().isPrecise());        assertEquals(true, GJChronology.getInstance().seconds().isPrecise());        assertEquals(true, GJChronology.getInstance().millis().isPrecise());                assertEquals(false, GJChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, GJChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, GJChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, GJChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, GJChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", GJChronology.getInstance().era().getName());        assertEquals("centuryOfEra", GJChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", GJChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", GJChronology.getInstance().yearOfEra().getName());        assertEquals("year", GJChronology.getInstance().year().getName());        assertEquals("monthOfYear", GJChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", GJChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", GJChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", GJChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", GJChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", GJChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", GJChronology.getInstance().dayOfWeek().getName());                assertEquals(true, GJChronology.getInstance().era().isSupported());        assertEquals(true, GJChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, GJChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, GJChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, GJChronology.getInstance().year().isSupported());        assertEquals(true, GJChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, GJChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, GJChronology.getInstance().weekyear().isSupported());        assertEquals(true, GJChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, GJChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, GJChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, GJChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", GJChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", GJChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", GJChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", GJChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", GJChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", GJChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", GJChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", GJChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", GJChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", GJChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", GJChronology.getInstance().millisOfSecond().getName());                assertEquals(true, GJChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, GJChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, GJChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, GJChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, GJChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, GJChronology.getInstance().millisOfSecond().isSupported());    }    public void testIllegalDates() {        try {            new DateTime(1582, 10, 5, 0, 0, 0, 0, GJChronology.getInstance(DateTimeZone.UTC));            fail("Constructed illegal date");        } catch (IllegalArgumentException e) { /* good */ }        try {            new DateTime(1582, 10, 14, 0, 0, 0, 0, GJChronology.getInstance(DateTimeZone.UTC));            fail("Constructed illegal date");        } catch (IllegalArgumentException e) { /* good */ }    }    public void testParseEquivalence() {        testParse("1581-01-01T01:23:45.678", 1581, 1, 1, 1, 23, 45, 678);        testParse("1581-06-30", 1581, 6, 30, 0, 0, 0, 0);        testParse("1582-01-01T01:23:45.678", 1582, 1, 1, 1, 23, 45, 678);        testParse("1582-06-30T01:23:45.678", 1582, 6, 30, 1, 23, 45, 678);        testParse("1582-10-04", 1582, 10, 4, 0, 0, 0, 0);        testParse("1582-10-15", 1582, 10, 15, 0, 0, 0, 0);        testParse("1582-12-31", 1582, 12, 31, 0, 0, 0, 0);        testParse("1583-12-31", 1583, 12, 31, 0, 0, 0, 0);    }    private void testParse(String str,                           int year, int month, int day,                           int hour, int minute, int second, int millis) {        assertEquals(new DateTime(str, GJChronology.getInstance(DateTimeZone.UTC)),                     new DateTime(year, month, day, hour, minute, second, millis,                                  GJChronology.getInstance(DateTimeZone.UTC)));    }    public void testCutoverAddYears() {        testAdd("1582-01-01", DurationFieldType.years(), 1, "1583-01-01");        testAdd("1582-02-15", DurationFieldType.years(), 1, "1583-02-15");        testAdd("1582-02-28", DurationFieldType.years(), 1, "1583-02-28");        testAdd("1582-03-01", DurationFieldType.years(), 1, "1583-03-01");        testAdd("1582-09-30", DurationFieldType.years(), 1, "1583-09-30");        testAdd("1582-10-01", DurationFieldType.years(), 1, "1583-10-01");        testAdd("1582-10-04", DurationFieldType.years(), 1, "1583-10-04");        testAdd("1582-10-15", DurationFieldType.years(), 1, "1583-10-15");        testAdd("1582-10-16", DurationFieldType.years(), 1, "1583-10-16");        // Leap years...        testAdd("1580-01-01", DurationFieldType.years(), 4, "1584-01-01");        testAdd("1580-02-29", DurationFieldType.years(), 4, "1584-02-29");        testAdd("1580-10-01", DurationFieldType.years(), 4, "1584-10-01");        testAdd("1580-10-10", DurationFieldType.years(), 4, "1584-10-10");        testAdd("1580-10-15", DurationFieldType.years(), 4, "1584-10-15");        testAdd("1580-12-31", DurationFieldType.years(), 4, "1584-12-31");    }    public void testCutoverAddWeekyears() {        testAdd("1582-W01-1", DurationFieldType.weekyears(), 1, "1583-W01-1");        testAdd("1582-W39-1", DurationFieldType.weekyears(), 1, "1583-W39-1");        testAdd("1583-W45-1", DurationFieldType.weekyears(), 1, "1584-W45-1");        // This test fails, but I'm not sure if its worth fixing. The date        // falls after the cutover, but in the cutover year. The add operation        // is performed completely within the gregorian calendar, with no        // crossing of the cutover. As a result, no special correction is        // applied. Since the full gregorian year of 1582 has a different week        // numbers than the full julian year of 1582, the week number is off by        // one after the addition.        //        //testAdd("1582-W42-1", DurationFieldType.weekyears(), 1, "1583-W42-1");        // Leap years...        testAdd("1580-W01-1", DurationFieldType.weekyears(), 4, "1584-W01-1");        testAdd("1580-W30-7", DurationFieldType.weekyears(), 4, "1584-W30-7");        testAdd("1580-W50-7", DurationFieldType.weekyears(), 4, "1584-W50-7");    }    public void testCutoverAddMonths() {        testAdd("1582-01-01", DurationFieldType.months(), 1, "1582-02-01");        testAdd("1582-01-01", DurationFieldType.months(), 6, "1582-07-01");        testAdd("1582-01-01", DurationFieldType.months(), 12, "1583-01-01");        testAdd("1582-11-15", DurationFieldType.months(), 1, "1582-12-15");        testAdd("1582-09-04", DurationFieldType.months(), 2, "1582-11-04");        testAdd("1582-09-05", DurationFieldType.months(), 2, "1582-11-05");        testAdd("1582-09-10", DurationFieldType.months(), 2, "1582-11-10");        testAdd("1582-09-15", DurationFieldType.months(), 2, "1582-11-15");        // Leap years...        testAdd("1580-01-01", DurationFieldType.months(), 48, "1584-01-01");        testAdd("1580-02-29", DurationFieldType.months(), 48, "1584-02-29");        testAdd("1580-10-01", DurationFieldType.months(), 48, "1584-10-01");        testAdd("1580-10-10", DurationFieldType.months(), 48, "1584-10-10");        testAdd("1580-10-15", DurationFieldType.months(), 48, "1584-10-15");        testAdd("1580-12-31", DurationFieldType.months(), 48, "1584-12-31");    }    public void testCutoverAddWeeks() {        testAdd("1582-01-01", DurationFieldType.weeks(), 1, "1582-01-08");        testAdd("1583-01-01", DurationFieldType.weeks(), 1, "1583-01-08");        // Weeks are precise, and so cutover is not ignored.        testAdd("1582-10-01", DurationFieldType.weeks(), 2, "1582-10-25");        testAdd("1582-W01-1", DurationFieldType.weeks(), 51, "1583-W01-1");    }    public void testCutoverAddDays() {        testAdd("1582-10-03", DurationFieldType.days(), 1, "1582-10-04");        testAdd("1582-10-04", DurationFieldType.days(), 1, "1582-10-15");        testAdd("1582-10-15", DurationFieldType.days(), 1, "1582-10-16");        testAdd("1582-09-30", DurationFieldType.days(), 10, "1582-10-20");        testAdd("1582-10-04", DurationFieldType.days(), 10, "1582-10-24");        testAdd("1582-10-15", DurationFieldType.days(), 10, "1582-10-25");    }    public void testSubtractDays() {        // This is a test for a bug in version 1.0. The dayOfMonth range        // duration field did not match the monthOfYear duration field. This        // caused an exception to be thrown when subtracting days.        DateTime dt = new DateTime            (1112306400000L, GJChronology.getInstance(DateTimeZone.forID("Europe/Berlin")));        YearMonthDay ymd = dt.toYearMonthDay();        while (ymd.toDateTimeAtMidnight().getDayOfWeek() != DateTimeConstants.MONDAY) {             ymd = ymd.minus(Period.days(1));        }    }    private void testAdd(String start, DurationFieldType type, int amt, String end) {        DateTime dtStart = new DateTime(start, GJChronology.getInstance(DateTimeZone.UTC));        DateTime dtEnd = new DateTime(end, GJChronology.getInstance(DateTimeZone.UTC));        assertEquals(dtEnd, dtStart.withFieldAdded(type, amt));        assertEquals(dtStart, dtEnd.withFieldAdded(type, -amt));        DurationField field = type.getField(GJChronology.getInstance(DateTimeZone.UTC));        int diff = field.getDifference(dtEnd.getMillis(), dtStart.getMillis());        assertEquals(amt, diff);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.IllegalFieldValueException;/** * This class is a Junit unit test for ISOChronology. * * @author Stephen Colebourne */public class TestISOChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOChronology.class);    }    public TestISOChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, ISOChronology.getInstanceUTC().getZone());        assertSame(ISOChronology.class, ISOChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, ISOChronology.getInstance().getZone());        assertSame(ISOChronology.class, ISOChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, ISOChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, ISOChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, ISOChronology.getInstance(null).getZone());        assertSame(ISOChronology.class, ISOChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(LONDON));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(PARIS));        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC());        assertSame(ISOChronology.getInstance(), ISOChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(LONDON).withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(TOKYO).withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC().withUTC());        assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(null));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance().withZone(PARIS));        assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance(LONDON).toString());        assertEquals("ISOChronology[Asia/Tokyo]", ISOChronology.getInstance(TOKYO).toString());        assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance().toString());        assertEquals("ISOChronology[UTC]", ISOChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", ISOChronology.getInstance().eras().getName());        assertEquals("centuries", ISOChronology.getInstance().centuries().getName());        assertEquals("years", ISOChronology.getInstance().years().getName());        assertEquals("weekyears", ISOChronology.getInstance().weekyears().getName());        assertEquals("months", ISOChronology.getInstance().months().getName());        assertEquals("weeks", ISOChronology.getInstance().weeks().getName());        assertEquals("days", ISOChronology.getInstance().days().getName());        assertEquals("halfdays", ISOChronology.getInstance().halfdays().getName());        assertEquals("hours", ISOChronology.getInstance().hours().getName());        assertEquals("minutes", ISOChronology.getInstance().minutes().getName());        assertEquals("seconds", ISOChronology.getInstance().seconds().getName());        assertEquals("millis", ISOChronology.getInstance().millis().getName());                assertEquals(false, ISOChronology.getInstance().eras().isSupported());        assertEquals(true, ISOChronology.getInstance().centuries().isSupported());        assertEquals(true, ISOChronology.getInstance().years().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyears().isSupported());        assertEquals(true, ISOChronology.getInstance().months().isSupported());        assertEquals(true, ISOChronology.getInstance().weeks().isSupported());        assertEquals(true, ISOChronology.getInstance().days().isSupported());        assertEquals(true, ISOChronology.getInstance().halfdays().isSupported());        assertEquals(true, ISOChronology.getInstance().hours().isSupported());        assertEquals(true, ISOChronology.getInstance().minutes().isSupported());        assertEquals(true, ISOChronology.getInstance().seconds().isSupported());        assertEquals(true, ISOChronology.getInstance().millis().isSupported());                assertEquals(false, ISOChronology.getInstance().centuries().isPrecise());        assertEquals(false, ISOChronology.getInstance().years().isPrecise());        assertEquals(false, ISOChronology.getInstance().weekyears().isPrecise());        assertEquals(false, ISOChronology.getInstance().months().isPrecise());        assertEquals(false, ISOChronology.getInstance().weeks().isPrecise());        assertEquals(false, ISOChronology.getInstance().days().isPrecise());        assertEquals(false, ISOChronology.getInstance().halfdays().isPrecise());        assertEquals(true, ISOChronology.getInstance().hours().isPrecise());        assertEquals(true, ISOChronology.getInstance().minutes().isPrecise());        assertEquals(true, ISOChronology.getInstance().seconds().isPrecise());        assertEquals(true, ISOChronology.getInstance().millis().isPrecise());                assertEquals(false, ISOChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, ISOChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, ISOChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", ISOChronology.getInstance().era().getName());        assertEquals("centuryOfEra", ISOChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", ISOChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", ISOChronology.getInstance().yearOfEra().getName());        assertEquals("year", ISOChronology.getInstance().year().getName());        assertEquals("monthOfYear", ISOChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", ISOChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", ISOChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", ISOChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", ISOChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", ISOChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", ISOChronology.getInstance().dayOfWeek().getName());                assertEquals(true, ISOChronology.getInstance().era().isSupported());        assertEquals(true, ISOChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, ISOChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, ISOChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, ISOChronology.getInstance().year().isSupported());        assertEquals(true, ISOChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, ISOChronology.getInstance().weekyear().isSupported());        assertEquals(true, ISOChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, ISOChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", ISOChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", ISOChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", ISOChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", ISOChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", ISOChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", ISOChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", ISOChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", ISOChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", ISOChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", ISOChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", ISOChronology.getInstance().millisOfSecond().getName());                assertEquals(true, ISOChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, ISOChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, ISOChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, ISOChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, ISOChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, ISOChronology.getInstance().millisOfSecond().isSupported());    }    public void testMaxYear() {        final ISOChronology chrono = ISOChronology.getInstanceUTC();        final int maxYear = chrono.year().getMaximumValue();        DateTime start = new DateTime(maxYear, 1, 1, 0, 0, 0, 0, chrono);        DateTime end = new DateTime(maxYear, 12, 31, 23, 59, 59, 999, chrono);        assertTrue(start.getMillis() > 0);        assertTrue(end.getMillis() > start.getMillis());        assertEquals(maxYear, start.getYear());        assertEquals(maxYear, end.getYear());        long delta = end.getMillis() - start.getMillis();        long expectedDelta =             (start.year().isLeap() ? 366L : 365L) * DateTimeConstants.MILLIS_PER_DAY - 1;        assertEquals(expectedDelta, delta);        assertEquals(start, new DateTime(maxYear + "-01-01T00:00:00.000Z", chrono));        assertEquals(end, new DateTime(maxYear + "-12-31T23:59:59.999Z", chrono));        try {            start.plusYears(1);            fail();        } catch (IllegalFieldValueException e) {        }        try {            end.plusYears(1);            fail();        } catch (IllegalFieldValueException e) {        }        try {            chrono.year().get(Long.MAX_VALUE);            fail();        } catch (ArithmeticException e) {        }    }    public void testMinYear() {        final ISOChronology chrono = ISOChronology.getInstanceUTC();        final int minYear = chrono.year().getMinimumValue();        DateTime start = new DateTime(minYear, 1, 1, 0, 0, 0, 0, chrono);        DateTime end = new DateTime(minYear, 12, 31, 23, 59, 59, 999, chrono);        assertTrue(start.getMillis() < 0);        assertTrue(end.getMillis() > start.getMillis());        assertEquals(minYear, start.getYear());        assertEquals(minYear, end.getYear());        long delta = end.getMillis() - start.getMillis();        long expectedDelta =             (start.year().isLeap() ? 366L : 365L) * DateTimeConstants.MILLIS_PER_DAY - 1;        assertEquals(expectedDelta, delta);        assertEquals(start, new DateTime(minYear + "-01-01T00:00:00.000Z", chrono));        assertEquals(end, new DateTime(minYear + "-12-31T23:59:59.999Z", chrono));        try {            start.minusYears(1);            fail();        } catch (IllegalFieldValueException e) {        }        try {            end.minusYears(1);            fail();        } catch (IllegalFieldValueException e) {        }        try {            chrono.year().get(Long.MIN_VALUE);            fail();        } catch (ArithmeticException e) {        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.DurationField;import org.joda.time.DurationFieldType;import org.joda.time.DateTime.Property;/** * This class is a Junit unit test for CopticChronology. * * @author Stephen Colebourne */public class TestCopticChronology extends TestCase {    private static final int MILLIS_PER_DAY = DateTimeConstants.MILLIS_PER_DAY;    private static long SKIP = 1 * MILLIS_PER_DAY;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();    private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC();    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        SKIP = 1 * MILLIS_PER_DAY;        return new TestSuite(TestCopticChronology.class);    }    public TestCopticChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, CopticChronology.getInstanceUTC().getZone());        assertSame(CopticChronology.class, CopticChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, CopticChronology.getInstance().getZone());        assertSame(CopticChronology.class, CopticChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, CopticChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, CopticChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, CopticChronology.getInstance(null).getZone());        assertSame(CopticChronology.class, CopticChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO));        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(LONDON));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(PARIS));        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC());        assertSame(CopticChronology.getInstance(), CopticChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(LONDON).withUTC());        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(TOKYO).withUTC());        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC().withUTC());        assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(null));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance().withZone(PARIS));        assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("CopticChronology[Europe/London]", CopticChronology.getInstance(LONDON).toString());        assertEquals("CopticChronology[Asia/Tokyo]", CopticChronology.getInstance(TOKYO).toString());        assertEquals("CopticChronology[Europe/London]", CopticChronology.getInstance().toString());        assertEquals("CopticChronology[UTC]", CopticChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", CopticChronology.getInstance().eras().getName());        assertEquals("centuries", CopticChronology.getInstance().centuries().getName());        assertEquals("years", CopticChronology.getInstance().years().getName());        assertEquals("weekyears", CopticChronology.getInstance().weekyears().getName());        assertEquals("months", CopticChronology.getInstance().months().getName());        assertEquals("weeks", CopticChronology.getInstance().weeks().getName());        assertEquals("days", CopticChronology.getInstance().days().getName());        assertEquals("halfdays", CopticChronology.getInstance().halfdays().getName());        assertEquals("hours", CopticChronology.getInstance().hours().getName());        assertEquals("minutes", CopticChronology.getInstance().minutes().getName());        assertEquals("seconds", CopticChronology.getInstance().seconds().getName());        assertEquals("millis", CopticChronology.getInstance().millis().getName());                assertEquals(false, CopticChronology.getInstance().eras().isSupported());        assertEquals(true, CopticChronology.getInstance().centuries().isSupported());        assertEquals(true, CopticChronology.getInstance().years().isSupported());        assertEquals(true, CopticChronology.getInstance().weekyears().isSupported());        assertEquals(true, CopticChronology.getInstance().months().isSupported());        assertEquals(true, CopticChronology.getInstance().weeks().isSupported());        assertEquals(true, CopticChronology.getInstance().days().isSupported());        assertEquals(true, CopticChronology.getInstance().halfdays().isSupported());        assertEquals(true, CopticChronology.getInstance().hours().isSupported());        assertEquals(true, CopticChronology.getInstance().minutes().isSupported());        assertEquals(true, CopticChronology.getInstance().seconds().isSupported());        assertEquals(true, CopticChronology.getInstance().millis().isSupported());                assertEquals(false, CopticChronology.getInstance().centuries().isPrecise());        assertEquals(false, CopticChronology.getInstance().years().isPrecise());        assertEquals(false, CopticChronology.getInstance().weekyears().isPrecise());        assertEquals(false, CopticChronology.getInstance().months().isPrecise());        assertEquals(false, CopticChronology.getInstance().weeks().isPrecise());        assertEquals(false, CopticChronology.getInstance().days().isPrecise());        assertEquals(false, CopticChronology.getInstance().halfdays().isPrecise());        assertEquals(true, CopticChronology.getInstance().hours().isPrecise());        assertEquals(true, CopticChronology.getInstance().minutes().isPrecise());        assertEquals(true, CopticChronology.getInstance().seconds().isPrecise());        assertEquals(true, CopticChronology.getInstance().millis().isPrecise());                assertEquals(false, CopticChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, CopticChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, CopticChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, CopticChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, CopticChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", CopticChronology.getInstance().era().getName());        assertEquals("centuryOfEra", CopticChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", CopticChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", CopticChronology.getInstance().yearOfEra().getName());        assertEquals("year", CopticChronology.getInstance().year().getName());        assertEquals("monthOfYear", CopticChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", CopticChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", CopticChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", CopticChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", CopticChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", CopticChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", CopticChronology.getInstance().dayOfWeek().getName());                assertEquals(true, CopticChronology.getInstance().era().isSupported());        assertEquals(true, CopticChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, CopticChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, CopticChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, CopticChronology.getInstance().year().isSupported());        assertEquals(true, CopticChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, CopticChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, CopticChronology.getInstance().weekyear().isSupported());        assertEquals(true, CopticChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, CopticChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, CopticChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, CopticChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", CopticChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", CopticChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", CopticChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", CopticChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", CopticChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", CopticChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", CopticChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", CopticChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", CopticChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", CopticChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", CopticChronology.getInstance().millisOfSecond().getName());                assertEquals(true, CopticChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, CopticChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, CopticChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, CopticChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, CopticChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, CopticChronology.getInstance().millisOfSecond().isSupported());    }    //-----------------------------------------------------------------------    public void testEpoch() {        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, COPTIC_UTC);        assertEquals(new DateTime(284, 8, 29, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC));    }    public void testEra() {        assertEquals(1, CopticChronology.AM);        try {            new DateTime(-1, 13, 5, 0, 0, 0, 0, COPTIC_UTC);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    /**     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.     */    public void testCalendar() {        if (TestAll.FAST) {            return;        }        System.out.println("\nTestCopticChronology.testCalendar");        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, COPTIC_UTC);        long millis = epoch.getMillis();        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();        DateTimeField dayOfWeek = COPTIC_UTC.dayOfWeek();        DateTimeField dayOfYear = COPTIC_UTC.dayOfYear();        DateTimeField dayOfMonth = COPTIC_UTC.dayOfMonth();        DateTimeField monthOfYear = COPTIC_UTC.monthOfYear();        DateTimeField year = COPTIC_UTC.year();        DateTimeField yearOfEra = COPTIC_UTC.yearOfEra();        DateTimeField era = COPTIC_UTC.era();        int expectedDOW = new DateTime(284, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();        int expectedDOY = 1;        int expectedDay = 1;        int expectedMonth = 1;        int expectedYear = 1;        while (millis < end) {            int dowValue = dayOfWeek.get(millis);            int doyValue = dayOfYear.get(millis);            int dayValue = dayOfMonth.get(millis);            int monthValue = monthOfYear.get(millis);            int yearValue = year.get(millis);            int yearOfEraValue = yearOfEra.get(millis);            int monthLen = dayOfMonth.getMaximumValue(millis);            if (monthValue < 1 || monthValue > 13) {                fail("Bad month: " + millis);            }                        // test era            assertEquals(1, era.get(millis));            assertEquals("AM", era.getAsText(millis));            assertEquals("AM", era.getAsShortText(millis));                        // test date            assertEquals(expectedYear, yearValue);            assertEquals(expectedYear, yearOfEraValue);            assertEquals(expectedMonth, monthValue);            assertEquals(expectedDay, dayValue);            assertEquals(expectedDOW, dowValue);            assertEquals(expectedDOY, doyValue);                        // test leap year            assertEquals(yearValue % 4 == 3, year.isLeap(millis));                        // test month length            if (monthValue == 13) {                assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis));                if (yearValue % 4 == 3) {                    assertEquals(6, monthLen);                } else {                    assertEquals(5, monthLen);                }            } else {                assertEquals(30, monthLen);            }                        // recalculate date            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;            expectedDay++;            expectedDOY++;            if (expectedDay == 31 && expectedMonth < 13) {                expectedDay = 1;                expectedMonth++;            } else if (expectedMonth == 13) {                if (expectedYear % 4 == 3 && expectedDay == 7) {                    expectedDay = 1;                    expectedMonth = 1;                    expectedYear++;                    expectedDOY = 1;                } else if (expectedYear % 4 != 3 && expectedDay == 6) {                    expectedDay = 1;                    expectedMonth = 1;                    expectedYear++;                    expectedDOY = 1;                }            }            millis += SKIP;        }    }    public void testSampleDate() {        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ISO_UTC).withChronology(COPTIC_UTC);        assertEquals(CopticChronology.AM, dt.getEra());        assertEquals(18, dt.getCenturyOfEra());  // TODO confirm        assertEquals(20, dt.getYearOfCentury());        assertEquals(1720, dt.getYearOfEra());                assertEquals(1720, dt.getYear());        Property fld = dt.year();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(new DateTime(1721, 10, 2, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1));                assertEquals(10, dt.getMonthOfYear());        fld = dt.monthOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(13, fld.getMaximumValue());        assertEquals(13, fld.getMaximumValueOverall());        assertEquals(new DateTime(1721, 1, 2, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(4));        assertEquals(new DateTime(1720, 1, 2, 0, 0, 0, 0, COPTIC_UTC), fld.addWrapFieldToCopy(4));                assertEquals(2, dt.getDayOfMonth());        fld = dt.dayOfMonth();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(30, fld.getMaximumValue());        assertEquals(30, fld.getMaximumValueOverall());        assertEquals(new DateTime(1720, 10, 3, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1));                assertEquals(DateTimeConstants.WEDNESDAY, dt.getDayOfWeek());        fld = dt.dayOfWeek();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(7, fld.getMaximumValue());        assertEquals(7, fld.getMaximumValueOverall());        assertEquals(new DateTime(1720, 10, 3, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1));                assertEquals(9 * 30 + 2, dt.getDayOfYear());        fld = dt.dayOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(365, fld.getMaximumValue());        assertEquals(366, fld.getMaximumValueOverall());        assertEquals(new DateTime(1720, 10, 3, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1));                assertEquals(0, dt.getHourOfDay());        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void testSampleDateWithZone() {        DateTime dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, PARIS).withChronology(COPTIC_UTC);        assertEquals(CopticChronology.AM, dt.getEra());        assertEquals(1720, dt.getYear());        assertEquals(1720, dt.getYearOfEra());        assertEquals(10, dt.getMonthOfYear());        assertEquals(2, dt.getDayOfMonth());        assertEquals(10, dt.getHourOfDay());  // PARIS is UTC+2 in summer (12-2=10)        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void testDurationYear() {        // Leap 1723        DateTime dt20 = new DateTime(1720, 10, 2, 0, 0, 0, 0, COPTIC_UTC);        DateTime dt21 = new DateTime(1721, 10, 2, 0, 0, 0, 0, COPTIC_UTC);        DateTime dt22 = new DateTime(1722, 10, 2, 0, 0, 0, 0, COPTIC_UTC);        DateTime dt23 = new DateTime(1723, 10, 2, 0, 0, 0, 0, COPTIC_UTC);        DateTime dt24 = new DateTime(1724, 10, 2, 0, 0, 0, 0, COPTIC_UTC);                DurationField fld = dt20.year().getDurationField();        assertEquals(COPTIC_UTC.years(), fld);        assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1, dt20.getMillis()));        assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2, dt20.getMillis()));        assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3, dt20.getMillis()));        assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4, dt20.getMillis()));                assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1));        assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2));                assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1L, dt20.getMillis()));        assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2L, dt20.getMillis()));        assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3L, dt20.getMillis()));        assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4L, dt20.getMillis()));                assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1L));        assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2L));                assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getUnitMillis());                assertEquals(0, fld.getValue(1L * 365L * MILLIS_PER_DAY - 1L, dt20.getMillis()));        assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY, dt20.getMillis()));        assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY + 1L, dt20.getMillis()));        assertEquals(1, fld.getValue(2L * 365L * MILLIS_PER_DAY - 1L, dt20.getMillis()));        assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY, dt20.getMillis()));        assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY + 1L, dt20.getMillis()));        assertEquals(2, fld.getValue(3L * 365L * MILLIS_PER_DAY - 1L, dt20.getMillis()));        assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY, dt20.getMillis()));        assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY + 1L, dt20.getMillis()));        assertEquals(3, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY - 1L, dt20.getMillis()));        assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY, dt20.getMillis()));        assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY + 1L, dt20.getMillis()));                assertEquals(dt21.getMillis(), fld.add(dt20.getMillis(), 1));        assertEquals(dt22.getMillis(), fld.add(dt20.getMillis(), 2));        assertEquals(dt23.getMillis(), fld.add(dt20.getMillis(), 3));        assertEquals(dt24.getMillis(), fld.add(dt20.getMillis(), 4));                assertEquals(dt21.getMillis(), fld.add(dt20.getMillis(), 1L));        assertEquals(dt22.getMillis(), fld.add(dt20.getMillis(), 2L));        assertEquals(dt23.getMillis(), fld.add(dt20.getMillis(), 3L));        assertEquals(dt24.getMillis(), fld.add(dt20.getMillis(), 4L));    }    public void testDurationMonth() {        // Leap 1723        DateTime dt11 = new DateTime(1723, 11, 2, 0, 0, 0, 0, COPTIC_UTC);        DateTime dt12 = new DateTime(1723, 12, 2, 0, 0, 0, 0, COPTIC_UTC);        DateTime dt13 = new DateTime(1723, 13, 2, 0, 0, 0, 0, COPTIC_UTC);        DateTime dt01 = new DateTime(1724, 1, 2, 0, 0, 0, 0, COPTIC_UTC);                DurationField fld = dt11.monthOfYear().getDurationField();        assertEquals(COPTIC_UTC.months(), fld);        assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1, dt11.getMillis()));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2, dt11.getMillis()));        assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3, dt11.getMillis()));        assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4, dt11.getMillis()));                assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2));        assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13));                assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L, dt11.getMillis()));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L, dt11.getMillis()));        assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3L, dt11.getMillis()));        assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4L, dt11.getMillis()));                assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L));        assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L));        assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13L));                assertEquals(0, fld.getValue(1L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis()));        assertEquals(1, fld.getValue(2L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis()));        assertEquals(2, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis()));        assertEquals(3, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis()));        assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis()));        assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis()));                assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1));        assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2));        assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3));                assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1L));        assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2L));        assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3L));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;/** * This class is a Junit unit test for JulianChronology. * * @author Stephen Colebourne */public class TestJulianChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestJulianChronology.class);    }    public TestJulianChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, JulianChronology.getInstanceUTC().getZone());        assertSame(JulianChronology.class, JulianChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, JulianChronology.getInstance().getZone());        assertSame(JulianChronology.class, JulianChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, JulianChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, JulianChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, JulianChronology.getInstance(null).getZone());        assertSame(JulianChronology.class, JulianChronology.getInstance(TOKYO).getClass());    }    public void testFactory_Zone_int() {        JulianChronology chrono = JulianChronology.getInstance(TOKYO, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());                try {            JulianChronology.getInstance(TOKYO, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            JulianChronology.getInstance(TOKYO, 8);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO));        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(LONDON));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(PARIS));        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC());        assertSame(JulianChronology.getInstance(), JulianChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(LONDON).withUTC());        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(TOKYO).withUTC());        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC().withUTC());        assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(null));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance().withZone(PARIS));        assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("JulianChronology[Europe/London]", JulianChronology.getInstance(LONDON).toString());        assertEquals("JulianChronology[Asia/Tokyo]", JulianChronology.getInstance(TOKYO).toString());        assertEquals("JulianChronology[Europe/London]", JulianChronology.getInstance().toString());        assertEquals("JulianChronology[UTC]", JulianChronology.getInstanceUTC().toString());        assertEquals("JulianChronology[UTC,mdfw=2]", JulianChronology.getInstance(DateTimeZone.UTC, 2).toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", JulianChronology.getInstance().eras().getName());        assertEquals("centuries", JulianChronology.getInstance().centuries().getName());        assertEquals("years", JulianChronology.getInstance().years().getName());        assertEquals("weekyears", JulianChronology.getInstance().weekyears().getName());        assertEquals("months", JulianChronology.getInstance().months().getName());        assertEquals("weeks", JulianChronology.getInstance().weeks().getName());        assertEquals("days", JulianChronology.getInstance().days().getName());        assertEquals("halfdays", JulianChronology.getInstance().halfdays().getName());        assertEquals("hours", JulianChronology.getInstance().hours().getName());        assertEquals("minutes", JulianChronology.getInstance().minutes().getName());        assertEquals("seconds", JulianChronology.getInstance().seconds().getName());        assertEquals("millis", JulianChronology.getInstance().millis().getName());                assertEquals(false, JulianChronology.getInstance().eras().isSupported());        assertEquals(true, JulianChronology.getInstance().centuries().isSupported());        assertEquals(true, JulianChronology.getInstance().years().isSupported());        assertEquals(true, JulianChronology.getInstance().weekyears().isSupported());        assertEquals(true, JulianChronology.getInstance().months().isSupported());        assertEquals(true, JulianChronology.getInstance().weeks().isSupported());        assertEquals(true, JulianChronology.getInstance().days().isSupported());        assertEquals(true, JulianChronology.getInstance().halfdays().isSupported());        assertEquals(true, JulianChronology.getInstance().hours().isSupported());        assertEquals(true, JulianChronology.getInstance().minutes().isSupported());        assertEquals(true, JulianChronology.getInstance().seconds().isSupported());        assertEquals(true, JulianChronology.getInstance().millis().isSupported());                assertEquals(false, JulianChronology.getInstance().centuries().isPrecise());        assertEquals(false, JulianChronology.getInstance().years().isPrecise());        assertEquals(false, JulianChronology.getInstance().weekyears().isPrecise());        assertEquals(false, JulianChronology.getInstance().months().isPrecise());        assertEquals(false, JulianChronology.getInstance().weeks().isPrecise());        assertEquals(false, JulianChronology.getInstance().days().isPrecise());        assertEquals(false, JulianChronology.getInstance().halfdays().isPrecise());        assertEquals(true, JulianChronology.getInstance().hours().isPrecise());        assertEquals(true, JulianChronology.getInstance().minutes().isPrecise());        assertEquals(true, JulianChronology.getInstance().seconds().isPrecise());        assertEquals(true, JulianChronology.getInstance().millis().isPrecise());                assertEquals(false, JulianChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, JulianChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, JulianChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, JulianChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, JulianChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", JulianChronology.getInstance().era().getName());        assertEquals("centuryOfEra", JulianChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", JulianChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", JulianChronology.getInstance().yearOfEra().getName());        assertEquals("year", JulianChronology.getInstance().year().getName());        assertEquals("monthOfYear", JulianChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", JulianChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", JulianChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", JulianChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", JulianChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", JulianChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", JulianChronology.getInstance().dayOfWeek().getName());                assertEquals(true, JulianChronology.getInstance().era().isSupported());        assertEquals(true, JulianChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, JulianChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, JulianChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, JulianChronology.getInstance().year().isSupported());        assertEquals(true, JulianChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, JulianChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, JulianChronology.getInstance().weekyear().isSupported());        assertEquals(true, JulianChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, JulianChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, JulianChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, JulianChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", JulianChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", JulianChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", JulianChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", JulianChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", JulianChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", JulianChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", JulianChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", JulianChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", JulianChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", JulianChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", JulianChronology.getInstance().millisOfSecond().getName());                assertEquals(true, JulianChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, JulianChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, JulianChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, JulianChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, JulianChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, JulianChronology.getInstance().millisOfSecond().isSupported());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.DurationFieldType;import org.joda.time.DateTime.Property;/** * This class is a Junit unit test for IslamicChronology. * * @author Stephen Colebourne */public class TestIslamicChronology extends TestCase {    private static long SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final Chronology ISLAMIC_UTC = IslamicChronology.getInstanceUTC();    private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC();    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;        return new TestSuite(TestIslamicChronology.class);    }    public TestIslamicChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, IslamicChronology.getInstanceUTC().getZone());        assertSame(IslamicChronology.class, IslamicChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, IslamicChronology.getInstance().getZone());        assertSame(IslamicChronology.class, IslamicChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, IslamicChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, IslamicChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, IslamicChronology.getInstance(null).getZone());        assertSame(IslamicChronology.class, IslamicChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(IslamicChronology.getInstance(TOKYO), IslamicChronology.getInstance(TOKYO));        assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(LONDON));        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance(PARIS));        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstanceUTC());        assertSame(IslamicChronology.getInstance(), IslamicChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance(LONDON).withUTC());        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance(TOKYO).withUTC());        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstanceUTC().withUTC());        assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(IslamicChronology.getInstance(TOKYO), IslamicChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(TOKYO).withZone(null));        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance().withZone(PARIS));        assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("IslamicChronology[Europe/London]", IslamicChronology.getInstance(LONDON).toString());        assertEquals("IslamicChronology[Asia/Tokyo]", IslamicChronology.getInstance(TOKYO).toString());        assertEquals("IslamicChronology[Europe/London]", IslamicChronology.getInstance().toString());        assertEquals("IslamicChronology[UTC]", IslamicChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", IslamicChronology.getInstance().eras().getName());        assertEquals("centuries", IslamicChronology.getInstance().centuries().getName());        assertEquals("years", IslamicChronology.getInstance().years().getName());        assertEquals("weekyears", IslamicChronology.getInstance().weekyears().getName());        assertEquals("months", IslamicChronology.getInstance().months().getName());        assertEquals("weeks", IslamicChronology.getInstance().weeks().getName());        assertEquals("days", IslamicChronology.getInstance().days().getName());        assertEquals("halfdays", IslamicChronology.getInstance().halfdays().getName());        assertEquals("hours", IslamicChronology.getInstance().hours().getName());        assertEquals("minutes", IslamicChronology.getInstance().minutes().getName());        assertEquals("seconds", IslamicChronology.getInstance().seconds().getName());        assertEquals("millis", IslamicChronology.getInstance().millis().getName());                assertEquals(false, IslamicChronology.getInstance().eras().isSupported());        assertEquals(true, IslamicChronology.getInstance().centuries().isSupported());        assertEquals(true, IslamicChronology.getInstance().years().isSupported());        assertEquals(true, IslamicChronology.getInstance().weekyears().isSupported());        assertEquals(true, IslamicChronology.getInstance().months().isSupported());        assertEquals(true, IslamicChronology.getInstance().weeks().isSupported());        assertEquals(true, IslamicChronology.getInstance().days().isSupported());        assertEquals(true, IslamicChronology.getInstance().halfdays().isSupported());        assertEquals(true, IslamicChronology.getInstance().hours().isSupported());        assertEquals(true, IslamicChronology.getInstance().minutes().isSupported());        assertEquals(true, IslamicChronology.getInstance().seconds().isSupported());        assertEquals(true, IslamicChronology.getInstance().millis().isSupported());                assertEquals(false, IslamicChronology.getInstance().centuries().isPrecise());        assertEquals(false, IslamicChronology.getInstance().years().isPrecise());        assertEquals(false, IslamicChronology.getInstance().weekyears().isPrecise());        assertEquals(false, IslamicChronology.getInstance().months().isPrecise());        assertEquals(false, IslamicChronology.getInstance().weeks().isPrecise());        assertEquals(false, IslamicChronology.getInstance().days().isPrecise());        assertEquals(false, IslamicChronology.getInstance().halfdays().isPrecise());        assertEquals(true, IslamicChronology.getInstance().hours().isPrecise());        assertEquals(true, IslamicChronology.getInstance().minutes().isPrecise());        assertEquals(true, IslamicChronology.getInstance().seconds().isPrecise());        assertEquals(true, IslamicChronology.getInstance().millis().isPrecise());                assertEquals(false, IslamicChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, IslamicChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, IslamicChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, IslamicChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, IslamicChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, IslamicChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, IslamicChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, IslamicChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, IslamicChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, IslamicChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, IslamicChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", IslamicChronology.getInstance().era().getName());        assertEquals("centuryOfEra", IslamicChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", IslamicChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", IslamicChronology.getInstance().yearOfEra().getName());        assertEquals("year", IslamicChronology.getInstance().year().getName());        assertEquals("monthOfYear", IslamicChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", IslamicChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", IslamicChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", IslamicChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", IslamicChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", IslamicChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", IslamicChronology.getInstance().dayOfWeek().getName());                assertEquals(true, IslamicChronology.getInstance().era().isSupported());        assertEquals(true, IslamicChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, IslamicChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, IslamicChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, IslamicChronology.getInstance().year().isSupported());        assertEquals(true, IslamicChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, IslamicChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, IslamicChronology.getInstance().weekyear().isSupported());        assertEquals(true, IslamicChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, IslamicChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, IslamicChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, IslamicChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", IslamicChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", IslamicChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", IslamicChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", IslamicChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", IslamicChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", IslamicChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", IslamicChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", IslamicChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", IslamicChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", IslamicChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", IslamicChronology.getInstance().millisOfSecond().getName());                assertEquals(true, IslamicChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, IslamicChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, IslamicChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, IslamicChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, IslamicChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, IslamicChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, IslamicChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, IslamicChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, IslamicChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, IslamicChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, IslamicChronology.getInstance().millisOfSecond().isSupported());    }    //-----------------------------------------------------------------------    public void testEpoch() {        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC);        DateTime expectedEpoch = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC);        assertEquals(expectedEpoch.getMillis(), epoch.getMillis());    }    public void testEra() {        assertEquals(1, IslamicChronology.AH);        try {            new DateTime(-1, 13, 5, 0, 0, 0, 0, ISLAMIC_UTC);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testFieldConstructor() {        DateTime date = new DateTime(1364, 12, 6, 0, 0, 0, 0, ISLAMIC_UTC);        DateTime expectedDate = new DateTime(1945, 11, 12, 0, 0, 0, 0, ISO_UTC);        assertEquals(expectedDate.getMillis(), date.getMillis());    }    //-----------------------------------------------------------------------    /**     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.     */    public void testCalendar() {        if (TestAll.FAST) {            return;        }        System.out.println("\nTestIslamicChronology.testCalendar");        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC);        long millis = epoch.getMillis();        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();        DateTimeField dayOfWeek = ISLAMIC_UTC.dayOfWeek();        DateTimeField dayOfYear = ISLAMIC_UTC.dayOfYear();        DateTimeField dayOfMonth = ISLAMIC_UTC.dayOfMonth();        DateTimeField monthOfYear = ISLAMIC_UTC.monthOfYear();        DateTimeField year = ISLAMIC_UTC.year();        DateTimeField yearOfEra = ISLAMIC_UTC.yearOfEra();        DateTimeField era = ISLAMIC_UTC.era();        int expectedDOW = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();        int expectedDOY = 1;        int expectedDay = 1;        int expectedMonth = 1;        int expectedYear = 1;        while (millis < end) {            int dowValue = dayOfWeek.get(millis);            int doyValue = dayOfYear.get(millis);            int dayValue = dayOfMonth.get(millis);            int monthValue = monthOfYear.get(millis);            int yearValue = year.get(millis);            int yearOfEraValue = yearOfEra.get(millis);            int dayOfYearLen = dayOfYear.getMaximumValue(millis);            int monthLen = dayOfMonth.getMaximumValue(millis);            if (monthValue < 1 || monthValue > 12) {                fail("Bad month: " + millis);            }                        // test era            assertEquals(1, era.get(millis));            assertEquals("AH", era.getAsText(millis));            assertEquals("AH", era.getAsShortText(millis));                        // test date            assertEquals(expectedDOY, doyValue);            assertEquals(expectedMonth, monthValue);            assertEquals(expectedDay, dayValue);            assertEquals(expectedDOW, dowValue);            assertEquals(expectedYear, yearValue);            assertEquals(expectedYear, yearOfEraValue);                        // test leap year            boolean leap = ((11 * yearValue + 14) % 30) < 11;            assertEquals(leap, year.isLeap(millis));                        // test month length            switch (monthValue) {                case 1:                case 3:                case 5:                case 7:                case 9:                case 11:                    assertEquals(30, monthLen);                    break;                case 2:                case 4:                case 6:                case 8:                case 10:                    assertEquals(29, monthLen);                    break;                case 12:                    assertEquals((leap ? 30 : 29), monthLen);                    break;            }                        // test year length            assertEquals((leap ? 355 : 354), dayOfYearLen);                        // recalculate date            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;            expectedDay++;            expectedDOY++;            if (expectedDay > monthLen) {                expectedDay = 1;                expectedMonth++;                if (expectedMonth == 13) {                    expectedMonth = 1;                    expectedDOY = 1;                    expectedYear++;                }            }            millis += SKIP;        }    }    public void testSampleDate1() {        DateTime dt = new DateTime(1945, 11, 12, 0, 0, 0, 0, ISO_UTC);        dt = dt.withChronology(ISLAMIC_UTC);        assertEquals(IslamicChronology.AH, dt.getEra());        assertEquals(14, dt.getCenturyOfEra());  // TODO confirm        assertEquals(64, dt.getYearOfCentury());        assertEquals(1364, dt.getYearOfEra());                assertEquals(1364, dt.getYear());        Property fld = dt.year();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(new DateTime(1365, 12, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));                assertEquals(12, dt.getMonthOfYear());        fld = dt.monthOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(12, fld.getMaximumValue());        assertEquals(12, fld.getMaximumValueOverall());        assertEquals(new DateTime(1365, 1, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));        assertEquals(new DateTime(1364, 1, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addWrapFieldToCopy(1));                assertEquals(6, dt.getDayOfMonth());        fld = dt.dayOfMonth();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(29, fld.getMaximumValue());        assertEquals(30, fld.getMaximumValueOverall());        assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));                assertEquals(DateTimeConstants.MONDAY, dt.getDayOfWeek());        fld = dt.dayOfWeek();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(7, fld.getMaximumValue());        assertEquals(7, fld.getMaximumValueOverall());        assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));                assertEquals(6 * 30 + 5 * 29 + 6, dt.getDayOfYear());        fld = dt.dayOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(354, fld.getMaximumValue());        assertEquals(355, fld.getMaximumValueOverall());        assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1));                assertEquals(0, dt.getHourOfDay());        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void testSampleDate2() {        DateTime dt = new DateTime(2005, 11, 26, 0, 0, 0, 0, ISO_UTC);        dt = dt.withChronology(ISLAMIC_UTC);        assertEquals(IslamicChronology.AH, dt.getEra());        assertEquals(15, dt.getCenturyOfEra());  // TODO confirm        assertEquals(26, dt.getYearOfCentury());        assertEquals(1426, dt.getYearOfEra());                assertEquals(1426, dt.getYear());        Property fld = dt.year();        assertEquals(true, fld.isLeap());        assertEquals(1, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());                assertEquals(10, dt.getMonthOfYear());        fld = dt.monthOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(12, fld.getMaximumValue());        assertEquals(12, fld.getMaximumValueOverall());                assertEquals(24, dt.getDayOfMonth());        fld = dt.dayOfMonth();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(29, fld.getMaximumValue());        assertEquals(30, fld.getMaximumValueOverall());                assertEquals(DateTimeConstants.SATURDAY, dt.getDayOfWeek());        fld = dt.dayOfWeek();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(7, fld.getMaximumValue());        assertEquals(7, fld.getMaximumValueOverall());                assertEquals(5 * 30 + 4 * 29 + 24, dt.getDayOfYear());        fld = dt.dayOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(355, fld.getMaximumValue());        assertEquals(355, fld.getMaximumValueOverall());                assertEquals(0, dt.getHourOfDay());        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void testSampleDate3() {        DateTime dt = new DateTime(1426, 12, 24, 0, 0, 0, 0, ISLAMIC_UTC);        assertEquals(IslamicChronology.AH, dt.getEra());                assertEquals(1426, dt.getYear());        Property fld = dt.year();        assertEquals(true, fld.isLeap());        assertEquals(1, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());                assertEquals(12, dt.getMonthOfYear());        fld = dt.monthOfYear();        assertEquals(true, fld.isLeap());        assertEquals(1, fld.getLeapAmount());        assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(12, fld.getMaximumValue());        assertEquals(12, fld.getMaximumValueOverall());                assertEquals(24, dt.getDayOfMonth());        fld = dt.dayOfMonth();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(30, fld.getMaximumValue());        assertEquals(30, fld.getMaximumValueOverall());                assertEquals(DateTimeConstants.TUESDAY, dt.getDayOfWeek());        fld = dt.dayOfWeek();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(7, fld.getMaximumValue());        assertEquals(7, fld.getMaximumValueOverall());                assertEquals(6 * 30 + 5 * 29 + 24, dt.getDayOfYear());        fld = dt.dayOfYear();        assertEquals(false, fld.isLeap());        assertEquals(0, fld.getLeapAmount());        assertEquals(null, fld.getLeapDurationField());        assertEquals(1, fld.getMinimumValue());        assertEquals(1, fld.getMinimumValueOverall());        assertEquals(355, fld.getMaximumValue());        assertEquals(355, fld.getMaximumValueOverall());                assertEquals(0, dt.getHourOfDay());        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void testSampleDateWithZone() {        DateTime dt = new DateTime(2005, 11, 26, 12, 0, 0, 0, PARIS).withChronology(ISLAMIC_UTC);        assertEquals(IslamicChronology.AH, dt.getEra());        assertEquals(1426, dt.getYear());        assertEquals(10, dt.getMonthOfYear());        assertEquals(24, dt.getDayOfMonth());        assertEquals(11, dt.getHourOfDay());  // PARIS is UTC+1 in summer (12-1=11)        assertEquals(0, dt.getMinuteOfHour());        assertEquals(0, dt.getSecondOfMinute());        assertEquals(0, dt.getMillisOfSecond());    }    public void test15BasedLeapYear() {        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(1));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(2));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(3));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(4));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(5));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(6));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(7));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(8));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(9));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(10));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(11));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(12));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(13));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(14));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(15));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(16));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(17));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(18));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(19));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(20));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(21));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(22));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(23));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(24));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(25));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(26));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(27));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(28));        assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(29));        assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(30));    }    public void test16BasedLeapYear() {        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(1));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(2));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(3));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(4));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(5));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(6));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(7));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(8));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(9));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(10));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(11));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(12));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(13));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(14));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(15));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(16));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(17));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(18));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(19));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(20));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(21));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(22));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(23));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(24));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(25));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(26));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(27));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(28));        assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(29));        assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(30));    }    public void testIndianBasedLeapYear() {        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(1));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(2));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(3));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(4));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(5));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(6));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(7));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(8));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(9));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(10));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(11));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(12));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(13));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(14));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(15));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(16));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(17));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(18));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(19));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(20));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(21));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(22));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(23));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(24));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(25));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(26));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(27));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(28));        assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(29));        assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(30));    }    public void testHabashAlHasibBasedLeapYear() {        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(1));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(2));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(3));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(4));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(5));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(6));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(7));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(8));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(9));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(10));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(11));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(12));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(13));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(14));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(15));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(16));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(17));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(18));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(19));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(20));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(21));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(22));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(23));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(24));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(25));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(26));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(27));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(28));        assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(29));        assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(30));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public static boolean FAST = false;    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();                suite.addTest(TestBuddhistChronology.suite());        suite.addTest(TestCopticChronology.suite());        suite.addTest(TestEthiopicChronology.suite());        suite.addTest(TestGJChronology.suite());        suite.addTest(TestGregorianChronology.suite());        suite.addTest(TestIslamicChronology.suite());        suite.addTest(TestJulianChronology.suite());        suite.addTest(TestISOChronology.suite());                return suite;    }    public static void main(String args[]) {        FAST = false;        TestRunner.run(TestAll.suite());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateMidnight;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.YearMonthDay;/** * This class is a Junit unit test for GregorianChronology. * * @author Stephen Colebourne */public class TestGregorianChronology extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGregorianChronology.class);    }    public TestGregorianChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, GregorianChronology.getInstanceUTC().getZone());        assertSame(GregorianChronology.class, GregorianChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, GregorianChronology.getInstance().getZone());        assertSame(GregorianChronology.class, GregorianChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, GregorianChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, GregorianChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, GregorianChronology.getInstance(null).getZone());        assertSame(GregorianChronology.class, GregorianChronology.getInstance(TOKYO).getClass());    }    public void testFactory_Zone_int() {        GregorianChronology chrono = GregorianChronology.getInstance(TOKYO, 2);        assertEquals(TOKYO, chrono.getZone());        assertEquals(2, chrono.getMinimumDaysInFirstWeek());                try {            GregorianChronology.getInstance(TOKYO, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            GregorianChronology.getInstance(TOKYO, 8);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO));        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(LONDON));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(PARIS));        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC());        assertSame(GregorianChronology.getInstance(), GregorianChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(LONDON).withUTC());        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(TOKYO).withUTC());        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC().withUTC());        assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(null));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance().withZone(PARIS));        assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("GregorianChronology[Europe/London]", GregorianChronology.getInstance(LONDON).toString());        assertEquals("GregorianChronology[Asia/Tokyo]", GregorianChronology.getInstance(TOKYO).toString());        assertEquals("GregorianChronology[Europe/London]", GregorianChronology.getInstance().toString());        assertEquals("GregorianChronology[UTC]", GregorianChronology.getInstanceUTC().toString());        assertEquals("GregorianChronology[UTC,mdfw=2]", GregorianChronology.getInstance(DateTimeZone.UTC, 2).toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", GregorianChronology.getInstance().eras().getName());        assertEquals("centuries", GregorianChronology.getInstance().centuries().getName());        assertEquals("years", GregorianChronology.getInstance().years().getName());        assertEquals("weekyears", GregorianChronology.getInstance().weekyears().getName());        assertEquals("months", GregorianChronology.getInstance().months().getName());        assertEquals("weeks", GregorianChronology.getInstance().weeks().getName());        assertEquals("days", GregorianChronology.getInstance().days().getName());        assertEquals("halfdays", GregorianChronology.getInstance().halfdays().getName());        assertEquals("hours", GregorianChronology.getInstance().hours().getName());        assertEquals("minutes", GregorianChronology.getInstance().minutes().getName());        assertEquals("seconds", GregorianChronology.getInstance().seconds().getName());        assertEquals("millis", GregorianChronology.getInstance().millis().getName());                assertEquals(false, GregorianChronology.getInstance().eras().isSupported());        assertEquals(true, GregorianChronology.getInstance().centuries().isSupported());        assertEquals(true, GregorianChronology.getInstance().years().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekyears().isSupported());        assertEquals(true, GregorianChronology.getInstance().months().isSupported());        assertEquals(true, GregorianChronology.getInstance().weeks().isSupported());        assertEquals(true, GregorianChronology.getInstance().days().isSupported());        assertEquals(true, GregorianChronology.getInstance().halfdays().isSupported());        assertEquals(true, GregorianChronology.getInstance().hours().isSupported());        assertEquals(true, GregorianChronology.getInstance().minutes().isSupported());        assertEquals(true, GregorianChronology.getInstance().seconds().isSupported());        assertEquals(true, GregorianChronology.getInstance().millis().isSupported());                assertEquals(false, GregorianChronology.getInstance().centuries().isPrecise());        assertEquals(false, GregorianChronology.getInstance().years().isPrecise());        assertEquals(false, GregorianChronology.getInstance().weekyears().isPrecise());        assertEquals(false, GregorianChronology.getInstance().months().isPrecise());        assertEquals(false, GregorianChronology.getInstance().weeks().isPrecise());        assertEquals(false, GregorianChronology.getInstance().days().isPrecise());        assertEquals(false, GregorianChronology.getInstance().halfdays().isPrecise());        assertEquals(true, GregorianChronology.getInstance().hours().isPrecise());        assertEquals(true, GregorianChronology.getInstance().minutes().isPrecise());        assertEquals(true, GregorianChronology.getInstance().seconds().isPrecise());        assertEquals(true, GregorianChronology.getInstance().millis().isPrecise());                assertEquals(false, GregorianChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, GregorianChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, GregorianChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, GregorianChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, GregorianChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", GregorianChronology.getInstance().era().getName());        assertEquals("centuryOfEra", GregorianChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", GregorianChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", GregorianChronology.getInstance().yearOfEra().getName());        assertEquals("year", GregorianChronology.getInstance().year().getName());        assertEquals("monthOfYear", GregorianChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", GregorianChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", GregorianChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", GregorianChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", GregorianChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", GregorianChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", GregorianChronology.getInstance().dayOfWeek().getName());                assertEquals(true, GregorianChronology.getInstance().era().isSupported());        assertEquals(true, GregorianChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, GregorianChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, GregorianChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, GregorianChronology.getInstance().year().isSupported());        assertEquals(true, GregorianChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekyear().isSupported());        assertEquals(true, GregorianChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, GregorianChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, GregorianChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, GregorianChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", GregorianChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", GregorianChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", GregorianChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", GregorianChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", GregorianChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", GregorianChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", GregorianChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", GregorianChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", GregorianChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", GregorianChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", GregorianChronology.getInstance().millisOfSecond().getName());                assertEquals(true, GregorianChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, GregorianChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, GregorianChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, GregorianChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, GregorianChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, GregorianChronology.getInstance().millisOfSecond().isSupported());    }    public void testMaximumValue() {        YearMonthDay ymd1 = new YearMonthDay(1999, DateTimeConstants.FEBRUARY, 1);        DateMidnight dm1 = new DateMidnight(1999, DateTimeConstants.FEBRUARY, 1);        Chronology chrono = GregorianChronology.getInstance();        assertEquals(28, chrono.dayOfMonth().getMaximumValue(ymd1));        assertEquals(28, chrono.dayOfMonth().getMaximumValue(dm1.getMillis()));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time.chrono;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.DateTimeUtils;import org.joda.time.DateTimeZone;import org.joda.time.Period;/** * This class is a Junit unit test for BuddhistChronology. * * @author Stephen Colebourne */public class TestBuddhistChronology extends TestCase {    private static int SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;        private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();    private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC();    private static final Chronology GJ_UTC = GJChronology.getInstanceUTC();    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBuddhistChronology.class);    }    public TestBuddhistChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testFactoryUTC() {        assertEquals(DateTimeZone.UTC, BuddhistChronology.getInstanceUTC().getZone());        assertSame(BuddhistChronology.class, BuddhistChronology.getInstanceUTC().getClass());    }    public void testFactory() {        assertEquals(LONDON, BuddhistChronology.getInstance().getZone());        assertSame(BuddhistChronology.class, BuddhistChronology.getInstance().getClass());    }    public void testFactory_Zone() {        assertEquals(TOKYO, BuddhistChronology.getInstance(TOKYO).getZone());        assertEquals(PARIS, BuddhistChronology.getInstance(PARIS).getZone());        assertEquals(LONDON, BuddhistChronology.getInstance(null).getZone());        assertSame(BuddhistChronology.class, BuddhistChronology.getInstance(TOKYO).getClass());    }    //-----------------------------------------------------------------------    public void testEquality() {        assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO));        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(LONDON));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(PARIS));        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC());        assertSame(BuddhistChronology.getInstance(), BuddhistChronology.getInstance(LONDON));    }    public void testWithUTC() {        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(LONDON).withUTC());        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(TOKYO).withUTC());        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC().withUTC());        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance().withUTC());    }    public void testWithZone() {        assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO).withZone(TOKYO));        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(LONDON));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(TOKYO).withZone(PARIS));        assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(null));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance().withZone(PARIS));        assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstanceUTC().withZone(PARIS));    }    public void testToString() {        assertEquals("BuddhistChronology[Europe/London]", BuddhistChronology.getInstance(LONDON).toString());        assertEquals("BuddhistChronology[Asia/Tokyo]", BuddhistChronology.getInstance(TOKYO).toString());        assertEquals("BuddhistChronology[Europe/London]", BuddhistChronology.getInstance().toString());        assertEquals("BuddhistChronology[UTC]", BuddhistChronology.getInstanceUTC().toString());    }    //-----------------------------------------------------------------------    public void testDurationFields() {        assertEquals("eras", BuddhistChronology.getInstance().eras().getName());        assertEquals("centuries", BuddhistChronology.getInstance().centuries().getName());        assertEquals("years", BuddhistChronology.getInstance().years().getName());        assertEquals("weekyears", BuddhistChronology.getInstance().weekyears().getName());        assertEquals("months", BuddhistChronology.getInstance().months().getName());        assertEquals("weeks", BuddhistChronology.getInstance().weeks().getName());        assertEquals("days", BuddhistChronology.getInstance().days().getName());        assertEquals("halfdays", GregorianChronology.getInstance().halfdays().getName());        assertEquals("hours", BuddhistChronology.getInstance().hours().getName());        assertEquals("minutes", BuddhistChronology.getInstance().minutes().getName());        assertEquals("seconds", BuddhistChronology.getInstance().seconds().getName());        assertEquals("millis", BuddhistChronology.getInstance().millis().getName());                assertEquals(false, BuddhistChronology.getInstance().eras().isSupported());        assertEquals(true, BuddhistChronology.getInstance().centuries().isSupported());        assertEquals(true, BuddhistChronology.getInstance().years().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekyears().isSupported());        assertEquals(true, BuddhistChronology.getInstance().months().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weeks().isSupported());        assertEquals(true, BuddhistChronology.getInstance().days().isSupported());        assertEquals(true, BuddhistChronology.getInstance().halfdays().isSupported());        assertEquals(true, BuddhistChronology.getInstance().hours().isSupported());        assertEquals(true, BuddhistChronology.getInstance().minutes().isSupported());        assertEquals(true, BuddhistChronology.getInstance().seconds().isSupported());        assertEquals(true, BuddhistChronology.getInstance().millis().isSupported());                assertEquals(false, BuddhistChronology.getInstance().centuries().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().years().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().weekyears().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().months().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().weeks().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().days().isPrecise());        assertEquals(false, BuddhistChronology.getInstance().halfdays().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().hours().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().minutes().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().seconds().isPrecise());        assertEquals(true, BuddhistChronology.getInstance().millis().isPrecise());                assertEquals(false, BuddhistChronology.getInstanceUTC().centuries().isPrecise());        assertEquals(false, BuddhistChronology.getInstanceUTC().years().isPrecise());        assertEquals(false, BuddhistChronology.getInstanceUTC().weekyears().isPrecise());        assertEquals(false, BuddhistChronology.getInstanceUTC().months().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().weeks().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().days().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().halfdays().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().hours().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().minutes().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().seconds().isPrecise());        assertEquals(true, BuddhistChronology.getInstanceUTC().millis().isPrecise());    }    public void testDateFields() {        assertEquals("era", BuddhistChronology.getInstance().era().getName());        assertEquals("centuryOfEra", BuddhistChronology.getInstance().centuryOfEra().getName());        assertEquals("yearOfCentury", BuddhistChronology.getInstance().yearOfCentury().getName());        assertEquals("yearOfEra", BuddhistChronology.getInstance().yearOfEra().getName());        assertEquals("year", BuddhistChronology.getInstance().year().getName());        assertEquals("monthOfYear", BuddhistChronology.getInstance().monthOfYear().getName());        assertEquals("weekyearOfCentury", BuddhistChronology.getInstance().weekyearOfCentury().getName());        assertEquals("weekyear", BuddhistChronology.getInstance().weekyear().getName());        assertEquals("weekOfWeekyear", BuddhistChronology.getInstance().weekOfWeekyear().getName());        assertEquals("dayOfYear", BuddhistChronology.getInstance().dayOfYear().getName());        assertEquals("dayOfMonth", BuddhistChronology.getInstance().dayOfMonth().getName());        assertEquals("dayOfWeek", BuddhistChronology.getInstance().dayOfWeek().getName());                assertEquals(true, BuddhistChronology.getInstance().era().isSupported());        assertEquals(true, BuddhistChronology.getInstance().centuryOfEra().isSupported());        assertEquals(true, BuddhistChronology.getInstance().yearOfCentury().isSupported());        assertEquals(true, BuddhistChronology.getInstance().yearOfEra().isSupported());        assertEquals(true, BuddhistChronology.getInstance().year().isSupported());        assertEquals(true, BuddhistChronology.getInstance().monthOfYear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekyearOfCentury().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekyear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().weekOfWeekyear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().dayOfYear().isSupported());        assertEquals(true, BuddhistChronology.getInstance().dayOfMonth().isSupported());        assertEquals(true, BuddhistChronology.getInstance().dayOfWeek().isSupported());    }    public void testTimeFields() {        assertEquals("halfdayOfDay", BuddhistChronology.getInstance().halfdayOfDay().getName());        assertEquals("clockhourOfHalfday", BuddhistChronology.getInstance().clockhourOfHalfday().getName());        assertEquals("hourOfHalfday", BuddhistChronology.getInstance().hourOfHalfday().getName());        assertEquals("clockhourOfDay", BuddhistChronology.getInstance().clockhourOfDay().getName());        assertEquals("hourOfDay", BuddhistChronology.getInstance().hourOfDay().getName());        assertEquals("minuteOfDay", BuddhistChronology.getInstance().minuteOfDay().getName());        assertEquals("minuteOfHour", BuddhistChronology.getInstance().minuteOfHour().getName());        assertEquals("secondOfDay", BuddhistChronology.getInstance().secondOfDay().getName());        assertEquals("secondOfMinute", BuddhistChronology.getInstance().secondOfMinute().getName());        assertEquals("millisOfDay", BuddhistChronology.getInstance().millisOfDay().getName());        assertEquals("millisOfSecond", BuddhistChronology.getInstance().millisOfSecond().getName());                assertEquals(true, BuddhistChronology.getInstance().halfdayOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().clockhourOfHalfday().isSupported());        assertEquals(true, BuddhistChronology.getInstance().hourOfHalfday().isSupported());        assertEquals(true, BuddhistChronology.getInstance().clockhourOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().hourOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().minuteOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().minuteOfHour().isSupported());        assertEquals(true, BuddhistChronology.getInstance().secondOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().secondOfMinute().isSupported());        assertEquals(true, BuddhistChronology.getInstance().millisOfDay().isSupported());        assertEquals(true, BuddhistChronology.getInstance().millisOfSecond().isSupported());    }    //-----------------------------------------------------------------------    public void testEpoch() {        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        assertEquals(new DateTime(-543, 1, 1, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC));    }    public void testEra() {        assertEquals(1, BuddhistChronology.BE);        try {            new DateTime(-1, 13, 5, 0, 0, 0, 0, BUDDHIST_UTC);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testKeyYears() {        DateTime bd = new DateTime(2513, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        DateTime jd = new DateTime(1970, 1, 1, 0, 0, 0, 0, GJ_UTC);        assertEquals(jd, bd.withChronology(GJ_UTC));        assertEquals(2513, bd.getYear());        assertEquals(2513, bd.getYearOfEra());        assertEquals(2513, bd.plus(Period.weeks(1)).getWeekyear());                bd = new DateTime(2126, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        jd = new DateTime(1583, 1, 1, 0, 0, 0, 0, GJ_UTC);        assertEquals(jd, bd.withChronology(GJ_UTC));        assertEquals(2126, bd.getYear());        assertEquals(2126, bd.getYearOfEra());        assertEquals(2126, bd.plus(Period.weeks(1)).getWeekyear());                bd = new DateTime(2125, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        jd = new DateTime(1582, 1, 1, 0, 0, 0, 0, GJ_UTC);        assertEquals(jd, bd.withChronology(GJ_UTC));        assertEquals(2125, bd.getYear());        assertEquals(2125, bd.getYearOfEra());        assertEquals(2125, bd.plus(Period.weeks(1)).getWeekyear());                bd = new DateTime(544, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        jd = new DateTime(1, 1, 1, 0, 0, 0, 0, GJ_UTC);        assertEquals(jd, bd.withChronology(GJ_UTC));        assertEquals(544, bd.getYear());        assertEquals(544, bd.getYearOfEra());        assertEquals(544, bd.plus(Period.weeks(1)).getWeekyear());                bd = new DateTime(543, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        jd = new DateTime(-1, 1, 1, 0, 0, 0, 0, GJ_UTC);        assertEquals(jd, bd.withChronology(GJ_UTC));        assertEquals(543, bd.getYear());        assertEquals(543, bd.getYearOfEra());        assertEquals(543, bd.plus(Period.weeks(1)).getWeekyear());                bd = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        jd = new DateTime(-543, 1, 1, 0, 0, 0, 0, GJ_UTC);        assertEquals(jd, bd.withChronology(GJ_UTC));        assertEquals(1, bd.getYear());        assertEquals(1, bd.getYearOfEra());        assertEquals(1, bd.plus(Period.weeks(1)).getWeekyear());    }    public void testCalendar() {        if (TestAll.FAST) {            return;        }        System.out.println("\nTestBuddhistChronology.testCalendar");        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);        long millis = epoch.getMillis();        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();        DateTimeField dayOfWeek = BUDDHIST_UTC.dayOfWeek();        DateTimeField weekOfWeekyear = GJ_UTC.weekOfWeekyear();        DateTimeField dayOfYear = BUDDHIST_UTC.dayOfYear();        DateTimeField dayOfMonth = BUDDHIST_UTC.dayOfMonth();        DateTimeField monthOfYear = BUDDHIST_UTC.monthOfYear();        DateTimeField year = BUDDHIST_UTC.year();        DateTimeField yearOfEra = BUDDHIST_UTC.yearOfEra();        DateTimeField era = BUDDHIST_UTC.era();        DateTimeField gjDayOfWeek = GJ_UTC.dayOfWeek();        DateTimeField gjWeekOfWeekyear = GJ_UTC.weekOfWeekyear();        DateTimeField gjDayOfYear = GJ_UTC.dayOfYear();        DateTimeField gjDayOfMonth = GJ_UTC.dayOfMonth();        DateTimeField gjMonthOfYear = GJ_UTC.monthOfYear();        DateTimeField gjYear = GJ_UTC.year();        DateTimeField gjYearOfEra = GJ_UTC.yearOfEra();        DateTimeField gjEra = GJ_UTC.era();        while (millis < end) {            assertEquals(gjDayOfWeek.get(millis), dayOfWeek.get(millis));            assertEquals(gjDayOfYear.get(millis), dayOfYear.get(millis));            assertEquals(gjDayOfMonth.get(millis), dayOfMonth.get(millis));            assertEquals(gjMonthOfYear.get(millis), monthOfYear.get(millis));            assertEquals(gjWeekOfWeekyear.get(millis), weekOfWeekyear.get(millis));            assertEquals(1, era.get(millis));            int yearValue = gjYear.get(millis);            if (yearValue <= 0) {                yearValue++;            }            yearValue += 543;            assertEquals(yearValue, year.get(millis));            assertEquals(yearValue, yearOfEra.get(millis));            millis += SKIP;        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;/** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */public class TestPartial_Basics extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final int OFFSET = 1;    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);    private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);    private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);    private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPartial_Basics.class);    }    public TestPartial_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testGet() {        Partial test = createHourMinPartial();        assertEquals(10, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(DateTimeFieldType.secondOfMinute());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSize() {        Partial test = createHourMinPartial();        assertEquals(2, test.size());    }    public void testGetFieldType() {        Partial test = createHourMinPartial();        assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0));        assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1));        try {            test.getFieldType(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getFieldType(2);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldTypes() {        Partial test = createHourMinPartial();        DateTimeFieldType[] fields = test.getFieldTypes();        assertEquals(2, fields.length);        assertSame(DateTimeFieldType.hourOfDay(), fields[0]);        assertSame(DateTimeFieldType.minuteOfHour(), fields[1]);        assertNotSame(test.getFieldTypes(), test.getFieldTypes());    }    public void testGetField() {        Partial test = createHourMinPartial(COPTIC_PARIS);        assertSame(CopticChronology.getInstanceUTC().hourOfDay(), test.getField(0));        assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), test.getField(1));        try {            test.getField(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getField(5);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFields() {        Partial test = createHourMinPartial(COPTIC_PARIS);        DateTimeField[] fields = test.getFields();        assertEquals(2, fields.length);        assertSame(CopticChronology.getInstanceUTC().hourOfDay(), fields[0]);        assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), fields[1]);        assertNotSame(test.getFields(), test.getFields());    }    public void testGetValue() {        Partial test = createHourMinPartial(COPTIC_PARIS);        assertEquals(10, test.getValue(0));        assertEquals(20, test.getValue(1));        try {            test.getValue(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getValue(2);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetValues() {        Partial test = createHourMinPartial(COPTIC_PARIS);        int[] values = test.getValues();        assertEquals(2, values.length);        assertEquals(10, values[0]);        assertEquals(20, values[1]);        assertNotSame(test.getValues(), test.getValues());    }    public void testIsSupported() {        Partial test = createHourMinPartial(COPTIC_PARIS);        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(false, test.isSupported(DateTimeFieldType.secondOfMinute()));        assertEquals(false, test.isSupported(DateTimeFieldType.millisOfSecond()));        assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));    }    public void testEqualsHashCode() {        Partial test1 = createHourMinPartial(COPTIC_PARIS);        Partial test2 = createHourMinPartial(COPTIC_PARIS);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Partial test3 = createHourMinPartial2(COPTIC_PARIS);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));        assertEquals(new TimeOfDay(10, 20, 30, 40), createTODPartial(ISO_UTC));    }    //-----------------------------------------------------------------------    public void testCompareTo() {        Partial test1 = createHourMinPartial();        Partial test1a = createHourMinPartial();        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                Partial test2 = createHourMinPartial2(ISO_UTC);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                Partial test3 = createHourMinPartial2(COPTIC_UTC);        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(0, new TimeOfDay(10, 20, 30, 40).compareTo(createTODPartial(ISO_UTC)));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}        try {            test1.compareTo(new YearMonthDay());            fail();        } catch (ClassCastException ex) {}        try {            createTODPartial(ISO_UTC).without(DateTimeFieldType.hourOfDay()).compareTo(new YearMonthDay());            fail();        } catch (ClassCastException ex) {}    }    //-----------------------------------------------------------------------    public void testIsEqual_TOD() {        Partial test1 = createHourMinPartial();        Partial test1a = createHourMinPartial();        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                Partial test2 = createHourMinPartial2(ISO_UTC);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                Partial test3 = createHourMinPartial2(COPTIC_UTC);        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                try {            createHourMinPartial().isEqual(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testIsBefore_TOD() {        Partial test1 = createHourMinPartial();        Partial test1a = createHourMinPartial();        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                Partial test2 = createHourMinPartial2(ISO_UTC);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                Partial test3 = createHourMinPartial2(COPTIC_UTC);        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                try {            createHourMinPartial().isBefore(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testIsAfter_TOD() {        Partial test1 = createHourMinPartial();        Partial test1a = createHourMinPartial();        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                Partial test2 = createHourMinPartial2(ISO_UTC);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                Partial test3 = createHourMinPartial2(COPTIC_UTC);        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                try {            createHourMinPartial().isAfter(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testWithChronologyRetainFields_Chrono() {        Partial base = createHourMinPartial(COPTIC_PARIS);        Partial test = base.withChronologyRetainFields(BUDDHIST_TOKYO);        check(base, 10, 20);        assertEquals(COPTIC_UTC, base.getChronology());        check(test, 10, 20);        assertEquals(BUDDHIST_UTC, test.getChronology());    }    public void testWithChronologyRetainFields_sameChrono() {        Partial base = createHourMinPartial(COPTIC_PARIS);        Partial test = base.withChronologyRetainFields(COPTIC_TOKYO);        assertSame(base, test);    }    public void testWithChronologyRetainFields_nullChrono() {        Partial base = createHourMinPartial(COPTIC_PARIS);        Partial test = base.withChronologyRetainFields(null);        check(base, 10, 20);        assertEquals(COPTIC_UTC, base.getChronology());        check(test, 10, 20);        assertEquals(ISO_UTC, test.getChronology());    }    //-----------------------------------------------------------------------    public void testWith1() {        Partial test = createHourMinPartial();        Partial result = test.with(DateTimeFieldType.hourOfDay(), 15);        check(test, 10, 20);        check(result, 15, 20);    }    public void testWith2() {        Partial test = createHourMinPartial();        try {            test.with(null, 6);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWith3a() {        Partial test = createHourMinPartial();        Partial result = test.with(DateTimeFieldType.secondOfMinute(), 15);        check(test, 10, 20);        assertEquals(3, result.size());        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(true, result.isSupported(DateTimeFieldType.secondOfMinute()));        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(1));        assertEquals(DateTimeFieldType.secondOfMinute(), result.getFieldType(2));        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));        assertEquals(15, result.get(DateTimeFieldType.secondOfMinute()));    }    public void testWith3b() {        Partial test = createHourMinPartial();        Partial result = test.with(DateTimeFieldType.minuteOfDay(), 15);        check(test, 10, 20);        assertEquals(3, result.size());        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfDay()));        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));        assertEquals(DateTimeFieldType.minuteOfDay(), result.getFieldType(1));        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2));        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));        assertEquals(15, result.get(DateTimeFieldType.minuteOfDay()));    }    public void testWith3c() {        Partial test = createHourMinPartial();        Partial result = test.with(DateTimeFieldType.dayOfMonth(), 15);        check(test, 10, 20);        assertEquals(3, result.size());        assertEquals(true, result.isSupported(DateTimeFieldType.dayOfMonth()));        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(DateTimeFieldType.dayOfMonth(), result.getFieldType(0));        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(1));        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2));        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));        assertEquals(15, result.get(DateTimeFieldType.dayOfMonth()));    }    public void testWith3d() {        Partial test = new Partial(DateTimeFieldType.year(), 2005);        Partial result = test.with(DateTimeFieldType.monthOfYear(), 6);        assertEquals(2, result.size());        assertEquals(2005, result.get(DateTimeFieldType.year()));        assertEquals(6, result.get(DateTimeFieldType.monthOfYear()));    }            public void testWith3e() {        Partial test = new Partial(DateTimeFieldType.era(), 1);        Partial result = test.with(DateTimeFieldType.halfdayOfDay(), 0);        assertEquals(2, result.size());        assertEquals(1, result.get(DateTimeFieldType.era()));        assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(0, result.indexOf(DateTimeFieldType.era()));        assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay()));    }            public void testWith3f() {        Partial test = new Partial(DateTimeFieldType.halfdayOfDay(), 0);        Partial result = test.with(DateTimeFieldType.era(), 1);        assertEquals(2, result.size());        assertEquals(1, result.get(DateTimeFieldType.era()));        assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(0, result.indexOf(DateTimeFieldType.era()));        assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay()));    }            public void testWith4() {        Partial test = createHourMinPartial();        Partial result = test.with(DateTimeFieldType.hourOfDay(), 10);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithout1() {        Partial test = createHourMinPartial();        Partial result = test.without(DateTimeFieldType.year());        check(test, 10, 20);        check(result, 10, 20);    }    public void testWithout2() {        Partial test = createHourMinPartial();        Partial result = test.without((DateTimeFieldType) null);        check(test, 10, 20);        check(result, 10, 20);    }    public void testWithout3() {        Partial test = createHourMinPartial();        Partial result = test.without(DateTimeFieldType.hourOfDay());        check(test, 10, 20);        assertEquals(1, result.size());        assertEquals(false, result.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(0));    }    public void testWithout4() {        Partial test = createHourMinPartial();        Partial result = test.without(DateTimeFieldType.minuteOfHour());        check(test, 10, 20);        assertEquals(1, result.size());        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(false, result.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));    }    public void testWithout5() {        Partial test = new Partial(DateTimeFieldType.hourOfDay(), 12);        Partial result = test.without(DateTimeFieldType.hourOfDay());        assertEquals(0, result.size());        assertEquals(false, result.isSupported(DateTimeFieldType.hourOfDay()));    }    //-----------------------------------------------------------------------    public void testWithField1() {        Partial test = createHourMinPartial();        Partial result = test.withField(DateTimeFieldType.hourOfDay(), 15);        check(test, 10, 20);        check(result, 15, 20);    }    public void testWithField2() {        Partial test = createHourMinPartial();        try {            test.withField(null, 6);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithField3() {        Partial test = createHourMinPartial();        try {            test.withField(DateTimeFieldType.dayOfMonth(), 6);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithField4() {        Partial test = createHourMinPartial();        Partial result = test.withField(DateTimeFieldType.hourOfDay(), 10);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        Partial test = createHourMinPartial();        Partial result = test.withFieldAdded(DurationFieldType.hours(), 6);                assertEquals(createHourMinPartial(), test);        check(test, 10, 20);        check(result, 16, 20);    }    public void testWithFieldAdded2() {        Partial test = createHourMinPartial();        try {            test.withFieldAdded(null, 0);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithFieldAdded3() {        Partial test = createHourMinPartial();        try {            test.withFieldAdded(null, 6);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithFieldAdded4() {        Partial test = createHourMinPartial();        Partial result = test.withFieldAdded(DurationFieldType.hours(), 0);        assertSame(test, result);    }    public void testWithFieldAdded5() {        Partial test = createHourMinPartial();        try {            test.withFieldAdded(DurationFieldType.days(), 6);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithFieldAdded6() {        Partial test = createHourMinPartial();        try {            test.withFieldAdded(DurationFieldType.hours(), 16);            fail();        } catch (IllegalArgumentException ex) {            // expected        }        check(test, 10, 20);    }    public void testWithFieldAdded7() {        Partial test = createHourMinPartial(23, 59, ISO_UTC);        try {            test.withFieldAdded(DurationFieldType.minutes(), 1);            fail();        } catch (IllegalArgumentException ex) {            // expected        }        check(test, 23, 59);                test = createHourMinPartial(23, 59, ISO_UTC);        try {            test.withFieldAdded(DurationFieldType.hours(), 1);            fail();        } catch (IllegalArgumentException ex) {            // expected        }        check(test, 23, 59);    }    public void testWithFieldAdded8() {        Partial test = createHourMinPartial(0, 0, ISO_UTC);        try {            test.withFieldAdded(DurationFieldType.minutes(), -1);            fail();        } catch (IllegalArgumentException ex) {            // expected        }        check(test, 0, 0);                test = createHourMinPartial(0, 0, ISO_UTC);        try {            test.withFieldAdded(DurationFieldType.hours(), -1);            fail();        } catch (IllegalArgumentException ex) {            // expected        }        check(test, 0, 0);    }    //-----------------------------------------------------------------------    public void testWithFieldAddWrapped1() {        Partial test = createHourMinPartial();        Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 6);                assertEquals(createHourMinPartial(), test);        check(test, 10, 20);        check(result, 16, 20);    }    public void testWithFieldAddWrapped2() {        Partial test = createHourMinPartial();        try {            test.withFieldAddWrapped(null, 0);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithFieldAddWrapped3() {        Partial test = createHourMinPartial();        try {            test.withFieldAddWrapped(null, 6);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithFieldAddWrapped4() {        Partial test = createHourMinPartial();        Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 0);        assertSame(test, result);    }    public void testWithFieldAddWrapped5() {        Partial test = createHourMinPartial();        try {            test.withFieldAddWrapped(DurationFieldType.days(), 6);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20);    }    public void testWithFieldAddWrapped6() {        Partial test = createHourMinPartial();        Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 16);                assertEquals(createHourMinPartial(), test);        check(test, 10, 20);        check(result, 2, 20);    }    public void testWithFieldAddWrapped7() {        Partial test = createHourMinPartial(23, 59, ISO_UTC);        Partial result = test.withFieldAddWrapped(DurationFieldType.minutes(), 1);        check(test, 23, 59);        check(result, 0, 0);                test = createHourMinPartial(23, 59, ISO_UTC);        result = test.withFieldAddWrapped(DurationFieldType.hours(), 1);        check(test, 23, 59);        check(result, 0, 59);    }    public void testWithFieldAddWrapped8() {        Partial test = createHourMinPartial(0, 0, ISO_UTC);        Partial result = test.withFieldAddWrapped(DurationFieldType.minutes(), -1);        check(test, 0, 0);        check(result, 23, 59);                test = createHourMinPartial(0, 0, ISO_UTC);        result = test.withFieldAddWrapped(DurationFieldType.hours(), -1);        check(test, 0, 0);        check(result, 23, 0);    }    //-----------------------------------------------------------------------    public void testPlus_RP() {        Partial test = createHourMinPartial(BUDDHIST_LONDON);        Partial result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));        check(test, 10, 20);        check(result, 15, 26);                result = test.plus((ReadablePeriod) null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMinus_RP() {        Partial test = createHourMinPartial(BUDDHIST_LONDON);        Partial result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));        check(test, 10, 20);        check(result, 9, 19);                result = test.minus((ReadablePeriod) null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testToDateTime_RI() {        Partial base = createHourMinPartial(COPTIC_PARIS);        DateTime dt = new DateTime(0L); // LONDON zone        assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString());                DateTime test = base.toDateTime(dt);        check(base, 10, 20);        assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString());        assertEquals("1970-01-01T10:20:00.000+01:00", test.toString());    }    public void testToDateTime_nullRI() {        Partial base = createHourMinPartial(1, 2, ISO_UTC);        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);                DateTime test = base.toDateTime((ReadableInstant) null);        check(base, 1, 2);        assertEquals("1970-01-02T01:02:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testProperty() {        Partial test = createHourMinPartial();        assertNotNull(test.property(DateTimeFieldType.hourOfDay()));        assertNotNull(test.property(DateTimeFieldType.minuteOfHour()));        try {            test.property(DateTimeFieldType.secondOfDay());            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Partial test = createHourMinPartial(COPTIC_PARIS);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Partial result = (Partial) ois.readObject();        ois.close();                assertEquals(test, result);        assertTrue(Arrays.equals(test.getValues(), result.getValues()));        assertTrue(Arrays.equals(test.getFields(), result.getFields()));        assertEquals(test.getChronology(), result.getChronology());    }    //-----------------------------------------------------------------------    public void testGetFormatter1() {        Partial test = new Partial(DateTimeFieldType.year(), 2005);        assertEquals("2005", test.getFormatter().print(test));                test = test.with(DateTimeFieldType.monthOfYear(), 6);        assertEquals("2005-06", test.getFormatter().print(test));                test = test.with(DateTimeFieldType.dayOfMonth(), 25);        assertEquals("2005-06-25", test.getFormatter().print(test));                test = test.without(DateTimeFieldType.monthOfYear());        assertEquals("2005--25", test.getFormatter().print(test));    }    public void testGetFormatter2() {        Partial test = new Partial();        assertEquals(null, test.getFormatter());                test = test.with(DateTimeFieldType.era(), 1);        assertEquals(null, test.getFormatter());                test = test.with(DateTimeFieldType.halfdayOfDay(), 0);        assertEquals(null, test.getFormatter());    }    public void testGetFormatter3() {        Partial test = new Partial(DateTimeFieldType.dayOfWeek(), 5);        assertEquals("-W-5", test.getFormatter().print(test));                // contrast with testToString5        test = test.with(DateTimeFieldType.dayOfMonth(), 13);        assertEquals("---13", test.getFormatter().print(test));    }    //-----------------------------------------------------------------------    public void testToString1() {        Partial test = createHourMinPartial();        assertEquals("10:20", test.toString());    }    public void testToString2() {        Partial test = new Partial();        assertEquals("[]", test.toString());    }    public void testToString3() {        Partial test = new Partial(DateTimeFieldType.year(), 2005);        assertEquals("2005", test.toString());                test = test.with(DateTimeFieldType.monthOfYear(), 6);        assertEquals("2005-06", test.toString());                test = test.with(DateTimeFieldType.dayOfMonth(), 25);        assertEquals("2005-06-25", test.toString());                test = test.without(DateTimeFieldType.monthOfYear());        assertEquals("2005--25", test.toString());    }    public void testToString4() {        Partial test = new Partial(DateTimeFieldType.dayOfWeek(), 5);        assertEquals("-W-5", test.toString());                test = test.with(DateTimeFieldType.dayOfMonth(), 13);        assertEquals("[dayOfMonth=13, dayOfWeek=5]", test.toString());    }    public void testToString5() {        Partial test = new Partial(DateTimeFieldType.era(), 1);        assertEquals("[era=1]", test.toString());                test = test.with(DateTimeFieldType.halfdayOfDay(), 0);        assertEquals("[era=1, halfdayOfDay=0]", test.toString());    }    //-----------------------------------------------------------------------    public void testToString_String() {        Partial test = createHourMinPartial();        assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString("yyyy HH"));        assertEquals("10:20", test.toString((String) null));    }    //-----------------------------------------------------------------------    public void testToString_String_Locale() {        Partial test = createHourMinPartial();        assertEquals("10 20", test.toString("H m", Locale.ENGLISH));        assertEquals("10:20", test.toString(null, Locale.ENGLISH));        assertEquals("10 20", test.toString("H m", null));        assertEquals("10:20", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToString_DTFormatter() {        Partial test = createHourMinPartial();        assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString(DateTimeFormat.forPattern("yyyy HH")));        assertEquals("10:20", test.toString((DateTimeFormatter) null));    }    //-----------------------------------------------------------------------    private Partial createHourMinPartial() {        return createHourMinPartial(ISO_UTC);    }    private Partial createHourMinPartial(Chronology chrono) {        return createHourMinPartial(10, 20, chrono);    }    private Partial createHourMinPartial2(Chronology chrono) {        return createHourMinPartial(15, 20, chrono);    }    private Partial createHourMinPartial(int hour, int min, Chronology chrono) {        return new Partial(            new DateTimeFieldType[] {DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour()},            new int[] {hour, min},            chrono);    }    private Partial createTODPartial(Chronology chrono) {        return new Partial(            new DateTimeFieldType[] {                    DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(),                    DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond()},            new int[] {10, 20, 30, 40},            chrono);    }    private void check(Partial test, int hour, int min) {        assertEquals(test.toString(), hour, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(test.toString(), min, test.get(DateTimeFieldType.minuteOfHour()));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestYearMonthDay_Properties extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestYearMonthDay_Properties.class);    }    public TestYearMonthDay_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getReadablePartial());        assertSame(test, test.year().getYearMonthDay());        assertEquals(1972, test.year().get());        assertEquals("1972", test.year().getAsString());        assertEquals("1972", test.year().getAsText());        assertEquals("1972", test.year().getAsText(Locale.FRENCH));        assertEquals("1972", test.year().getAsShortText());        assertEquals("1972", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyAddYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().addToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1981, 6, 9);                copy = test.year().addToCopy(0);        check(copy, 1972, 6, 9);                copy = test.year().addToCopy(292277023 - 1972);        check(copy, 292277023, 6, 9);                try {            test.year().addToCopy(292277023 - 1972 + 1);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 1972, 6, 9);                copy = test.year().addToCopy(-1972);        check(copy, 0, 6, 9);                copy = test.year().addToCopy(-1973);        check(copy, -1, 6, 9);                try {            test.year().addToCopy(-292275054 - 1972 - 1);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 1972, 6, 9);    }    public void testPropertyAddWrapFieldYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().addWrapFieldToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1981, 6, 9);                copy = test.year().addWrapFieldToCopy(0);        check(copy, 1972, 6, 9);                copy = test.year().addWrapFieldToCopy(292277023 - 1972 + 1);        check(copy, -292275054, 6, 9);                copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1);        check(copy, 292277023, 6, 9);    }    public void testPropertySetYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 12, 6, 9);    }    public void testPropertySetTextYear() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.year().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 12, 6, 9);    }    public void testPropertyCompareToYear() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.year().compareTo(test2) < 0);        assertEquals(true, test2.year().compareTo(test1) > 0);        assertEquals(true, test1.year().compareTo(test1) == 0);        try {            test1.year().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.year().compareTo(dt2) < 0);        assertEquals(true, test2.year().compareTo(dt1) > 0);        assertEquals(true, test1.year().compareTo(dt1) == 0);        try {            test1.year().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getReadablePartial());        assertSame(test, test.monthOfYear().getYearMonthDay());        assertEquals(6, test.monthOfYear().get());        assertEquals("6", test.monthOfYear().getAsString());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new YearMonthDay(1972, 7, 9);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));    }    public void testPropertyGetMaxMinValuesMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyAddMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().addToCopy(6);        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().addToCopy(7);        check(copy, 1973, 1, 9);                copy = test.monthOfYear().addToCopy(-5);        check(copy, 1972, 1, 9);                copy = test.monthOfYear().addToCopy(-6);        check(copy, 1971, 12, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().addToCopy(1);        check(copy, 1972, 2, 29);                copy = test.monthOfYear().addToCopy(2);        check(copy, 1972, 3, 31);                copy = test.monthOfYear().addToCopy(3);        check(copy, 1972, 4, 30);                test = new YearMonthDay(1971, 1, 31);        copy = test.monthOfYear().addToCopy(1);        check(copy, 1971, 2, 28);    }    public void testPropertyAddWrapFieldMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().addWrapFieldToCopy(4);        check(test, 1972, 6, 9);        check(copy, 1972, 10, 9);                copy = test.monthOfYear().addWrapFieldToCopy(8);        check(copy, 1972, 2, 9);                copy = test.monthOfYear().addWrapFieldToCopy(-8);        check(copy, 1972, 10, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().addWrapFieldToCopy(1);        check(copy, 1972, 2, 29);                copy = test.monthOfYear().addWrapFieldToCopy(2);        check(copy, 1972, 3, 31);                copy = test.monthOfYear().addWrapFieldToCopy(3);        check(copy, 1972, 4, 30);                test = new YearMonthDay(1971, 1, 31);        copy = test.monthOfYear().addWrapFieldToCopy(1);        check(copy, 1971, 2, 28);    }    public void testPropertySetMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                test = new YearMonthDay(1972, 1, 31);        copy = test.monthOfYear().setCopy(2);        check(copy, 1972, 2, 29);                try {            test.monthOfYear().setCopy(13);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.monthOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.monthOfYear().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().setCopy("December");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);                copy = test.monthOfYear().setCopy("Dec");        check(test, 1972, 6, 9);        check(copy, 1972, 12, 9);    }    public void testPropertyCompareToMonth() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);        try {            test1.monthOfYear().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getReadablePartial());        assertSame(test, test.dayOfMonth().getYearMonthDay());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsString());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        test = new YearMonthDay(1972, 7, 9);        assertEquals(31, test.dayOfMonth().getMaximumValue());        test = new YearMonthDay(1972, 2, 9);        assertEquals(29, test.dayOfMonth().getMaximumValue());        test = new YearMonthDay(1971, 2, 9);        assertEquals(28, test.dayOfMonth().getMaximumValue());    }    public void testPropertyAddDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().addToCopy(9);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 18);                copy = test.dayOfMonth().addToCopy(21);        check(copy, 1972, 6, 30);                copy = test.dayOfMonth().addToCopy(22);        check(copy, 1972, 7, 1);                copy = test.dayOfMonth().addToCopy(22 + 30);        check(copy, 1972, 7, 31);                copy = test.dayOfMonth().addToCopy(22 + 31);        check(copy, 1972, 8, 1);        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        check(copy, 1972, 12, 31);                copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        check(copy, 1973, 1, 1);                copy = test.dayOfMonth().addToCopy(-8);        check(copy, 1972, 6, 1);                copy = test.dayOfMonth().addToCopy(-9);        check(copy, 1972, 5, 31);                copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        check(copy, 1972, 1, 1);                copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        check(copy, 1971, 12, 31);    }    public void testPropertyAddWrapFieldDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().addWrapFieldToCopy(21);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 30);                copy = test.dayOfMonth().addWrapFieldToCopy(22);        check(copy, 1972, 6, 1);                copy = test.dayOfMonth().addWrapFieldToCopy(-12);        check(copy, 1972, 6, 27);                test = new YearMonthDay(1972, 7, 9);        copy = test.dayOfMonth().addWrapFieldToCopy(21);        check(copy, 1972, 7, 30);            copy = test.dayOfMonth().addWrapFieldToCopy(22);        check(copy, 1972, 7, 31);            copy = test.dayOfMonth().addWrapFieldToCopy(23);        check(copy, 1972, 7, 1);            copy = test.dayOfMonth().addWrapFieldToCopy(-12);        check(copy, 1972, 7, 28);    }    public void testPropertySetDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().setCopy(12);        check(test, 1972, 6, 9);        check(copy, 1972, 6, 12);                try {            test.dayOfMonth().setCopy(31);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfMonth().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDay() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().setCopy("12");        check(test, 1972, 6, 9);        check(copy, 1972, 6, 12);    }    public void testPropertyWithMaximumValueDayOfMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().withMaximumValue();        check(test, 1972, 6, 9);        check(copy, 1972, 6, 30);    }    public void testPropertyWithMinimumValueDayOfMonth() {        YearMonthDay test = new YearMonthDay(1972, 6, 9);        YearMonthDay copy = test.dayOfMonth().withMinimumValue();        check(test, 1972, 6, 9);        check(copy, 1972, 6, 1);    }    public void testPropertyCompareToDay() {        YearMonthDay test1 = new YearMonthDay(TEST_TIME1);        YearMonthDay test2 = new YearMonthDay(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);        try {            test1.dayOfMonth().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    private void check(YearMonthDay test, int hour, int min, int sec) {        assertEquals(hour, test.getYear());        assertEquals(min, test.getMonthOfYear());        assertEquals(sec, test.getDayOfMonth());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import junit.framework.Assert;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.format.DateTimeFormatter;import org.joda.time.format.ISODateTimeFormat;/** * Unit test the parsing of ISO format datetimes * * @author Guy Allard * @author Stephen Colebourne */public class TestParseISO extends TestCase {        private static final int DEFAULT = 99999;    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }        /**     * TestSuite suite() is a junit required method.     * @see org.joda.test.time.BulkTest     */    public static TestSuite suite() {        return new TestSuite(TestParseISO.class);    }        /**     * Constructor.     * @param name     */    public TestParseISO(String name) {        super(name);    }    protected void setUp() throws Exception {        super.setUp();    }        protected void tearDown() throws Exception {        super.tearDown();    }        //-----------------------------------------------------------------------    // Dates    //-----------------------------------------------------------------------    public void testSpecCompleteDate() {        new DMatcher("5.2.1.1", "1999-10-20", "19991020",            19, 99, 10, 20, DEFAULT).run();    }            //-----------------------------------------------------------------------    public void testSpecReducedPrecisionCYM() {        new DMatcher("5.2.1.2", "1999-10", "199910",            19, 99, 10, DEFAULT, DEFAULT).run();    }    public void testSpecReducedPrecisionCY() {        new DMatcher("5.2.1.2", "1999", "1999",            19, 99, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecReducedPrecisionC() {        new DMatcher("5.2.1.2", "20", "20",            20, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();        new DMatcher("5.2.1.2", "19", "19",            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTruncatedYMD() {        new DMatcher("5.2.1.3", "85-04-11", "850411",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecTruncatedYM() {        new DMatcher("5.2.1.3", "-85-04", "-8504",            DEFAULT, 85, 4, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedY() {        new DMatcher("5.2.1.3", "-85", "-85",            DEFAULT, 85, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedMD() {        new DMatcher("5.2.1.3", "--04-11", "--0411",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    public void testSpecTruncatedM() {        new DMatcher("5.2.1.3", "--04", "--04",            DEFAULT, DEFAULT, 4, DEFAULT, DEFAULT).run();    }    public void testSpecTruncatedD() {        new DMatcher("5.2.1.3", "---11", "---11",            DEFAULT, DEFAULT, DEFAULT, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecExpandedCYMD() {        new DMatcher("5.2.1.4", "+001985-04-11", "+0019850411",            19, 85, 4, 11, DEFAULT).run();    }    public void testSpecExpandedCYM() {        new DMatcher("5.2.1.4", "+001985-04", "+00198504",            19, 85, 4, DEFAULT, DEFAULT).run();    }    public void testSpecExpandedCY() {        new DMatcher("5.2.1.4", "+001985", "+001985",            19, 85, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecExpandedC() {        // Not supported - could only tell difference from CY if you knew        // number of digits representing year//        new DMatcher("5.2.1.4", "+0019", "+0019",//            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).assert();    }        //-----------------------------------------------------------------------    // Ordinal based date    //-----------------------------------------------------------------------    public void testSpecOrdinalComplete() {        new DMatcher("5.2.2.1", "1985-101", "1985101",            19, 85, 4, 11, DEFAULT).run();        new DMatcher("5.2.2.1", "1985-021", "1985021",            19, 85, 1, 21, DEFAULT).run();        new DMatcher("5.2.2.1", "1985-006", "1985006",            19, 85, 1, 6, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecOrdinalTruncatedYD() {        new DMatcher("5.2.2.2", "85-101", "85101",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecOrdinalTruncatedD() {        new DMatcher("5.2.2.2", "-101", "-101",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecOrdinalExpandedYD() {        new DMatcher("5.2.2.3", "+001985-101", "+001985101",            19, 85, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    // Week based date    //-----------------------------------------------------------------------    public void testSpecWeekComplete() {        new DMatcher("5.2.3.1", "1985-W15-1", "1985W151",            19, 85, 4, 8, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-2", "1985W152",            19, 85, 4, 9, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-3", "1985W153",            19, 85, 4, 10, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-4", "1985W154",            19, 85, 4, 11, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-5", "1985W155",            19, 85, 4, 12, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-6", "1985W156",            19, 85, 4, 13, DEFAULT).run();        new DMatcher("5.2.3.1", "1985-W15-7", "1985W157",            19, 85, 4, 14, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecWeekReducedPrecision() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "1985-W15", "1985W15",            19, 85, 4, 14, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecWeekTruncatedYWD() {        new DMatcher("5.2.3.2", "85-W154", "85W154",            DEFAULT, 85, 4, 11, DEFAULT).run();    }    public void testSpecWeekTruncatedYW() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "85-W15", "85W15",            DEFAULT, 85, 4, 14, DEFAULT).run();    }    public void testSpecWeekTruncatedDWD() {        // decade not supported    }    public void testSpecWeekTruncatedDW() {        // decade not supported    }    public void testSpecWeekTruncatedWD() {        new DMatcher("5.2.3.2", "-W154", "-W154",            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();    }    public void testSpecWeekTruncatedW() {        // test date is Sunday, which should be left alone        new DMatcher("5.2.3.2", "-W15", "-W15",            DEFAULT, DEFAULT, 4, 14, DEFAULT).run();    }    public void testSpecWeekTruncatedD() {        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov        new DMatcher("5.2.3.3", "-W-4", "-W-4",            DEFAULT, DEFAULT, 11, 30, DEFAULT).run();    }    public void testSpecWeekExpandedYWD() {        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov        new DMatcher("5.2.3.4", "+001985-W15-4", "+001985W154",            19, 85, 4, 11, DEFAULT).run();    }    //-----------------------------------------------------------------------    // Times    //-----------------------------------------------------------------------    public void testSpecTimeComplete() {        new TMatcher("5.3.1.1", "23:20:50", "232050",            23, 20, 50, 0, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeReducedPrecisionHM() {        new TMatcher("5.3.1.2", "23:20", "2320",            23, 20, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTimeReducedPrecisionH() {        new TMatcher("5.3.1.2", "23", "23",            23, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeFractionalHMS() {        new TMatcher("5.3.1.3", "23:20:50.607", "232050.607",            23, 20, 50, 607, DEFAULT).run();        new TMatcher("5.3.1.3", "23:20:50,607", "232050,607",            23, 20, 50, 607, DEFAULT).run();    }    public void testSpecTimeFractionalHM() {        new TMatcher("5.3.1.3", "23:20.4", "2320.4",            23, 20, 24, 0, DEFAULT).run();        new TMatcher("5.3.1.3", "23:20,4", "2320,4",            23, 20, 24, 0, DEFAULT).run();    }    public void testSpecTimeFractionalH() {        new TMatcher("5.3.1.3", "23.25", "23.25",            23, 15, 0, 0, DEFAULT).run();        new TMatcher("5.3.1.3", "23.25", "23,25",            23, 15, 0, 0, DEFAULT).run();    }    //-----------------------------------------------------------------------    public void testSpecTimeTruncatedMS() {        new TMatcher("5.3.1.4", "-20:50", "-2050",            DEFAULT, 20, 50, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedM() {        new TMatcher("5.3.1.4", "-20", "-20",            DEFAULT, 20, DEFAULT, DEFAULT, DEFAULT).run();    }    public void testSpecTimeTruncatedS() {        new TMatcher("5.3.1.4", "--50", "--50",            DEFAULT, DEFAULT, 50, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionMS() {        new TMatcher("5.3.1.4", "-20:50.607", "-2050.607",            DEFAULT, 20, 50, 607, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionM() {        new TMatcher("5.3.1.4", "-20.4", "-20.4",            DEFAULT, 20, 24, 0, DEFAULT).run();    }    public void testSpecTimeTruncatedFractionS() {        new TMatcher("5.3.1.4", "--50.607", "--50.607",            DEFAULT, DEFAULT, 50, 607, DEFAULT).run();    }        //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    /**     * Perform test.     */            protected static abstract class Matcher extends Assert {        String spec, extended, basic;        int century, yearOfCentury, monthOfYear, dayOfMonth, hour, min, sec, milli, zone;        MutableDateTime dt;                protected Matcher(String spec, String extended, String basic) {            this.spec = spec;            this.extended = extended;            this.basic = basic;        }                protected abstract void run();        protected void assertDate() {            String msg = "\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     " + dt;            assertEquals(msg + "\nCentury: ", century, dt.getCenturyOfEra());            assertEquals(msg + "\nYear: ", yearOfCentury, dt.getYearOfCentury());            assertEquals(msg + "\nMonth: ", monthOfYear, dt.getMonthOfYear());            assertEquals(msg + "\nDay: ", dayOfMonth, dt.getDayOfMonth());            assertEquals(msg + "\nHour: ", hour, dt.getHourOfDay());            assertEquals(msg + "\nMinute: ", min, dt.getMinuteOfHour());            assertEquals(msg + "\nSecond: ", sec, dt.getSecondOfMinute());            assertEquals(msg + "\nMilli: ", milli, dt.getMillisOfSecond());            DateTimeZone z;            if (zone == DEFAULT) {                z = DateTimeZone.getDefault();            } else if (zone == 0) {                    z = DateTimeZone.UTC;            } else {                String str = "0" + Math.abs(zone) + ":00";                str = str.substring(str.length() - 4);                str = (zone < 0 ? "-" : "+") + str;                z = DateTimeZone.forID(str);            }            assertEquals(msg + "\nZone: ", z, dt.getZone());        }        protected void parse(DateTimeFormatter p) {            int result = p.parseInto(dt, extended, 0);            assertTrue("\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     "                + dt + "\nParse failed at: " + ~result,                result >= 0);        }    }    protected static class DTMatcher extends Matcher {        protected DTMatcher(String spec, String extended, String basic,                int century, int yearOfCentury, int monthOfYear, int dayOfMonth,                int hour, int min, int sec, int milli, int zone) {            super(spec, extended, basic);            this.century = (century == DEFAULT ? 19 : century);            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);            this.hour = (hour == DEFAULT ? 10 : hour);            this.min = (min == DEFAULT ? 32 : min);            this.sec = (sec == DEFAULT ? 40 : sec);            this.milli = (milli == DEFAULT ? 205 : milli);            this.zone = zone;        }                    protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.dateTimeParser());            super.assertDate();        }    }    protected static class DMatcher extends Matcher {        protected DMatcher(String spec, String extended, String basic,                int century, int yearOfCentury, int monthOfYear, int dayOfMonth, int zone) {            super(spec, extended, basic);            this.century = (century == DEFAULT ? 19 : century);            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);            this.hour = 10;            this.min = 32;            this.sec = 40;            this.milli = 205;            this.zone = zone;        }        protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.dateParser());            super.assertDate();                    dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.dateTimeParser());            super.assertDate();        }    }    protected static class TMatcher extends Matcher {        protected TMatcher(String spec, String extended, String basic,                int hour, int min, int sec, int milli, int zone) {            super(spec, extended, basic);            this.century = 19;            this.yearOfCentury = 72;            this.monthOfYear = 12;            this.dayOfMonth = 3;            this.hour = (hour == DEFAULT ? 10 : hour);            this.min = (min == DEFAULT ? 32 : min);            this.sec = (sec == DEFAULT ? 40 : sec);            this.milli = (milli == DEFAULT ? 205 : milli);            this.zone = zone;        }        protected void run() {            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.timeParser());            super.assertDate();                        extended = "T" + extended;            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.timeParser());            super.assertDate();                        dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);            parse(ISODateTimeFormat.dateTimeParser());            super.assertDate();        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractPartial;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.field.AbstractPartialFieldProperty;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestAbstractPartial extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestAbstractPartial.class);    }    public TestAbstractPartial(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testGetValue() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(1970, mock.getValue(0));        assertEquals(1, mock.getValue(1));                try {            mock.getValue(-1);            fail();        } catch (IndexOutOfBoundsException ex) {}        try {            mock.getValue(2);            fail();        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetValues() throws Throwable {        MockPartial mock = new MockPartial();        int[] vals = mock.getValues();        assertEquals(2, vals.length);        assertEquals(1970, vals[0]);        assertEquals(1, vals[1]);    }    public void testGetField() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(BuddhistChronology.getInstanceUTC().year(), mock.getField(0));        assertEquals(BuddhistChronology.getInstanceUTC().monthOfYear(), mock.getField(1));                try {            mock.getField(-1);            fail();        } catch (IndexOutOfBoundsException ex) {}        try {            mock.getField(2);            fail();        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldType() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(DateTimeFieldType.year(), mock.getFieldType(0));        assertEquals(DateTimeFieldType.monthOfYear(), mock.getFieldType(1));                try {            mock.getFieldType(-1);            fail();        } catch (IndexOutOfBoundsException ex) {}        try {            mock.getFieldType(2);            fail();        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldTypes() throws Throwable {        MockPartial mock = new MockPartial();        DateTimeFieldType[] vals = mock.getFieldTypes();        assertEquals(2, vals.length);        assertEquals(DateTimeFieldType.year(), vals[0]);        assertEquals(DateTimeFieldType.monthOfYear(), vals[1]);    }    public void testGetPropertyEquals() throws Throwable {        MockPartial mock = new MockPartial();        YearMonthDay ymd = new YearMonthDay(1970, 2, 1, BuddhistChronology.getInstance());                MockProperty0 prop0 = new MockProperty0();        assertEquals(true, prop0.equals(prop0));        assertEquals(true, prop0.equals(new MockProperty0()));        assertEquals(false, prop0.equals(new MockProperty1()));        assertEquals(false, prop0.equals(new MockProperty0Val()));        assertEquals(false, prop0.equals(new MockProperty0Field()));        assertEquals(false, prop0.equals(new MockProperty0Chrono()));        assertEquals(false, prop0.equals(""));        assertEquals(false, prop0.equals(null));    }    //-----------------------------------------------------------------------    static class MockPartial extends AbstractPartial {                int[] val = new int[] {1970, 1};                MockPartial() {            super();        }        protected DateTimeField getField(int index, Chronology chrono) {            switch (index) {                case 0:                    return chrono.year();                case 1:                    return chrono.monthOfYear();                default:                    throw new IndexOutOfBoundsException();            }        }        public int size() {            return 2;        }                public int getValue(int index) {            return val[index];        }        public void setValue(int index, int value) {            val[index] = value;        }        public Chronology getChronology() {            return BuddhistChronology.getInstanceUTC();        }    }        static class MockProperty0 extends AbstractPartialFieldProperty {        MockPartial partial = new MockPartial();        public DateTimeField getField() {            return partial.getField(0);        }        public ReadablePartial getReadablePartial() {            return partial;        }        public int get() {            return partial.getValue(0);        }    }    static class MockProperty1 extends AbstractPartialFieldProperty {        MockPartial partial = new MockPartial();        public DateTimeField getField() {            return partial.getField(1);        }        public ReadablePartial getReadablePartial() {            return partial;        }        public int get() {            return partial.getValue(1);        }    }    static class MockProperty0Field extends MockProperty0 {        public DateTimeField getField() {            return BuddhistChronology.getInstanceUTC().hourOfDay();        }    }    static class MockProperty0Val extends MockProperty0 {        public int get() {            return 99;        }    }    static class MockProperty0Chrono extends MockProperty0 {        public ReadablePartial getReadablePartial() {            return new MockPartial() {                public Chronology getChronology() {                    return ISOChronology.getInstanceUTC();                }            };        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Modifier;import java.util.Date;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInstant_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInstant_Basics.class);    }    public TestInstant_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet_DateTimeFieldType() {        Instant test = new Instant();  // 2002-06-09        assertEquals(1, test.get(DateTimeFieldType.era()));        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));        assertEquals(2002, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));  // UTC zone        assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay()));  // UTC zone        assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));  // UTC zone        assertEquals(0, test.get(DateTimeFieldType.hourOfDay()));  // UTC zone        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfDay()));        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(0, test.get(DateTimeFieldType.secondOfDay()));        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));        assertEquals(0, test.get(DateTimeFieldType.millisOfDay()));        try {            test.get((DateTimeFieldType) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGet_DateTimeField() {        Instant test = new Instant();  // 2002-06-09        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get((DateTimeField) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        Instant test = new Instant();                assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());        assertEquals(DateTimeZone.UTC, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    public void testEqualsHashCode() {        Instant test1 = new Instant(TEST_TIME1);        Instant test2 = new Instant(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Instant test3 = new Instant(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return ISOChronology.getInstanceUTC();        }    }    public void testCompareTo() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        //-----------------------------------------------------------------------    public void testIsEqual_long() {        assertEquals(false, new Instant(TEST_TIME1).isEqual(TEST_TIME2));        assertEquals(true, new Instant(TEST_TIME1).isEqual(TEST_TIME1));        assertEquals(false, new Instant(TEST_TIME2).isEqual(TEST_TIME1));    }        public void testIsEqualNow() {        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqualNow());        assertEquals(true, new Instant(TEST_TIME_NOW).isEqualNow());        assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqualNow());    }        public void testIsEqual_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new Instant(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqual(null));    }        //-----------------------------------------------------------------------    public void testIsBefore_long() {        assertEquals(true, new Instant(TEST_TIME1).isBefore(TEST_TIME2));        assertEquals(false, new Instant(TEST_TIME1).isBefore(TEST_TIME1));        assertEquals(false, new Instant(TEST_TIME2).isBefore(TEST_TIME1));    }        public void testIsBeforeNow() {        assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBeforeNow());        assertEquals(false, new Instant(TEST_TIME_NOW).isBeforeNow());        assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBeforeNow());    }        public void testIsBefore_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new Instant(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBefore(null));    }        //-----------------------------------------------------------------------    public void testIsAfter_long() {        assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME2));        assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME1));        assertEquals(true, new Instant(TEST_TIME2).isAfter(TEST_TIME1));    }        public void testIsAfterNow() {        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfterNow());        assertEquals(false, new Instant(TEST_TIME_NOW).isAfterNow());        assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfterNow());    }        public void testIsAfter_RI() {        Instant test1 = new Instant(TEST_TIME1);        Instant test1a = new Instant(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                Instant test2 = new Instant(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new Instant(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Instant test = new Instant(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Instant result = (Instant) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        Instant test = new Instant(TEST_TIME_NOW);        assertEquals("2002-06-09T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testToInstant() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.toInstant();        assertSame(test, result);    }    public void testToDateTime() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTimeISO() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_DateTimeZone() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_Chronology() {        Instant test = new Instant(TEST_TIME1);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toDateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        Instant test = new Instant(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new Instant(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        Instant test = new Instant(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new Instant(TEST_TIME1);        result = test.withMillis(TEST_TIME1);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long_int() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.withDurationAdded(123456789L, 1);        Instant expected = new Instant(TEST_TIME1 + 123456789L);        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, 0);        assertSame(test, result);                result = test.withDurationAdded(123456789L, 2);        expected = new Instant(TEST_TIME1 + (2L * 123456789L));        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, -3);        expected = new Instant(TEST_TIME1 - (3L * 123456789L));        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_RD_int() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.withDurationAdded(new Duration(123456789L), 1);        Instant expected = new Instant(TEST_TIME1 + 123456789L);        assertEquals(expected, result);                result = test.withDurationAdded(null, 1);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 0);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 2);        expected = new Instant(TEST_TIME1 + (2L * 123456789L));        assertEquals(expected, result);                result = test.withDurationAdded(new Duration(123456789L), -3);        expected = new Instant(TEST_TIME1 - (3L * 123456789L));        assertEquals(expected, result);    }        //-----------------------------------------------------------------------        public void testPlus_long() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.plus(123456789L);        Instant expected = new Instant(TEST_TIME1 + 123456789L);        assertEquals(expected, result);    }        public void testPlus_RD() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.plus(new Duration(123456789L));        Instant expected = new Instant(TEST_TIME1 + 123456789L);        assertEquals(expected, result);                result = test.plus((ReadableDuration) null);        assertSame(test, result);    }        //-----------------------------------------------------------------------        public void testMinus_long() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.minus(123456789L);        Instant expected = new Instant(TEST_TIME1 - 123456789L);        assertEquals(expected, result);    }        public void testMinus_RD() {        Instant test = new Instant(TEST_TIME1);        Instant result = test.minus(new Duration(123456789L));        Instant expected = new Instant(TEST_TIME1 - 123456789L);        assertEquals(expected, result);                result = test.minus((ReadableDuration) null);        assertSame(test, result);    }        //-----------------------------------------------------------------------    public void testImmutable() {        assertTrue(Modifier.isFinal(Instant.class.getModifiers()));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */public class TestPartial_Properties extends TestCase {    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");        private DateTimeZone zone = null;    private static final DateTimeFieldType[] TYPES = new DateTimeFieldType[] {        DateTimeFieldType.hourOfDay(),        DateTimeFieldType.minuteOfHour(),        DateTimeFieldType.secondOfMinute(),        DateTimeFieldType.millisOfSecond()    };    private static final int[] VALUES = new int[] {10, 20, 30, 40};    private static final int[] VALUES1 = new int[] {1, 2, 3, 4};    private static final int[] VALUES2 = new int[] {5, 6, 7, 8};//    private long TEST_TIME_NOW =//        10L * DateTimeConstants.MILLIS_PER_HOUR//        + 20L * DateTimeConstants.MILLIS_PER_MINUTE//        + 30L * DateTimeConstants.MILLIS_PER_SECOND//        + 40L;//            private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;    private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPartial_Properties.class);    }    public TestPartial_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testPropertyGetHour() {        Partial test = new Partial(TYPES, VALUES);        assertSame(test.getChronology().hourOfDay(), test.property(DateTimeFieldType.hourOfDay()).getField());        assertEquals("hourOfDay", test.property(DateTimeFieldType.hourOfDay()).getName());        assertEquals("Property[hourOfDay]", test.property(DateTimeFieldType.hourOfDay()).toString());        assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getReadablePartial());        assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getPartial());        assertEquals(10, test.property(DateTimeFieldType.hourOfDay()).get());        assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsString());        assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsText());        assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsText(Locale.FRENCH));        assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsShortText());        assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.hourOfDay()).getDurationField());        assertEquals(test.getChronology().days(), test.property(DateTimeFieldType.hourOfDay()).getRangeDurationField());        assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumTextLength(null));        assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesHour() {        Partial test = new Partial(TYPES, VALUES);        assertEquals(0, test.property(DateTimeFieldType.hourOfDay()).getMinimumValue());        assertEquals(0, test.property(DateTimeFieldType.hourOfDay()).getMinimumValueOverall());        assertEquals(23, test.property(DateTimeFieldType.hourOfDay()).getMaximumValue());        assertEquals(23, test.property(DateTimeFieldType.hourOfDay()).getMaximumValueOverall());    }//    public void testPropertyAddHour() {//        Partial test = new Partial(TYPES, VALUES);//        Partial copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(9);//        check(test, 10, 20, 30, 40);//        check(copy, 19, 20, 30, 40);//        //        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(0);//        check(copy, 10, 20, 30, 40);//        //        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(13);//        check(copy, 23, 20, 30, 40);//        //        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(14);//        check(copy, 0, 20, 30, 40);//        //        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-10);//        check(copy, 0, 20, 30, 40);//        //        copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-11);//        check(copy, 23, 20, 30, 40);//    }//    public void testPropertyAddHour() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(13);        check(copy, 23, 20, 30, 40);                try {            test.property(DateTimeFieldType.hourOfDay()).addToCopy(14);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-10);        check(copy, 0, 20, 30, 40);                try {            test.property(DateTimeFieldType.hourOfDay()).addToCopy(-11);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldHour() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(18);        check(copy, 4, 20, 30, 40);                copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(-15);        check(copy, 19, 20, 30, 40);    }    public void testPropertySetHour() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.hourOfDay()).setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);                try {            test.property(DateTimeFieldType.hourOfDay()).setCopy(24);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(DateTimeFieldType.hourOfDay()).setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextHour() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.hourOfDay()).setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);    }    public void testPropertyWithMaximumValueHour() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.hourOfDay()).withMaximumValue();        check(test, 10, 20, 30, 40);        check(copy, 23, 20, 30, 40);    }    public void testPropertyWithMinimumValueHour() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.hourOfDay()).withMinimumValue();        check(test, 10, 20, 30, 40);        check(copy, 0, 20, 30, 40);    }    public void testPropertyCompareToHour() {        Partial test1 = new Partial(TYPES, VALUES1);        Partial test2 = new Partial(TYPES, VALUES2);        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(test2) < 0);        assertEquals(true, test2.property(DateTimeFieldType.hourOfDay()).compareTo(test1) > 0);        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(test1) == 0);        try {            test1.property(DateTimeFieldType.hourOfDay()).compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(dt2) < 0);        assertEquals(true, test2.property(DateTimeFieldType.hourOfDay()).compareTo(dt1) > 0);        assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(dt1) == 0);        try {            test1.property(DateTimeFieldType.hourOfDay()).compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMinute() {        Partial test = new Partial(TYPES, VALUES);        assertSame(test.getChronology().minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()).getField());        assertEquals("minuteOfHour", test.property(DateTimeFieldType.minuteOfHour()).getName());        assertEquals("Property[minuteOfHour]", test.property(DateTimeFieldType.minuteOfHour()).toString());        assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getReadablePartial());        assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getPartial());        assertEquals(20, test.property(DateTimeFieldType.minuteOfHour()).get());        assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsString());        assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsText());        assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsText(Locale.FRENCH));        assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText());        assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.property(DateTimeFieldType.minuteOfHour()).getDurationField());        assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.minuteOfHour()).getRangeDurationField());        assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumTextLength(null));        assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesMinute() {        Partial test = new Partial(TYPES, VALUES);        assertEquals(0, test.property(DateTimeFieldType.minuteOfHour()).getMinimumValue());        assertEquals(0, test.property(DateTimeFieldType.minuteOfHour()).getMinimumValueOverall());        assertEquals(59, test.property(DateTimeFieldType.minuteOfHour()).getMaximumValue());        assertEquals(59, test.property(DateTimeFieldType.minuteOfHour()).getMaximumValueOverall());    }//    public void testPropertyAddMinute() {//        Partial test = new Partial(TYPES, VALUES);//        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(9);//        check(test, 10, 20, 30, 40);//        check(copy, 10, 29, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(39);//        check(copy, 10, 59, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(40);//        check(copy, 11, 0, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(1 * 60 + 45);//        check(copy, 12, 5, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 39);//        check(copy, 23, 59, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 40);//        check(copy, 0, 0, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-9);//        check(copy, 10, 11, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-19);//        check(copy, 10, 1, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-20);//        check(copy, 10, 0, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-21);//        check(copy, 9, 59, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 20));//        check(copy, 0, 0, 30, 40);//        //        copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 21));//        check(copy, 23, 59, 30, 40);//    }    public void testPropertyAddMinute() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(39);        check(copy, 10, 59, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(40);        check(copy, 11, 0, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(1 * 60 + 45);        check(copy, 12, 5, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 39);        check(copy, 23, 59, 30, 40);                try {            test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 40);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-9);        check(copy, 10, 11, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-19);        check(copy, 10, 1, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-20);        check(copy, 10, 0, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-21);        check(copy, 9, 59, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 20));        check(copy, 0, 0, 30, 40);                try {            test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 21));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldMinute() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(49);        check(copy, 10, 9, 30, 40);                copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(-47);        check(copy, 10, 33, 30, 40);    }    public void testPropertySetMinute() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);                try {            test.property(DateTimeFieldType.minuteOfHour()).setCopy(60);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(DateTimeFieldType.minuteOfHour()).setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMinute() {        Partial test = new Partial(TYPES, VALUES);        Partial copy = test.property(DateTimeFieldType.minuteOfHour()).setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);    }    public void testPropertyCompareToMinute() {        Partial test1 = new Partial(TYPES, VALUES1);        Partial test2 = new Partial(TYPES, VALUES2);        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(test2) < 0);        assertEquals(true, test2.property(DateTimeFieldType.minuteOfHour()).compareTo(test1) > 0);        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(test1) == 0);        try {            test1.property(DateTimeFieldType.minuteOfHour()).compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(dt2) < 0);        assertEquals(true, test2.property(DateTimeFieldType.minuteOfHour()).compareTo(dt1) > 0);        assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(dt1) == 0);        try {            test1.property(DateTimeFieldType.minuteOfHour()).compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    private void check(Partial test, int hour, int min, int sec, int milli) {        assertEquals(hour, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(min, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(sec, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(milli, test.get(DateTimeFieldType.millisOfSecond()));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.LenientChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestDateTimeUtils extends TestCase {    private static final boolean OLD_JDK;    static {        String str = System.getProperty("java.version");        boolean old = true;        if (str.length() > 3 &&            str.charAt(0) == '1' &&            str.charAt(1) == '.' &&            (str.charAt(2) == '4' || str.charAt(2) == '5' || str.charAt(2) == '6')) {            old = false;        }        OLD_JDK = old;    }    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return true;//                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeUtils.class);    }    public TestDateTimeUtils(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testClass() {        Class cls = DateTimeUtils.class;        assertEquals(true, Modifier.isPublic(cls.getModifiers()));        assertEquals(false, Modifier.isFinal(cls.getModifiers()));                assertEquals(1, cls.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(cls.getDeclaredConstructors()[0].getModifiers()));                DateTimeUtils utils = new DateTimeUtils() {};    }        //-----------------------------------------------------------------------    public void testSystemMillis() {        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testSystemMillisSecurity() {        if (OLD_JDK) {            return;        }        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisSystem();                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testFixedMillis() {        try {            DateTimeUtils.setCurrentMillisFixed(0L);            assertEquals(0L, DateTimeUtils.currentTimeMillis());            assertEquals(0L, DateTimeUtils.currentTimeMillis());            assertEquals(0L, DateTimeUtils.currentTimeMillis());        } finally {            DateTimeUtils.setCurrentMillisSystem();        }        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testFixedMillisSecurity() {        if (OLD_JDK) {            return;        }        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisFixed(0L);                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testOffsetMillis() {        try {            // set time to one day ago            DateTimeUtils.setCurrentMillisOffset(-24 * 60 *  60 * 1000);            long nowSystem = System.currentTimeMillis();            long now = DateTimeUtils.currentTimeMillis();            long nowAdjustDay = now + (24 * 60 *  60 * 1000);            assertTrue((now < nowSystem));            assertTrue((nowAdjustDay >= nowSystem));            assertTrue((nowAdjustDay - nowSystem) < 10000L);        } finally {            DateTimeUtils.setCurrentMillisSystem();        }        long nowSystem = System.currentTimeMillis();        long now = DateTimeUtils.currentTimeMillis();        assertTrue((now >= nowSystem));        assertTrue((now - nowSystem) < 10000L);    }    //-----------------------------------------------------------------------    public void testOffsetMillisToZero() {        long now1 = 0L;        try {            // set time to one day ago            DateTimeUtils.setCurrentMillisOffset(0);            now1 = DateTimeUtils.currentTimeMillis();        } finally {            DateTimeUtils.setCurrentMillisSystem();        }        long now2 = DateTimeUtils.currentTimeMillis();        assertEquals(now1, now2);    }    //-----------------------------------------------------------------------    public void testOffsetMillisSecurity() {        if (OLD_JDK) {            return;        }        try {            try {                Policy.setPolicy(RESTRICT);                System.setSecurityManager(new SecurityManager());                DateTimeUtils.setCurrentMillisOffset(-24 * 60 *  60 * 1000);                fail();            } catch (SecurityException ex) {                // ok            } finally {                System.setSecurityManager(null);                Policy.setPolicy(ALLOW);            }        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testGetInstantMillis_RI() {        Instant i = new Instant(123L);        assertEquals(123L, DateTimeUtils.getInstantMillis(i));        try {            DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);            assertEquals(TEST_TIME_NOW, DateTimeUtils.getInstantMillis(null));        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testGetInstantChronology_RI() {        DateTime dt = new DateTime(123L, BuddhistChronology.getInstance());        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt));                Instant i = new Instant(123L);        assertEquals(ISOChronology.getInstanceUTC(), DateTimeUtils.getInstantChronology(i));                AbstractInstant ai = new AbstractInstant() {            public long getMillis() {                return 0L;            }            public Chronology getChronology() {                return null; // testing for this            }        };        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(ai));                assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(null));    }    //-----------------------------------------------------------------------    public void testGetIntervalChronology_RInterval() {        Interval dt = new Interval(123L, 456L, BuddhistChronology.getInstance());        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt));                assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(null));                MutableInterval ai = new MutableInterval() {            public Chronology getChronology() {                return null; // testing for this            }        };        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(ai));    }    //-----------------------------------------------------------------------    public void testGetIntervalChronology_RI_RI() {        DateTime dt1 = new DateTime(123L, BuddhistChronology.getInstance());        DateTime dt2 = new DateTime(123L, CopticChronology.getInstance());        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt1, dt2));        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt1, null));        assertEquals(CopticChronology.getInstance(), DateTimeUtils.getIntervalChronology(null, dt2));        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(null, null));    }    //-----------------------------------------------------------------------    public void testGetReadableInterval_ReadableInterval() {        ReadableInterval input = new Interval(0, 100L);        assertEquals(input, DateTimeUtils.getReadableInterval(input));                try {            DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);            assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW), DateTimeUtils.getReadableInterval(null));        } finally {            DateTimeUtils.setCurrentMillisSystem();        }    }    //-----------------------------------------------------------------------    public void testGetChronology_Chronology() {        assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getChronology(BuddhistChronology.getInstance()));        assertEquals(ISOChronology.getInstance(), DateTimeUtils.getChronology(null));    }    //-----------------------------------------------------------------------    public void testGetZone_Zone() {        assertEquals(PARIS, DateTimeUtils.getZone(PARIS));        assertEquals(DateTimeZone.getDefault(), DateTimeUtils.getZone(null));    }    //-----------------------------------------------------------------------    public void testGetPeriodType_PeriodType() {        assertEquals(PeriodType.dayTime(), DateTimeUtils.getPeriodType(PeriodType.dayTime()));        assertEquals(PeriodType.standard(), DateTimeUtils.getPeriodType(null));    }    //-----------------------------------------------------------------------    public void testGetDurationMillis_RI() {        Duration dur = new Duration(123L);        assertEquals(123L, DateTimeUtils.getDurationMillis(dur));        assertEquals(0L, DateTimeUtils.getDurationMillis(null));    }    //-----------------------------------------------------------------------    public void testIsContiguous_RP() {        YearMonthDay ymd = new YearMonthDay(2005, 6, 9);        assertEquals(true, DateTimeUtils.isContiguous(ymd));        TimeOfDay tod = new TimeOfDay(12, 20, 30, 0);        assertEquals(true, DateTimeUtils.isContiguous(tod));        Partial year = new Partial(DateTimeFieldType.year(), 2005);        assertEquals(true, DateTimeUtils.isContiguous(year));        Partial hourOfDay = new Partial(DateTimeFieldType.hourOfDay(), 12);        assertEquals(true, DateTimeUtils.isContiguous(hourOfDay));        Partial yearHour = year.with(DateTimeFieldType.hourOfDay(), 12);        assertEquals(false, DateTimeUtils.isContiguous(yearHour));        Partial ymdd = new Partial(ymd).with(DateTimeFieldType.dayOfWeek(), 2);        assertEquals(false, DateTimeUtils.isContiguous(ymdd));        Partial dd = new Partial(DateTimeFieldType.dayOfMonth(), 13).with(DateTimeFieldType.dayOfWeek(), 5);        assertEquals(false, DateTimeUtils.isContiguous(dd));                try {            DateTimeUtils.isContiguous((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testToGregorianCalendar() {        TimeZone jdkZone = TimeZone.getDefault();        try {            TimeZone.setDefault(TimeZone.getTimeZone("Europe/Paris"));            DateTime dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, PARIS);            Calendar cal = new GregorianCalendar(1970, 0, 1, 2, 30);  // same field values                        assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));                        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));            dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, LONDON);            cal = new GregorianCalendar(1970, 0, 1, 2, 30);  // same field values                        assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));                        dt = new DateTime(1800, 1, 1, 0, 30, 0, 0, LONDON);            int year = dt.getYear();            while (year < 2000) {                dt = dt.plusHours(1);                int hourOfDay = dt.getHourOfDay();                if (hourOfDay == 4) {                    dt = dt.plusHours(18);  // speed up test                } else {                    year = dt.getYear();                    cal.clear();                    cal.set(year, dt.getMonthOfYear() - 1, dt.getDayOfMonth(),                        hourOfDay, dt.getMinuteOfHour(), dt.getSecondOfMinute());                    //cal.get(Calendar.ERA);                    assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));                }            }                    } finally {            TimeZone.setDefault(jdkZone);        }        try {            DateTimeUtils.toGregorianCalendar(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testToDateTime_Calendar() {        TimeZone jdkZone = TimeZone.getDefault();        try {            TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));            GregorianCalendar cal = new GregorianCalendar(1800, 0, 1, 0, 30, 0);            int year = cal.get(Calendar.YEAR);            while (year < 2000) {                cal.add(Calendar.HOUR_OF_DAY, 1);                int hourOfDay = cal.get(Calendar.HOUR_OF_DAY);                if (hourOfDay == 4) {                    cal.add(Calendar.HOUR_OF_DAY, 18);  // speed up test                } else {                    year = cal.get(Calendar.YEAR);                    DateTime dt = new DateTime(                        year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),                        cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE),                        cal.get(Calendar.SECOND), 0,                        LenientChronology.getInstance(ISOChronology.getInstance(LONDON)))                        .withChronology(ISOChronology.getInstance(LONDON));                    assertEquals(dt, DateTimeUtils.toDateTime(cal));                }            }                    } finally {            TimeZone.setDefault(jdkZone);        }        try {            DateTimeUtils.toDateTime((Calendar) null);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne * @author Mike Schrag */public class TestDateMidnight_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Properties.class);    }    public TestDateMidnight_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getDateMidnight());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getDateMidnight());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getDateMidnight());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getDateMidnight());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getDateMidnight());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getDateMidnight());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getDateMidnight());        assertEquals(6, test.monthOfYear().get());        assertEquals("6", test.monthOfYear().getAsString());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new DateMidnight(2004, 7, 9);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertySetMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy(8);        assertEquals(2004, copy.getYear());        assertEquals(8, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertySetTextMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy("8");        assertEquals(2004, copy.getYear());        assertEquals(8, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertySetTextLocaleMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().setCopy("mars", Locale.FRENCH);        assertEquals(2004, copy.getYear());        assertEquals(3, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addToCopy(8);        assertEquals(2005, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddLongMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addToCopy(8L);        assertEquals(2005, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyAddWrapFieldMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.monthOfYear().addWrapFieldToCopy(8);        assertEquals(2004, copy.getYear());        assertEquals(2, copy.getMonthOfYear());        assertEquals(9, copy.getDayOfMonth());    }    public void testPropertyGetDifferenceMonthOfYear() {        DateMidnight test1 = new DateMidnight(2004, 6, 9);        DateMidnight test2 = new DateMidnight(2004, 8, 9);        assertEquals(-2, test1.monthOfYear().getDifference(test2));        assertEquals(2, test2.monthOfYear().getDifference(test1));        assertEquals(-2L, test1.monthOfYear().getDifferenceAsLong(test2));        assertEquals(2L, test2.monthOfYear().getDifferenceAsLong(test1));    }    public void testPropertyRoundFloorMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundCeilingMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfFloorMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfFloorCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfCeilingMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfCeilingCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfEvenMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 16);        DateMidnight copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 9, 16);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-10-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 17);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                test = new DateMidnight(2004, 6, 15);        copy = test.monthOfYear().roundHalfEvenCopy();        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyRemainderMonthOfYear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertEquals((9L - 1L) * DateTimeConstants.MILLIS_PER_DAY, test.monthOfYear().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getDateMidnight());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    public void testPropertyWithMaximumValueDayOfMonth() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.dayOfMonth().withMaximumValue();        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());    }    public void testPropertyWithMinimumValueDayOfMonth() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight copy = test.dayOfMonth().withMinimumValue();        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getDateMidnight());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getDateMidnight());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        DateMidnight test = new DateMidnight(2004, 6, 9);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getDateMidnight());        assertEquals(3, test.dayOfWeek().get());        assertEquals("3", test.dayOfWeek().getAsString());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }    //-----------------------------------------------------------------------    public void testPropertyToIntervalYearOfEra() {      DateMidnight test = new DateMidnight(2004, 6, 9);      Interval testInterval = test.yearOfEra().toInterval();      assertEquals(new DateMidnight(2004, 1, 1), testInterval.getStart());      assertEquals(new DateMidnight(2005, 1, 1), testInterval.getEnd());    }    public void testPropertyToIntervalYearOfCentury() {      DateMidnight test = new DateMidnight(2004, 6, 9);      Interval testInterval = test.yearOfCentury().toInterval();      assertEquals(new DateMidnight(2004, 1, 1), testInterval.getStart());      assertEquals(new DateMidnight(2005, 1, 1), testInterval.getEnd());    }    public void testPropertyToIntervalYear() {      DateMidnight test = new DateMidnight(2004, 6, 9);      Interval testInterval = test.year().toInterval();      assertEquals(new DateMidnight(2004, 1, 1), testInterval.getStart());      assertEquals(new DateMidnight(2005, 1, 1), testInterval.getEnd());    }    public void testPropertyToIntervalMonthOfYear() {      DateMidnight test = new DateMidnight(2004, 6, 9);      Interval testInterval = test.monthOfYear().toInterval();      assertEquals(new DateMidnight(2004, 6, 1), testInterval.getStart());      assertEquals(new DateMidnight(2004, 7, 1), testInterval.getEnd());    }    public void testPropertyToIntervalDayOfMonth() {      DateMidnight test = new DateMidnight(2004, 6, 9);      Interval testInterval = test.dayOfMonth().toInterval();      assertEquals(new DateMidnight(2004, 6, 9), testInterval.getStart());      assertEquals(new DateMidnight(2004, 6, 10), testInterval.getEnd());      DateMidnight febTest = new DateMidnight(2004, 2, 29);      Interval febTestInterval = febTest.dayOfMonth().toInterval();      assertEquals(new DateMidnight(2004, 2, 29), febTestInterval.getStart());      assertEquals(new DateMidnight(2004, 3, 1), febTestInterval.getEnd());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.BaseChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.field.UnsupportedDateTimeField;import org.joda.time.field.UnsupportedDurationField;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Basics.class);    }    public TestMutableDateTime_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet_DateTimeField() {        MutableDateTime test = new MutableDateTime();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get((DateTimeField) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGet_DateTimeFieldType() {        MutableDateTime test = new MutableDateTime();        assertEquals(1, test.get(DateTimeFieldType.era()));        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));        assertEquals(2002, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(60, test.get(DateTimeFieldType.minuteOfDay()));        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay()));        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay()));        try {            test.get((DateTimeFieldType) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        MutableDateTime test = new MutableDateTime();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(1, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(60, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(60 * 60, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(60 * 60 * 1000, test.getMillisOfDay());    }    public void testEqualsHashCode() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test2 = new MutableDateTime(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutableDateTime test3 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                DateTime test4 = new DateTime(TEST_TIME2);        assertEquals(true, test4.equals(test3));        assertEquals(true, test3.equals(test4));        assertEquals(false, test4.equals(test1));        assertEquals(false, test1.equals(test4));        assertEquals(true, test3.hashCode() == test4.hashCode());        assertEquals(false, test1.hashCode() == test4.hashCode());                MutableDateTime test5 = new MutableDateTime(TEST_TIME2);        test5.setRounding(ISOChronology.getInstance().millisOfSecond());        assertEquals(true, test5.equals(test3));        assertEquals(true, test5.equals(test4));        assertEquals(true, test3.equals(test5));        assertEquals(true, test4.equals(test5));        assertEquals(true, test3.hashCode() == test5.hashCode());        assertEquals(true, test4.hashCode() == test5.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance())));        assertEquals(true, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, new MockEqualsChronology())));        assertEquals(false, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, ISOChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    class MockEqualsChronology extends BaseChronology {        public boolean equals(Object obj) {            return obj instanceof MockEqualsChronology;        }        public DateTimeZone getZone() {            return null;        }        public Chronology withUTC() {            return this;        }        public Chronology withZone(DateTimeZone zone) {            return this;        }        public String toString() {            return "";        }    }    public void testCompareTo() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        public void testIsEqual() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new MutableDateTime(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isEqual(null));    }        public void testIsBefore() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new MutableDateTime(TEST_TIME_NOW - 1).isBefore(null));    }        public void testIsAfter() {        MutableDateTime test1 = new MutableDateTime(TEST_TIME1);        MutableDateTime test1a = new MutableDateTime(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                MutableDateTime test2 = new MutableDateTime(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new MutableDateTime(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutableDateTime result = (MutableDateTime) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString());                test = new MutableDateTime(TEST_TIME_NOW, PARIS);        assertEquals("2002-06-09T02:00:00.000+02:00", test.toString());    }    public void testToString_String() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("2002 01", test.toString("yyyy HH"));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString((String) null));    }    public void testToString_String_String() {        MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));    }    public void testToString_DTFormatter() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW);        assertEquals("2002 00", test.toString(DateTimeFormat.forPattern("yyyy HH")));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((DateTimeFormatter) null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Instant result = test.toInstant();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTime() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        DateTime result = test.toDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(test.getChronology(), result.getChronology());    }    public void testToDateTimeISO() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        DateTime result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_DateTimeZone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(test.getChronology(), result.getChronology());        assertEquals(LONDON, result.getZone());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(PARIS, result.getZone());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(LONDON), result.getChronology());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_Chronology() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);    }    public void testToMutableDateTime_DateTimeZone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(LONDON), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new MutableDateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertTrue(test != result);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new MutableDateTime(TEST_TIME1, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testClone() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = (MutableDateTime) test.clone();        assertEquals(true, test.equals(result));        assertEquals(true, test != result);    }    public void testCopy() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        MutableDateTime result = test.copy();        assertEquals(true, test.equals(result));        assertEquals(true, test != result);    }    public void testRounding1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay());        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());    }    public void testRounding2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());    }    public void testRounding3() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());    }    public void testRounding4() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());    }    public void testRounding5() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T05:00:00.000+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_HALF_EVEN, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T06:00:00.000+01:00", test.toString());                test = new MutableDateTime(2002, 6, 9, 4, 30, 0, 0);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN);        assertEquals("2002-06-09T04:00:00.000+01:00", test.toString());    }    public void testRounding6() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE);        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());    }    public void testRounding7() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setRounding(ISOChronology.getInstance().hourOfDay(), -1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testRounding8() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING);        assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(null, -1);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());                test.setRounding(ISOChronology.getInstance().hourOfDay());        assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode());        assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField());                test.setRounding(null);        assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode());        assertEquals(null, test.getRoundingField());    }    //-----------------------------------------------------------------------    public void testProperty() {        MutableDateTime test = new MutableDateTime();        assertEquals(test.year(), test.property(DateTimeFieldType.year()));        assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));        assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));        assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));        DateTimeFieldType bad = new DateTimeFieldType("bad") {            public DurationFieldType getDurationType() {                return DurationFieldType.weeks();            }            public DurationFieldType getRangeDurationType() {                return null;            }            public DateTimeField getField(Chronology chronology) {                return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType()));            }        };        try {            test.property(bad);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(null);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Constructors.class);    }    public TestDateTime_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        java.util.TimeZone.setDefault(LONDON.toTimeZone());        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        java.util.TimeZone.setDefault(zone.toTimeZone());        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        DateTime test = new DateTime();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateTime test = new DateTime(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        DateTime test = new DateTime(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        DateTime test = new DateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        DateTime test = new DateTime(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        DateTime test = new DateTime(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME2, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        DateTime test = new DateTime(TEST_TIME1, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new DateTime(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        DateTime test = new DateTime((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new DateTime(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        DateTime test = new DateTime((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new DateTime(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        DateTime test = new DateTime((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        DateTime test = new DateTime(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        DateTime test = new DateTime((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0);        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  // +02:00        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new DateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());        try {            new DateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {        DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePeriod;/** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */public class TestPeriod_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriod_Basics.class);    }    public TestPeriod_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetPeriodType() {        Period test = new Period(0L);        assertEquals(PeriodType.standard(), test.getPeriodType());    }    public void testGetMethods() {        Period test = new Period(0L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testValueIndexMethods() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(6, test.size());        assertEquals(1, test.getValue(0));        assertEquals(4, test.getValue(1));        assertEquals(5, test.getValue(2));        assertEquals(6, test.getValue(3));        assertEquals(7, test.getValue(4));        assertEquals(8, test.getValue(5));        assertEquals(true, Arrays.equals(new int[] {1, 4, 5, 6, 7, 8}, test.getValues()));    }    public void testTypeIndexMethods() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(6, test.size());        assertEquals(DurationFieldType.years(), test.getFieldType(0));        assertEquals(DurationFieldType.days(), test.getFieldType(1));        assertEquals(DurationFieldType.hours(), test.getFieldType(2));        assertEquals(DurationFieldType.minutes(), test.getFieldType(3));        assertEquals(DurationFieldType.seconds(), test.getFieldType(4));        assertEquals(DurationFieldType.millis(), test.getFieldType(5));        assertEquals(true, Arrays.equals(new DurationFieldType[] {            DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(),            DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis()},            test.getFieldTypes()));    }    public void testIsSupported() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(true, test.isSupported(DurationFieldType.years()));        assertEquals(false, test.isSupported(DurationFieldType.months()));        assertEquals(false, test.isSupported(DurationFieldType.weeks()));        assertEquals(true, test.isSupported(DurationFieldType.days()));        assertEquals(true, test.isSupported(DurationFieldType.hours()));        assertEquals(true, test.isSupported(DurationFieldType.minutes()));        assertEquals(true, test.isSupported(DurationFieldType.seconds()));        assertEquals(true, test.isSupported(DurationFieldType.millis()));    }            public void testIndexOf() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(0, test.indexOf(DurationFieldType.years()));        assertEquals(-1, test.indexOf(DurationFieldType.months()));        assertEquals(-1, test.indexOf(DurationFieldType.weeks()));        assertEquals(1, test.indexOf(DurationFieldType.days()));        assertEquals(2, test.indexOf(DurationFieldType.hours()));        assertEquals(3, test.indexOf(DurationFieldType.minutes()));        assertEquals(4, test.indexOf(DurationFieldType.seconds()));        assertEquals(5, test.indexOf(DurationFieldType.millis()));    }    public void testGet() {        Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());        assertEquals(1, test.get(DurationFieldType.years()));        assertEquals(0, test.get(DurationFieldType.months()));        assertEquals(0, test.get(DurationFieldType.weeks()));        assertEquals(4, test.get(DurationFieldType.days()));        assertEquals(5, test.get(DurationFieldType.hours()));        assertEquals(6, test.get(DurationFieldType.minutes()));        assertEquals(7, test.get(DurationFieldType.seconds()));        assertEquals(8, test.get(DurationFieldType.millis()));    }    public void testEqualsHashCode() {        Period test1 = new Period(123L);        Period test2 = new Period(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Period test3 = new Period(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockPeriod(123L)));        assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime())));    }        class MockPeriod extends BasePeriod {        public MockPeriod(long value) {            super(value, null, null);        }    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Period test = new Period(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Period result = (Period) ois.readObject();        ois.close();                assertEquals(test, result);    }//    //-----------------------------------------------------------------------//    public void testAddTo1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    public void testAddTo2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, -2);//        assertEquals(expected, added);//    }//    //    public void testAddTo3() {//        long expected = TEST_TIME_NOW;//        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 0);//        assertEquals(expected, added);//    }//    //    public void testAddTo4() {//        long expected = TEST_TIME_NOW + 100L;//        Period test = new Period(100L);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToWithChronology1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC());  // local specified so use it//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so use default//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToRI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2);  // DateTime has UTC time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstanceUTC(), added.getChronology());//    }//    //    public void testAddToRI4() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);//        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);//        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);//        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);//        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);//        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);//        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);//        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());//    }//    //    public void testAddToRI5() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(null, -2);  // null has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    //-----------------------------------------------------------------------//    public void testAddIntoRWI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, 1);//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI3() {//        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);//        try {//            test.addInto(null, 1);//            fail();//        } catch (IllegalArgumentException ex) {}//    }        //-----------------------------------------------------------------------    public void testToString() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString());                test = new Period(0, 0, 0, 0, 0, 0, 0, 0);        assertEquals("PT0S", test.toString());                test = new Period(12345L);        assertEquals("PT12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToPeriod() {        Period test = new Period(123L);        Period result = test.toPeriod();        assertSame(test, result);    }    public void testToMutablePeriod() {        Period test = new Period(123L);        MutablePeriod result = test.toMutablePeriod();        assertEquals(test, result);    }    //-----------------------------------------------------------------------//    public void testToDurationMillisFrom() {//        Period test = new Period(123L);//        assertEquals(123L, test.toDurationMillisFrom(0L, null));//    }    public void testToDurationFrom() {        Period test = new Period(123L);        assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L)));    }    public void testToDurationTo() {        Period test = new Period(123L);        assertEquals(new Duration(123L), test.toDurationTo(new Instant(123L)));    }    //-----------------------------------------------------------------------    public void testWithPeriodType1() {        Period test = new Period(123L);        Period result = test.withPeriodType(PeriodType.standard());        assertSame(test, result);    }    public void testWithPeriodType2() {        Period test = new Period(3123L);        Period result = test.withPeriodType(PeriodType.dayTime());        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(PeriodType.dayTime(), result.getPeriodType());    }    public void testWithPeriodType3() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());        try {            test.withPeriodType(PeriodType.dayTime());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithPeriodType4() {        Period test = new Period(3123L);        Period result = test.withPeriodType(null);        assertEquals(3, result.getSeconds());        assertEquals(123, result.getMillis());        assertEquals(PeriodType.standard(), result.getPeriodType());    }    public void testWithPeriodType5() {        Period test = new Period(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.standard());        Period result = test.withPeriodType(PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), result.getPeriodType());        assertEquals(1, result.getYears());        assertEquals(2, result.getMonths());        assertEquals(0, result.getWeeks());        assertEquals(4, result.getDays());        assertEquals(5, result.getHours());        assertEquals(6, result.getMinutes());        assertEquals(7, result.getSeconds());        assertEquals(8, result.getMillis());    }    //-----------------------------------------------------------------------    public void testWithFields1() {        Period test1 = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period test2 = new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis());        Period result = test1.withFields(test2);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()), test2);        assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 9), result);    }    public void testWithFields2() {        Period test1 = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period test2 = null;        Period result = test1.withFields(test2);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test1);        assertSame(test1, result);    }    public void testWithFields3() {        Period test1 = new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis());        Period test2 = new Period(1, 2, 3, 4, 5, 6, 7, 8);        try {            test1.withFields(test2);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()), test1);        assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test2);    }    //-----------------------------------------------------------------------    public void testWithField1() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period result = test.withField(DurationFieldType.years(), 6);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test);        assertEquals(new Period(6, 2, 3, 4, 5, 6, 7, 8), result);    }    public void testWithField2() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.withField(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithField3() {        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time());        try {            test.withField(DurationFieldType.years(), 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithField4() {        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time());        Period result = test.withField(DurationFieldType.years(), 0);        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        Period result = test.withFieldAdded(DurationFieldType.years(), 6);                assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test);        assertEquals(new Period(7, 2, 3, 4, 5, 6, 7, 8), result);    }    public void testWithFieldAdded2() {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.withFieldAdded(null, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded3() {        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time());        try {            test.withFieldAdded(DurationFieldType.years(), 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded4() {        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time());        Period result = test.withFieldAdded(DurationFieldType.years(), 0);        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testPeriodStatics() {        Period test;        test = Period.years(1);        assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.months(1);        assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.weeks(1);        assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.days(1);        assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard()));        test = Period.hours(1);        assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard()));        test = Period.minutes(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard()));        test = Period.seconds(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard()));        test = Period.millis(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard()));    }    //-----------------------------------------------------------------------    public void testWith() {        Period test;        test = Period.years(5).withYears(1);        assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.months(5).withMonths(1);        assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.weeks(5).withWeeks(1);        assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard()));        test = Period.days(5).withDays(1);        assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard()));        test = Period.hours(5).withHours(1);        assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard()));        test = Period.minutes(5).withMinutes(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard()));        test = Period.seconds(5).withSeconds(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard()));        test = Period.millis(5).withMillis(1);        assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard()));                test = new Period(0L, PeriodType.millis());        try {            test.withYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPlus() {        Period test;        test = Period.years(1).plusYears(1);        assertEquals(new Period(2, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.months(1).plusMonths(1);        assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.weeks(1).plusWeeks(1);        assertEquals(new Period(0, 0, 2, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.days(1).plusDays(1);        assertEquals(new Period(0, 0, 0, 2, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.hours(1).plusHours(1);        assertEquals(new Period(0, 0, 0, 0, 2, 0, 0, 0, PeriodType.standard()), test);        test = Period.minutes(1).plusMinutes(1);        assertEquals(new Period(0, 0, 0, 0, 0, 2, 0, 0, PeriodType.standard()), test);        test = Period.seconds(1).plusSeconds(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 2, 0, PeriodType.standard()), test);        test = Period.millis(1).plusMillis(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 2, PeriodType.standard()), test);                test = new Period(0L, PeriodType.millis());        try {            test.plusYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPlusZero() {        Period test, result;        test = Period.years(1);        result = test.plusYears(0);        assertSame(test, result);        test = Period.months(1);        result = test.plusMonths(0);        assertSame(test, result);        test = Period.weeks(1);        result = test.plusWeeks(0);        assertSame(test, result);        test = Period.days(1);        result = test.plusDays(0);        assertSame(test, result);        test = Period.hours(1);        result = test.plusHours(0);        assertSame(test, result);        test = Period.minutes(1);        result = test.plusMinutes(0);        assertSame(test, result);        test = Period.seconds(1);        result = test.plusSeconds(0);        assertSame(test, result);        test = Period.millis(1);        result = test.plusMillis(0);        assertSame(test, result);    }    public void testMinus() {        Period test;        test = Period.years(3).minusYears(1);        assertEquals(new Period(2, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.months(3).minusMonths(1);        assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.weeks(3).minusWeeks(1);        assertEquals(new Period(0, 0, 2, 0, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.days(3).minusDays(1);        assertEquals(new Period(0, 0, 0, 2, 0, 0, 0, 0, PeriodType.standard()), test);        test = Period.hours(3).minusHours(1);        assertEquals(new Period(0, 0, 0, 0, 2, 0, 0, 0, PeriodType.standard()), test);        test = Period.minutes(3).minusMinutes(1);        assertEquals(new Period(0, 0, 0, 0, 0, 2, 0, 0, PeriodType.standard()), test);        test = Period.seconds(3).minusSeconds(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 2, 0, PeriodType.standard()), test);        test = Period.millis(3).minusMillis(1);        assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 2, PeriodType.standard()), test);                test = new Period(0L, PeriodType.millis());        try {            test.minusYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;import org.joda.time.field.FieldUtils;import org.joda.time.field.SkipDateTimeField;/** * Tests IllegalFieldValueException by triggering it from other methods. * * @author Brian S O'Neill */public class TestIllegalFieldValueException extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestIllegalFieldValueException.class);    }    public TestIllegalFieldValueException(String name) {        super(name);    }    public void testVerifyValueBounds() {        try {            FieldUtils.verifyValueBounds(ISOChronology.getInstance().monthOfYear(), -5, 1, 31);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("monthOfYear", e.getFieldName());            assertEquals(new Integer(-5), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("-5", e.getIllegalValueAsString());            assertEquals(new Integer(1), e.getLowerBound());            assertEquals(new Integer(31), e.getUpperBound());        }        try {            FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), 27, 0, 23);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.hourOfDay(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("hourOfDay", e.getFieldName());            assertEquals(new Integer(27), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("27", e.getIllegalValueAsString());            assertEquals(new Integer(0), e.getLowerBound());            assertEquals(new Integer(23), e.getUpperBound());        }        try {            FieldUtils.verifyValueBounds("foo", 1, 2, 3);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(null, e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("foo", e.getFieldName());            assertEquals(new Integer(1), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("1", e.getIllegalValueAsString());            assertEquals(new Integer(2), e.getLowerBound());            assertEquals(new Integer(3), e.getUpperBound());        }    }    public void testSkipDateTimeField() {        DateTimeField field = new SkipDateTimeField            (ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC().year(), 1970);        try {            field.set(0, 1970);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("year", e.getFieldName());            assertEquals(new Integer(1970), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("1970", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }    }    public void testSetText() {        try {            ISOChronology.getInstanceUTC().year().set(0, null, java.util.Locale.US);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("year", e.getFieldName());            assertEquals(null, e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("null", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }        try {            ISOChronology.getInstanceUTC().year().set(0, "nineteen seventy", java.util.Locale.US);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("year", e.getFieldName());            assertEquals(null, e.getIllegalNumberValue());            assertEquals("nineteen seventy", e.getIllegalStringValue());            assertEquals("nineteen seventy", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }        try {            ISOChronology.getInstanceUTC().era().set(0, "long ago", java.util.Locale.US);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.era(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("era", e.getFieldName());            assertEquals(null, e.getIllegalNumberValue());            assertEquals("long ago", e.getIllegalStringValue());            assertEquals("long ago", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }        try {            ISOChronology.getInstanceUTC().monthOfYear().set(0, "spring", java.util.Locale.US);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("monthOfYear", e.getFieldName());            assertEquals(null, e.getIllegalNumberValue());            assertEquals("spring", e.getIllegalStringValue());            assertEquals("spring", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }        try {            ISOChronology.getInstanceUTC().dayOfWeek().set(0, "yesterday", java.util.Locale.US);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.dayOfWeek(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("dayOfWeek", e.getFieldName());            assertEquals(null, e.getIllegalNumberValue());            assertEquals("yesterday", e.getIllegalStringValue());            assertEquals("yesterday", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }        try {            ISOChronology.getInstanceUTC().halfdayOfDay().set(0, "morning", java.util.Locale.US);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.halfdayOfDay(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("halfdayOfDay", e.getFieldName());            assertEquals(null, e.getIllegalNumberValue());            assertEquals("morning", e.getIllegalStringValue());            assertEquals("morning", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }    }    public void testZoneTransition() {        DateTime dt = new DateTime            (2005, 4, 3, 1, 0, 0, 0, DateTimeZone.forID("America/Los_Angeles"));        try {            dt.hourOfDay().setCopy(2);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.hourOfDay(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("hourOfDay", e.getFieldName());            assertEquals(new Integer(2), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("2", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }    }    public void testJulianYearZero() {        DateTime dt = new DateTime(JulianChronology.getInstanceUTC());        try {            dt.year().setCopy(0);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("year", e.getFieldName());            assertEquals(new Integer(0), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("0", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }    }    public void testGJCutover() {        DateTime dt = new DateTime("1582-10-04", GJChronology.getInstanceUTC());        try {            dt.dayOfMonth().setCopy(5);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.dayOfMonth(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("dayOfMonth", e.getFieldName());            assertEquals(new Integer(5), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("5", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }        dt = new DateTime("1582-10-15", GJChronology.getInstanceUTC());        try {            dt.dayOfMonth().setCopy(14);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.dayOfMonth(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("dayOfMonth", e.getFieldName());            assertEquals(new Integer(14), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("14", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(null, e.getUpperBound());        }    }    public void testReadablePartialValidate() {        try {            new YearMonthDay(1970, -5, 1);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("monthOfYear", e.getFieldName());            assertEquals(new Integer(-5), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("-5", e.getIllegalValueAsString());            assertEquals(new Integer(1), e.getLowerBound());            assertEquals(null, e.getUpperBound());        }        try {            new YearMonthDay(1970, 500, 1);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("monthOfYear", e.getFieldName());            assertEquals(new Integer(500), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("500", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(new Integer(12), e.getUpperBound());        }        try {            new YearMonthDay(1970, 2, 30);            fail();        } catch (IllegalFieldValueException e) {            assertEquals(DateTimeFieldType.dayOfMonth(), e.getDateTimeFieldType());            assertEquals(null, e.getDurationFieldType());            assertEquals("dayOfMonth", e.getFieldName());            assertEquals(new Integer(30), e.getIllegalNumberValue());            assertEquals(null, e.getIllegalStringValue());            assertEquals("30", e.getIllegalValueAsString());            assertEquals(null, e.getLowerBound());            assertEquals(new Integer(28), e.getUpperBound());        }    }    // Test extra constructors not currently called by anything    public void testOtherConstructors() {        IllegalFieldValueException e = new IllegalFieldValueException            (DurationFieldType.days(), new Integer(1), new Integer(2), new Integer(3));        assertEquals(null, e.getDateTimeFieldType());        assertEquals(DurationFieldType.days(), e.getDurationFieldType());        assertEquals("days", e.getFieldName());        assertEquals(new Integer(1), e.getIllegalNumberValue());        assertEquals(null, e.getIllegalStringValue());        assertEquals("1", e.getIllegalValueAsString());        assertEquals(new Integer(2), e.getLowerBound());        assertEquals(new Integer(3), e.getUpperBound());        e = new IllegalFieldValueException(DurationFieldType.months(), "five");        assertEquals(null, e.getDateTimeFieldType());        assertEquals(DurationFieldType.months(), e.getDurationFieldType());        assertEquals("months", e.getFieldName());        assertEquals(null, e.getIllegalNumberValue());        assertEquals("five", e.getIllegalStringValue());        assertEquals("five", e.getIllegalValueAsString());        assertEquals(null, e.getLowerBound());        assertEquals(null, e.getUpperBound());        e = new IllegalFieldValueException("months", "five");        assertEquals(null, e.getDateTimeFieldType());        assertEquals(null, e.getDurationFieldType());        assertEquals("months", e.getFieldName());        assertEquals(null, e.getIllegalNumberValue());        assertEquals("five", e.getIllegalStringValue());        assertEquals("five", e.getIllegalValueAsString());        assertEquals(null, e.getLowerBound());        assertEquals(null, e.getUpperBound());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.CopticChronology;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne * @author Mike Schrag */public class TestDateTime_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Properties.class);    }    public TestDateTime_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getDateTime());        assertEquals(1, test.era().get());        assertEquals("1", test.era().getAsString());        assertEquals("AD", test.era().getAsText());        assertEquals("AD", test.era().getField().getAsText(1, Locale.ENGLISH));        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("ap. J.-C.", test.era().getField().getAsText(1, Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("AD", test.era().getField().getAsShortText(1, Locale.ENGLISH));        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals("ap. J.-C.", test.era().getField().getAsShortText(1, Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertSame(test, test.yearOfEra().getDateTime());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsString());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertSame(test, test.centuryOfEra().getDateTime());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsString());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertSame(test, test.yearOfCentury().getDateTime());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsString());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertSame(test, test.weekyear().getDateTime());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsString());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertSame(test, test.year().getDateTime());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsString());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyLeapYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(true, test.year().isLeap());        assertEquals(1, test.year().getLeapAmount());        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());        test = new DateTime(2003, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.year().isLeap());        assertEquals(0, test.year().getLeapAmount());        assertEquals(test.getChronology().days(), test.year().getLeapDurationField());    }    public void testPropertyAddYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addToCopy(0);        assertEquals("2004-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addToCopy(292277023 - 2004);        assertEquals(292277023, copy.getYear());                try {            test.year().addToCopy(292277023 - 2004 + 1);            fail();        } catch (IllegalArgumentException ex) {}                copy = test.year().addToCopy(-2004);        assertEquals(0, copy.getYear());                copy = test.year().addToCopy(-2005);        assertEquals(-1, copy.getYear());                try {            test.year().addToCopy(-292275054 - 2004 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertyAddWrapFieldYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().addWrapFieldToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString());                copy = test.year().addWrapFieldToCopy(0);        assertEquals(2004, copy.getYear());                copy = test.year().addWrapFieldToCopy(292277023 - 2004 + 1);        assertEquals(-292275054, copy.getYear());                copy = test.year().addWrapFieldToCopy(-292275054 - 2004 - 1);        assertEquals(292277023, copy.getYear());    }    public void testPropertySetYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().setCopy(1960);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetTextYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.year().setCopy("1960");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.year().compareTo(test2) < 0);        assertEquals(true, test2.year().compareTo(test1) > 0);        assertEquals(true, test1.year().compareTo(test1) == 0);        try {            test1.year().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertyCompareToYear2() {        DateTime test1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        YearMonthDay ymd1 = new YearMonthDay(2003, 6, 9);        YearMonthDay ymd2 = new YearMonthDay(2004, 6, 9);        YearMonthDay ymd3 = new YearMonthDay(2005, 6, 9);        assertEquals(true, test1.year().compareTo(ymd1) > 0);        assertEquals(true, test1.year().compareTo(ymd2) == 0);        assertEquals(true, test1.year().compareTo(ymd3) < 0);        try {            test1.year().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertyEqualsHashCodeYear() {        DateTime test1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(true, test1.year().equals(test1.year()));        assertEquals(true, test1.year().equals(new DateTime(2004, 6, 9, 0, 0, 0, 0).year()));        assertEquals(false, test1.year().equals(new DateTime(2004, 6, 9, 0, 0, 0, 0).monthOfYear()));        assertEquals(false, test1.year().equals(new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()).year()));                assertEquals(true, test1.year().hashCode() == test1.year().hashCode());        assertEquals(true, test1.year().hashCode() == new DateTime(2004, 6, 9, 0, 0, 0, 0).year().hashCode());        assertEquals(false, test1.year().hashCode() == new DateTime(2004, 6, 9, 0, 0, 0, 0).monthOfYear().hashCode());        assertEquals(false, test1.year().hashCode() == new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()).year().hashCode());    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertSame(test, test.monthOfYear().getDateTime());        assertEquals(6, test.monthOfYear().get());        assertEquals("6", test.monthOfYear().getAsString());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("June", test.monthOfYear().getField().getAsText(6, Locale.ENGLISH));        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juin", test.monthOfYear().getField().getAsText(6, Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("Jun", test.monthOfYear().getField().getAsShortText(6, Locale.ENGLISH));        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals("juin", test.monthOfYear().getField().getAsShortText(6, Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juillet", test.monthOfYear().getField().getAsText(7, Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getField().getAsShortText(7, Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyLeapMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2004, 2, 9, 0, 0, 0, 0);        assertEquals(true, test.monthOfYear().isLeap());        assertEquals(1, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2003, 6, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());                test = new DateTime(2003, 2, 9, 0, 0, 0, 0);        assertEquals(false, test.monthOfYear().isLeap());        assertEquals(0, test.monthOfYear().getLeapAmount());        assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField());    }    public void testPropertyAddMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().addToCopy(6);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(7);        assertEquals("2005-01-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(-5);        assertEquals("2004-01-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(-6);        assertEquals("2003-12-09T00:00:00.000Z", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addToCopy(1);        assertEquals("2004-01-31T00:00:00.000Z", test.toString());        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addToCopy(2);        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addToCopy(3);        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());                test = new DateTime(2003, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addToCopy(1);        assertEquals("2003-02-28T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().addWrapFieldToCopy(4);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(8);        assertEquals("2004-02-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(-8);        assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addWrapFieldToCopy(1);        assertEquals("2004-01-31T00:00:00.000Z", test.toString());        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(2);        assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString());                copy = test.monthOfYear().addWrapFieldToCopy(3);        assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString());                test = new DateTime(2005, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().addWrapFieldToCopy(1);        assertEquals("2005-01-31T00:00:00.000Z", test.toString());        assertEquals("2005-02-28T00:00:00.000Z", copy.toString());    }    public void testPropertySetMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                test = new DateTime(2004, 1, 31, 0, 0, 0, 0);        copy = test.monthOfYear().setCopy(2);        assertEquals("2004-02-29T00:00:00.000Z", copy.toString());                try {            test.monthOfYear().setCopy(13);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.monthOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMonthOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.monthOfYear().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().setCopy("December");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());                copy = test.monthOfYear().setCopy("Dec");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-12-09T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToMonthOfYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(test2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(test1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(test1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0);        try {            test1.monthOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertSame(test, test.dayOfMonth().getDateTime());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsString());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals(31, test.dayOfMonth().getMaximumValue());        test = new DateTime(2004, 2, 9, 0, 0, 0, 0);        assertEquals(29, test.dayOfMonth().getMaximumValue());        test = new DateTime(2003, 2, 9, 0, 0, 0, 0);        assertEquals(28, test.dayOfMonth().getMaximumValue());    }    public void testPropertyAddDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 30);        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 31);        assertEquals("2004-08-01T00:00:00.000+01:00", copy.toString());        copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().addWrapFieldToCopy(21);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addWrapFieldToCopy(22);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfMonth().addWrapFieldToCopy(-12);        assertEquals("2004-06-27T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 7, 9, 0, 0, 0, 0);        copy = test.dayOfMonth().addWrapFieldToCopy(21);        assertEquals("2004-07-30T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(22);        assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(23);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());            copy = test.dayOfMonth().addWrapFieldToCopy(-12);        assertEquals("2004-07-28T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());                try {            test.dayOfMonth().setCopy(31);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfMonth().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString());    }    public void testPropertyWithMaximumValueDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().withMaximumValue();        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());    }    public void testPropertyWithMinimumValueDayOfMonth() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfMonth().withMinimumValue();        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToDayOfMonth() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0);        try {            test1.dayOfMonth().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertSame(test, test.dayOfYear().getDateTime());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsString());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.dayOfYear().getMinimumValue());        assertEquals(1, test.dayOfYear().getMinimumValueOverall());        assertEquals(366, test.dayOfYear().getMaximumValue());        assertEquals(366, test.dayOfYear().getMaximumValueOverall());        test = new DateTime(2002, 6, 9, 0, 0, 0, 0);        assertEquals(365, test.dayOfYear().getMaximumValue());        assertEquals(366, test.dayOfYear().getMaximumValueOverall());    }    public void testPropertyAddDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().addToCopy(9);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().addWrapFieldToCopy(21);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-12);        assertEquals("2004-05-28T00:00:00.000+01:00", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(205);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(206);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-160);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfYear().addWrapFieldToCopy(-161);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertySetDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().setCopy(12);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());                try {            test.dayOfYear().setCopy(367);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfYear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfYear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfYear().setCopy("12");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-12T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToDayOfYear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfYear().compareTo(test2) < 0);        assertEquals(true, test2.dayOfYear().compareTo(test1) > 0);        assertEquals(true, test1.dayOfYear().compareTo(test1) == 0);        try {            test1.dayOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.dayOfYear().compareTo(dt2) < 0);        assertEquals(true, test2.dayOfYear().compareTo(dt1) > 0);        assertEquals(true, test1.dayOfYear().compareTo(dt1) == 0);        try {            test1.dayOfYear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        // 2002-01-01 = Thu        // 2002-12-31 = Thu (+364 days)        // 2003-12-30 = Thu (+364 days)        // 2004-01-03 = Mon             W1        // 2004-01-31 = Mon (+28 days)  W5        // 2004-02-28 = Mon (+28 days)  W9        // 2004-03-27 = Mon (+28 days)  W13        // 2004-04-24 = Mon (+28 days)  W17        // 2004-05-23 = Mon (+28 days)  W21        // 2004-06-05 = Mon (+14 days)  W23        // 2004-06-09 = Fri        // 2004-12-25 = Mon             W52        // 2005-01-01 = Mon             W1        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertSame(test, test.weekOfWeekyear().getDateTime());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsString());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    public void testPropertyGetMaxMinValuesWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertEquals(1, test.weekOfWeekyear().getMinimumValue());        assertEquals(1, test.weekOfWeekyear().getMinimumValueOverall());        assertEquals(53, test.weekOfWeekyear().getMaximumValue());        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());        test = new DateTime(2005, 6, 9, 0, 0, 0, 0);        assertEquals(52, test.weekOfWeekyear().getMaximumValue());        assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall());    }    public void testPropertyAddWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().addToCopy(1);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());                copy = test.weekOfWeekyear().addToCopy(29);        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(30);        assertEquals("2005-01-03T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(-22);        assertEquals("2004-01-05T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addToCopy(-23);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());    }    public void testPropertyAddWrapFieldWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().addWrapFieldToCopy(1);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(29);        assertEquals("2004-12-27T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(30);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());                copy = test.weekOfWeekyear().addWrapFieldToCopy(-23);        assertEquals("2003-12-29T00:00:00.000Z", copy.toString());    }    public void testPropertySetWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().setCopy(4);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());                try {            test.weekOfWeekyear().setCopy(54);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.weekOfWeekyear().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextWeekOfWeekyear() {        DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0);        DateTime copy = test.weekOfWeekyear().setCopy("4");        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());        assertEquals("2004-01-19T00:00:00.000Z", copy.toString());    }    public void testPropertyCompareToWeekOfWeekyear() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.weekOfWeekyear().compareTo(test2) < 0);        assertEquals(true, test2.weekOfWeekyear().compareTo(test1) > 0);        assertEquals(true, test1.weekOfWeekyear().compareTo(test1) == 0);        try {            test1.weekOfWeekyear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.weekOfWeekyear().compareTo(dt2) < 0);        assertEquals(true, test2.weekOfWeekyear().compareTo(dt1) > 0);        assertEquals(true, test1.weekOfWeekyear().compareTo(dt1) == 0);        try {            test1.weekOfWeekyear().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertSame(test, test.dayOfWeek().getDateTime());        assertEquals(3, test.dayOfWeek().get());        assertEquals("3", test.dayOfWeek().getAsString());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("Wednesday", test.dayOfWeek().getField().getAsText(3, Locale.ENGLISH));        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("mercredi", test.dayOfWeek().getField().getAsText(3, Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("Wed", test.dayOfWeek().getField().getAsShortText(3, Locale.ENGLISH));        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals("mer.", test.dayOfWeek().getField().getAsShortText(3, Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }    public void testPropertyAddDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().addToCopy(1);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(21);        assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(22);        assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2004-12-31T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31);        assertEquals("2005-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(-8);        assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(-9);        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addToCopy(-8 - 31 - 30 - 31 - 29 - 31);        assertEquals("2004-01-01T00:00:00.000Z", copy.toString());                copy = test.dayOfWeek().addToCopy(-9 - 31 - 30 - 31 - 29 - 31);        assertEquals("2003-12-31T00:00:00.000Z", copy.toString());    }    public void testPropertyAddLongDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().addToCopy(1L);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());    }            public void testPropertyAddWrapFieldDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);  // Wed        DateTime copy = test.dayOfWeek().addWrapFieldToCopy(1);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addWrapFieldToCopy(5);        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());                copy = test.dayOfWeek().addWrapFieldToCopy(-10);        assertEquals("2004-06-13T00:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 2, 0, 0, 0, 0);        copy = test.dayOfWeek().addWrapFieldToCopy(5);        assertEquals("2004-06-02T00:00:00.000+01:00", test.toString());        assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString());    }    public void testPropertySetDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().setCopy(4);        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());                try {            test.dayOfWeek().setCopy(8);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.dayOfWeek().setCopy(0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextDayOfWeek() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime copy = test.dayOfWeek().setCopy("4");        assertEquals("2004-06-09T00:00:00.000+01:00", test.toString());        assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("Mon");        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("Tuesday");        assertEquals("2004-06-08T00:00:00.000+01:00", copy.toString());        copy = test.dayOfWeek().setCopy("lundi", Locale.FRENCH);        assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString());    }    public void testPropertyCompareToDayOfWeek() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test2.dayOfWeek().compareTo(test1) < 0);        assertEquals(true, test1.dayOfWeek().compareTo(test2) > 0);        assertEquals(true, test1.dayOfWeek().compareTo(test1) == 0);        try {            test1.dayOfWeek().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test2.dayOfWeek().compareTo(dt1) < 0);        assertEquals(true, test1.dayOfWeek().compareTo(dt2) > 0);        assertEquals(true, test1.dayOfWeek().compareTo(dt1) == 0);        try {            test1.dayOfWeek().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getDateTime());        assertEquals(13, test.hourOfDay().get());        assertEquals("13", test.hourOfDay().getAsString());        assertEquals("13", test.hourOfDay().getAsText());        assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("13", test.hourOfDay().getAsShortText());        assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyGetDifferenceHourOfDay() {        DateTime test1 = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime test2 = new DateTime(2004, 6, 9, 15, 30, 0, 0);        assertEquals(-2, test1.hourOfDay().getDifference(test2));        assertEquals(2, test2.hourOfDay().getDifference(test1));        assertEquals(-2L, test1.hourOfDay().getDifferenceAsLong(test2));        assertEquals(2L, test2.hourOfDay().getDifferenceAsLong(test1));                DateTime test = new DateTime(TEST_TIME_NOW + (13L * DateTimeConstants.MILLIS_PER_HOUR));        assertEquals(13, test.hourOfDay().getDifference(null));        assertEquals(13L, test.hourOfDay().getDifferenceAsLong(null));    }    public void testPropertyRoundFloorHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundCeilingHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfFloorHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfFloorCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfCeilingHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfCeilingCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRoundHalfEvenHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        DateTime copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 14, 30, 0, 0);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 30, 0, 1);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString());                test = new DateTime(2004, 6, 9, 13, 29, 59, 999);        copy = test.hourOfDay().roundHalfEvenCopy();        assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString());    }    public void testPropertyRemainderHourOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0);        assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfHour() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getDateTime());        assertEquals(23, test.minuteOfHour().get());        assertEquals("23", test.minuteOfHour().getAsString());        assertEquals("23", test.minuteOfHour().getAsText());        assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("23", test.minuteOfHour().getAsShortText());        assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());        assertEquals("minuteOfDay", test.minuteOfDay().getName());        assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString());        assertSame(test, test.minuteOfDay().getDateTime());        assertEquals(803, test.minuteOfDay().get());        assertEquals("803", test.minuteOfDay().getAsString());        assertEquals("803", test.minuteOfDay().getAsText());        assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH));        assertEquals("803", test.minuteOfDay().getAsShortText());        assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());        assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));        assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfMinute() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getDateTime());        assertEquals(43, test.secondOfMinute().get());        assertEquals("43", test.secondOfMinute().getAsString());        assertEquals("43", test.secondOfMinute().getAsText());        assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("43", test.secondOfMinute().getAsShortText());        assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());        assertEquals("secondOfDay", test.secondOfDay().getName());        assertEquals("Property[secondOfDay]", test.secondOfDay().toString());        assertSame(test, test.secondOfDay().getDateTime());        assertEquals(48223, test.secondOfDay().get());        assertEquals("48223", test.secondOfDay().getAsString());        assertEquals("48223", test.secondOfDay().getAsText());        assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH));        assertEquals("48223", test.secondOfDay().getAsShortText());        assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());        assertEquals(5, test.secondOfDay().getMaximumTextLength(null));        assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfSecond() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getDateTime());        assertEquals(53, test.millisOfSecond().get());        assertEquals("53", test.millisOfSecond().getAsString());        assertEquals("53", test.millisOfSecond().getAsText());        assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("53", test.millisOfSecond().getAsShortText());        assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfDay() {        DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());        assertEquals("millisOfDay", test.millisOfDay().getName());        assertEquals("Property[millisOfDay]", test.millisOfDay().toString());        assertSame(test, test.millisOfDay().getDateTime());        assertEquals(48223053, test.millisOfDay().get());        assertEquals("48223053", test.millisOfDay().getAsString());        assertEquals("48223053", test.millisOfDay().getAsText());        assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH));        assertEquals("48223053", test.millisOfDay().getAsShortText());        assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());        assertEquals(8, test.millisOfDay().getMaximumTextLength(null));        assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyToIntervalYearOfEra() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.yearOfEra().toInterval();      assertEquals(new DateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new DateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());    }    public void testPropertyToIntervalYearOfCentury() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.yearOfCentury().toInterval();      assertEquals(new DateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new DateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());    }    public void testPropertyToIntervalYear() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.year().toInterval();      assertEquals(new DateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new DateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());    }    public void testPropertyToIntervalMonthOfYear() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.monthOfYear().toInterval();      assertEquals(new DateTime(2004, 6, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new DateTime(2004, 7, 1, 0, 0, 0, 0), testInterval.getEnd());    }    public void testPropertyToIntervalDayOfMonth() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.dayOfMonth().toInterval();      assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new DateTime(2004, 6, 10, 0, 0, 0, 0), testInterval.getEnd());      DateTime febTest = new DateTime(2004, 2, 29, 13, 23, 43, 53);      Interval febTestInterval = febTest.dayOfMonth().toInterval();      assertEquals(new DateTime(2004, 2, 29, 0, 0, 0, 0), febTestInterval.getStart());      assertEquals(new DateTime(2004, 3, 1, 0, 0, 0, 0), febTestInterval.getEnd());    }    public void testPropertyToIntervalHourOfDay() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.hourOfDay().toInterval();      assertEquals(new DateTime(2004, 6, 9, 13, 0, 0, 0), testInterval.getStart());      assertEquals(new DateTime(2004, 6, 9, 14, 0, 0, 0), testInterval.getEnd());      DateTime midnightTest = new DateTime(2004, 6, 9, 23, 23, 43, 53);      Interval midnightTestInterval = midnightTest.hourOfDay().toInterval();      assertEquals(new DateTime(2004, 6, 9, 23, 0, 0, 0), midnightTestInterval.getStart());      assertEquals(new DateTime(2004, 6, 10, 0, 0, 0, 0), midnightTestInterval.getEnd());    }    public void testPropertyToIntervalMinuteOfHour() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.minuteOfHour().toInterval();      assertEquals(new DateTime(2004, 6, 9, 13, 23, 0, 0), testInterval.getStart());      assertEquals(new DateTime(2004, 6, 9, 13, 24, 0, 0), testInterval.getEnd());    }    public void testPropertyToIntervalSecondOfMinute() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.secondOfMinute().toInterval();      assertEquals(new DateTime(2004, 6, 9, 13, 23, 43, 0), testInterval.getStart());      assertEquals(new DateTime(2004, 6, 9, 13, 23, 44, 0), testInterval.getEnd());    }    public void testPropertyToIntervalMillisOfSecond() {      DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.millisOfSecond().toInterval();      assertEquals(new DateTime(2004, 6, 9, 13, 23, 43, 53), testInterval.getStart());      assertEquals(new DateTime(2004, 6, 9, 13, 23, 43, 54), testInterval.getEnd());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Adds extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Adds.class);    }    public TestMutableDateTime_Adds(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testAdd_long1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(123456L);        assertEquals(TEST_TIME1 + 123456L, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testAdd_RD1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(new Duration(123456L));        assertEquals(TEST_TIME1 + 123456L, test.getMillis());    }    public void testAdd_RD2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadableDuration) null);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RD_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(new Duration(123456L), -2);        assertEquals(TEST_TIME1 - (2L * 123456L), test.getMillis());    }    public void testAdd_RD_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadableDuration) null, 1);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RP1() {        Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());        test.add(d);        assertEquals("2003-07-10T06:07:08.009+01:00", test.toString());    }    public void testAdd_RP2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadablePeriod) null);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RP_int1() {        Period d = new Period(0, 0, 0, 0, 0, 0, 1, 2);        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(d, -2);        assertEquals(TEST_TIME1 - (2L * 1002L), test.getMillis());    }    public void testAdd_RP_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add((ReadablePeriod) null, 1);        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_DurationFieldType_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.add(DurationFieldType.years(), 8);        assertEquals(2010, test.getYear());    }    public void testAdd_DurationFieldType_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.add((DurationFieldType) null, 0);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    public void testAdd_DurationFieldType_int3() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.add((DurationFieldType) null, 6);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAddYears_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addYears(8);        assertEquals("2010-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMonths_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMonths(6);        assertEquals("2002-12-09T05:06:07.008Z", test.toString());    }    //-----------------------------------------------------------------------    public void testAddDays_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addDays(17);        assertEquals("2002-06-26T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddWeekyears_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addWeekyears(-1);        assertEquals("2001-06-10T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddWeeks_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addWeeks(-21);        assertEquals("2002-01-13T05:06:07.008Z", test.toString());    }    //-----------------------------------------------------------------------    public void testAddHours_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addHours(13);        assertEquals("2002-06-09T18:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMinutes_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMinutes(13);        assertEquals("2002-06-09T05:19:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddSeconds_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addSeconds(13);        assertEquals("2002-06-09T05:06:20.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testAddMillis_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.addMillis(13);        assertEquals("2002-06-09T05:06:07.021+01:00", test.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.IntervalConverter;/** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */public class TestInterval_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInterval_Constructors.class);    }    public TestInterval_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.getMillis(), dt2.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1.getMillis(), dt1.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    public void testConstructor_long_long3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new Interval(dt1.getMillis(), dt2.getMillis());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), GJChronology.getInstance());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(GJChronology.getInstance(), test.getChronology());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0));        Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1));        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1, (ReadableInstant) null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval((ReadableInstant) null, dt2);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI6() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval test = new Interval(dt1, dt1);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI7() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new Interval(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RI_RI8() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, GJChronology.getInstance());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(GJChronology.getInstance(), test.getChronology());    }    public void testConstructor_RI_RI9() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, GJChronology.getInstance());        Interval test = new Interval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RP1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, 6);        result = ISOChronology.getInstanceUTC().days().add(result, 3);        result = ISOChronology.getInstanceUTC().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, CopticChronology.getInstanceUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = CopticChronology.getInstanceUTC().months().add(result, 6);        result = CopticChronology.getInstanceUTC().days().add(result, 3);        result = CopticChronology.getInstanceUTC().hours().add(result, 1);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, 1);        result = ISOChronology.getInstance().millis().add(result, 23);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP5() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadablePeriod) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RP6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval(dt, (ReadablePeriod) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RP7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Interval test = new Interval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new Interval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RI1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, -6);        result = ISOChronology.getInstanceUTC().days().add(result, -3);        result = ISOChronology.getInstanceUTC().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, CopticChronology.getInstanceUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = CopticChronology.getInstanceUTC().months().add(result, -6);        result = CopticChronology.getInstanceUTC().days().add(result, -3);        result = CopticChronology.getInstanceUTC().hours().add(result, -1);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, -1);        result = ISOChronology.getInstance().millis().add(result, -23);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI5() throws Throwable {        Interval test = new Interval((ReadablePeriod) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval((ReadablePeriod) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Interval test = new Interval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new Interval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(result - TEST_TIME_NOW);                Interval test = new Interval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        Interval test = new Interval((ReadableInstant) null, (ReadableDuration) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RD3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval(dt, (ReadableDuration) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RD4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Duration dur = new Duration(result - TEST_TIME_NOW);                Interval test = new Interval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new Interval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(TEST_TIME_NOW - result);                Interval test = new Interval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI2() throws Throwable {        Interval test = new Interval((ReadableDuration) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Interval test = new Interval((ReadableDuration) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Duration dur = new Duration(TEST_TIME_NOW - result);                Interval test = new Interval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new Interval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_Object1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval test = new Interval(dt1.toString() + '/' + dt2.toString());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                Interval test = new Interval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval base = new MutableInterval(dt1, dt2);                Interval test = new Interval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object4() throws Throwable {        MockInterval base = new MockInterval();        Interval test = new Interval(base);        assertEquals(base.getStartMillis(), test.getStartMillis());        assertEquals(base.getEndMillis(), test.getEndMillis());    }    public void testConstructor_Object5() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter("");        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return String.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);            DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);            Interval test = new Interval(dt1.toString() + '/' + dt2.toString());            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    public void testConstructor_Object6() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 0L));        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return ReadableInterval.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            Interval base = new Interval(-1000L, 1000L);            Interval test = new Interval(base);            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    class MockInterval implements ReadableInterval {        public Chronology getChronology() {            return ISOChronology.getInstance();        }        public long getStartMillis() {            return 1234L;        }        public DateTime getStart() {            return new DateTime(1234L);        }        public long getEndMillis() {            return 5678L;        }        public DateTime getEnd() {            return new DateTime(5678L);        }        public long toDurationMillis() {            return (5678L - 1234L);        }        public Duration toDuration() {            return new Duration(5678L - 1234L);        }        public boolean contains(long millisInstant) {            return false;        }        public boolean containsNow() {            return false;        }        public boolean contains(ReadableInstant instant) {            return false;        }        public boolean contains(ReadableInterval interval) {            return false;        }        public boolean overlaps(ReadableInterval interval) {            return false;        }        public boolean isBefore(ReadableInstant instant) {            return false;        }        public boolean isBefore(ReadableInterval interval) {            return false;        }        public boolean isAfter(ReadableInstant instant) {            return false;        }        public boolean isAfter(ReadableInterval interval) {            return false;        }        public Interval toInterval() {            return null;        }        public MutableInterval toMutableInterval() {            return null;        }        public Period toPeriod() {            return null;        }        public Period toPeriod(PeriodType type) {            return null;        }    }    //-----------------------------------------------------------------------    public void testConstructor_Object_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                Interval test = new Interval(base, BuddhistChronology.getInstance());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(BuddhistChronology.getInstance(), test.getChronology());    }    public void testConstructor_Object_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                Interval test = new Interval(base, null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractDuration;import org.joda.time.base.BaseDuration;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */public class TestDuration_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDuration_Basics.class);    }    public TestDuration_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        Duration test = new Duration(0L);        assertEquals(0, test.getMillis());                test = new Duration(1234567890L);        assertEquals(1234567890L, test.getMillis());    }    public void testEqualsHashCode() {        Duration test1 = new Duration(123L);        Duration test2 = new Duration(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Duration test3 = new Duration(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockDuration(123L)));    }        class MockDuration extends AbstractDuration {        private final long iValue;        public MockDuration(long value) {            super();            iValue = value;        }        public long getMillis() {            return iValue;        }    }    public void testCompareTo() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                Duration test2 = new Duration(321L);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                assertEquals(+1, test2.compareTo(new MockDuration(123L)));        assertEquals(0, test1.compareTo(new MockDuration(123L)));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Long(123L));            fail();        } catch (ClassCastException ex) {}    }    public void testIsEqual() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                Duration test2 = new Duration(321L);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                assertEquals(false, test2.isEqual(new MockDuration(123L)));        assertEquals(true, test1.isEqual(new MockDuration(123L)));        assertEquals(false, test1.isEqual(null));        assertEquals(true, new Duration(0L).isEqual(null));    }        public void testIsBefore() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(false, test1.isShorterThan(test1a));        assertEquals(false, test1a.isShorterThan(test1));        assertEquals(false, test1.isShorterThan(test1));        assertEquals(false, test1a.isShorterThan(test1a));                Duration test2 = new Duration(321L);        assertEquals(true, test1.isShorterThan(test2));        assertEquals(false, test2.isShorterThan(test1));                assertEquals(false, test2.isShorterThan(new MockDuration(123L)));        assertEquals(false, test1.isShorterThan(new MockDuration(123L)));        assertEquals(false, test1.isShorterThan(null));        assertEquals(false, new Duration(0L).isShorterThan(null));    }        public void testIsAfter() {        Duration test1 = new Duration(123L);        Duration test1a = new Duration(123L);        assertEquals(false, test1.isLongerThan(test1a));        assertEquals(false, test1a.isLongerThan(test1));        assertEquals(false, test1.isLongerThan(test1));        assertEquals(false, test1a.isLongerThan(test1a));                Duration test2 = new Duration(321L);        assertEquals(false, test1.isLongerThan(test2));        assertEquals(true, test2.isLongerThan(test1));                assertEquals(true, test2.isLongerThan(new MockDuration(123L)));        assertEquals(false, test1.isLongerThan(new MockDuration(123L)));        assertEquals(true, test1.isLongerThan(null));        assertEquals(false, new Duration(0L).isLongerThan(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Duration test = new Duration(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Duration result = (Duration) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        long length = (365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 845L;        Duration test = new Duration(length);        assertEquals("PT" + (length / 1000) + "." + (length % 1000) + "S", test.toString());                test = new Duration(0L);        assertEquals("PT0S", test.toString());                test = new Duration(12345L);        assertEquals("PT12.345S", test.toString());                test = new Duration(-12345L);        assertEquals("PT-12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToDuration1() {        Duration test = new Duration(123L);        Duration result = test.toDuration();        assertSame(test, result);    }        public void testToDuration2() {        MockDuration test = new MockDuration(123L);        Duration result = test.toDuration();        assertNotSame(test, result);        assertEquals(test, result);    }        //-----------------------------------------------------------------------    public void testToPeriod() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod();        assertEquals(new Period(test), result);        assertEquals(new Period(test.getMillis()), result);    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(PeriodType.standard().withMillisRemoved());        assertEquals(new Period(test, PeriodType.standard().withMillisRemoved()), result);        assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved()), result);    }    //-----------------------------------------------------------------------    public void testToPeriod_Chronology() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(ISOChronology.getInstanceUTC());        assertEquals(new Period(test, ISOChronology.getInstanceUTC()), result);        assertEquals(new Period(test.getMillis(), ISOChronology.getInstanceUTC()), result);    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType_Chronology() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        Period result = test.toPeriod(PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC());        assertEquals(new Period(test, PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC()), result);        assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC()), result);    }    //-----------------------------------------------------------------------    public void testToPeriodFrom() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Period result = test.toPeriodFrom(dt);        assertEquals(new Period(dt, test), result);    }    //-----------------------------------------------------------------------    public void testToPeriodFrom_PeriodType() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Period result = test.toPeriodFrom(dt, PeriodType.standard().withMillisRemoved());        assertEquals(new Period(dt, test, PeriodType.standard().withMillisRemoved()), result);    }    //-----------------------------------------------------------------------    public void testToPeriodTo() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Period result = test.toPeriodTo(dt);        assertEquals(new Period(test, dt), result);    }    //-----------------------------------------------------------------------    public void testToPeriodTo_PeriodType() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Period result = test.toPeriodTo(dt, PeriodType.standard().withMillisRemoved());        assertEquals(new Period(test, dt, PeriodType.standard().withMillisRemoved()), result);    }    //-----------------------------------------------------------------------    public void testToIntervalFrom() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval result = test.toIntervalFrom(dt);        assertEquals(new Interval(dt, test), result);    }    //-----------------------------------------------------------------------    public void testToIntervalTo() {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Duration test = new Duration(length);        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Interval result = test.toIntervalTo(dt);        assertEquals(new Interval(test, dt), result);    }    //-----------------------------------------------------------------------    public void testWithMillis1() {        Duration test = new Duration(123L);        Duration result = test.withMillis(123L);        assertSame(test, result);    }    public void testWithMillis2() {        Duration test = new Duration(123L);        Duration result = test.withMillis(1234567890L);        assertEquals(1234567890L, result.getMillis());    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long_int1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 1);        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_long_int2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 2);        assertEquals(16123L, result.getMillis());    }    public void testWithDurationAdded_long_int3() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, -1);        assertEquals((123L - 8000L), result.getMillis());    }    public void testWithDurationAdded_long_int4() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(0L, 1);        assertSame(test, result);    }    public void testWithDurationAdded_long_int5() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(8000L, 0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testPlus_long1() {        Duration test = new Duration(123L);        Duration result = test.plus(8000L);        assertEquals(8123L, result.getMillis());    }    public void testPlus_long2() {        Duration test = new Duration(123L);        Duration result = test.plus(0L);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMinus_long1() {        Duration test = new Duration(123L);        Duration result = test.minus(8000L);        assertEquals(123L - 8000L, result.getMillis());    }    public void testMinus_long2() {        Duration test = new Duration(123L);        Duration result = test.minus(0L);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_RD_int1() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 1);        assertEquals(8123L, result.getMillis());    }    public void testWithDurationAdded_RD_int2() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 2);        assertEquals(16123L, result.getMillis());    }    public void testWithDurationAdded_RD_int3() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), -1);        assertEquals((123L - 8000L), result.getMillis());    }    public void testWithDurationAdded_RD_int4() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(0L), 1);        assertSame(test, result);    }    public void testWithDurationAdded_RD_int5() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(new Duration(8000L), 0);        assertSame(test, result);    }    public void testWithDurationAdded_RD_int6() {        Duration test = new Duration(123L);        Duration result = test.withDurationAdded(null, 0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testPlus_RD1() {        Duration test = new Duration(123L);        Duration result = test.plus(new Duration(8000L));        assertEquals(8123L, result.getMillis());    }    public void testPlus_RD2() {        Duration test = new Duration(123L);        Duration result = test.plus(new Duration(0L));        assertSame(test, result);    }    public void testPlus_RD3() {        Duration test = new Duration(123L);        Duration result = test.plus(null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMinus_RD1() {        Duration test = new Duration(123L);        Duration result = test.minus(new Duration(8000L));        assertEquals(123L - 8000L, result.getMillis());    }    public void testMinus_RD2() {        Duration test = new Duration(123L);        Duration result = test.minus(new Duration(0L));        assertSame(test, result);    }    public void testMinus_RD3() {        Duration test = new Duration(123L);        Duration result = test.minus(null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMutableDuration() {        // no MutableDuration, so...        MockMutableDuration test = new MockMutableDuration(123L);        assertEquals(123L, test.getMillis());                test.setMillis(2345L);        assertEquals(2345L, test.getMillis());    }    static class MockMutableDuration extends BaseDuration {        public MockMutableDuration(long duration) {            super(duration);        }        public void setMillis(long duration) {            super.setMillis(duration);        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Arrays;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */public class TestPartial_Constructors extends TestCase {    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS);    private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();    private static final int OFFSET = 1;        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPartial_Constructors.class);    }    public TestPartial_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor     */    public void testConstructor() throws Throwable {        Partial test = new Partial();        assertEquals(ISO_UTC, test.getChronology());        assertEquals(0, test.size());    }    //-----------------------------------------------------------------------    /**     * Test constructor     */    public void testConstructor_Chrono() throws Throwable {        Partial test = new Partial((Chronology) null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(0, test.size());                test = new Partial(GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(0, test.size());    }    //-----------------------------------------------------------------------    /**     * Test constructor     */    public void testConstructor_Type_int() throws Throwable {        Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1, test.size());        assertEquals(4, test.getValue(0));        assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));    }    /**     * Test constructor     */    public void testConstructorEx1_Type_int() throws Throwable {        try {            new Partial(null, 4);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not be null");        }    }    /**     * Test constructor     */    public void testConstructorEx2_Type_int() throws Throwable {        try {            new Partial(DateTimeFieldType.dayOfYear(), 0);            fail();        } catch (IllegalArgumentException ex) {            // expected        }    }    //-----------------------------------------------------------------------    /**     * Test constructor     */    public void testConstructor_Type_int_Chrono() throws Throwable {        Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4, GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(1, test.size());        assertEquals(4, test.getValue(0));        assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));    }    /**     * Test constructor     */    public void testConstructorEx_Type_int_Chrono() throws Throwable {        try {            new Partial(null, 4, ISO_UTC);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not be null");        }    }    /**     * Test constructor     */    public void testConstructorEx2_Type_int_Chrono() throws Throwable {        try {            new Partial(DateTimeFieldType.dayOfYear(), 0, ISO_UTC);            fail();        } catch (IllegalArgumentException ex) {            // expected        }    }    //-----------------------------------------------------------------------    /**     * Test constructor     */    public void testConstructor_TypeArray_intArray() throws Throwable {        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.year(),            DateTimeFieldType.dayOfYear()        };        int[] values = new int[] {2005, 33};        Partial test = new Partial(types, values);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(2, test.size());        assertEquals(2005, test.getValue(0));        assertEquals(2005, test.get(DateTimeFieldType.year()));        assertEquals(true, test.isSupported(DateTimeFieldType.year()));        assertEquals(33, test.getValue(1));        assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));        assertEquals(true, Arrays.equals(test.getValues(), values));    }    /**     * Test constructor     */    public void testConstructor2_TypeArray_intArray() throws Throwable {        DateTimeFieldType[] types = new DateTimeFieldType[0];        int[] values = new int[0];        Partial test = new Partial(types, values);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(0, test.size());    }    /**     * Test constructor     */    public void testConstructorEx1_TypeArray_intArray() throws Throwable {        try {            new Partial((DateTimeFieldType[]) null, new int[] {1});            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not be null");        }    }    /**     * Test constructor     */    public void testConstructorEx3_TypeArray_intArray() throws Throwable {        try {            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, null);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not be null");        }    }    /**     * Test constructor     */    public void testConstructorEx5_TypeArray_intArray() throws Throwable {        try {            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, new int[2]);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "same length");        }    }    /**     * Test constructor     */    public void testConstructorEx6_TypeArray_intArray() throws Throwable {        try {            new Partial(new DateTimeFieldType[] {null, DateTimeFieldType.dayOfYear()}, new int[2]);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "contain null");        }        try {            new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear(), null}, new int[2]);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "contain null");        }    }    /**     * Test constructor     */    public void testConstructorEx7_TypeArray_intArray() throws Throwable {        int[] values = new int[] {1, 1, 1};        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must be in order", "largest-smallest");        }                types = new DateTimeFieldType[] {            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must be in order", "largest-smallest");        }                types = new DateTimeFieldType[] {            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must be in order", "largest-smallest");        }                types = new DateTimeFieldType[] {            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must be in order", "largest-smallest");        }                types = new DateTimeFieldType[] {            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must be in order", "largest-smallest");        }                types = new DateTimeFieldType[] {            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must be in order", "largest-smallest");        }    }    /**     * Test constructor     */    public void testConstructorEx8_TypeArray_intArray() throws Throwable {        int[] values = new int[] {1, 1, 1};        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.era(), DateTimeFieldType.year(), DateTimeFieldType.year() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not", "duplicate");        }                types = new DateTimeFieldType[] {            DateTimeFieldType.era(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not", "duplicate");        }                types = new DateTimeFieldType[] {            DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth() };        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not", "duplicate");        }    }    /**     * Test constructor     */    public void testConstructorEx9_TypeArray_intArray() throws Throwable {        int[] values = new int[] {3, 0};        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfWeek()};        try {            new Partial(types, values);            fail();        } catch (IllegalArgumentException ex) {            // expected        }    }    //-----------------------------------------------------------------------    /**     * Test constructor     */    public void testConstructor_TypeArray_intArray_Chrono() throws Throwable {        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.year(),            DateTimeFieldType.dayOfYear()        };        int[] values = new int[] {2005, 33};        Partial test = new Partial(types, values, GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(2, test.size());        assertEquals(2005, test.getValue(0));        assertEquals(2005, test.get(DateTimeFieldType.year()));        assertEquals(true, test.isSupported(DateTimeFieldType.year()));        assertEquals(33, test.getValue(1));        assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));        assertEquals(true, Arrays.equals(test.getValues(), values));    }    //-----------------------------------------------------------------------    /**     * Test constructor     */    public void testConstructor_Partial() throws Throwable {        YearMonthDay ymd = new YearMonthDay(2005, 6, 25, GREGORIAN_PARIS);        Partial test = new Partial(ymd);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(3, test.size());        assertEquals(2005, test.getValue(0));        assertEquals(2005, test.get(DateTimeFieldType.year()));        assertEquals(true, test.isSupported(DateTimeFieldType.year()));        assertEquals(6, test.getValue(1));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));        assertEquals(25, test.getValue(2));        assertEquals(25, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));    }    /**     * Test constructor     */    public void testConstructorEx_Partial() throws Throwable {        try {            new Partial((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {            assertMessageContains(ex, "must not be null");        }    }    //-----------------------------------------------------------------------    /**     * Checks if the exception message is valid.     *      * @param ex  the exception to check     * @param str  the string to check     */    private void assertMessageContains(Exception ex, String str) {        assertEquals(ex.getMessage() + ": " + str, true, ex.getMessage().indexOf(str) >= 0);    }    /**     * Checks if the exception message is valid.     *      * @param ex  the exception to check     * @param str1  the string to check     * @param str2  the string to check     */    private void assertMessageContains(Exception ex, String str1, String str2) {        assertEquals(ex.getMessage() + ": " + str1 + "/" + str2, true,            ex.getMessage().indexOf(str1) >= 0 &&            ex.getMessage().indexOf(str2) >= 0 &&            ex.getMessage().indexOf(str1) < ex.getMessage().indexOf(str2));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;import org.joda.time.field.DelegatedDurationField;import org.joda.time.field.MillisDurationField;import org.joda.time.field.UnsupportedDateTimeField;import org.joda.time.field.UnsupportedDurationField;/** * This class is a Junit unit test for serialization. * * @author Stephen Colebourne */public class TestSerialization extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;    private static class MockDelegatedDurationField extends DelegatedDurationField implements Serializable {        private static final long serialVersionUID = 1878496002811998493L;                public MockDelegatedDurationField() {            super(MillisDurationField.INSTANCE);        }    }    private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestSerialization.class);    }    public TestSerialization(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testSerializedInstant() throws Exception {        Instant test = new Instant();        loadAndCompare(test, "Instant.dat", false);        inlineCompare(test, false);    }    public void testSerializedDateTime() throws Exception {        DateTime test = new DateTime();        loadAndCompare(test, "DateTime.dat", false);        inlineCompare(test, false);    }    public void testSerializedDateTimeProperty() throws Exception {        DateTime.Property test = new DateTime().hourOfDay();        loadAndCompare(test, "DateTimeProperty.dat", false);        inlineCompare(test, false);    }    public void testSerializedMutableDateTime() throws Exception {        MutableDateTime test = new MutableDateTime();        loadAndCompare(test, "MutableDateTime.dat", false);        inlineCompare(test, false);    }    public void testSerializedMutableDateTimeProperty() throws Exception {        MutableDateTime.Property test = new MutableDateTime().hourOfDay();        loadAndCompare(test, "MutableDateTimeProperty.dat", false);        inlineCompare(test, false);    }    public void testSerializedDateMidnight() throws Exception {        DateMidnight test = new DateMidnight();        loadAndCompare(test, "DateMidnight.dat", false);        inlineCompare(test, false);    }    public void testSerializedDateMidnightProperty() throws Exception {        DateMidnight.Property test = new DateMidnight().monthOfYear();        loadAndCompare(test, "DateMidnightProperty.dat", false);        inlineCompare(test, false);    }    public void testSerializedYearMonthDay() throws Exception {        YearMonthDay test = new YearMonthDay();        loadAndCompare(test, "YearMonthDay.dat", false);        inlineCompare(test, false);    }    public void testSerializedTimeOfDay() throws Exception {        TimeOfDay test = new TimeOfDay();        loadAndCompare(test, "TimeOfDay.dat", false);        inlineCompare(test, false);    }    public void testSerializedDateTimeZoneUTC() throws Exception {        DateTimeZone test = DateTimeZone.UTC;        loadAndCompare(test, "DateTimeZoneUTC.dat", true);        inlineCompare(test, true);    }    public void testSerializedDateTimeZone() throws Exception {        // have to re-get the zone, as TestDateTimeZone may have        // changed the cache, or a SoftReference may have got cleared        DateTimeZone test = DateTimeZone.forID("Europe/Paris");        loadAndCompare(test, "DateTimeZone.dat", true);        inlineCompare(test, true);    }    public void testSerializedCopticChronology() throws Exception {        CopticChronology test = CopticChronology.getInstance(LONDON);        loadAndCompare(test, "CopticChronology.dat", true);        inlineCompare(test, true);    }    public void testSerializedISOChronology() throws Exception {        ISOChronology test = ISOChronology.getInstance(PARIS);        loadAndCompare(test, "ISOChronology.dat", true);        inlineCompare(test, true);    }    public void testSerializedGJChronology() throws Exception {        GJChronology test = GJChronology.getInstance(TOKYO);        loadAndCompare(test, "GJChronology.dat", true);        inlineCompare(test, true);    }    public void testSerializedGregorianChronology() throws Exception {        GregorianChronology test = GregorianChronology.getInstance(PARIS);        loadAndCompare(test, "GregorianChronology.dat", true);        inlineCompare(test, true);    }    public void testSerializedJulianChronology() throws Exception {        JulianChronology test = JulianChronology.getInstance(PARIS);        loadAndCompare(test, "JulianChronology.dat", true);        inlineCompare(test, true);    }    public void testSerializedBuddhistChronology() throws Exception {        BuddhistChronology test = BuddhistChronology.getInstance(PARIS);        loadAndCompare(test, "BuddhistChronology.dat", true);        inlineCompare(test, true);    }    public void testSerializedPeriodType() throws Exception {        PeriodType test = PeriodType.dayTime();        loadAndCompare(test, "PeriodType.dat", false);        inlineCompare(test, false);    }    public void testSerializedDateTimeFieldType() throws Exception {        DateTimeFieldType test = DateTimeFieldType.clockhourOfDay();        loadAndCompare(test, "DateTimeFieldType.dat", true);        inlineCompare(test, true);    }    public void testSerializedUnsupportedDateTimeField() throws Exception {        UnsupportedDateTimeField test = UnsupportedDateTimeField.getInstance(                DateTimeFieldType.year(),                UnsupportedDurationField.getInstance(DurationFieldType.years()));        loadAndCompare(test, "UnsupportedDateTimeField.dat", true);        inlineCompare(test, true);    }    private void loadAndCompare(Serializable test, String filename, boolean same) throws Exception {        FileInputStream fis = new FileInputStream("src/testdata/" + filename);        ObjectInputStream ois = new ObjectInputStream(fis);        Object obj = ois.readObject();        ois.close();        if (same) {            assertSame(test, obj);        } else {            assertEquals(test, obj);        }    }    public void inlineCompare(Serializable test, boolean same) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bais);        Object obj = ois.readObject();        ois.close();                if (same) {            assertSame(test, obj);        } else {            assertEquals(test, obj);        }    }//    //-----------------------------------------------------------------------//    public void testStoreSerializedInstant() throws Exception {//        Instant test = new Instant();//        store(test, "Instant.dat");//    }////    public void testStoreSerializedDateTime() throws Exception {//        DateTime test = new DateTime();//        store(test, "DateTime.dat");//    }////    public void testStoreSerializedMutableDateTime() throws Exception {//        MutableDateTime test = new MutableDateTime();//        store(test, "MutableDateTime.dat");//    }////    public void testStoreSerializedDateMidnight() throws Exception {//        DateMidnight test = new DateMidnight();//        store(test, "DateMidnight.dat");//    }////    public void testStoreSerializedYearMonthDay() throws Exception {//        YearMonthDay test = new YearMonthDay();//        store(test, "YearMonthDay.dat");//    }////    public void testStoreSerializedYearMonthDayProperty() throws Exception {//        YearMonthDay.Property test = new YearMonthDay().monthOfYear();//        store(test, "YearMonthDayProperty.dat");//    }////    public void testStoreSerializedTimeOfDay() throws Exception {//        TimeOfDay test = new TimeOfDay();//        store(test, "TimeOfDay.dat");//    }////    public void testStoreSerializedTimeOfDayProperty() throws Exception {//        TimeOfDay.Property test = new TimeOfDay().hourOfDay();//        store(test, "TimeOfDayProperty.dat");//    }////    public void testStoreSerializedDateTimeZoneUTC() throws Exception {//        DateTimeZone test = DateTimeZone.UTC;//        store(test, "DateTimeZoneUTC.dat");//    }////    public void testStoreSerializedDateTimeZone() throws Exception {//        DateTimeZone test = PARIS;//        store(test, "DateTimeZone.dat");//    }////    public void testStoreSerializedCopticChronology() throws Exception {//        CopticChronology test = CopticChronology.getInstance(LONDON);//        store(test, "CopticChronology.dat");//    }////    public void testStoreSerializedISOChronology() throws Exception {//        ISOChronology test = ISOChronology.getInstance(PARIS);//        store(test, "ISOChronology.dat");//    }////    public void testStoreSerializedGJChronology() throws Exception {//        GJChronology test = GJChronology.getInstance(TOKYO);//        store(test, "GJChronology.dat");//    }////    public void testStoreSerializedGregorianChronology() throws Exception {//        GregorianChronology test = GregorianChronology.getInstance(PARIS);//        store(test, "GregorianChronology.dat");//    }////    public void testStoreSerializedJulianChronology() throws Exception {//        JulianChronology test = JulianChronology.getInstance(PARIS);//        store(test, "JulianChronology.dat");//    }////    public void testStoreSerializedBuddhistChronology() throws Exception {//        BuddhistChronology test = BuddhistChronology.getInstance(PARIS);//        store(test, "BuddhistChronology.dat");//    }////    public void testStoreSerializedPeriodType() throws Exception {//        PeriodType test = PeriodType.dayTime();//        store(test, "PeriodType.dat");//    }////    public void testStoreSerializedDateTimeFieldType() throws Exception {//        DateTimeFieldType test = DateTimeFieldType.clockhourOfDay();//        store(test, "DateTimeFieldType.dat");//    }////    public void testStoreSerializedUnsupportedDateTimeField() throws Exception {//        UnsupportedDateTimeField test = UnsupportedDateTimeField.getInstance(//                DateTimeFieldType.year(),//                UnsupportedDurationField.getInstance(DurationFieldType.years()));//        store(test, "UnsupportedDateTimeField.dat");//    }////    public void testStoreSerializedDurationFieldType() throws Exception {//        DurationFieldType test = DurationFieldType.MINUTES_TYPE;//        store(test, "DurationFieldType.dat");//    }////    public void testStoreSerializedMillisDurationField() throws Exception {//        MillisDurationField test = (MillisDurationField) MillisDurationField.INSTANCE;//        store(test, "MillisDurationField.dat");//    }////    public void testStoreSerializedDelegatedDurationField() throws Exception {//        DelegatedDurationField test = new MockDelegatedDurationField();//        store(test, "DelegatedDurationField.dat");//    }////    public void testStoreSerializedUnsupportedDurationField() throws Exception {//        UnsupportedDurationField test = UnsupportedDurationField.getInstance(DurationFieldType.eras());//        store(test, "UnsupportedDurationField.dat");//    }//    // format changed (properly defined) in v1.1//    public void testStoreSerializedDateTimeProperty() throws Exception {//        DateTime.Property test = new DateTime().hourOfDay();//        store(test, "DateTimeProperty.dat");//    }////    public void testStoreSerializedMutableDateTimeProperty() throws Exception {//        MutableDateTime.Property test = new MutableDateTime().hourOfDay();//        store(test, "MutableDateTimeProperty.dat");//    }////    public void testStoreSerializedDateMidnightProperty() throws Exception {//        DateMidnight.Property test = new DateMidnight().monthOfYear();//        store(test, "DateMidnightProperty.dat");//    }//    private void store(Serializable test, String filename) throws Exception {//        FileOutputStream fos = new FileOutputStream("src/testdata/" + filename);//        ObjectOutputStream oos = new ObjectOutputStream(fos);//        try {//            oos.writeObject(test);//        } finally {//            oos.close();//        }//        oos.close();//    }//}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePeriod;/** * This class is a Junit unit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Basics.class);    }    public TestMutablePeriod_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetPeriodType() {        MutablePeriod test = new MutablePeriod();        assertEquals(PeriodType.standard(), test.getPeriodType());    }    public void testGetMethods() {        MutablePeriod test = new MutablePeriod();        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getDays());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testEqualsHashCode() {        MutablePeriod test1 = new MutablePeriod(123L);        MutablePeriod test2 = new MutablePeriod(123L);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutablePeriod test3 = new MutablePeriod(321L);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockMutablePeriod(123L)));        assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime())));    }        class MockMutablePeriod extends BasePeriod {        public MockMutablePeriod(long value) {            super(value, null, null);        }    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutablePeriod test = new MutablePeriod(123L);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutablePeriod result = (MutablePeriod) ois.readObject();        ois.close();                assertEquals(test, result);    }//    //-----------------------------------------------------------------------//    public void testAddTo1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    public void testAddTo2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, -2);//        assertEquals(expected, added);//    }//    //    public void testAddTo3() {//        long expected = TEST_TIME_NOW;//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 0);//        assertEquals(expected, added);//    }//    //    public void testAddTo4() {//        long expected = TEST_TIME_NOW + 100L;//        MutablePeriod test = new MutablePeriod(100L);//        long added = test.addTo(TEST_TIME_NOW, 1);//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToWithChronology1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC());  // chrono specified so use it//        assertEquals(expected, added);//    }//    //    public void testAddToWithChronology3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono so use default//        assertEquals(expected, added);//    }//    //    //-----------------------------------------------------------------------//    public void testAddToRI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    public void testAddToRI3() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);//        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);//        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);//        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);//        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);//        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);//        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);//        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2);  // DateTime has UTC time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstanceUTC(), added.getChronology());//    }//    //    public void testAddToRI4() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);//        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);//        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);//        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);//        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);//        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);//        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);//        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());//    }//    //    public void testAddToRI5() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        DateTime added = test.addTo(null, -2);  // null has no time zone, use default//        assertEquals(expected, added.getMillis());//        assertEquals(ISOChronology.getInstance(), added.getChronology());//    }//    //    //-----------------------------------------------------------------------//    public void testAddIntoRWI1() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, 1);//        expected = ISOChronology.getInstance().months().add(expected, 2);//        expected = ISOChronology.getInstance().weeks().add(expected, 3);//        expected = ISOChronology.getInstance().days().add(expected, 4);//        expected = ISOChronology.getInstance().hours().add(expected, 5);//        expected = ISOChronology.getInstance().minutes().add(expected, 6);//        expected = ISOChronology.getInstance().seconds().add(expected, 7);//        expected = ISOChronology.getInstance().millis().add(expected, 8);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, 1);//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI2() {//        long expected = TEST_TIME_NOW;//        expected = ISOChronology.getInstance().years().add(expected, -2);//        expected = ISOChronology.getInstance().months().add(expected, -4);//        expected = ISOChronology.getInstance().weeks().add(expected, -6);//        expected = ISOChronology.getInstance().days().add(expected, -8);//        expected = ISOChronology.getInstance().hours().add(expected, -10);//        expected = ISOChronology.getInstance().minutes().add(expected, -12);//        expected = ISOChronology.getInstance().seconds().add(expected, -14);//        expected = ISOChronology.getInstance().millis().add(expected, -16);//        //        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());//        MutableDateTime mdt = new MutableDateTime();//        test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it//        assertEquals(expected, mdt.getMillis());//    }//    //    public void testAddIntoRWI3() {//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);//        try {//            test.addInto(null, 1);//            fail();//        } catch (IllegalArgumentException ex) {}//    }        //-----------------------------------------------------------------------    public void testToString() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString());                test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 0);        assertEquals("PT0S", test.toString());                test = new MutablePeriod(12345L);        assertEquals("PT12.345S", test.toString());    }    //-----------------------------------------------------------------------    public void testToPeriod() {        MutablePeriod test = new MutablePeriod(123L);        Period result = test.toPeriod();        assertEquals(test, result);    }    public void testToMutablePeriod() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod result = test.toMutablePeriod();        assertEquals(test, result);    }    //-----------------------------------------------------------------------//    public void testToDurationMillisFrom() {//        MutablePeriod test = new MutablePeriod(123L);//        assertEquals(123L, test.toDurationMillisFrom(0L, null));//    }    public void testToDurationFrom() {        MutablePeriod test = new MutablePeriod(123L);        assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L)));    }    //-----------------------------------------------------------------------    public void testCopy() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod copy = test.copy();        assertEquals(test.getPeriodType(), copy.getPeriodType());        assertEquals(test, copy);    }    //-----------------------------------------------------------------------    public void testClone() {        MutablePeriod test = new MutablePeriod(123L);        MutablePeriod copy = (MutablePeriod) test.clone();        assertEquals(test.getPeriodType(), copy.getPeriodType());        assertEquals(test, copy);    }    }
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.Calendar;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.List;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.DateTimeComparator class. * * @author Guy Allard */public class TestDateTimeComparator extends TestCase {    private static final Chronology ISO = ISOChronology.getInstance();        public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeComparator.class);    }    public TestDateTimeComparator(String name) {        super(name);    }    /**     * A reference to a DateTime object.     */    DateTime aDateTime = null;    /**     * A reference to a DateTime object.     */    DateTime bDateTime = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for millis of seconds.     */    Comparator cMillis = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for seconds.     */    Comparator cSecond = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for minutes.     */    Comparator cMinute = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for hours.     */    Comparator cHour = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the week.     */    Comparator cDayOfWeek = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the month.     */    Comparator cDayOfMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the year.     */    Comparator cDayOfYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for week of the weekyear.     */    Comparator cWeekOfWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year given a week of the year.     */    Comparator cWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for months.     */    Comparator cMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year.     */    Comparator cYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the date portion of an     * object.     */    Comparator cDate = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the time portion of an     * object.     */    Comparator cTime = null;    /**     * Junit <code>setUp()</code> method.     */    public void setUp() /* throws Exception */ {        Chronology chrono = ISOChronology.getInstanceUTC();        // super.setUp();        // Obtain comparator's        cMillis = DateTimeComparator.getInstance(null, DateTimeFieldType.secondOfMinute());        cSecond = DateTimeComparator.getInstance(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.minuteOfHour());        cMinute = DateTimeComparator.getInstance(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.hourOfDay());        cHour = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());        cDayOfWeek = DateTimeComparator.getInstance(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.weekOfWeekyear());        cDayOfMonth = DateTimeComparator.getInstance(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear());        cDayOfYear = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), DateTimeFieldType.year());        cWeekOfWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekyear());        cWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekyear());        cMonth = DateTimeComparator.getInstance(DateTimeFieldType.monthOfYear(), DateTimeFieldType.year());        cYear = DateTimeComparator.getInstance(DateTimeFieldType.year());        cDate = DateTimeComparator.getDateOnlyInstance();        cTime = DateTimeComparator.getTimeOnlyInstance();    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();        aDateTime = null;        bDateTime = null;        //        cMillis = null;        cSecond = null;        cMinute = null;        cHour = null;        cDayOfWeek = null;        cDayOfMonth = null;        cDayOfYear = null;        cWeekOfWeekyear = null;        cWeekyear = null;        cMonth = null;        cYear = null;        cDate = null;        cTime = null;    }    //-----------------------------------------------------------------------    public void testClass() {        assertEquals(true, Modifier.isPublic(DateTimeComparator.class.getModifiers()));        assertEquals(false, Modifier.isFinal(DateTimeComparator.class.getModifiers()));        assertEquals(1, DateTimeComparator.class.getDeclaredConstructors().length);        assertEquals(true, Modifier.isProtected(DateTimeComparator.class.getDeclaredConstructors()[0].getModifiers()));    }        //-----------------------------------------------------------------------    public void testStaticGetInstance() {        DateTimeComparator c = DateTimeComparator.getInstance();        assertEquals(null, c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[]", c.toString());    }            public void testStaticGetDateOnlyInstance() {        DateTimeComparator c = DateTimeComparator.getDateOnlyInstance();        assertEquals(DateTimeFieldType.dayOfYear(), c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[dayOfYear-]", c.toString());                assertSame(DateTimeComparator.getDateOnlyInstance(), DateTimeComparator.getDateOnlyInstance());    }    public void testStaticGetTimeOnlyInstance() {        DateTimeComparator c = DateTimeComparator.getTimeOnlyInstance();        assertEquals(null, c.getLowerLimit());        assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit());        assertEquals("DateTimeComparator[-dayOfYear]", c.toString());                assertSame(DateTimeComparator.getTimeOnlyInstance(), DateTimeComparator.getTimeOnlyInstance());    }    public void testStaticGetInstanceLower() {        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay());        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());        assertEquals(null, c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay-]", c.toString());                c = DateTimeComparator.getInstance(null);        assertSame(DateTimeComparator.getInstance(), c);    }    public void testStaticGetInstanceLowerUpper() {        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());        assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay-dayOfYear]", c.toString());                c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfDay());        assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit());        assertEquals(DateTimeFieldType.hourOfDay(), c.getUpperLimit());        assertEquals("DateTimeComparator[hourOfDay]", c.toString());                c = DateTimeComparator.getInstance(null, null);        assertSame(DateTimeComparator.getInstance(), c);                c = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), null);        assertSame(DateTimeComparator.getDateOnlyInstance(), c);                c = DateTimeComparator.getInstance(null, DateTimeFieldType.dayOfYear());        assertSame(DateTimeComparator.getTimeOnlyInstance(), c);    }        //-----------------------------------------------------------------------    public void testEqualsHashCode() {        DateTimeComparator c1 = DateTimeComparator.getInstance();        assertEquals(true, c1.equals(c1));        assertEquals(false, c1.equals(null));        assertEquals(true, c1.hashCode() == c1.hashCode());                DateTimeComparator c2 = DateTimeComparator.getTimeOnlyInstance();        assertEquals(true, c2.equals(c2));        assertEquals(false, c2.equals(c1));        assertEquals(false, c1.equals(c2));        assertEquals(false, c2.equals(null));        assertEquals(false, c1.hashCode() == c2.hashCode());                DateTimeComparator c3 = DateTimeComparator.getTimeOnlyInstance();        assertEquals(true, c3.equals(c3));        assertEquals(false, c3.equals(c1));        assertEquals(true, c3.equals(c2));        assertEquals(false, c1.equals(c3));        assertEquals(true, c2.equals(c3));        assertEquals(false, c1.hashCode() == c3.hashCode());        assertEquals(true, c2.hashCode() == c3.hashCode());                DateTimeComparator c4 = DateTimeComparator.getDateOnlyInstance();        assertEquals(false, c4.hashCode() == c3.hashCode());    }        //-----------------------------------------------------------------------    public void testSerialization1() throws Exception {        DateTimeField f = ISO.dayOfYear();        f.toString();        DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(c);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeComparator result = (DateTimeComparator) ois.readObject();        ois.close();                assertEquals(c, result);    }    //-----------------------------------------------------------------------    public void testSerialization2() throws Exception {        DateTimeComparator c = DateTimeComparator.getInstance();                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(c);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeComparator result = (DateTimeComparator) ois.readObject();        ois.close();                assertSame(c, result);    }    //-----------------------------------------------------------------------    /**     * Test all basic comparator operation with DateTime objects.     */    public void testBasicComps1() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with ReadableInstant objects.     */    public void testBasicComps2() {        ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with java Date objects.     */    public void testBasicComps3() {        Date aDateTime            = new Date( System.currentTimeMillis() );        Date bDateTime            = new Date( aDateTime.getTime() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Long objects.     */    public void testBasicComps4() {        Long aDateTime            = new Long( System.currentTimeMillis() );        Long bDateTime            = new Long( aDateTime.longValue() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Calendar objects.     */    public void testBasicComps5() {        Calendar aDateTime            = Calendar.getInstance();   // right now        Calendar bDateTime = aDateTime;        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test unequal comparisons with millis of second comparators.     */    public void testMillis() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC );        assertEquals( "MillisM1", -1, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "MillisP1", 1, cMillis.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with second comparators.     */    public void testSecond() {        aDateTime = getADate( "1969-12-31T23:59:58" );        bDateTime = getADate( "1969-12-31T23:50:59" );        assertEquals( "SecondM1a", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1a", 1, cSecond.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:00:01" );        assertEquals( "SecondM1b", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1b", 1, cSecond.compare( bDateTime, aDateTime ) );    }   // end of testSecond    /**     * Test unequal comparisons with minute comparators.     */    public void testMinute() {        aDateTime = getADate( "1969-12-31T23:58:00" );        bDateTime = getADate( "1969-12-31T23:59:00" );        assertEquals( "MinuteM1a", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1a", 1, cMinute.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:01:00" );        assertEquals( "MinuteM1b", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1b", 1, cMinute.compare( bDateTime, aDateTime ) );    }   // end of testMinute    /**     * Test unequal comparisons with hour comparators.     */    public void testHour() {        aDateTime = getADate( "1969-12-31T22:00:00" );        bDateTime = getADate( "1969-12-31T23:00:00" );        assertEquals( "HourM1a", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1a", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T01:00:00" );        assertEquals( "HourM1b", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1b", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "HourP1c", 1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourM1c", -1, cHour.compare( bDateTime, aDateTime ) );    }   // end of testHour    /**     * Test unequal comparisons with day of week comparators.     */    public void testDOW() {        /*         * Dates chosen when I wrote the code, so I know what day of         * the week it is.         */        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOWM1a", -1, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOWP1a", 1, cDayOfWeek.compare( bDateTime, aDateTime ) );    }   // end of testDOW    /**     * Test unequal comparisons with day of month comparators.     */    public void testDOM() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOMM1a", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1a", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-12-01T00:00:00" );        bDateTime = getADate( "1814-04-30T00:00:00" );        assertEquals( "DOMM1b", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1b", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );    }   // end of testDOM    /**     * Test unequal comparisons with day of year comparators.     */    public void testDOY() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOYM1a", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1a", 1, cDayOfYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-02-29T00:00:00" );        bDateTime = getADate( "1814-11-30T00:00:00" );        assertEquals( "DOYM1b", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1b", 1, cDayOfYear.compare( bDateTime, aDateTime ) );    }   // end of testDOY    /**     * Test unequal comparisons with week of weekyear comparators.     */    public void testWOW() {        // 1st week of year contains Jan 04.        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "2000-01-11T00:00:00" );        assertEquals( "WOWM1a", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1a", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "1999-12-31T00:00:00" );        assertEquals( "WOWM1b", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1b", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with year given the week comparators.     */    public void testWOYY() {        // How do I test the end conditions of this?        // Don't understand ......        aDateTime = getADate( "1998-12-31T23:59:59" );        bDateTime = getADate( "1999-01-01T00:00:00" );        assertEquals( "YOYYZ", 0, cWeekyear.compare( aDateTime, bDateTime ) );        bDateTime = getADate( "1999-01-04T00:00:00" );        assertEquals( "YOYYM1", -1, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "YOYYP1", 1, cWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testWOYY    /**     * Test unequal comparisons with month comparators.     */    public void testMonth() {        aDateTime = getADate( "2002-04-30T00:00:00" );        bDateTime = getADate( "2002-05-01T00:00:00" );        assertEquals( "MONTHM1a", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1a", 1, cMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1900-01-01T00:00:00" );        bDateTime = getADate( "1899-12-31T00:00:00" );        assertEquals( "MONTHM1b", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1b", 1, cMonth.compare( bDateTime, aDateTime ) );    }   // end of testMonth    /**     * Test unequal comparisons with year comparators.     */    public void testYear() {        aDateTime = getADate( "2000-01-01T00:00:00" );        bDateTime = getADate( "2001-01-01T00:00:00" );        assertEquals( "YEARM1a", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1a", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1968-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1b", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1b", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1c", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1c", 1, cYear.compare( bDateTime, aDateTime ) );    }   // end of testYear    /*     * 'List' processing tests follow.     */     /**      * Test sorting with full default comparator.      */     public void testListBasic() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-01-20T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListBasic", !isSorted1, isSorted2);     } // end of testListBasic     /**      * Test sorting with millis of second comparator.      */    public void testListMillis() {        //        List sl = new ArrayList();        long base = 12345L * 1000L;        sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) );        //        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMillis );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListLillis", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with second comparator.      */    public void testListSecond() {        String[] dtStrs = {            "1999-02-01T00:00:10",            "1999-02-01T00:00:30",            "1999-02-01T00:00:25",            "1999-02-01T00:00:18",            "1999-02-01T00:00:01",            "1999-02-01T00:00:59",            "1999-02-01T00:00:22"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cSecond );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListSecond", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with minute comparator.      */    public void testListMinute() {        String[] dtStrs = {            "1999-02-01T00:10:00",            "1999-02-01T00:30:00",            "1999-02-01T00:25:00",            "1999-02-01T00:18:00",            "1999-02-01T00:01:00",            "1999-02-01T00:59:00",            "1999-02-01T00:22:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMinute );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMinute", !isSorted1, isSorted2);    } // end of testListMinute     /**      * Test sorting with hour comparator.      */    public void testListHour() {        String[] dtStrs = {            "1999-02-01T10:00:00",            "1999-02-01T23:00:00",            "1999-02-01T01:00:00",            "1999-02-01T15:00:00",            "1999-02-01T05:00:00",            "1999-02-01T20:00:00",            "1999-02-01T17:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cHour );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListHour", !isSorted1, isSorted2);    } // end of testListHour     /**      * Test sorting with day of week comparator.      */    public void testListDOW() {        String[] dtStrs = {            /* 2002-04-15 = Monday */            "2002-04-21T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-20T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfWeek );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOW", !isSorted1, isSorted2);    } // end of testListDOW     /**      * Test sorting with day of month comparator.      */    public void testListDOM() {        String[] dtStrs = {            /* 2002-04-14 = Sunday */            "2002-04-20T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-14T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOM", !isSorted1, isSorted2);    } // end of testListDOM     /**      * Test sorting with day of year comparator.      */    public void testListDOY() {        String[] dtStrs = {            "2002-04-20T10:00:00",            "2002-01-16T10:00:00",            "2002-12-31T10:00:00",            "2002-09-14T10:00:00",            "2002-09-19T10:00:00",            "2002-02-14T10:00:00",            "2002-10-30T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOY", !isSorted1, isSorted2);    } // end of testListDOY     /**      * Test sorting with week of weekyear comparator.      */    public void testListWOW() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekOfWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListWOW", !isSorted1, isSorted2);    } // end of testListWOW     /**      * Test sorting with year (given week) comparator.      */    public void testListYOYY() {        // ?? How to catch end conditions ??        String[] dtStrs = {            "2010-04-01T10:00:00",            "2002-01-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYOYY", !isSorted1, isSorted2);    } // end of testListYOYY     /**      * Test sorting with month comparator.      */    public void testListMonth() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMonth", !isSorted1, isSorted2);    } // end of testListMonth     /**      * Test sorting with year comparator.      */     public void testListYear() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-02-01T00:00:00",            "2525-02-01T00:00:00",            "1776-02-01T00:00:00",            "1863-02-01T00:00:00",            "1066-02-01T00:00:00",            "2100-02-01T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYear", !isSorted1, isSorted2);     } // end of testListYear     /**      * Test sorting with date only comparator.      */    public void testListDate() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-10-03T00:00:00",            "2525-05-20T00:00:00",            "1776-12-25T00:00:00",            "1863-01-31T00:00:00",            "1066-09-22T00:00:00",            "2100-07-04T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDate );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDate", !isSorted1, isSorted2);    } // end of testListDate     /**      * Test sorting with time only comparator.      */    public void testListTime() {        String[] dtStrs = {            "1999-02-01T01:02:05",            "1999-02-01T22:22:22",            "1999-02-01T05:30:45",            "1999-02-01T09:17:59",            "1999-02-01T09:17:58",            "1999-02-01T15:30:00",            "1999-02-01T17:00:44"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cTime );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListTime", !isSorted1, isSorted2);    } // end of testListTime    /**     * Test comparator operation with null object(s).     */    public void testNullDT() {        // null means now        aDateTime = getADate("2000-01-01T00:00:00");        assertTrue(cYear.compare(null, aDateTime) > 0);        assertTrue(cYear.compare(aDateTime, null) < 0);    }    /**     * Test comparator operation with an invalid object type.     */    public void testInvalidObj() {        aDateTime = getADate("2000-01-01T00:00:00");        try {            cYear.compare("FreeBird", aDateTime);            fail("Invalid object failed");        } catch (IllegalArgumentException cce) {}    }    // private convenience methods    //-----------------------------------------------------------------------    /**     * Creates a date to test with.     */    private DateTime getADate(String s) {        DateTime retDT = null;        try {            retDT = new DateTime(s, DateTimeZone.UTC);        } catch (IllegalArgumentException pe) {            pe.printStackTrace();        }        return retDT;    }    /**     * Load a string array.     */    private List loadAList(String[] someStrs) {        List newList = new ArrayList();        try {            for (int i = 0; i < someStrs.length; ++i) {                newList.add(new DateTime(someStrs[i], DateTimeZone.UTC));            } // end of the for        } catch (IllegalArgumentException pe) {            pe.printStackTrace();        }        return newList;    }    /**     * Check if the list is sorted.     */    private boolean isListSorted(List tl) {        // tl must be populated with DateTime objects.        DateTime lhDT = (DateTime)tl.get(0);        DateTime rhDT = null;        Long lhVal = new Long( lhDT.getMillis() );        Long rhVal = null;        for (int i = 1; i < tl.size(); ++i) {            rhDT = (DateTime)tl.get(i);            rhVal = new Long( rhDT.getMillis() );            if ( lhVal.compareTo( rhVal) > 0 ) return false;            //            lhVal = rhVal;  // swap for next iteration            lhDT = rhDT;    // swap for next iteration        }        return true;    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.IntervalConverter;/** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */public class TestMutableInterval_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Constructors.class);    }    public TestMutableInterval_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testConstructor() throws Throwable {        MutableInterval test = new MutableInterval();        assertEquals(0L, test.getStartMillis());        assertEquals(0L, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt1.getMillis());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    public void testConstructor_long_long3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new MutableInterval(dt1.getMillis(), dt2.getMillis());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), GJChronology.getInstance());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(GJChronology.getInstance(), test.getChronology());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0));        Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1));        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1, (ReadableInstant) null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval((ReadableInstant) null, dt2);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI6() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        MutableInterval test = new MutableInterval(dt1, dt1);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt1.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RI7() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            new MutableInterval(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RI_RI8() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, GJChronology.getInstance());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(GJChronology.getInstance(), test.getChronology());    }    public void testConstructor_RI_RI9() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, GJChronology.getInstance());        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RP1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, 6);        result = ISOChronology.getInstanceUTC().days().add(result, 3);        result = ISOChronology.getInstanceUTC().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, ISOChronology.getInstanceUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, 6);        result = ISOChronology.getInstanceUTC().days().add(result, 3);        result = ISOChronology.getInstanceUTC().hours().add(result, 1);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, 1);        result = ISOChronology.getInstance().millis().add(result, 23);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP5() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadablePeriod) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RP6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval(dt, (ReadablePeriod) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RP7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                MutableInterval test = new MutableInterval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RP8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new MutableInterval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RI1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI2() throws Throwable {        Instant dt = new Instant(new DateTime(TEST_TIME_NOW));        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, -6);        result = ISOChronology.getInstanceUTC().days().add(result, -3);        result = ISOChronology.getInstanceUTC().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, ISOChronology.getInstanceUTC());        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());        long result = TEST_TIME_NOW;        result = ISOChronology.getInstanceUTC().months().add(result, -6);        result = ISOChronology.getInstanceUTC().days().add(result, -3);        result = ISOChronology.getInstanceUTC().hours().add(result, -1);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI4() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().hours().add(result, -1);        result = ISOChronology.getInstance().millis().add(result, -23);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI5() throws Throwable {        MutableInterval test = new MutableInterval((ReadablePeriod) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI6() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval((ReadablePeriod) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RP_RI7() throws Throwable {        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                MutableInterval test = new MutableInterval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RP_RI8() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1);        try {            new MutableInterval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, 6);        result = ISOChronology.getInstance().hours().add(result, 1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(result - TEST_TIME_NOW);                MutableInterval test = new MutableInterval(dt, dur);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableDuration) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RI_RD3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval(dt, (ReadableDuration) null);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RI_RD4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, 6);        result = ISOChronology.getInstance().hourOfDay().add(result, 1);                Duration dur = new Duration(result - TEST_TIME_NOW);                MutableInterval test = new MutableInterval((ReadableInstant) null, dur);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(result, test.getEndMillis());    }    public void testConstructor_RI_RD5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new MutableInterval(dt, dur);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI1() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().months().add(result, -6);        result = ISOChronology.getInstance().hours().add(result, -1);                DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(TEST_TIME_NOW - result);                MutableInterval test = new MutableInterval(dur, dt);        assertEquals(result, test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI2() throws Throwable {        MutableInterval test = new MutableInterval((ReadableDuration) null, (ReadableInstant) null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI3() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        MutableInterval test = new MutableInterval((ReadableDuration) null, dt);        assertEquals(dt.getMillis(), test.getStartMillis());        assertEquals(dt.getMillis(), test.getEndMillis());    }    public void testConstructor_RD_RI4() throws Throwable {        long result = TEST_TIME_NOW;        result = ISOChronology.getInstance().monthOfYear().add(result, -6);        result = ISOChronology.getInstance().hourOfDay().add(result, -1);                Duration dur = new Duration(TEST_TIME_NOW - result);                MutableInterval test = new MutableInterval(dur, (ReadableInstant) null);        assertEquals(result, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testConstructor_RD_RI5() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW);        Duration dur = new Duration(-1);        try {            new MutableInterval(dur, dt);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_Object1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutableInterval base = new MutableInterval(dt1, dt2);                MutableInterval test = new MutableInterval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                MutableInterval test = new MutableInterval(base);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());    }    public void testConstructor_Object4() throws Throwable {        MockInterval base = new MockInterval();        MutableInterval test = new MutableInterval(base);        assertEquals(base.getStartMillis(), test.getStartMillis());        assertEquals(base.getEndMillis(), test.getEndMillis());    }    public void testConstructor_Object5() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter("");        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return String.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);            DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);            MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString());            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    public void testConstructor_Object6() throws Throwable {        IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new MutableInterval(0L, 0L));        IntervalConverter conv = new IntervalConverter() {            public boolean isReadableInterval(Object object, Chronology chrono) {                return false;            }            public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {                interval.setChronology(chrono);                interval.setInterval(1234L, 5678L);            }            public Class getSupportedType() {                return ReadableInterval.class;            }        };        try {            ConverterManager.getInstance().addIntervalConverter(conv);            Interval base = new Interval(-1000L, 1000L);            MutableInterval test = new MutableInterval(base);            assertEquals(1234L, test.getStartMillis());            assertEquals(5678L, test.getEndMillis());        } finally {            ConverterManager.getInstance().addIntervalConverter(oldConv);        }    }    class MockInterval implements ReadableInterval {        public Chronology getChronology() {            return ISOChronology.getInstance();        }        public long getStartMillis() {            return 1234L;        }        public DateTime getStart() {            return new DateTime(1234L);        }        public long getEndMillis() {            return 5678L;        }        public DateTime getEnd() {            return new DateTime(5678L);        }        public long toDurationMillis() {            return (5678L - 1234L);        }        public Duration toDuration() {            return new Duration(5678L - 1234L);        }        public boolean contains(long millisInstant) {            return false;        }        public boolean containsNow() {            return false;        }        public boolean contains(ReadableInstant instant) {            return false;        }        public boolean contains(ReadableInterval interval) {            return false;        }        public boolean overlaps(ReadableInterval interval) {            return false;        }        public boolean isBefore(ReadableInstant instant) {            return false;        }        public boolean isBefore(ReadableInterval interval) {            return false;        }        public boolean isAfter(ReadableInstant instant) {            return false;        }        public boolean isAfter(ReadableInterval interval) {            return false;        }        public Interval toInterval() {            return null;        }        public MutableInterval toMutableInterval() {            return null;        }        public Period toPeriod() {            return null;        }        public Period toPeriod(PeriodType type) {            return null;        }    }    //-----------------------------------------------------------------------    public void testConstructor_Object_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                MutableInterval test = new MutableInterval(base, BuddhistChronology.getInstance());        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(BuddhistChronology.getInstance(), test.getChronology());    }    public void testConstructor_Object_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);                MutableInterval test = new MutableInterval(base, null);        assertEquals(dt1.getMillis(), test.getStartMillis());        assertEquals(dt2.getMillis(), test.getEndMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.BasePartial;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestBasePartial extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBasePartial.class);    }    public TestBasePartial(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(DateTimeZone.UTC);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testSetMethods() throws Throwable {        MockPartial mock = new MockPartial();        assertEquals(1970, mock.getYear());        assertEquals(1, mock.getMonthOfYear());                mock.setYear(2004);        assertEquals(2004, mock.getYear());        assertEquals(1, mock.getMonthOfYear());                mock.setMonthOfYear(6);        assertEquals(2004, mock.getYear());        assertEquals(6, mock.getMonthOfYear());                mock.set(2005, 5);        assertEquals(2005, mock.getYear());        assertEquals(5, mock.getMonthOfYear());                try {            mock.setMonthOfYear(0);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(2005, mock.getYear());        assertEquals(5, mock.getMonthOfYear());                try {            mock.setMonthOfYear(13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(2005, mock.getYear());        assertEquals(5, mock.getMonthOfYear());    }    static class MockPartial extends BasePartial {                MockPartial() {            super(new int[] {1970, 1}, null);        }        protected DateTimeField getField(int index, Chronology chrono) {            switch (index) {                case 0:                    return chrono.year();                case 1:                    return chrono.monthOfYear();                default:                    throw new IndexOutOfBoundsException();            }        }        public int size() {            return 2;        }                public int getYear() {            return getValue(0);        }                public void setYear(int year) {            setValue(0, year);        }                public int getMonthOfYear() {            return getValue(1);        }                public void setMonthOfYear(int month) {            setValue(1, month);        }                public void set(int year, int month) {            setValues(new int[] {year, month});        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Sets extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Sets.class);    }    public TestMutableDateTime_Sets(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testSetMillis_long1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setMillis(TEST_TIME2);        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetChronology_Chronology1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setChronology(GregorianChronology.getInstance(PARIS));        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), test.getChronology());    }            public void testSetChronology_Chronology2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setChronology(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSetZone_DateTimeZone1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZone(PARIS);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());    }            public void testSetZone_DateTimeZone2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZone(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }            //-----------------------------------------------------------------------    public void testSetZoneRetainFields_DateTimeZone1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZoneRetainFields(PARIS);        assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.setZoneRetainFields(null);        assertEquals(TEST_TIME1, test.getMillis());        assertEquals(ISOChronology.getInstance(), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone3() {        MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        test.setZoneRetainFields(null);        assertEquals(TEST_TIME1 + DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertEquals(GregorianChronology.getInstance(), test.getChronology());    }            public void testSetZoneRetainFields_DateTimeZone4() {        Chronology chrono = new MockNullZoneChronology();        MutableDateTime test = new MutableDateTime(TEST_TIME1, chrono);        test.setZoneRetainFields(PARIS);        assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        assertSame(chrono, test.getChronology());    }            //-----------------------------------------------------------------------    public void testSetMillis_RI1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1, BuddhistChronology.getInstance());        test.setMillis(new Instant(TEST_TIME2));        assertEquals(TEST_TIME2, test.getMillis());        assertEquals(BuddhistChronology.getInstance(), test.getChronology());    }    public void testSetMillis_RI2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1, BuddhistChronology.getInstance());        test.setMillis(null);        assertEquals(TEST_TIME_NOW, test.getMillis());        assertEquals(BuddhistChronology.getInstance(), test.getChronology());    }    //-----------------------------------------------------------------------    public void testSet_DateTimeFieldType_int1() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        test.set(DateTimeFieldType.year(), 2010);        assertEquals(2010, test.getYear());    }    public void testSet_DateTimeFieldType_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.set(null, 0);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    public void testSet_DateTimeFieldType_int3() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.set(DateTimeFieldType.monthOfYear(), 13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetDate_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(2010, 12, 3);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    public void testSetDate_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setDate(2010, 13, 3);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetDate_long1() {        long setter = new DateTime(2010, 12, 3, 5, 7, 9, 501).getMillis();        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(setter);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetDate_RI1() {        DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 501);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDate(setter);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    public void testSetDate_RI2() {        MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501);        test.setDate(null);  // sets to TEST_TIME_NOW        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(12, test.getHourOfDay());        assertEquals(24, test.getMinuteOfHour());        assertEquals(48, test.getSecondOfMinute());        assertEquals(501, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetTime_int_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(5, 6, 7, 8);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    public void testSetTime_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setTime(60, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetTime_long1() {        long setter = new DateTime(2010, 12, 3, 5, 7, 9, 11).getMillis();        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetTime_RI1() {        DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 11);        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    public void testSetTime_RI2() {        MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501);        test.setTime(null);  // sets to TEST_TIME_NOW, which has no time part        assertEquals(2010, test.getYear());        assertEquals(7, test.getMonthOfYear());        assertEquals(8, test.getDayOfMonth());        assertEquals(new DateTime(TEST_TIME_NOW).getHourOfDay(), test.getHourOfDay());        assertEquals(new DateTime(TEST_TIME_NOW).getMinuteOfHour(), test.getMinuteOfHour());        assertEquals(new DateTime(TEST_TIME_NOW).getSecondOfMinute(), test.getSecondOfMinute());        assertEquals(new DateTime(TEST_TIME_NOW).getMillisOfSecond(), test.getMillisOfSecond());    }    public void testSetTime_Object3() {        DateTime temp = new DateTime(2010, 12, 3, 5, 7, 9, 11);        DateTime setter = new DateTime(temp.getMillis(), new MockNullZoneChronology());        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setTime(setter);        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(7, test.getMinuteOfHour());        assertEquals(9, test.getSecondOfMinute());        assertEquals(11, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    public void testSetDateTime_int_int_int_int_int_int_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);        test.setDateTime(2010, 12, 3, 5, 6, 7, 8);        assertEquals(2010, test.getYear());        assertEquals(12, test.getMonthOfYear());        assertEquals(3, test.getDayOfMonth());        assertEquals(5, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }        public void testSetDateTime_int_int_int_int_int_int_int2() {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        try {            test.setDateTime(2010, 13, 3, 5, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {        }        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setYear(2010);        assertEquals("2010-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMonthOfYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMonthOfYear(12);        assertEquals("2002-12-09T05:06:07.008Z", test.toString());    }    public void testSetMonthOfYear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMonthOfYear(13);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfMonth_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfMonth(17);        assertEquals("2002-06-17T05:06:07.008+01:00", test.toString());    }    public void testSetDayOfMonth_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfMonth(31);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfYear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfYear(3);        assertEquals("2002-01-03T05:06:07.008Z", test.toString());    }    public void testSetDayOfYear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfYear(366);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetWeekyear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setWeekyear(2001);        assertEquals("2001-06-10T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetWeekOfWeekyear_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setWeekOfWeekyear(2);        assertEquals("2002-01-13T05:06:07.008Z", test.toString());    }    public void testSetWeekOfWeekyear_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setWeekOfWeekyear(53);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetDayOfWeek_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setDayOfWeek(5);        assertEquals("2002-06-07T05:06:07.008+01:00", test.toString());    }    public void testSetDayOfWeek_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setDayOfWeek(8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetHourOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setHourOfDay(13);        assertEquals("2002-06-09T13:06:07.008+01:00", test.toString());    }    public void testSetHourOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setHourOfDay(24);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMinuteOfHour_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMinuteOfHour(13);        assertEquals("2002-06-09T05:13:07.008+01:00", test.toString());    }    public void testSetMinuteOfHour_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMinuteOfHour(60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMinuteOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMinuteOfDay(13);        assertEquals("2002-06-09T00:13:07.008+01:00", test.toString());    }    public void testSetMinuteOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMinuteOfDay(24 * 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetSecondOfMinute_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setSecondOfMinute(13);        assertEquals("2002-06-09T05:06:13.008+01:00", test.toString());    }    public void testSetSecondOfMinute_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setSecondOfMinute(60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetSecondOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setSecondOfDay(13);        assertEquals("2002-06-09T00:00:13.008+01:00", test.toString());    }    public void testSetSecondOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setSecondOfDay(24 * 60 * 60);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMilliOfSecond_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMillisOfSecond(13);        assertEquals("2002-06-09T05:06:07.013+01:00", test.toString());    }    public void testSetMilliOfSecond_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMillisOfSecond(1000);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testSetMilliOfDay_int1() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        test.setMillisOfDay(13);        assertEquals("2002-06-09T00:00:00.013+01:00", test.toString());    }    public void testSetMilliOfDay_int2() {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);        try {            test.setMillisOfDay(24 * 60 * 60 * 1000);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import org.joda.time.chrono.ISOChronology;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DurationField. * * @author Stephen Colebourne */public class TestDurationField extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDurationField.class);    }    public TestDurationField(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_subtract() throws Exception {        DurationField fld = ISOChronology.getInstanceUTC().millis();        assertEquals(900, fld.subtract(1000L, 100));        assertEquals(900L, fld.subtract(1000L, 100L));        assertEquals((1000L - Integer.MAX_VALUE), fld.subtract(1000L, Integer.MAX_VALUE));        assertEquals((1000L - Integer.MIN_VALUE), fld.subtract(1000L, Integer.MIN_VALUE));        assertEquals((1000L - Long.MAX_VALUE), fld.subtract(1000L, Long.MAX_VALUE));        try {            fld.subtract(-1000L, Long.MIN_VALUE);            fail();        } catch (ArithmeticException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestYearMonthDay_Basics extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final int OFFSET = 1;    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);    private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);    private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);    private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestYearMonthDay_Basics.class);    }    public TestYearMonthDay_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testGet() {        YearMonthDay test = new YearMonthDay();        assertEquals(1970, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(DateTimeFieldType.hourOfDay());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSize() {        YearMonthDay test = new YearMonthDay();        assertEquals(3, test.size());    }    public void testGetFieldType() {        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);        assertSame(DateTimeFieldType.year(), test.getFieldType(0));        assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1));        assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2));        try {            test.getFieldType(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getFieldType(3);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldTypes() {        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);        DateTimeFieldType[] fields = test.getFieldTypes();        assertSame(DateTimeFieldType.year(), fields[0]);        assertSame(DateTimeFieldType.monthOfYear(), fields[1]);        assertSame(DateTimeFieldType.dayOfMonth(), fields[2]);        assertNotSame(test.getFieldTypes(), test.getFieldTypes());    }    public void testGetField() {        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);        assertSame(COPTIC_UTC.year(), test.getField(0));        assertSame(COPTIC_UTC.monthOfYear(), test.getField(1));        assertSame(COPTIC_UTC.dayOfMonth(), test.getField(2));        try {            test.getField(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getField(3);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFields() {        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);        DateTimeField[] fields = test.getFields();        assertSame(COPTIC_UTC.year(), fields[0]);        assertSame(COPTIC_UTC.monthOfYear(), fields[1]);        assertSame(COPTIC_UTC.dayOfMonth(), fields[2]);        assertNotSame(test.getFields(), test.getFields());    }    public void testGetValue() {        YearMonthDay test = new YearMonthDay();        assertEquals(1970, test.getValue(0));        assertEquals(6, test.getValue(1));        assertEquals(9, test.getValue(2));        try {            test.getValue(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getValue(3);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetValues() {        YearMonthDay test = new YearMonthDay();        int[] values = test.getValues();        assertEquals(1970, values[0]);        assertEquals(6, values[1]);        assertEquals(9, values[2]);        assertNotSame(test.getValues(), test.getValues());    }    public void testIsSupported() {        YearMonthDay test = new YearMonthDay(COPTIC_PARIS);        assertEquals(true, test.isSupported(DateTimeFieldType.year()));        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));        assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay()));    }    public void testEqualsHashCode() {        YearMonthDay test1 = new YearMonthDay(1970, 6, 9, COPTIC_PARIS);        YearMonthDay test2 = new YearMonthDay(1970, 6, 9, COPTIC_PARIS);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                YearMonthDay test3 = new YearMonthDay(1971, 6, 9);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));    }        class MockInstant extends MockPartial {        public Chronology getChronology() {            return COPTIC_UTC;        }        public DateTimeField[] getFields() {            return new DateTimeField[] {                COPTIC_UTC.year(),                COPTIC_UTC.monthOfYear(),                COPTIC_UTC.dayOfMonth(),            };        }        public int[] getValues() {            return new int[] {1970, 6, 9};        }    }    //-----------------------------------------------------------------------    public void testCompareTo() {        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                YearMonthDay test2 = new YearMonthDay(2005, 7, 2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.year(),            DateTimeFieldType.monthOfYear(),            DateTimeFieldType.dayOfMonth(),        };        int[] values = new int[] {2005, 6, 2};        Partial p = new Partial(types, values);        assertEquals(0, test1.compareTo(p));        try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}        try {            test1.compareTo(new TimeOfDay());            fail();        } catch (ClassCastException ex) {}        Partial partial = new Partial()            .with(DateTimeFieldType.centuryOfEra(), 1)            .with(DateTimeFieldType.halfdayOfDay(), 0)            .with(DateTimeFieldType.dayOfMonth(), 9);        try {            new YearMonthDay(1970, 6, 9).compareTo(partial);            fail();        } catch (ClassCastException ex) {}    }        //-----------------------------------------------------------------------    public void testIsEqual_YMD() {        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                YearMonthDay test2 = new YearMonthDay(2005, 7, 2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                try {            new YearMonthDay(2005, 7, 2).isEqual(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testIsBefore_YMD() {        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                YearMonthDay test2 = new YearMonthDay(2005, 7, 2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                try {            new YearMonthDay(2005, 7, 2).isBefore(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testIsAfter_YMD() {        YearMonthDay test1 = new YearMonthDay(2005, 6, 2);        YearMonthDay test1a = new YearMonthDay(2005, 6, 2);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                YearMonthDay test2 = new YearMonthDay(2005, 7, 2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                try {            new YearMonthDay(2005, 7, 2).isAfter(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testWithChronologyRetainFields_Chrono() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);        YearMonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);        check(base, 2005, 6, 9);        assertEquals(COPTIC_UTC, base.getChronology());        check(test, 2005, 6, 9);        assertEquals(BUDDHIST_UTC, test.getChronology());    }    public void testWithChronologyRetainFields_sameChrono() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);        YearMonthDay test = base.withChronologyRetainFields(COPTIC_TOKYO);        assertSame(base, test);    }    public void testWithChronologyRetainFields_nullChrono() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);        YearMonthDay test = base.withChronologyRetainFields(null);        check(base, 2005, 6, 9);        assertEquals(COPTIC_UTC, base.getChronology());        check(test, 2005, 6, 9);        assertEquals(ISO_UTC, test.getChronology());    }    public void testWithChronologyRetainFields_invalidInNewChrono() {        YearMonthDay base = new YearMonthDay(2005, 1, 31, ISO_UTC);        try {            base.withChronologyRetainFields(COPTIC_UTC);            fail();        } catch (IllegalArgumentException ex) {            // expected        }    }    //-----------------------------------------------------------------------    public void testWithField1() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        YearMonthDay result = test.withField(DateTimeFieldType.year(), 2006);                assertEquals(new YearMonthDay(2004, 6, 9), test);        assertEquals(new YearMonthDay(2006, 6, 9), result);    }    public void testWithField2() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        try {            test.withField(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithField3() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        try {            test.withField(DateTimeFieldType.hourOfDay(), 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithField4() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        YearMonthDay result = test.withField(DateTimeFieldType.year(), 2004);        assertEquals(new YearMonthDay(2004, 6, 9), test);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        YearMonthDay result = test.withFieldAdded(DurationFieldType.years(), 6);                assertEquals(new YearMonthDay(2004, 6, 9), test);        assertEquals(new YearMonthDay(2010, 6, 9), result);    }    public void testWithFieldAdded2() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        try {            test.withFieldAdded(null, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded3() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        try {            test.withFieldAdded(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded4() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        YearMonthDay result = test.withFieldAdded(DurationFieldType.years(), 0);        assertSame(test, result);    }    public void testWithFieldAdded5() {        YearMonthDay test = new YearMonthDay(2004, 6, 9);        try {            test.withFieldAdded(DurationFieldType.hours(), 6);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPlus_RP() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));        YearMonthDay expected = new YearMonthDay(2003, 7, 7, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadablePeriod) null);        assertSame(test, result);    }    public void testPlusYears_int() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.plusYears(1);        YearMonthDay expected = new YearMonthDay(2003, 5, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusYears(0);        assertSame(test, result);    }    public void testPlusMonths_int() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.plusMonths(1);        YearMonthDay expected = new YearMonthDay(2002, 6, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusMonths(0);        assertSame(test, result);    }    public void testPlusDays_int() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.plusDays(1);        YearMonthDay expected = new YearMonthDay(2002, 5, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusDays(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMinus_RP() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));        YearMonthDay expected = new YearMonthDay(2001, 4, 2, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadablePeriod) null);        assertSame(test, result);    }    public void testMinusYears_int() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.minusYears(1);        YearMonthDay expected = new YearMonthDay(2001, 5, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusYears(0);        assertSame(test, result);    }    public void testMinusMonths_int() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.minusMonths(1);        YearMonthDay expected = new YearMonthDay(2002, 4, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusMonths(0);        assertSame(test, result);    }    public void testMinusDays_int() {        YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());        YearMonthDay result = test.minusDays(1);        YearMonthDay expected = new YearMonthDay(2002, 5, 2, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusDays(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testToDateTimeAtMidnight() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);                DateTime test = base.toDateTimeAtMidnight();        check(base, 2005, 6, 9);        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);    }    //-----------------------------------------------------------------------    public void testToDateTimeAtMidnight_Zone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);                DateTime test = base.toDateTimeAtMidnight(TOKYO);        check(base, 2005, 6, 9);        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test);    }    public void testToDateTimeAtMidnight_nullZone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);                DateTime test = base.toDateTimeAtMidnight((DateTimeZone) null);        check(base, 2005, 6, 9);        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);    }    //-----------------------------------------------------------------------    public void testToDateTimeAtCurrentTime() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());                DateTime test = base.toDateTimeAtCurrentTime();        check(base, 2005, 6, 9);        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);        expected = expected.year().setCopy(2005);        expected = expected.monthOfYear().setCopy(6);        expected = expected.dayOfMonth().setCopy(9);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToDateTimeAtCurrentTime_Zone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());                DateTime test = base.toDateTimeAtCurrentTime(TOKYO);        check(base, 2005, 6, 9);        DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);        expected = expected.year().setCopy(2005);        expected = expected.monthOfYear().setCopy(6);        expected = expected.dayOfMonth().setCopy(9);        assertEquals(expected, test);    }    public void testToDateTimeAtCurrentTime_nullZone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());                DateTime test = base.toDateTimeAtCurrentTime((DateTimeZone) null);        check(base, 2005, 6, 9);        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);        expected = expected.year().setCopy(2005);        expected = expected.monthOfYear().setCopy(6);        expected = expected.dayOfMonth().setCopy(9);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToDateTime_TOD() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);                DateTime test = base.toDateTime(tod);        check(base, 2005, 6, 9);        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);        assertEquals(expected, test);    }    public void testToDateTime_nullTOD() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_LONDON).getMillis();        DateTimeUtils.setCurrentMillisFixed(now);                DateTime test = base.toDateTime((TimeOfDay) null);        check(base, 2005, 6, 9);        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToDateTime_TOD_Zone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);                DateTime test = base.toDateTime(tod, TOKYO);        check(base, 2005, 6, 9);        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);        assertEquals(expected, test);    }    public void testToDateTime_TOD_nullZone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);                DateTime test = base.toDateTime(tod, null);        check(base, 2005, 6, 9);        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);        assertEquals(expected, test);    }    public void testToDateTime_nullTOD_Zone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_TOKYO).getMillis();        DateTimeUtils.setCurrentMillisFixed(now);                DateTime test = base.toDateTime((TimeOfDay) null, TOKYO);        check(base, 2005, 6, 9);        DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToDateMidnight() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);                DateMidnight test = base.toDateMidnight();        check(base, 2005, 6, 9);        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);    }    //-----------------------------------------------------------------------    public void testToDateMidnight_Zone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);                DateMidnight test = base.toDateMidnight(TOKYO);        check(base, 2005, 6, 9);        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test);    }    public void testToDateMidnight_nullZone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);                DateMidnight test = base.toDateMidnight((DateTimeZone) null);        check(base, 2005, 6, 9);        assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);    }    //-----------------------------------------------------------------------    public void testToDateTime_RI() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);                DateTime test = base.toDateTime(dt);        check(base, 2005, 6, 9);        DateTime expected = dt;        expected = expected.year().setCopy(2005);        expected = expected.monthOfYear().setCopy(6);        expected = expected.dayOfMonth().setCopy(9);        assertEquals(expected, test);    }    public void testToDateTime_nullRI() {        YearMonthDay base = new YearMonthDay(2005, 6, 9);        DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());                DateTime test = base.toDateTime((ReadableInstant) null);        check(base, 2005, 6, 9);        DateTime expected = dt;        expected = expected.year().setCopy(2005);        expected = expected.monthOfYear().setCopy(6);        expected = expected.dayOfMonth().setCopy(9);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToInterval() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        Interval test = base.toInterval();        check(base, 2005, 6, 9);        DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT);        DateTime end = start.plus(Period.days(1));        Interval expected = new Interval(start, end);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToInterval_Zone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        Interval test = base.toInterval(TOKYO);        check(base, 2005, 6, 9);        DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT, TOKYO);        DateTime end = start.plus(Period.days(1));        Interval expected = new Interval(start, end);        assertEquals(expected, test);    }    public void testToInterval_nullZone() {        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant        Interval test = base.toInterval(null);        check(base, 2005, 6, 9);        DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT, LONDON);        DateTime end = start.plus(Period.days(1));        Interval expected = new Interval(start, end);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testProperty() {        YearMonthDay test = new YearMonthDay(2005, 6, 9);        assertEquals(test.year(), test.property(DateTimeFieldType.year()));        assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));        assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));        try {            test.property(DateTimeFieldType.millisOfDay());            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        YearMonthDay test = new YearMonthDay(1972, 6, 9, COPTIC_PARIS);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        YearMonthDay result = (YearMonthDay) ois.readObject();        ois.close();                assertEquals(test, result);        assertTrue(Arrays.equals(test.getValues(), result.getValues()));        assertTrue(Arrays.equals(test.getFields(), result.getFields()));        assertEquals(test.getChronology(), result.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        YearMonthDay test = new YearMonthDay(2002, 6, 9);        assertEquals("2002-06-09", test.toString());    }    //-----------------------------------------------------------------------    public void testToString_String() {        YearMonthDay test = new YearMonthDay(2002, 6, 9);        assertEquals("2002 \ufffd\ufffd", test.toString("yyyy HH"));        assertEquals("2002-06-09", test.toString((String) null));    }    //-----------------------------------------------------------------------    public void testToString_String_Locale() {        YearMonthDay test = new YearMonthDay(2002, 6, 9);        assertEquals("\ufffd 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("\ufffd 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09", test.toString(null, Locale.ENGLISH));        assertEquals("\ufffd 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToString_DTFormatter() {        YearMonthDay test = new YearMonthDay(2002, 6, 9);        assertEquals("2002 \ufffd\ufffd", test.toString(DateTimeFormat.forPattern("yyyy HH")));        assertEquals("2002-06-09", test.toString((DateTimeFormatter) null));    }    //-----------------------------------------------------------------------    private void check(YearMonthDay test, int hour, int min, int sec) {        assertEquals(hour, test.getYear());        assertEquals(min, test.getMonthOfYear());        assertEquals(sec, test.getDayOfMonth());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for Chronology. * * @author Stephen Colebourne */public class TestChronology extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestChronology.class);    }    public TestChronology(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetISO() {        assertEquals(ISOChronology.getInstance(), Chronology.getISO());    }    public void testGetISOUTC() {        assertEquals(ISOChronology.getInstanceUTC(), Chronology.getISOUTC());    }    public void testGetISO_Zone() {        assertEquals(ISOChronology.getInstance(PARIS), Chronology.getISO(PARIS));        assertEquals(ISOChronology.getInstance(), Chronology.getISO(null));    }    //-----------------------------------------------------------------------    public void testGetGJ() {        assertEquals(GJChronology.getInstance(), Chronology.getGJ());    }    public void testGetGJUTC() {        assertEquals(GJChronology.getInstanceUTC(), Chronology.getGJUTC());    }    public void testGetGJ_Zone() {        assertEquals(GJChronology.getInstance(PARIS), Chronology.getGJ(PARIS));        assertEquals(GJChronology.getInstance(), Chronology.getGJ(null));    }    //-----------------------------------------------------------------------    public void testGetGregorian() {        assertEquals(GregorianChronology.getInstance(), Chronology.getGregorian());    }    public void testGetGregorianUTC() {        assertEquals(GregorianChronology.getInstanceUTC(), Chronology.getGregorianUTC());    }    public void testGetGregorian_Zone() {        assertEquals(GregorianChronology.getInstance(PARIS), Chronology.getGregorian(PARIS));        assertEquals(GregorianChronology.getInstance(), Chronology.getGregorian(null));    }    //-----------------------------------------------------------------------    public void testGetJulian() {        assertEquals(JulianChronology.getInstance(), Chronology.getJulian());    }    public void testGetJulianUTC() {        assertEquals(JulianChronology.getInstanceUTC(), Chronology.getJulianUTC());    }    public void testGetJulian_Zone() {        assertEquals(JulianChronology.getInstance(PARIS), Chronology.getJulian(PARIS));        assertEquals(JulianChronology.getInstance(), Chronology.getJulian(null));    }    //-----------------------------------------------------------------------    public void testGetBuddhist() {        assertEquals(BuddhistChronology.getInstance(), Chronology.getBuddhist());    }    public void testGetBuddhistUTC() {        assertEquals(BuddhistChronology.getInstanceUTC(), Chronology.getBuddhistUTC());    }    public void testGetBuddhist_Zone() {        assertEquals(BuddhistChronology.getInstance(PARIS), Chronology.getBuddhist(PARIS));        assertEquals(BuddhistChronology.getInstance(), Chronology.getBuddhist(null));    }    //-----------------------------------------------------------------------    public void testGetCoptic() {        assertEquals(CopticChronology.getInstance(), Chronology.getCoptic());    }    public void testGetCopticUTC() {        assertEquals(CopticChronology.getInstanceUTC(), Chronology.getCopticUTC());    }    public void testGetCoptic_Zone() {        assertEquals(CopticChronology.getInstance(PARIS), Chronology.getCoptic(PARIS));        assertEquals(CopticChronology.getInstance(), Chronology.getCoptic(null));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInterval_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInterval_Basics.class);    }    public TestInterval_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getStart().getMillis());        assertEquals(TEST_TIME2, test.getEndMillis());        assertEquals(TEST_TIME2, test.getEnd().getMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME1);        assertSame(Duration.ZERO, test.toDuration());    }    public void testEqualsHashCode() {        Interval test1 = new Interval(TEST_TIME1, TEST_TIME2);        Interval test2 = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                Interval test3 = new Interval(TEST_TIME_NOW, TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                Interval test4 = new Interval(TEST_TIME1, TEST_TIME2, GJChronology.getInstance());        assertEquals(true, test4.equals(test4));        assertEquals(false, test1.equals(test4));        assertEquals(false, test2.equals(test4));        assertEquals(false, test4.equals(test1));        assertEquals(false, test4.equals(test2));        assertEquals(false, test1.hashCode() == test4.hashCode());        assertEquals(false, test2.hashCode() == test4.hashCode());                MutableInterval test5 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test5));        assertEquals(true, test2.equals(test5));        assertEquals(false, test3.equals(test5));        assertEquals(true, test5.equals(test1));        assertEquals(true, test5.equals(test2));        assertEquals(false, test5.equals(test3));        assertEquals(true, test1.hashCode() == test5.hashCode());        assertEquals(true, test2.hashCode() == test5.hashCode());        assertEquals(false, test3.hashCode() == test5.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInterval()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInterval extends AbstractInterval {        public MockInterval() {            super();        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }        public long getStartMillis() {            return TEST_TIME1;        }        public long getEndMillis() {            return TEST_TIME2;        }    }    //-----------------------------------------------------------------------    public void testContains_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(TEST_TIME1));        assertEquals(false, test.contains(TEST_TIME1 - 1));        assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2));        assertEquals(false, test.contains(TEST_TIME2));        assertEquals(true, test.contains(TEST_TIME2 - 1));    }    public void testContainsNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(true, test.containsNow());    }    public void testContains_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(new Instant(TEST_TIME1)));        assertEquals(false, test.contains(new Instant(TEST_TIME1 - 1)));        assertEquals(true, test.contains(new Instant(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2)));        assertEquals(false, test.contains(new Instant(TEST_TIME2)));        assertEquals(true, test.contains(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.contains((ReadableInstant) null));    }    //-----------------------------------------------------------------------    public void testContains_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1)));                assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));                assertEquals(true, test.contains((ReadableInterval) null));    }    public void testOverlaps_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));                assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));                assertEquals(true, test.overlaps((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testOverlap_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(                new Interval(TEST_TIME1, TEST_TIME2),                test.overlap(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(                new Interval(TEST_TIME1, TEST_TIME2),                test.overlap(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(                new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2),                test.overlap(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(                null,                test.overlap(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(                new Interval(TEST_TIME2 - 1, TEST_TIME2),                test.overlap(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(                new Interval(TEST_TIME1, TEST_TIME2),                test.overlap(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(                new Interval(TEST_TIME1, TEST_TIME2),                test.overlap(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(                new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2),                test.overlap(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(                null,                test.overlap(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(                new Interval(TEST_TIME2 - 1, TEST_TIME2),                test.overlap(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));                assertEquals(                null,                test.overlap(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1)));        assertEquals(                null,                test.overlap(new Interval(TEST_TIME1 - 1, TEST_TIME1)));        assertEquals(                new Interval(TEST_TIME1, TEST_TIME1 + 1),                test.overlap(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));                assertEquals(                new Interval(TEST_TIME_NOW, TEST_TIME_NOW),                test.overlap((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testGap_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(                new Interval(TEST_TIME2, TEST_TIME2 + 2),                test.gap(new Interval(TEST_TIME2 + 2, TEST_TIME2 + 4)));        assertEquals(                null,                test.gap(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(                new Interval(TEST_TIME1 - 2, TEST_TIME1),                test.gap(new Interval(TEST_TIME1 - 4, TEST_TIME1 - 2)));        assertEquals(                null,                test.gap(new Interval(TEST_TIME1 - 2, TEST_TIME1)));        assertEquals(                null,                test.gap(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(                null,                test.gap(new Interval(TEST_TIME1 + 1, TEST_TIME2 - 1)));    }    //-----------------------------------------------------------------------    public void testAbuts_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(                false,                test.abuts(new Interval(TEST_TIME2 + 2, TEST_TIME2 + 4)));        assertEquals(                true,                test.abuts(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(                false,                test.abuts(new Interval(TEST_TIME1 - 4, TEST_TIME1 - 2)));        assertEquals(                true,                test.abuts(new Interval(TEST_TIME1 - 2, TEST_TIME1)));        assertEquals(                false,                test.abuts(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(                false,                test.abuts(new Interval(TEST_TIME1 + 1, TEST_TIME2 - 1)));    }    //-----------------------------------------------------------------------    public void testIsBefore_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(TEST_TIME1 - 1));        assertEquals(false, test.isBefore(TEST_TIME1));        assertEquals(false, test.isBefore(TEST_TIME1 + 1));                assertEquals(false, test.isBefore(TEST_TIME2 - 1));        assertEquals(true, test.isBefore(TEST_TIME2));        assertEquals(true, test.isBefore(TEST_TIME2 + 1));    }    public void testIsBeforeNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(false, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(true, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 + 1);        assertEquals(true, test.isBeforeNow());    }    public void testIsBefore_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isBefore((ReadableInstant) null));    }    public void testIsBefore_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isBefore((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testIsAfter_long() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(TEST_TIME1 - 1));        assertEquals(false, test.isAfter(TEST_TIME1));        assertEquals(false, test.isAfter(TEST_TIME1 + 1));                assertEquals(false, test.isAfter(TEST_TIME2 - 1));        assertEquals(false, test.isAfter(TEST_TIME2));        assertEquals(false, test.isAfter(TEST_TIME2 + 1));    }    public void testIsAfterNow() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(true, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(false, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + 1);        assertEquals(false, test.isAfterNow());    }    public void testIsAfter_RI() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Instant(TEST_TIME2 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isAfter((ReadableInstant) null));    }    public void testIsAfter_RInterval() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isAfter((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testToInterval1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval result = test.toInterval();        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testToMutableInterval1() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        MutableInterval result = test.toMutableInterval();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToPeriod() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);        Interval base = new Interval(dt1, dt2);                Period test = base.toPeriod();        Period expected = new Period(dt1, dt2, PeriodType.standard());        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType1() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);        Interval base = new Interval(dt1, dt2);                Period test = base.toPeriod(null);        Period expected = new Period(dt1, dt2, PeriodType.standard());        assertEquals(expected, test);    }    public void testToPeriod_PeriodType2() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        Interval base = new Interval(dt1, dt2);                Period test = base.toPeriod(PeriodType.yearWeekDayTime());        Period expected = new Period(dt1, dt2, PeriodType.yearWeekDayTime());        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        Interval result = (Interval) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);        Interval test = new Interval(dt1, dt2);        assertEquals("2004-06-09T07:08:09.010/2005-08-13T12:14:16.018", test.toString());    }    //-----------------------------------------------------------------------    public void testWithChronology1() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withChronology(BuddhistChronology.getInstance());        assertEquals(new Interval(TEST_TIME1, TEST_TIME2, BuddhistChronology.getInstance()), test);    }    public void testWithChronology2() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withChronology(null);        assertEquals(new Interval(TEST_TIME1, TEST_TIME2, ISOChronology.getInstance()), test);    }    public void testWithChronology3() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withChronology(COPTIC_PARIS);        assertSame(base, test);    }    //-----------------------------------------------------------------------    public void testWithStartMillis_long1() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withStartMillis(TEST_TIME1 - 1);        assertEquals(new Interval(TEST_TIME1 - 1, TEST_TIME2, COPTIC_PARIS), test);    }    public void testWithStartMillis_long2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withStartMillis(TEST_TIME2 + 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithStartMillis_long3() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withStartMillis(TEST_TIME1);        assertSame(base, test);    }    //-----------------------------------------------------------------------    public void testWithStartInstant_RI1() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withStart(new Instant(TEST_TIME1 - 1));        assertEquals(new Interval(TEST_TIME1 - 1, TEST_TIME2, COPTIC_PARIS), test);    }    public void testWithStartInstant_RI2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withStart(new Instant(TEST_TIME2 + 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithStartInstant_RI3() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withStart(null);        assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS), test);    }    //-----------------------------------------------------------------------    public void testWithEndMillis_long1() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withEndMillis(TEST_TIME2 - 1);        assertEquals(new Interval(TEST_TIME1, TEST_TIME2 - 1, COPTIC_PARIS), test);    }    public void testWithEndMillis_long2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withEndMillis(TEST_TIME1 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithEndMillis_long3() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withEndMillis(TEST_TIME2);        assertSame(base, test);    }    //-----------------------------------------------------------------------    public void testWithEndInstant_RI1() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withEnd(new Instant(TEST_TIME2 - 1));        assertEquals(new Interval(TEST_TIME1, TEST_TIME2 - 1, COPTIC_PARIS), test);    }    public void testWithEndInstant_RI2() {        Interval test = new Interval(TEST_TIME1, TEST_TIME2);        try {            test.withEnd(new Instant(TEST_TIME1 - 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithEndInstant_RI3() {        Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withEnd(null);        assertEquals(new Interval(TEST_TIME1, TEST_TIME_NOW, COPTIC_PARIS), test);    }    //-----------------------------------------------------------------------    public void testWithDurationAfterStart1() throws Throwable {        Duration dur = new Duration(TEST_TIME2 - TEST_TIME_NOW);        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS);        Interval test = base.withDurationAfterStart(dur);                assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS), test);    }    public void testWithDurationAfterStart2() throws Throwable {        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withDurationAfterStart(null);                assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS), test);    }    public void testWithDurationAfterStart3() throws Throwable {        Duration dur = new Duration(-1);        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW);        try {            base.withDurationAfterStart(dur);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithDurationAfterStart4() throws Throwable {        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withDurationAfterStart(base.toDuration());                assertSame(base, test);    }    //-----------------------------------------------------------------------    public void testWithDurationBeforeEnd1() throws Throwable {        Duration dur = new Duration(TEST_TIME_NOW - TEST_TIME1);        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS);        Interval test = base.withDurationBeforeEnd(dur);                assertEquals(new Interval(TEST_TIME1, TEST_TIME_NOW, COPTIC_PARIS), test);    }    public void testWithDurationBeforeEnd2() throws Throwable {        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withDurationBeforeEnd(null);                assertEquals(new Interval(TEST_TIME2, TEST_TIME2, COPTIC_PARIS), test);    }    public void testWithDurationBeforeEnd3() throws Throwable {        Duration dur = new Duration(-1);        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW);        try {            base.withDurationBeforeEnd(dur);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithDurationBeforeEnd4() throws Throwable {        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withDurationBeforeEnd(base.toDuration());                assertSame(base, test);    }    //-----------------------------------------------------------------------    public void testWithPeriodAfterStart1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, COPTIC_PARIS);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);                Interval base = new Interval(dt, dt);        Interval test = base.withPeriodAfterStart(dur);        assertEquals(new Interval(dt, dur), test);    }    public void testWithPeriodAfterStart2() throws Throwable {        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withPeriodAfterStart(null);                assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS), test);    }    public void testWithPeriodAfterStart3() throws Throwable {        Period per = new Period(0, 0, 0, 0, 0, 0, 0, -1);        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW);        try {            base.withPeriodAfterStart(per);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testWithPeriodBeforeEnd1() throws Throwable {        DateTime dt = new DateTime(TEST_TIME_NOW, COPTIC_PARIS);        Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);                Interval base = new Interval(dt, dt);        Interval test = base.withPeriodBeforeEnd(dur);        assertEquals(new Interval(dur, dt), test);    }    public void testWithPeriodBeforeEnd2() throws Throwable {        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS);        Interval test = base.withPeriodBeforeEnd(null);                assertEquals(new Interval(TEST_TIME2, TEST_TIME2, COPTIC_PARIS), test);    }    public void testWithPeriodBeforeEnd3() throws Throwable {        Period per = new Period(0, 0, 0, 0, 0, 0, 0, -1);        Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW);        try {            base.withPeriodBeforeEnd(per);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */public class TestTimeOfDay_Properties extends TestCase {    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestTimeOfDay_Properties.class);    }    public TestTimeOfDay_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testPropertyGetHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertSame(test, test.hourOfDay().getReadablePartial());        assertSame(test, test.hourOfDay().getTimeOfDay());        assertEquals(10, test.hourOfDay().get());        assertEquals("10", test.hourOfDay().getAsString());        assertEquals("10", test.hourOfDay().getAsText());        assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("10", test.hourOfDay().getAsShortText());        assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.hourOfDay().getMinimumValue());        assertEquals(0, test.hourOfDay().getMinimumValueOverall());        assertEquals(23, test.hourOfDay().getMaximumValue());        assertEquals(23, test.hourOfDay().getMaximumValueOverall());    }    public void testPropertyAddHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.hourOfDay().addToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.hourOfDay().addToCopy(13);        check(copy, 23, 20, 30, 40);                copy = test.hourOfDay().addToCopy(14);        check(copy, 0, 20, 30, 40);                copy = test.hourOfDay().addToCopy(-10);        check(copy, 0, 20, 30, 40);                copy = test.hourOfDay().addToCopy(-11);        check(copy, 23, 20, 30, 40);    }    public void testPropertyAddNoWrapHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().addNoWrapToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.hourOfDay().addNoWrapToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.hourOfDay().addNoWrapToCopy(13);        check(copy, 23, 20, 30, 40);                try {            test.hourOfDay().addNoWrapToCopy(14);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.hourOfDay().addNoWrapToCopy(-10);        check(copy, 0, 20, 30, 40);                try {            test.hourOfDay().addNoWrapToCopy(-11);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 19, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(0);        check(copy, 10, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(18);        check(copy, 4, 20, 30, 40);                copy = test.hourOfDay().addWrapFieldToCopy(-15);        check(copy, 19, 20, 30, 40);    }    public void testPropertySetHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);                try {            test.hourOfDay().setCopy(24);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.hourOfDay().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 12, 20, 30, 40);    }    public void testPropertyWithMaximumValueHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().withMaximumValue();        check(test, 10, 20, 30, 40);        check(copy, 23, 20, 30, 40);    }    public void testPropertyWithMinimumValueHour() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.hourOfDay().withMinimumValue();        check(test, 10, 20, 30, 40);        check(copy, 0, 20, 30, 40);    }    public void testPropertyCompareToHour() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.hourOfDay().compareTo(test2) < 0);        assertEquals(true, test2.hourOfDay().compareTo(test1) > 0);        assertEquals(true, test1.hourOfDay().compareTo(test1) == 0);        try {            test1.hourOfDay().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0);        assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0);        assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0);        try {            test1.hourOfDay().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertSame(test, test.minuteOfHour().getReadablePartial());        assertSame(test, test.minuteOfHour().getTimeOfDay());        assertEquals(20, test.minuteOfHour().get());        assertEquals("20", test.minuteOfHour().getAsString());        assertEquals("20", test.minuteOfHour().getAsText());        assertEquals("20", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("20", test.minuteOfHour().getAsShortText());        assertEquals("20", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.minuteOfHour().getMinimumValue());        assertEquals(0, test.minuteOfHour().getMinimumValueOverall());        assertEquals(59, test.minuteOfHour().getMaximumValue());        assertEquals(59, test.minuteOfHour().getMaximumValueOverall());    }    public void testPropertyAddMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.minuteOfHour().addToCopy(39);        check(copy, 10, 59, 30, 40);                copy = test.minuteOfHour().addToCopy(40);        check(copy, 11, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(1 * 60 + 45);        check(copy, 12, 5, 30, 40);                copy = test.minuteOfHour().addToCopy(13 * 60 + 39);        check(copy, 23, 59, 30, 40);                copy = test.minuteOfHour().addToCopy(13 * 60 + 40);        check(copy, 0, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(-9);        check(copy, 10, 11, 30, 40);                copy = test.minuteOfHour().addToCopy(-19);        check(copy, 10, 1, 30, 40);                copy = test.minuteOfHour().addToCopy(-20);        check(copy, 10, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(-21);        check(copy, 9, 59, 30, 40);                copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20));        check(copy, 0, 0, 30, 40);                copy = test.minuteOfHour().addToCopy(-(10 * 60 + 21));        check(copy, 23, 59, 30, 40);    }    public void testPropertyAddNoWrapMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().addNoWrapToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(39);        check(copy, 10, 59, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(40);        check(copy, 11, 0, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(1 * 60 + 45);        check(copy, 12, 5, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(13 * 60 + 39);        check(copy, 23, 59, 30, 40);                try {            test.minuteOfHour().addNoWrapToCopy(13 * 60 + 40);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(-9);        check(copy, 10, 11, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(-19);        check(copy, 10, 1, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(-20);        check(copy, 10, 0, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(-21);        check(copy, 9, 59, 30, 40);                copy = test.minuteOfHour().addNoWrapToCopy(-(10 * 60 + 20));        check(copy, 0, 0, 30, 40);                try {            test.minuteOfHour().addNoWrapToCopy(-(10 * 60 + 21));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 29, 30, 40);                copy = test.minuteOfHour().addWrapFieldToCopy(49);        check(copy, 10, 9, 30, 40);                copy = test.minuteOfHour().addWrapFieldToCopy(-47);        check(copy, 10, 33, 30, 40);    }    public void testPropertySetMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);                try {            test.minuteOfHour().setCopy(60);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.minuteOfHour().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMinute() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.minuteOfHour().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 12, 30, 40);    }    public void testPropertyCompareToMinute() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0);        assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0);        assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0);        try {            test1.minuteOfHour().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0);        assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0);        assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0);        try {            test1.minuteOfHour().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertSame(test, test.secondOfMinute().getReadablePartial());        assertSame(test, test.secondOfMinute().getTimeOfDay());        assertEquals(30, test.secondOfMinute().get());        assertEquals("30", test.secondOfMinute().getAsString());        assertEquals("30", test.secondOfMinute().getAsText());        assertEquals("30", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("30", test.secondOfMinute().getAsShortText());        assertEquals("30", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.secondOfMinute().getMinimumValue());        assertEquals(0, test.secondOfMinute().getMinimumValueOverall());        assertEquals(59, test.secondOfMinute().getMaximumValue());        assertEquals(59, test.secondOfMinute().getMaximumValueOverall());    }    public void testPropertyAddSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 39, 40);                copy = test.secondOfMinute().addToCopy(29);        check(copy, 10, 20, 59, 40);                copy = test.secondOfMinute().addToCopy(30);        check(copy, 10, 21, 0, 40);                copy = test.secondOfMinute().addToCopy(39 * 60 + 29);        check(copy, 10, 59, 59, 40);                copy = test.secondOfMinute().addToCopy(39 * 60 + 30);        check(copy, 11, 0, 0, 40);                copy = test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30);        check(copy, 0, 0, 0, 40);                copy = test.secondOfMinute().addToCopy(-9);        check(copy, 10, 20, 21, 40);                copy = test.secondOfMinute().addToCopy(-30);        check(copy, 10, 20, 0, 40);                copy = test.secondOfMinute().addToCopy(-31);        check(copy, 10, 19, 59, 40);                copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30));        check(copy, 0, 0, 0, 40);                copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31));        check(copy, 23, 59, 59, 40);    }    public void testPropertyAddNoWrapSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().addNoWrapToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 39, 40);                copy = test.secondOfMinute().addNoWrapToCopy(29);        check(copy, 10, 20, 59, 40);                copy = test.secondOfMinute().addNoWrapToCopy(30);        check(copy, 10, 21, 0, 40);                copy = test.secondOfMinute().addNoWrapToCopy(39 * 60 + 29);        check(copy, 10, 59, 59, 40);                copy = test.secondOfMinute().addNoWrapToCopy(39 * 60 + 30);        check(copy, 11, 0, 0, 40);                try {            test.secondOfMinute().addNoWrapToCopy(13 * 60 * 60 + 39 * 60 + 30);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.secondOfMinute().addNoWrapToCopy(-9);        check(copy, 10, 20, 21, 40);                copy = test.secondOfMinute().addNoWrapToCopy(-30);        check(copy, 10, 20, 0, 40);                copy = test.secondOfMinute().addNoWrapToCopy(-31);        check(copy, 10, 19, 59, 40);                copy = test.secondOfMinute().addNoWrapToCopy(-(10 * 60 * 60 + 20 * 60 + 30));        check(copy, 0, 0, 0, 40);                try {            test.secondOfMinute().addNoWrapToCopy(-(10 * 60 * 60 + 20 * 60 + 31));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 39, 40);                copy = test.secondOfMinute().addWrapFieldToCopy(49);        check(copy, 10, 20, 19, 40);                copy = test.secondOfMinute().addWrapFieldToCopy(-47);        check(copy, 10, 20, 43, 40);    }    public void testPropertySetSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 12, 40);                try {            test.secondOfMinute().setCopy(60);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.secondOfMinute().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextSecond() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.secondOfMinute().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 12, 40);    }    public void testPropertyCompareToSecond() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0);        assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0);        assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0);        try {            test1.secondOfMinute().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0);        assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0);        assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0);        try {            test1.secondOfMinute().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testPropertyGetMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertSame(test, test.millisOfSecond().getReadablePartial());        assertSame(test, test.millisOfSecond().getTimeOfDay());        assertEquals(40, test.millisOfSecond().get());        assertEquals("40", test.millisOfSecond().getAsString());        assertEquals("40", test.millisOfSecond().getAsText());        assertEquals("40", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("40", test.millisOfSecond().getAsShortText());        assertEquals("40", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    public void testPropertyGetMaxMinValuesMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test.millisOfSecond().getMinimumValue());        assertEquals(0, test.millisOfSecond().getMinimumValueOverall());        assertEquals(999, test.millisOfSecond().getMaximumValue());        assertEquals(999, test.millisOfSecond().getMaximumValueOverall());    }    public void testPropertyAddMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().addToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 49);                copy = test.millisOfSecond().addToCopy(959);        check(copy, 10, 20, 30, 999);                copy = test.millisOfSecond().addToCopy(960);        check(copy, 10, 20, 31, 0);                copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);        check(copy, 23, 59, 59, 999);                copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);        check(copy, 0, 0, 0, 0);                copy = test.millisOfSecond().addToCopy(-9);        check(copy, 10, 20, 30, 31);                copy = test.millisOfSecond().addToCopy(-40);        check(copy, 10, 20, 30, 0);                copy = test.millisOfSecond().addToCopy(-41);        check(copy, 10, 20, 29, 999);                copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));        check(copy, 0, 0, 0, 0);                copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));        check(copy, 23, 59, 59, 999);    }    public void testPropertyAddNoWrapMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().addNoWrapToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 49);                copy = test.millisOfSecond().addNoWrapToCopy(959);        check(copy, 10, 20, 30, 999);                copy = test.millisOfSecond().addNoWrapToCopy(960);        check(copy, 10, 20, 31, 0);                copy = test.millisOfSecond().addNoWrapToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959);        check(copy, 23, 59, 59, 999);                try {            test.millisOfSecond().addNoWrapToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960);            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);                copy = test.millisOfSecond().addNoWrapToCopy(-9);        check(copy, 10, 20, 30, 31);                copy = test.millisOfSecond().addNoWrapToCopy(-40);        check(copy, 10, 20, 30, 0);                copy = test.millisOfSecond().addNoWrapToCopy(-41);        check(copy, 10, 20, 29, 999);                copy = test.millisOfSecond().addNoWrapToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40));        check(copy, 0, 0, 0, 0);                try {            test.millisOfSecond().addNoWrapToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41));            fail();        } catch (IllegalArgumentException ex) {}        check(test, 10, 20, 30, 40);    }    public void testPropertyAddWrapFieldMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().addWrapFieldToCopy(9);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 49);                copy = test.millisOfSecond().addWrapFieldToCopy(995);        check(copy, 10, 20, 30, 35);                copy = test.millisOfSecond().addWrapFieldToCopy(-47);        check(copy, 10, 20, 30, 993);    }    public void testPropertySetMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().setCopy(12);        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 12);                try {            test.millisOfSecond().setCopy(1000);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.millisOfSecond().setCopy(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testPropertySetTextMilli() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay copy = test.millisOfSecond().setCopy("12");        check(test, 10, 20, 30, 40);        check(copy, 10, 20, 30, 12);    }    public void testPropertyCompareToMilli() {        TimeOfDay test1 = new TimeOfDay(TEST_TIME1);        TimeOfDay test2 = new TimeOfDay(TEST_TIME2);        assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0);        assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0);        assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0);        try {            test1.millisOfSecond().compareTo((ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}                DateTime dt1 = new DateTime(TEST_TIME1);        DateTime dt2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0);        assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0);        assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0);        try {            test1.millisOfSecond().compareTo((ReadableInstant) null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {        assertEquals(hour, test.getHourOfDay());        assertEquals(min, test.getMinuteOfHour());        assertEquals(sec, test.getSecondOfMinute());        assertEquals(milli, test.getMillisOfSecond());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.TimeZone;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in Joda Time. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAllPackages extends TestCase {    public TestAllPackages(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(org.joda.time.TestAll.suite());        suite.addTest(org.joda.time.chrono.TestAll.suite());        suite.addTest(org.joda.time.chrono.gj.TestAll.suite());        suite.addTest(org.joda.time.convert.TestAll.suite());        suite.addTest(org.joda.time.field.TestAll.suite());        suite.addTest(org.joda.time.format.TestAll.suite());        suite.addTest(org.joda.time.tz.TestAll.suite());        return suite;    }    public static void main(String args[]) {        // setup a time zone other than one tester is in        TimeZone.setDefault(TimeZone.getTimeZone("Asia/Seoul"));                // run tests        String[] testCaseName = {            TestAllPackages.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.BaseChronology;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.field.UnsupportedDateTimeField;import org.joda.time.field.UnsupportedDurationField;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */public class TestDateTime_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTime_Basics.class);    }    public TestDateTime_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGet_DateTimeField() {        DateTime test = new DateTime();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get((DateTimeField) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGet_DateTimeFieldType() {        DateTime test = new DateTime();        assertEquals(1, test.get(DateTimeFieldType.era()));        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));        assertEquals(2002, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay()));        assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday()));        assertEquals(1, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(60, test.get(DateTimeFieldType.minuteOfDay()));        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay()));        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));        assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay()));        try {            test.get((DateTimeFieldType) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testIsSupported_DateTimeFieldType() {        DateTime test = new DateTime();        assertEquals(true, test.isSupported(DateTimeFieldType.era()));        assertEquals(true, test.isSupported(DateTimeFieldType.centuryOfEra()));        assertEquals(true, test.isSupported(DateTimeFieldType.yearOfCentury()));        assertEquals(true, test.isSupported(DateTimeFieldType.yearOfEra()));        assertEquals(true, test.isSupported(DateTimeFieldType.year()));        assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));        assertEquals(true, test.isSupported(DateTimeFieldType.weekyear()));        assertEquals(true, test.isSupported(DateTimeFieldType.weekOfWeekyear()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfWeek()));        assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));        assertEquals(true, test.isSupported(DateTimeFieldType.halfdayOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfHalfday()));        assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfHalfday()));        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute()));        assertEquals(true, test.isSupported(DateTimeFieldType.secondOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond()));        assertEquals(true, test.isSupported(DateTimeFieldType.millisOfDay()));        assertEquals(false, test.isSupported(null));    }    public void testGetMethods() {        DateTime test = new DateTime();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(1, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(60, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(60 * 60, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(60 * 60 * 1000, test.getMillisOfDay());    }    public void testEqualsHashCode() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test2 = new DateTime(TEST_TIME1);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                DateTime test3 = new DateTime(TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1, GregorianChronology.getInstance())));        assertEquals(true, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, new MockEqualsChronology())));        assertEquals(false, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, ISOChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    class MockEqualsChronology extends BaseChronology {        public boolean equals(Object obj) {            return obj instanceof MockEqualsChronology;        }        public DateTimeZone getZone() {            return null;        }        public Chronology withUTC() {            return this;        }        public Chronology withZone(DateTimeZone zone) {            return this;        }        public String toString() {            return "";        }    }    public void testCompareTo() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        //-----------------------------------------------------------------------    public void testIsEqual_long() {        assertEquals(false, new DateTime(TEST_TIME1).isEqual(TEST_TIME2));        assertEquals(true, new DateTime(TEST_TIME1).isEqual(TEST_TIME1));        assertEquals(false, new DateTime(TEST_TIME2).isEqual(TEST_TIME1));    }        public void testIsEqualNow() {        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqualNow());        assertEquals(true, new DateTime(TEST_TIME_NOW).isEqualNow());        assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqualNow());    }        public void testIsEqual_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqual(null));        assertEquals(true, new DateTime(TEST_TIME_NOW).isEqual(null));        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqual(null));    }        //-----------------------------------------------------------------------    public void testIsBefore_long() {        assertEquals(true, new DateTime(TEST_TIME1).isBefore(TEST_TIME2));        assertEquals(false, new DateTime(TEST_TIME1).isBefore(TEST_TIME1));        assertEquals(false, new DateTime(TEST_TIME2).isBefore(TEST_TIME1));    }        public void testIsBeforeNow() {        assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBeforeNow());        assertEquals(false, new DateTime(TEST_TIME_NOW).isBeforeNow());        assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBeforeNow());    }        public void testIsBefore_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBefore(null));        assertEquals(false, new DateTime(TEST_TIME_NOW).isBefore(null));        assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBefore(null));    }        //-----------------------------------------------------------------------    public void testIsAfter_long() {        assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME2));        assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME1));        assertEquals(true, new DateTime(TEST_TIME2).isAfter(TEST_TIME1));    }        public void testIsAfterNow() {        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfterNow());        assertEquals(false, new DateTime(TEST_TIME_NOW).isAfterNow());        assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfterNow());    }        public void testIsAfter_RI() {        DateTime test1 = new DateTime(TEST_TIME1);        DateTime test1a = new DateTime(TEST_TIME1);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                DateTime test2 = new DateTime(TEST_TIME2);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfter(null));        assertEquals(false, new DateTime(TEST_TIME_NOW).isAfter(null));        assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfter(null));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DateTime test = new DateTime(TEST_TIME_NOW);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTime result = (DateTime) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString());                test = new DateTime(TEST_TIME_NOW, PARIS);        assertEquals("2002-06-09T02:00:00.000+02:00", test.toString());    }    public void testToString_String() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("2002 01", test.toString("yyyy HH"));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString((String) null));    }    public void testToString_String_Locale() {        DateTime test = new DateTime(TEST_TIME_NOW);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));    }    public void testToString_DTFormatter() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW);        assertEquals("2002 00", test.toString(DateTimeFormat.forPattern("yyyy HH")));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((DateTimeFormatter) null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        DateTime test = new DateTime(TEST_TIME1);        Instant result = test.toInstant();        assertEquals(TEST_TIME1, result.getMillis());    }    public void testToDateTime() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime();        assertSame(test, result);    }    public void testToDateTimeISO() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTimeISO();        assertSame(test, result);                test = new DateTime(TEST_TIME1, ISOChronology.getInstance(PARIS));        result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);                test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);                test = new DateTime(TEST_TIME1, new MockNullZoneChronology());        result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        assertNotSame(test, result);    }    public void testToDateTime_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime(LONDON);        assertSame(test, result);        test = new DateTime(TEST_TIME1);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(PARIS, result.getZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateTime(TEST_TIME1);        result = test.toDateTime((DateTimeZone) null);        assertSame(test, result);    }    public void testToDateTime_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertSame(test, result);        test = new DateTime(TEST_TIME1);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toDateTime((Chronology) null);        assertSame(test, result);    }    public void testToMutableDateTime() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateTime(TEST_TIME1);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        DateTime test = new DateTime(TEST_TIME1);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        DateTime test = new DateTime(TEST_TIME1);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        DateTime test = new DateTime(TEST_TIME1);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateTime(TEST_TIME1, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    //-----------------------------------------------------------------------    public void testToDateMidnight() {        DateTime base = new DateTime(TEST_TIME1, CopticChronology.getInstance());        DateMidnight test = base.toDateMidnight();        assertEquals(new DateMidnight(base, CopticChronology.getInstance()), test);    }    public void testToYearMonthDay() {        DateTime base = new DateTime(TEST_TIME1, CopticChronology.getInstance());        YearMonthDay test = base.toYearMonthDay();        assertEquals(new YearMonthDay(TEST_TIME1, CopticChronology.getInstance()), test);    }    public void testToTimeOfDay() {        DateTime base = new DateTime(TEST_TIME1, CopticChronology.getInstance());        TimeOfDay test = base.toTimeOfDay();        assertEquals(new TimeOfDay(TEST_TIME1, CopticChronology.getInstance()), test);    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withMillis(TEST_TIME2);        assertEquals(TEST_TIME2, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withMillis(TEST_TIME1);        assertSame(test, result);    }    public void testWithChronology_Chronology() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withChronology(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withChronology(ISOChronology.getInstance());        assertSame(test, result);    }    public void testWithZone_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withZone(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withZone(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withZone(null);        assertSame(test, result);    }    public void testWithZoneRetainFields_DateTimeZone() {        DateTime test = new DateTime(TEST_TIME1);        DateTime result = test.withZoneRetainFields(PARIS);        assertEquals(test.getMillis() - DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateTime(TEST_TIME1);        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);                test = new DateTime(TEST_TIME1);        result = test.withZoneRetainFields(null);        assertSame(test, result);                test = new DateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS));        result = test.withZoneRetainFields(null);        assertEquals(test.getMillis() + DateTimeConstants.MILLIS_PER_HOUR, result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateTime(TEST_TIME1, new MockNullZoneChronology());        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);    }        //-----------------------------------------------------------------------    public void testWithDate_int_int_int() {        DateTime test = new DateTime(2002, 4, 5, 1, 2, 3, 4, ISOChronology.getInstanceUTC());        DateTime result = test.withDate(2003, 5, 6);        DateTime expected = new DateTime(2003, 5, 6, 1, 2, 3, 4, ISOChronology.getInstanceUTC());        assertEquals(expected, result);                test = new DateTime(TEST_TIME1);        try {            test.withDate(2003, 13, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testWithTime_int_int_int() {        DateTime test = new DateTime(TEST_TIME1 - 12345L, BuddhistChronology.getInstanceUTC());        DateTime result = test.withTime(12, 24, 0, 0);        assertEquals(TEST_TIME1, result.getMillis());        assertEquals(BuddhistChronology.getInstanceUTC(), result.getChronology());                test = new DateTime(TEST_TIME1);        try {            test.withTime(25, 1, 1, 1);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testWithFields_RPartial() {        DateTime test = new DateTime(2004, 5, 6, 7, 8, 9, 0);        DateTime result = test.withFields(new YearMonthDay(2003, 4, 5));        DateTime expected = new DateTime(2003, 4, 5, 7, 8, 9, 0);        assertEquals(expected, result);                test = new DateTime(TEST_TIME1);        result = test.withFields(null);        assertSame(test, result);    }        //-----------------------------------------------------------------------    public void testWithField1() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime result = test.withField(DateTimeFieldType.year(), 2006);                assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test);        assertEquals(new DateTime(2006, 6, 9, 0, 0, 0, 0), result);    }    public void testWithField2() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            test.withField(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime result = test.withFieldAdded(DurationFieldType.years(), 6);                assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test);        assertEquals(new DateTime(2010, 6, 9, 0, 0, 0, 0), result);    }    public void testWithFieldAdded2() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            test.withFieldAdded(null, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded3() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        try {            test.withFieldAdded(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded4() {        DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime result = test.withFieldAdded(DurationFieldType.years(), 0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long_int() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(123456789L, 1);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, 0);        assertSame(test, result);                result = test.withDurationAdded(123456789L, 2);        expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, -3);        expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_RD_int() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.withDurationAdded(new Duration(123456789L), 1);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(null, 1);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 0);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 2);        expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(new Duration(123456789L), -3);        expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_RP_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1);        DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(null, 1);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3);        expected = new DateTime(2005, 11, 15, 16, 20, 24, 28, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1);        expected = new DateTime(2001, 3, 2, 0, 0, 0, 0, BuddhistChronology.getInstance());        assertEquals(expected, result);    }    //-----------------------------------------------------------------------        public void testPlus_long() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.plus(123456789L);        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);    }        public void testPlus_RD() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.plus(new Duration(123456789L));        DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadableDuration) null);        assertSame(test, result);    }        public void testPlus_RP() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));        DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadablePeriod) null);        assertSame(test, result);    }    public void testPlusYears_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusYears(1);        DateTime expected = new DateTime(2003, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusYears(0);        assertSame(test, result);    }    public void testPlusMonths_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusMonths(1);        DateTime expected = new DateTime(2002, 6, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusMonths(0);        assertSame(test, result);    }    public void testPlusWeeks_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusWeeks(1);        DateTime expected = new DateTime(2002, 5, 10, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusWeeks(0);        assertSame(test, result);    }    public void testPlusDays_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusDays(1);        DateTime expected = new DateTime(2002, 5, 4, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusDays(0);        assertSame(test, result);    }    public void testPlusHours_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusHours(1);        DateTime expected = new DateTime(2002, 5, 3, 2, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusHours(0);        assertSame(test, result);    }    public void testPlusMinutes_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusMinutes(1);        DateTime expected = new DateTime(2002, 5, 3, 1, 3, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusMinutes(0);        assertSame(test, result);    }    public void testPlusSeconds_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusSeconds(1);        DateTime expected = new DateTime(2002, 5, 3, 1, 2, 4, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusSeconds(0);        assertSame(test, result);    }    public void testPlusMillis_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.plusMillis(1);        DateTime expected = new DateTime(2002, 5, 3, 1, 2, 3, 5, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusMillis(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------        public void testMinus_long() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.minus(123456789L);        DateTime expected = new DateTime(TEST_TIME1 - 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);    }        public void testMinus_RD() {        DateTime test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());        DateTime result = test.minus(new Duration(123456789L));        DateTime expected = new DateTime(TEST_TIME1 - 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadableDuration) null);        assertSame(test, result);    }        public void testMinus_RP() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));        DateTime expected = new DateTime(2001, 3, 26, 0, 1, 2, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadablePeriod) null);        assertSame(test, result);    }    public void testMinusYears_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusYears(1);        DateTime expected = new DateTime(2001, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusYears(0);        assertSame(test, result);    }    public void testMinusMonths_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusMonths(1);        DateTime expected = new DateTime(2002, 4, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusMonths(0);        assertSame(test, result);    }    public void testMinusWeeks_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusWeeks(1);        DateTime expected = new DateTime(2002, 4, 26, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusWeeks(0);        assertSame(test, result);    }    public void testMinusDays_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusDays(1);        DateTime expected = new DateTime(2002, 5, 2, 1, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusDays(0);        assertSame(test, result);    }    public void testMinusHours_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusHours(1);        DateTime expected = new DateTime(2002, 5, 3, 0, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusHours(0);        assertSame(test, result);    }    public void testMinusMinutes_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusMinutes(1);        DateTime expected = new DateTime(2002, 5, 3, 1, 1, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusMinutes(0);        assertSame(test, result);    }    public void testMinusSeconds_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusSeconds(1);        DateTime expected = new DateTime(2002, 5, 3, 1, 2, 2, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusSeconds(0);        assertSame(test, result);    }    public void testMinusMillis_int() {        DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BuddhistChronology.getInstance());        DateTime result = test.minusMillis(1);        DateTime expected = new DateTime(2002, 5, 3, 1, 2, 3, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusMillis(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testProperty() {        DateTime test = new DateTime();        assertEquals(test.year(), test.property(DateTimeFieldType.year()));        assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));        assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));        assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));        DateTimeFieldType bad = new DateTimeFieldType("bad") {            public DurationFieldType getDurationType() {                return DurationFieldType.weeks();            }            public DurationFieldType getRangeDurationType() {                return null;            }            public DateTimeField getField(Chronology chronology) {                return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType()));            }        };        try {            test.property(bad);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(null);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */public class TestPeriod_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriod_Constructors.class);    }    public TestPeriod_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testConstructor1() throws Throwable {        Period test = new Period();        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long2() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long3() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        Period test = new Period(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.millis());        assertEquals(PeriodType.millis(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(length, test.getMillis());    }    public void testConstructor_long_PeriodType3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType4() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, ISOChronology.getInstance());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, ISOChronology.getInstanceUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.time().withMillisRemoved(), ISOChronology.getInstance());        assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.standard(), ISOChronology.getInstanceUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, PeriodType.standard(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology4() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Period test = new Period(length, (PeriodType) null, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (4ints)     */    public void testConstructor_4int1() throws Throwable {        Period test = new Period(5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int1() throws Throwable {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int__PeriodType1() throws Throwable {        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType2() throws Throwable {        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType3() throws Throwable {        try {            new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testToPeriod_PeriodType3() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.yearWeekDayTime());                assertEquals(PeriodType.yearWeekDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());  // tests using years and not weekyears        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());        Period test = new Period(dt1.getMillis(), dt2.getMillis(), CopticChronology.getInstance());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, CopticChronology.getInstance());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(-3, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Period test = new Period(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Period test = new Period(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RP1() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2004, 6, 9);        YearMonthDay dt2 = new YearMonthDay(2005, 7, 10);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RP_RP2() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2004, 6, 9);        YearMonthDay dt2 = new YearMonthDay(2005, 5, 17);        Period test = new Period(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(11, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RP_RP3() throws Throwable {        YearMonthDay dt1 = null;        YearMonthDay dt2 = new YearMonthDay(2005, 7, 17);        try {            new Period(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP4() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2005, 7, 17);        YearMonthDay dt2 = null;        try {            new Period(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP5() throws Throwable {        YearMonthDay dt1 = null;        YearMonthDay dt2 = null;        try {            new Period(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP6() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2005, 7, 17);        TimeOfDay dt2 = new TimeOfDay(10, 20, 30, 40);        try {            new Period(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP7() throws Throwable {        Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.monthOfYear(), 12);        Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14);        try {            new Period(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP8() throws Throwable {        Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 12);        Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14);        try {            new Period(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RP_RP_PeriodType1() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2004, 6, 9);        YearMonthDay dt2 = new YearMonthDay(2005, 7, 10);        Period test = new Period(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RP_RP_PeriodType2() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2004, 6, 9);        YearMonthDay dt2 = new YearMonthDay(2005, 5, 17);        Period test = new Period(dt1, dt2, PeriodType.yearMonthDay());        assertEquals(PeriodType.yearMonthDay(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(11, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(8, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RP_RP_PeriodType3() throws Throwable {        YearMonthDay dt1 = null;        YearMonthDay dt2 = new YearMonthDay(2005, 7, 17);        try {            new Period(dt1, dt2, PeriodType.standard());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP_PeriodType4() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2005, 7, 17);        YearMonthDay dt2 = null;        try {            new Period(dt1, dt2);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP_PeriodType5() throws Throwable {        YearMonthDay dt1 = null;        YearMonthDay dt2 = null;        try {            new Period(dt1, dt2, PeriodType.standard());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP_PeriodType6() throws Throwable {        YearMonthDay dt1 = new YearMonthDay(2005, 7, 17);        TimeOfDay dt2 = new TimeOfDay(10, 20, 30, 40);        try {            new Period(dt1, dt2, PeriodType.standard());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP_PeriodType7() throws Throwable {        Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.monthOfYear(), 12);        Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14);        try {            new Period(dt1, dt2, PeriodType.standard());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor_RP_RP_PeriodType8() throws Throwable {        Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 12);        Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14);        try {            new Period(dt1, dt2, PeriodType.standard());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        Period test = new Period(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        Period test = new Period(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        Period test = new Period(dt1, dur, PeriodType.yearDayTime());        assertEquals(PeriodType.yearDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        Period test = new Period(dt1, dur, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        Period test = new Period(dur, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RD_RI2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        Period test = new Period(dur, dt1);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RD_RI_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        Period test = new Period(dur, dt2, PeriodType.yearDayTime());        assertEquals(PeriodType.yearDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RD_RI_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        Period test = new Period(dur, dt1, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        Period test = new Period("P1Y2M3D");        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object2() throws Throwable {        Period test = new Period((Object) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object3() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()));        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object4() throws Throwable {        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard());        Period test = new Period(base);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object_PeriodType1() throws Throwable {        Period test = new Period("P1Y2M3D", PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType2() throws Throwable {        Period test = new Period((Object) null, PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType3() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object_PeriodType4() throws Throwable {        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null);        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    //-----------------------------------------------------------------------    public void testFactoryYears() throws Throwable {        Period test = Period.years(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(6, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactoryMonths() throws Throwable {        Period test = Period.months(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(6, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactoryWeeks() throws Throwable {        Period test = Period.weeks(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(6, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactoryDays() throws Throwable {        Period test = Period.days(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(6, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactoryHours() throws Throwable {        Period test = Period.hours(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(6, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactoryMinutes() throws Throwable {        Period test = Period.minutes(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactorySeconds() throws Throwable {        Period test = Period.seconds(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(6, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactoryMillis() throws Throwable {        Period test = Period.millis(6);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(6, test.getMillis());    }    //-----------------------------------------------------------------------    public void testFactoryFieldDifference1() throws Throwable {        YearMonthDay start = new YearMonthDay(2005, 4, 9);        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.year(),            DateTimeFieldType.monthOfYear(),            DateTimeFieldType.dayOfMonth(),        };        Partial end = new Partial(types, new int[] {2004, 6, 7});        Period test = Period.fieldDifference(start, end);        assertEquals(PeriodType.yearMonthDay(), test.getPeriodType());        assertEquals(-1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(-2, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testFactoryFieldDifference2() throws Throwable {        YearMonthDay ymd = new YearMonthDay(2005, 4, 9);        try {            Period.fieldDifference(ymd, (ReadablePartial) null);            fail();        } catch (IllegalArgumentException ex) {}        try {            Period.fieldDifference((ReadablePartial) null, ymd);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFactoryFieldDifference3() throws Throwable {        YearMonthDay start = new YearMonthDay(2005, 4, 9);        TimeOfDay endTime = new TimeOfDay(12, 30, 40, 0);        try {            Period.fieldDifference(start, endTime);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFactoryFieldDifference4() throws Throwable {        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.year(),            DateTimeFieldType.monthOfYear(),            DateTimeFieldType.dayOfWeek(),        };        YearMonthDay start = new YearMonthDay(2005, 4, 9);        Partial end = new Partial(types, new int[] {1, 2, 3});        try {            Period.fieldDifference(start, end);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testFactoryFieldDifference5() throws Throwable {        DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.year(),            DateTimeFieldType.dayOfMonth(),            DateTimeFieldType.dayOfWeek(),        };        Partial start = new Partial(types, new int[] {1, 2, 3});        Partial end = new Partial(types, new int[] {1, 2, 3});        try {            Period.fieldDifference(start, end);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Arrays;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;/** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */public class TestTimeOfDay_Basics extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final int OFFSET = 1;    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);    private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);    private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);    private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestTimeOfDay_Basics.class);    }    public TestTimeOfDay_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testGet() {        TimeOfDay test = new TimeOfDay();        assertEquals(10 + OFFSET, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(30, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(40, test.get(DateTimeFieldType.millisOfSecond()));        try {            test.get(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.get(DateTimeFieldType.dayOfMonth());            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSize() {        TimeOfDay test = new TimeOfDay();        assertEquals(4, test.size());    }    public void testGetFieldType() {        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);        assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0));        assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1));        assertSame(DateTimeFieldType.secondOfMinute(), test.getFieldType(2));        assertSame(DateTimeFieldType.millisOfSecond(), test.getFieldType(3));        try {            test.getFieldType(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getFieldType(5);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFieldTypes() {        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);        DateTimeFieldType[] fields = test.getFieldTypes();        assertSame(DateTimeFieldType.hourOfDay(), fields[0]);        assertSame(DateTimeFieldType.minuteOfHour(), fields[1]);        assertSame(DateTimeFieldType.secondOfMinute(), fields[2]);        assertSame(DateTimeFieldType.millisOfSecond(), fields[3]);        assertNotSame(test.getFieldTypes(), test.getFieldTypes());    }    public void testGetField() {        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);        assertSame(CopticChronology.getInstanceUTC().hourOfDay(), test.getField(0));        assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), test.getField(1));        assertSame(CopticChronology.getInstanceUTC().secondOfMinute(), test.getField(2));        assertSame(CopticChronology.getInstanceUTC().millisOfSecond(), test.getField(3));        try {            test.getField(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getField(5);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetFields() {        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);        DateTimeField[] fields = test.getFields();        assertSame(CopticChronology.getInstanceUTC().hourOfDay(), fields[0]);        assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), fields[1]);        assertSame(CopticChronology.getInstanceUTC().secondOfMinute(), fields[2]);        assertSame(CopticChronology.getInstanceUTC().millisOfSecond(), fields[3]);        assertNotSame(test.getFields(), test.getFields());    }    public void testGetValue() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        assertEquals(10, test.getValue(0));        assertEquals(20, test.getValue(1));        assertEquals(30, test.getValue(2));        assertEquals(40, test.getValue(3));        try {            test.getValue(-1);        } catch (IndexOutOfBoundsException ex) {}        try {            test.getValue(5);        } catch (IndexOutOfBoundsException ex) {}    }    public void testGetValues() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        int[] values = test.getValues();        assertEquals(10, values[0]);        assertEquals(20, values[1]);        assertEquals(30, values[2]);        assertEquals(40, values[3]);        assertNotSame(test.getValues(), test.getValues());    }    public void testIsSupported() {        TimeOfDay test = new TimeOfDay(COPTIC_PARIS);        assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay()));        assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour()));        assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute()));        assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond()));        assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth()));    }    public void testEqualsHashCode() {        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                TimeOfDay test3 = new TimeOfDay(15, 20, 30, 40);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));    }    class MockInstant extends MockPartial {        public Chronology getChronology() {            return CopticChronology.getInstanceUTC();        }        public DateTimeField[] getFields() {            return new DateTimeField[] {                CopticChronology.getInstanceUTC().hourOfDay(),                CopticChronology.getInstanceUTC().minuteOfHour(),                CopticChronology.getInstanceUTC().secondOfMinute(),                CopticChronology.getInstanceUTC().millisOfSecond(),            };        }        public int[] getValues() {            return new int[] {10, 20, 30, 40};        }    }    //-----------------------------------------------------------------------    public void testCompareTo() {        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(0, test3.compareTo(test2));                DateTimeFieldType[] types = new DateTimeFieldType[] {            DateTimeFieldType.hourOfDay(),            DateTimeFieldType.minuteOfHour(),            DateTimeFieldType.secondOfMinute(),            DateTimeFieldType.millisOfSecond(),        };        int[] values = new int[] {10, 20, 30, 40};        Partial p = new Partial(types, values);        assertEquals(0, test1.compareTo(p));        try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }    //-----------------------------------------------------------------------    public void testIsEqual_TOD() {        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(true, test3.isEqual(test2));                try {            new TimeOfDay(10, 20, 35, 40).isEqual(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testIsBefore_TOD() {        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(false, test3.isBefore(test2));                try {            new TimeOfDay(10, 20, 35, 40).isBefore(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testIsAfter_TOD() {        TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);        TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));                try {            new TimeOfDay(10, 20, 35, 40).isAfter(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testWithChronologyRetainFields_Chrono() {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        TimeOfDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);        check(base, 10, 20, 30, 40);        assertEquals(COPTIC_UTC, base.getChronology());        check(test, 10, 20, 30, 40);        assertEquals(BUDDHIST_UTC, test.getChronology());    }    public void testWithChronologyRetainFields_sameChrono() {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        TimeOfDay test = base.withChronologyRetainFields(COPTIC_TOKYO);        assertSame(base, test);    }    public void testWithChronologyRetainFields_nullChrono() {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        TimeOfDay test = base.withChronologyRetainFields(null);        check(base, 10, 20, 30, 40);        assertEquals(COPTIC_UTC, base.getChronology());        check(test, 10, 20, 30, 40);        assertEquals(ISO_UTC, test.getChronology());    }    //-----------------------------------------------------------------------    public void testWithField1() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay result = test.withField(DateTimeFieldType.hourOfDay(), 15);                assertEquals(new TimeOfDay(10, 20, 30, 40), test);        assertEquals(new TimeOfDay(15, 20, 30, 40), result);    }    public void testWithField2() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        try {            test.withField(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithField3() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        try {            test.withField(DateTimeFieldType.dayOfMonth(), 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithField4() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay result = test.withField(DateTimeFieldType.hourOfDay(), 10);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay result = test.withFieldAdded(DurationFieldType.hours(), 6);                assertEquals(new TimeOfDay(10, 20, 30, 40), test);        assertEquals(new TimeOfDay(16, 20, 30, 40), result);    }    public void testWithFieldAdded2() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        try {            test.withFieldAdded(null, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded3() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        try {            test.withFieldAdded(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded4() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay result = test.withFieldAdded(DurationFieldType.hours(), 0);        assertSame(test, result);    }    public void testWithFieldAdded5() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        try {            test.withFieldAdded(DurationFieldType.days(), 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded6() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        TimeOfDay result = test.withFieldAdded(DurationFieldType.hours(), 16);                assertEquals(new TimeOfDay(10, 20, 30, 40), test);        assertEquals(new TimeOfDay(2, 20, 30, 40), result);    }    public void testWithFieldAdded7() {        TimeOfDay test = new TimeOfDay(23, 59, 59, 999);        TimeOfDay result = test.withFieldAdded(DurationFieldType.millis(), 1);        assertEquals(new TimeOfDay(0, 0, 0, 0), result);                test = new TimeOfDay(23, 59, 59, 999);        result = test.withFieldAdded(DurationFieldType.seconds(), 1);        assertEquals(new TimeOfDay(0, 0, 0, 999), result);                test = new TimeOfDay(23, 59, 59, 999);        result = test.withFieldAdded(DurationFieldType.minutes(), 1);        assertEquals(new TimeOfDay(0, 0, 59, 999), result);                test = new TimeOfDay(23, 59, 59, 999);        result = test.withFieldAdded(DurationFieldType.hours(), 1);        assertEquals(new TimeOfDay(0, 59, 59, 999), result);    }    public void testWithFieldAdded8() {        TimeOfDay test = new TimeOfDay(0, 0, 0, 0);        TimeOfDay result = test.withFieldAdded(DurationFieldType.millis(), -1);        assertEquals(new TimeOfDay(23, 59, 59, 999), result);                test = new TimeOfDay(0, 0, 0, 0);        result = test.withFieldAdded(DurationFieldType.seconds(), -1);        assertEquals(new TimeOfDay(23, 59, 59, 0), result);                test = new TimeOfDay(0, 0, 0, 0);        result = test.withFieldAdded(DurationFieldType.minutes(), -1);        assertEquals(new TimeOfDay(23, 59, 0, 0), result);                test = new TimeOfDay(0, 0, 0, 0);        result = test.withFieldAdded(DurationFieldType.hours(), -1);        assertEquals(new TimeOfDay(23, 0, 0, 0), result);    }    //-----------------------------------------------------------------------    public void testPlus_RP() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, BuddhistChronology.getInstance());        TimeOfDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));        TimeOfDay expected = new TimeOfDay(15, 26, 37, 48, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadablePeriod) null);        assertSame(test, result);    }    public void testPlusHours_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.plusHours(1);        TimeOfDay expected = new TimeOfDay(2, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusHours(0);        assertSame(test, result);    }    public void testPlusMinutes_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.plusMinutes(1);        TimeOfDay expected = new TimeOfDay(1, 3, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusMinutes(0);        assertSame(test, result);    }    public void testPlusSeconds_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.plusSeconds(1);        TimeOfDay expected = new TimeOfDay(1, 2, 4, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusSeconds(0);        assertSame(test, result);    }    public void testPlusMillis_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.plusMillis(1);        TimeOfDay expected = new TimeOfDay(1, 2, 3, 5, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusMillis(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testMinus_RP() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, BuddhistChronology.getInstance());        TimeOfDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));        TimeOfDay expected = new TimeOfDay(9, 19, 29, 39, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadablePeriod) null);        assertSame(test, result);    }    public void testMinusHours_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.minusHours(1);        TimeOfDay expected = new TimeOfDay(0, 2, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusHours(0);        assertSame(test, result);    }    public void testMinusMinutes_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.minusMinutes(1);        TimeOfDay expected = new TimeOfDay(1, 1, 3, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusMinutes(0);        assertSame(test, result);    }    public void testMinusSeconds_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.minusSeconds(1);        TimeOfDay expected = new TimeOfDay(1, 2, 2, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusSeconds(0);        assertSame(test, result);    }    public void testMinusMillis_int() {        TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance());        TimeOfDay result = test.minusMillis(1);        TimeOfDay expected = new TimeOfDay(1, 2, 3, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusMillis(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testToDateTimeToday() {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());                DateTime test = base.toDateTimeToday();        check(base, 10, 20, 30, 40);        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);        expected = expected.hourOfDay().setCopy(10);        expected = expected.minuteOfHour().setCopy(20);        expected = expected.secondOfMinute().setCopy(30);        expected = expected.millisOfSecond().setCopy(40);        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToDateTimeToday_Zone() {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());                DateTime test = base.toDateTimeToday(TOKYO);        check(base, 10, 20, 30, 40);        DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);        expected = expected.hourOfDay().setCopy(10);        expected = expected.minuteOfHour().setCopy(20);        expected = expected.secondOfMinute().setCopy(30);        expected = expected.millisOfSecond().setCopy(40);        assertEquals(expected, test);    }    public void testToDateTimeToday_nullZone() {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant        DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());                DateTime test = base.toDateTimeToday((DateTimeZone) null);        check(base, 10, 20, 30, 40);        DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);        expected = expected.hourOfDay().setCopy(10);        expected = expected.minuteOfHour().setCopy(20);        expected = expected.secondOfMinute().setCopy(30);        expected = expected.millisOfSecond().setCopy(40);        assertEquals(expected, test);    }    // Removed as too complex//    /**//     * Merges two partial together, taking account of the different chronologies.//     *//     * @param main  the main partial//     * @param base  the partial to use as a base to merge on top of//     * @param instant  the instant to start from and to use for missing fields//     * @return the merged instant//     *///    public long merge(ReadablePartial main, ReadablePartial base, long instant) {//        DateTimeZone zone = main.getChronology().getZone();//        instant = base.getChronology().withZone(zone).set(base, instant);//        return set(main, instant);//    }////    //-----------------------------------------------------------------------//    /**//     * Converts this object to a DateTime using a YearMonthDay to fill in the//     * missing fields and using the default time zone.//     * This instance is immutable and unaffected by this method call.//     * <p>//     * The resulting chronology is determined by the chronology of this//     * TimeOfDay plus the time zone.//     * <p>//     * This method makes use of the chronology of the specified YearMonthDay//     * in the calculation. This can be significant when mixing chronologies.//     * If the YearMonthDay is in the same chronology as this instance the//     * method will perform exactly as you might expect.//     * <p>//     * If the chronologies differ, then both this TimeOfDay and the YearMonthDay//     * are converted to the destination chronology and then merged. As a result//     * it may be the case that the year, monthOfYear and dayOfMonth fields on//     * the result are different from the values returned by the methods on the//     * YearMonthDay.//     * <p>//     * See {@link DateTime#withFields(ReadablePartial)} for an algorithm that//     * ignores the chronology.//     *//     * @param date  the date to use, null means today//     * @return the DateTime instance//     *///    public DateTime toDateTime(YearMonthDay date) {//        return toDateTime(date, null);//    }////    /**//     * Converts this object to a DateTime using a YearMonthDay to fill in the//     * missing fields.//     * This instance is immutable and unaffected by this method call.//     * <p>//     * The resulting chronology is determined by the chronology of this//     * TimeOfDay plus the time zone.//     * <p>//     * This method makes use of the chronology of the specified YearMonthDay//     * in the calculation. This can be significant when mixing chronologies.//     * If the YearMonthDay is in the same chronology as this instance the//     * method will perform exactly as you might expect.//     * <p>//     * If the chronologies differ, then both this TimeOfDay and the YearMonthDay//     * are converted to the destination chronology and then merged. As a result//     * it may be the case that the year, monthOfYear and dayOfMonth fields on//     * the result are different from the values returned by the methods on the//     * YearMonthDay.//     * <p>//     * See {@link DateTime#withFields(ReadablePartial)} for an algorithm that//     * ignores the chronology and just assigns the fields.//     *//     * @param date  the date to use, null means today//     * @param zone  the zone to get the DateTime in, null means default//     * @return the DateTime instance//     *///    public DateTime toDateTime(YearMonthDay date, DateTimeZone zone) {//        Chronology chrono = getChronology().withZone(zone);//        if (date == null) {//            DateTime dt = new DateTime(chrono);//            return dt.withFields(this);//        } else {//            long millis = chrono.merge(this, date, DateTimeUtils.currentTimeMillis());//            return new DateTime(millis, chrono);//        }//    }////    //-----------------------------------------------------------------------//    public void testToDateTime_YMD() {//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant//        YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_TOKYO);//        //        DateTime test = base.toDateTime(ymd);//        check(base, 10, 20, 30, 40);//        DateTime expected = new DateTime(ymd.toDateMidnight(LONDON), COPTIC_LONDON);//        expected = expected.hourOfDay().setCopy(10);//        expected = expected.minuteOfHour().setCopy(20);//        expected = expected.secondOfMinute().setCopy(30);//        expected = expected.millisOfSecond().setCopy(40);//        assertEquals(expected, test);//    }////    public void testToDateTime_nullYMD() {//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant//        //        DateTime test = base.toDateTime((YearMonthDay) null);//        check(base, 10, 20, 30, 40);//        DateTime expected = new DateTime(COPTIC_LONDON);//        expected = expected.hourOfDay().setCopy(10);//        expected = expected.minuteOfHour().setCopy(20);//        expected = expected.secondOfMinute().setCopy(30);//        expected = expected.millisOfSecond().setCopy(40);//        assertEquals(expected, test);//    }////    //-----------------------------------------------------------------------//    public void testToDateTime_YMD_Zone() {//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant//        YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_LONDON);//        //        DateTime test = base.toDateTime(ymd, TOKYO);//        check(base, 10, 20, 30, 40);//        DateTime expected = new DateTime(ymd.toDateMidnight(TOKYO), COPTIC_TOKYO);//        expected = expected.hourOfDay().setCopy(10);//        expected = expected.minuteOfHour().setCopy(20);//        expected = expected.secondOfMinute().setCopy(30);//        expected = expected.millisOfSecond().setCopy(40);//        assertEquals(expected, test);//    }////    public void testToDateTime_YMD_nullZone() {//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant//        YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_LONDON);//        //        DateTime test = base.toDateTime(ymd, null);//        check(base, 10, 20, 30, 40);//        DateTime expected = new DateTime(ymd.toDateMidnight(LONDON), COPTIC_LONDON);//        expected = expected.hourOfDay().setCopy(10);//        expected = expected.minuteOfHour().setCopy(20);//        expected = expected.secondOfMinute().setCopy(30);//        expected = expected.millisOfSecond().setCopy(40);//        assertEquals(expected, test);//    }////    public void testToDateTime_nullYMD_Zone() {//        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant//        //        DateTime test = base.toDateTime((YearMonthDay) null, TOKYO);//        check(base, 10, 20, 30, 40);//        DateTime expected = new DateTime(COPTIC_TOKYO);//        expected = expected.hourOfDay().setCopy(10);//        expected = expected.minuteOfHour().setCopy(20);//        expected = expected.secondOfMinute().setCopy(30);//        expected = expected.millisOfSecond().setCopy(40);//        assertEquals(expected, test);//    }    //-----------------------------------------------------------------------    public void testToDateTime_RI() {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);        DateTime dt = new DateTime(0L); // LONDON zone        assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString());                DateTime test = base.toDateTime(dt);        check(base, 10, 20, 30, 40);        assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString());        assertEquals("1970-01-01T10:20:30.040+01:00", test.toString());    }    public void testToDateTime_nullRI() {        TimeOfDay base = new TimeOfDay(1, 2, 3, 4);        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);                DateTime test = base.toDateTime((ReadableInstant) null);        check(base, 1, 2, 3, 4);        assertEquals("1970-01-02T01:02:03.004+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testProperty() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay()));        assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()));        assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));        assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));        try {            test.property(DateTimeFieldType.millisOfDay());            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(null);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        TimeOfDay result = (TimeOfDay) ois.readObject();        ois.close();                assertEquals(test, result);        assertTrue(Arrays.equals(test.getValues(), result.getValues()));        assertTrue(Arrays.equals(test.getFields(), result.getFields()));        assertEquals(test.getChronology(), result.getChronology());    }    //-----------------------------------------------------------------------    public void testToString() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals("T10:20:30.040", test.toString());    }    //-----------------------------------------------------------------------    public void testToString_String() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString("yyyy HH"));        assertEquals("T10:20:30.040", test.toString((String) null));    }    //-----------------------------------------------------------------------    public void testToString_String_Locale() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals("10 20", test.toString("H m", Locale.ENGLISH));        assertEquals("T10:20:30.040", test.toString(null, Locale.ENGLISH));        assertEquals("10 20", test.toString("H m", null));        assertEquals("T10:20:30.040", test.toString(null, null));    }    //-----------------------------------------------------------------------    public void testToString_DTFormatter() {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString(DateTimeFormat.forPattern("yyyy HH")));        assertEquals("T10:20:30.040", test.toString((DateTimeFormatter) null));    }    //-----------------------------------------------------------------------    private void check(TimeOfDay test, int hour, int min, int sec, int milli) {        assertEquals(hour, test.getHourOfDay());        assertEquals(min, test.getMinuteOfHour());        assertEquals(sec, test.getSecondOfMinute());        assertEquals(milli, test.getMillisOfSecond());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.CopticChronology;/** * This class is a Junit unit test for Chronology. * * @author Stephen Colebourne */public class TestDateTimeFieldType extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeFieldType.class);    }    public TestDateTimeFieldType(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_era() throws Exception {        assertEquals(DateTimeFieldType.era(), DateTimeFieldType.era());        assertEquals("era", DateTimeFieldType.era().getName());        assertEquals(DurationFieldType.eras(), DateTimeFieldType.era().getDurationType());        assertEquals(null, DateTimeFieldType.era().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().era(), DateTimeFieldType.era().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().era().isSupported(), DateTimeFieldType.era().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.era());    }    public void test_centuryOfEra() throws Exception {        assertEquals(DateTimeFieldType.centuryOfEra(), DateTimeFieldType.centuryOfEra());        assertEquals("centuryOfEra", DateTimeFieldType.centuryOfEra().getName());        assertEquals(DurationFieldType.centuries(), DateTimeFieldType.centuryOfEra().getDurationType());        assertEquals(DurationFieldType.eras(), DateTimeFieldType.centuryOfEra().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().centuryOfEra(), DateTimeFieldType.centuryOfEra().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().centuryOfEra().isSupported(), DateTimeFieldType.centuryOfEra().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.centuryOfEra());    }    public void test_yearOfCentury() throws Exception {        assertEquals(DateTimeFieldType.yearOfCentury(), DateTimeFieldType.yearOfCentury());        assertEquals("yearOfCentury", DateTimeFieldType.yearOfCentury().getName());        assertEquals(DurationFieldType.years(), DateTimeFieldType.yearOfCentury().getDurationType());        assertEquals(DurationFieldType.centuries(), DateTimeFieldType.yearOfCentury().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().yearOfCentury(), DateTimeFieldType.yearOfCentury().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().yearOfCentury().isSupported(), DateTimeFieldType.yearOfCentury().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.yearOfCentury());    }    public void test_yearOfEra() throws Exception {        assertEquals(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfEra());        assertEquals("yearOfEra", DateTimeFieldType.yearOfEra().getName());        assertEquals(DurationFieldType.years(), DateTimeFieldType.yearOfEra().getDurationType());        assertEquals(DurationFieldType.eras(), DateTimeFieldType.yearOfEra().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().yearOfEra(), DateTimeFieldType.yearOfEra().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().yearOfEra().isSupported(), DateTimeFieldType.yearOfEra().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.yearOfEra());    }    public void test_year() throws Exception {        assertEquals(DateTimeFieldType.year(), DateTimeFieldType.year());        assertEquals("year", DateTimeFieldType.year().getName());        assertEquals(DurationFieldType.years(), DateTimeFieldType.year().getDurationType());        assertEquals(null, DateTimeFieldType.year().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().year(), DateTimeFieldType.year().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().year().isSupported(), DateTimeFieldType.year().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.year());    }    public void test_monthOfYear() throws Exception {        assertEquals(DateTimeFieldType.monthOfYear(), DateTimeFieldType.monthOfYear());        assertEquals("monthOfYear", DateTimeFieldType.monthOfYear().getName());        assertEquals(DurationFieldType.months(), DateTimeFieldType.monthOfYear().getDurationType());        assertEquals(DurationFieldType.years(), DateTimeFieldType.monthOfYear().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().monthOfYear(), DateTimeFieldType.monthOfYear().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().monthOfYear().isSupported(), DateTimeFieldType.monthOfYear().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.monthOfYear());    }    public void test_weekyearOfCentury() throws Exception {        assertEquals(DateTimeFieldType.weekyearOfCentury(), DateTimeFieldType.weekyearOfCentury());        assertEquals("weekyearOfCentury", DateTimeFieldType.weekyearOfCentury().getName());        assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekyearOfCentury().getDurationType());        assertEquals(DurationFieldType.centuries(), DateTimeFieldType.weekyearOfCentury().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().weekyearOfCentury(), DateTimeFieldType.weekyearOfCentury().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().weekyearOfCentury().isSupported(), DateTimeFieldType.weekyearOfCentury().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.weekyearOfCentury());    }    public void test_weekyear() throws Exception {        assertEquals(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyear());        assertEquals("weekyear", DateTimeFieldType.weekyear().getName());        assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekyear().getDurationType());        assertEquals(null, DateTimeFieldType.weekyear().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().weekyear(), DateTimeFieldType.weekyear().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().weekyear().isSupported(), DateTimeFieldType.weekyear().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.weekyear());    }    public void test_weekOfWeekyear() throws Exception {        assertEquals(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekOfWeekyear());        assertEquals("weekOfWeekyear", DateTimeFieldType.weekOfWeekyear().getName());        assertEquals(DurationFieldType.weeks(), DateTimeFieldType.weekOfWeekyear().getDurationType());        assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekOfWeekyear().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().weekOfWeekyear(), DateTimeFieldType.weekOfWeekyear().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().weekOfWeekyear().isSupported(), DateTimeFieldType.weekOfWeekyear().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.weekOfWeekyear());    }    public void test_dayOfYear() throws Exception {        assertEquals(DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfYear());        assertEquals("dayOfYear", DateTimeFieldType.dayOfYear().getName());        assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfYear().getDurationType());        assertEquals(DurationFieldType.years(), DateTimeFieldType.dayOfYear().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().dayOfYear(), DateTimeFieldType.dayOfYear().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().dayOfYear().isSupported(), DateTimeFieldType.dayOfYear().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.dayOfYear());    }    public void test_dayOfMonth() throws Exception {        assertEquals(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth());        assertEquals("dayOfMonth", DateTimeFieldType.dayOfMonth().getName());        assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfMonth().getDurationType());        assertEquals(DurationFieldType.months(), DateTimeFieldType.dayOfMonth().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().dayOfMonth(), DateTimeFieldType.dayOfMonth().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().dayOfMonth().isSupported(), DateTimeFieldType.dayOfMonth().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.dayOfMonth());    }    public void test_dayOfWeek() throws Exception {        assertEquals(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.dayOfWeek());        assertEquals("dayOfWeek", DateTimeFieldType.dayOfWeek().getName());        assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfWeek().getDurationType());        assertEquals(DurationFieldType.weeks(), DateTimeFieldType.dayOfWeek().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().dayOfWeek(), DateTimeFieldType.dayOfWeek().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().dayOfWeek().isSupported(), DateTimeFieldType.dayOfWeek().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.dayOfWeek());    }    public void test_halfdayOfDay() throws Exception {        assertEquals(DateTimeFieldType.halfdayOfDay(), DateTimeFieldType.halfdayOfDay());        assertEquals("halfdayOfDay", DateTimeFieldType.halfdayOfDay().getName());        assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.halfdayOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.halfdayOfDay().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().halfdayOfDay(), DateTimeFieldType.halfdayOfDay().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().halfdayOfDay().isSupported(), DateTimeFieldType.halfdayOfDay().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.halfdayOfDay());    }    public void test_clockhourOfDay() throws Exception {        assertEquals(DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.clockhourOfDay());        assertEquals("clockhourOfDay", DateTimeFieldType.clockhourOfDay().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.clockhourOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.clockhourOfDay().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().clockhourOfDay(), DateTimeFieldType.clockhourOfDay().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().clockhourOfDay().isSupported(), DateTimeFieldType.clockhourOfDay().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.clockhourOfDay());    }    public void test_clockhourOfHalfday() throws Exception {        assertEquals(DateTimeFieldType.clockhourOfHalfday(), DateTimeFieldType.clockhourOfHalfday());        assertEquals("clockhourOfHalfday", DateTimeFieldType.clockhourOfHalfday().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.clockhourOfHalfday().getDurationType());        assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.clockhourOfHalfday().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().clockhourOfHalfday(), DateTimeFieldType.clockhourOfHalfday().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().clockhourOfHalfday().isSupported(), DateTimeFieldType.clockhourOfHalfday().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.clockhourOfHalfday());    }    public void test_hourOfHalfday() throws Exception {        assertEquals(DateTimeFieldType.hourOfHalfday(), DateTimeFieldType.hourOfHalfday());        assertEquals("hourOfHalfday", DateTimeFieldType.hourOfHalfday().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.hourOfHalfday().getDurationType());        assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.hourOfHalfday().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().hourOfHalfday(), DateTimeFieldType.hourOfHalfday().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().hourOfHalfday().isSupported(), DateTimeFieldType.hourOfHalfday().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.hourOfHalfday());    }    public void test_hourOfDay() throws Exception {        assertEquals(DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfDay());        assertEquals("hourOfDay", DateTimeFieldType.hourOfDay().getName());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.hourOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.hourOfDay().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().hourOfDay(), DateTimeFieldType.hourOfDay().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().hourOfDay().isSupported(), DateTimeFieldType.hourOfDay().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.hourOfDay());    }    public void test_minuteOfDay() throws Exception {        assertEquals(DateTimeFieldType.minuteOfDay(), DateTimeFieldType.minuteOfDay());        assertEquals("minuteOfDay", DateTimeFieldType.minuteOfDay().getName());        assertEquals(DurationFieldType.minutes(), DateTimeFieldType.minuteOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.minuteOfDay().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().minuteOfDay(), DateTimeFieldType.minuteOfDay().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().minuteOfDay().isSupported(), DateTimeFieldType.minuteOfDay().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.minuteOfDay());    }    public void test_minuteOfHour() throws Exception {        assertEquals(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.minuteOfHour());        assertEquals("minuteOfHour", DateTimeFieldType.minuteOfHour().getName());        assertEquals(DurationFieldType.minutes(), DateTimeFieldType.minuteOfHour().getDurationType());        assertEquals(DurationFieldType.hours(), DateTimeFieldType.minuteOfHour().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().minuteOfHour(), DateTimeFieldType.minuteOfHour().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().minuteOfHour().isSupported(), DateTimeFieldType.minuteOfHour().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.minuteOfHour());    }    public void test_secondOfDay() throws Exception {        assertEquals(DateTimeFieldType.secondOfDay(), DateTimeFieldType.secondOfDay());        assertEquals("secondOfDay", DateTimeFieldType.secondOfDay().getName());        assertEquals(DurationFieldType.seconds(), DateTimeFieldType.secondOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.secondOfDay().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().secondOfDay(), DateTimeFieldType.secondOfDay().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().secondOfDay().isSupported(), DateTimeFieldType.secondOfDay().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.secondOfDay());    }    public void test_secondOfMinute() throws Exception {        assertEquals(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.secondOfMinute());        assertEquals("secondOfMinute", DateTimeFieldType.secondOfMinute().getName());        assertEquals(DurationFieldType.seconds(), DateTimeFieldType.secondOfMinute().getDurationType());        assertEquals(DurationFieldType.minutes(), DateTimeFieldType.secondOfMinute().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().secondOfMinute(), DateTimeFieldType.secondOfMinute().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().secondOfMinute().isSupported(), DateTimeFieldType.secondOfMinute().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.secondOfMinute());    }    public void test_millisOfDay() throws Exception {        assertEquals(DateTimeFieldType.millisOfDay(), DateTimeFieldType.millisOfDay());        assertEquals("millisOfDay", DateTimeFieldType.millisOfDay().getName());        assertEquals(DurationFieldType.millis(), DateTimeFieldType.millisOfDay().getDurationType());        assertEquals(DurationFieldType.days(), DateTimeFieldType.millisOfDay().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().millisOfDay(), DateTimeFieldType.millisOfDay().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().millisOfDay().isSupported(), DateTimeFieldType.millisOfDay().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.millisOfDay());    }    public void test_millisOfSecond() throws Exception {        assertEquals(DateTimeFieldType.millisOfSecond(), DateTimeFieldType.millisOfSecond());        assertEquals("millisOfSecond", DateTimeFieldType.millisOfSecond().getName());        assertEquals(DurationFieldType.millis(), DateTimeFieldType.millisOfSecond().getDurationType());        assertEquals(DurationFieldType.seconds(), DateTimeFieldType.millisOfSecond().getRangeDurationType());        assertEquals(CopticChronology.getInstanceUTC().millisOfSecond(), DateTimeFieldType.millisOfSecond().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().millisOfSecond().isSupported(), DateTimeFieldType.millisOfSecond().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DateTimeFieldType.millisOfSecond());    }    public void test_other() throws Exception {        assertEquals(1, DateTimeFieldType.class.getDeclaredClasses().length);        Class cls = DateTimeFieldType.class.getDeclaredClasses()[0];        assertEquals(1, cls.getDeclaredConstructors().length);        Constructor con = cls.getDeclaredConstructors()[0];        Object[] params = new Object[] {            "other", new Byte((byte) 128), DurationFieldType.hours(), DurationFieldType.months()};        DateTimeFieldType type = (DateTimeFieldType) con.newInstance(params);                assertEquals("other", type.getName());        assertSame(DurationFieldType.hours(), type.getDurationType());        assertSame(DurationFieldType.months(), type.getRangeDurationType());        try {            type.getField(CopticChronology.getInstanceUTC());            fail();        } catch (InternalError ex) {}        DateTimeFieldType result = doSerialization(type);        assertEquals(type.getName(), result.getName());        assertNotSame(type, result);    }    //-----------------------------------------------------------------------    private void assertSerialization(DateTimeFieldType type) throws Exception {        DateTimeFieldType result = doSerialization(type);        assertSame(type, result);    }    private DateTimeFieldType doSerialization(DateTimeFieldType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeFieldType result = (DateTimeFieldType) ois.readObject();        ois.close();        return result;    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne * @author Mike Schrag */public class TestMutableDateTime_Properties extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Properties.class);    }    public TestMutableDateTime_Properties(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().era(), test.era().getField());        assertEquals("era", test.era().getName());        assertEquals("Property[era]", test.era().toString());        assertSame(test, test.era().getMutableDateTime());        assertEquals(1, test.era().get());        assertEquals("AD", test.era().getAsText());        assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH));        assertEquals("AD", test.era().getAsShortText());        assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().eras(), test.era().getDurationField());        assertEquals(null, test.era().getRangeDurationField());        assertEquals(2, test.era().getMaximumTextLength(null));        assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));        assertEquals(2, test.era().getMaximumShortTextLength(null));        assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());        assertEquals("yearOfEra", test.yearOfEra().getName());        assertEquals("Property[yearOfEra]", test.yearOfEra().toString());        assertEquals(2004, test.yearOfEra().get());        assertEquals("2004", test.yearOfEra().getAsText());        assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH));        assertEquals("2004", test.yearOfEra().getAsShortText());        assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());        assertEquals(null, test.yearOfEra().getRangeDurationField());        assertEquals(9, test.yearOfEra().getMaximumTextLength(null));        assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetCenturyOfEra() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());        assertEquals("centuryOfEra", test.centuryOfEra().getName());        assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString());        assertEquals(20, test.centuryOfEra().get());        assertEquals("20", test.centuryOfEra().getAsText());        assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH));        assertEquals("20", test.centuryOfEra().getAsShortText());        assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());        assertEquals(null, test.centuryOfEra().getRangeDurationField());        assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));        assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYearOfCentury() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());        assertEquals("yearOfCentury", test.yearOfCentury().getName());        assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString());        assertEquals(4, test.yearOfCentury().get());        assertEquals("4", test.yearOfCentury().getAsText());        assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH));        assertEquals("4", test.yearOfCentury().getAsShortText());        assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());        assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());        assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));        assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekyear(), test.weekyear().getField());        assertEquals("weekyear", test.weekyear().getName());        assertEquals("Property[weekyear]", test.weekyear().toString());        assertEquals(2004, test.weekyear().get());        assertEquals("2004", test.weekyear().getAsText());        assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH));        assertEquals("2004", test.weekyear().getAsShortText());        assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());        assertEquals(null, test.weekyear().getRangeDurationField());        assertEquals(9, test.weekyear().getMaximumTextLength(null));        assertEquals(9, test.weekyear().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().year(), test.year().getField());        assertEquals("year", test.year().getName());        assertEquals("Property[year]", test.year().toString());        assertEquals(2004, test.year().get());        assertEquals("2004", test.year().getAsText());        assertEquals("2004", test.year().getAsText(Locale.FRENCH));        assertEquals("2004", test.year().getAsShortText());        assertEquals("2004", test.year().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().years(), test.year().getDurationField());        assertEquals(null, test.year().getRangeDurationField());        assertEquals(9, test.year().getMaximumTextLength(null));        assertEquals(9, test.year().getMaximumShortTextLength(null));        assertEquals(-292275054, test.year().getMinimumValue());        assertEquals(-292275054, test.year().getMinimumValueOverall());        assertEquals(292277023, test.year().getMaximumValue());        assertEquals(292277023, test.year().getMaximumValueOverall());    }    public void testPropertyAddYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().add(9);        assertEquals("2013-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().addWrapField(9);        assertEquals("2013-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertySetYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().set(1960);        assertEquals("1960-06-09T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.year().set("1960");        assertEquals("1960-06-09T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());        assertEquals("monthOfYear", test.monthOfYear().getName());        assertEquals("Property[monthOfYear]", test.monthOfYear().toString());        assertEquals(6, test.monthOfYear().get());        assertEquals("June", test.monthOfYear().getAsText());        assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("Jun", test.monthOfYear().getAsShortText());        assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());        assertEquals(9, test.monthOfYear().getMaximumTextLength(null));        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));        test = new MutableDateTime(2004, 7, 9, 0, 0, 0, 0);        assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));        assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());        assertEquals(1, test.monthOfYear().getMinimumValue());        assertEquals(1, test.monthOfYear().getMinimumValueOverall());        assertEquals(12, test.monthOfYear().getMaximumValue());        assertEquals(12, test.monthOfYear().getMaximumValueOverall());    }    public void testPropertyAddMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().add(6);        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    public void testPropertyAddWrapFieldMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().addWrapField(8);        assertEquals("2004-02-09T00:00:00.000Z", test.toString());    }    public void testPropertySetMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set(12);        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    public void testPropertySetTextMonthOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("12");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("December");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.monthOfYear().set("Dec");        assertEquals("2004-12-09T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());        assertEquals("dayOfMonth", test.dayOfMonth().getName());        assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString());        assertEquals(9, test.dayOfMonth().get());        assertEquals("9", test.dayOfMonth().getAsText());        assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH));        assertEquals("9", test.dayOfMonth().getAsShortText());        assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());        assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());        assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));        assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));        assertEquals(1, test.dayOfMonth().getMinimumValue());        assertEquals(1, test.dayOfMonth().getMinimumValueOverall());        assertEquals(30, test.dayOfMonth().getMaximumValue());        assertEquals(31, test.dayOfMonth().getMaximumValueOverall());        assertEquals(false, test.dayOfMonth().isLeap());        assertEquals(0, test.dayOfMonth().getLeapAmount());        assertEquals(null, test.dayOfMonth().getLeapDurationField());    }    public void testPropertyAddDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().add(9);        assertEquals("2004-06-18T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().addWrapField(22);        assertEquals("2004-06-01T00:00:00.000+01:00", test.toString());    }    public void testPropertySetDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().set(12);        assertEquals("2004-06-12T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextDayOfMonth() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfMonth().set("12");        assertEquals("2004-06-12T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfYear() {        // 31+29+31+30+31+9 = 161        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());        assertEquals("dayOfYear", test.dayOfYear().getName());        assertEquals("Property[dayOfYear]", test.dayOfYear().toString());        assertEquals(161, test.dayOfYear().get());        assertEquals("161", test.dayOfYear().getAsText());        assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH));        assertEquals("161", test.dayOfYear().getAsShortText());        assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());        assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());        assertEquals(3, test.dayOfYear().getMaximumTextLength(null));        assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));        assertEquals(false, test.dayOfYear().isLeap());        assertEquals(0, test.dayOfYear().getLeapAmount());        assertEquals(null, test.dayOfYear().getLeapDurationField());    }    public void testPropertyAddDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().add(9);        assertEquals("2004-06-18T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().addWrapField(206);        assertEquals("2004-01-01T00:00:00.000Z", test.toString());    }    public void testPropertySetDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().set(12);        assertEquals("2004-01-12T00:00:00.000Z", test.toString());    }    public void testPropertySetTextDayOfYear() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfYear().set("12");        assertEquals("2004-01-12T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetWeekOfWeekyear() {        // 2002-01-01 = Thu        // 2002-12-31 = Thu (+364 days)        // 2003-12-30 = Thu (+364 days)        // 2004-01-03 = Mon             W1        // 2004-01-31 = Mon (+28 days)  W5        // 2004-02-28 = Mon (+28 days)  W9        // 2004-03-27 = Mon (+28 days)  W13        // 2004-04-24 = Mon (+28 days)  W17        // 2004-05-23 = Mon (+28 days)  W21        // 2004-06-05 = Mon (+14 days)  W23        // 2004-06-09 = Fri        // 2004-12-25 = Mon             W52        // 2005-01-01 = Mon             W1        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());        assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName());        assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString());        assertEquals(24, test.weekOfWeekyear().get());        assertEquals("24", test.weekOfWeekyear().getAsText());        assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH));        assertEquals("24", test.weekOfWeekyear().getAsShortText());        assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());        assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());        assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));        assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));        assertEquals(false, test.weekOfWeekyear().isLeap());        assertEquals(0, test.weekOfWeekyear().getLeapAmount());        assertEquals(null, test.weekOfWeekyear().getLeapDurationField());    }    public void testPropertyAddWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().add(1);        assertEquals("2004-06-14T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().addWrapField(30);        assertEquals("2003-12-29T00:00:00.000Z", test.toString());    }    public void testPropertySetWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().set(4);        assertEquals("2004-01-19T00:00:00.000Z", test.toString());    }    public void testPropertySetTextWeekOfWeekyear() {        MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0);        test.weekOfWeekyear().set("4");        assertEquals("2004-01-19T00:00:00.000Z", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());        assertEquals("dayOfWeek", test.dayOfWeek().getName());        assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString());        assertEquals(3, test.dayOfWeek().get());        assertEquals("Wednesday", test.dayOfWeek().getAsText());        assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH));        assertEquals("Wed", test.dayOfWeek().getAsShortText());        assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());        assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());        assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));        assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));        assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));        assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));        assertEquals(1, test.dayOfWeek().getMinimumValue());        assertEquals(1, test.dayOfWeek().getMinimumValueOverall());        assertEquals(7, test.dayOfWeek().getMaximumValue());        assertEquals(7, test.dayOfWeek().getMaximumValueOverall());        assertEquals(false, test.dayOfWeek().isLeap());        assertEquals(0, test.dayOfWeek().getLeapAmount());        assertEquals(null, test.dayOfWeek().getLeapDurationField());    }    public void testPropertyAddDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().add(1);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddLongDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().add(1L);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertyAddWrapFieldDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);  // Wed        test.dayOfWeek().addWrapField(5);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());    }    public void testPropertySetDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set(4);        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());    }    public void testPropertySetTextDayOfWeek() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("4");        assertEquals("2004-06-10T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("Mon");        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("Tuesday");        assertEquals("2004-06-08T00:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);        test.dayOfWeek().set("lundi", Locale.FRENCH);        assertEquals("2004-06-07T00:00:00.000+01:00", test.toString());    }    //-----------------------------------------------------------------------    public void testPropertyGetHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());        assertEquals("hourOfDay", test.hourOfDay().getName());        assertEquals("Property[hourOfDay]", test.hourOfDay().toString());        assertEquals(13, test.hourOfDay().get());        assertEquals("13", test.hourOfDay().getAsText());        assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH));        assertEquals("13", test.hourOfDay().getAsShortText());        assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());        assertEquals(2, test.hourOfDay().getMaximumTextLength(null));        assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));    }    public void testPropertyRoundFloorHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundCeilingHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfFloorHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfFloor();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfCeilingHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfCeiling();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRoundHalfEvenHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 14, 30, 0, 0);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T14:00:00.000+01:00", test.toString());                test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999);        test.hourOfDay().roundHalfEven();        assertEquals("2004-06-09T13:00:00.000+01:00", test.toString());    }    public void testPropertyRemainderHourOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0);        assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder());    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfHour() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());        assertEquals("minuteOfHour", test.minuteOfHour().getName());        assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString());        assertEquals(23, test.minuteOfHour().get());        assertEquals("23", test.minuteOfHour().getAsText());        assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH));        assertEquals("23", test.minuteOfHour().getAsShortText());        assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());        assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());        assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));        assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMinuteOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());        assertEquals("minuteOfDay", test.minuteOfDay().getName());        assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString());        assertEquals(803, test.minuteOfDay().get());        assertEquals("803", test.minuteOfDay().getAsText());        assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH));        assertEquals("803", test.minuteOfDay().getAsShortText());        assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());        assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));        assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfMinute() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());        assertEquals("secondOfMinute", test.secondOfMinute().getName());        assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString());        assertEquals(43, test.secondOfMinute().get());        assertEquals("43", test.secondOfMinute().getAsText());        assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH));        assertEquals("43", test.secondOfMinute().getAsShortText());        assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());        assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());        assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));        assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetSecondOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());        assertEquals("secondOfDay", test.secondOfDay().getName());        assertEquals("Property[secondOfDay]", test.secondOfDay().toString());        assertEquals(48223, test.secondOfDay().get());        assertEquals("48223", test.secondOfDay().getAsText());        assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH));        assertEquals("48223", test.secondOfDay().getAsShortText());        assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());        assertEquals(5, test.secondOfDay().getMaximumTextLength(null));        assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfSecond() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());        assertEquals("millisOfSecond", test.millisOfSecond().getName());        assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString());        assertEquals(53, test.millisOfSecond().get());        assertEquals("53", test.millisOfSecond().getAsText());        assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH));        assertEquals("53", test.millisOfSecond().getAsShortText());        assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());        assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());        assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));        assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyGetMillisOfDay() {        MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);        assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());        assertEquals("millisOfDay", test.millisOfDay().getName());        assertEquals("Property[millisOfDay]", test.millisOfDay().toString());        assertEquals(48223053, test.millisOfDay().get());        assertEquals("48223053", test.millisOfDay().getAsText());        assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH));        assertEquals("48223053", test.millisOfDay().getAsShortText());        assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH));        assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());        assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());        assertEquals(8, test.millisOfDay().getMaximumTextLength(null));        assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));    }    //-----------------------------------------------------------------------    public void testPropertyToIntervalYearOfEra() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.yearOfEra().toInterval();      assertEquals(new MutableDateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);    }    public void testPropertyToIntervalYearOfCentury() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.yearOfCentury().toInterval();      assertEquals(new MutableDateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);    }    public void testPropertyToIntervalYear() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.year().toInterval();      assertEquals(new MutableDateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);    }    public void testPropertyToIntervalMonthOfYear() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.monthOfYear().toInterval();      assertEquals(new MutableDateTime(2004, 6, 1, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2004, 7, 1, 0, 0, 0, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);    }    public void testPropertyToIntervalDayOfMonth() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.dayOfMonth().toInterval();      assertEquals(new MutableDateTime(2004, 6, 9, 0, 0, 0, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2004, 6, 10, 0, 0, 0, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);      MutableDateTime febTest = new MutableDateTime(2004, 2, 29, 13, 23, 43, 53);      Interval febTestInterval = febTest.dayOfMonth().toInterval();      assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0), febTestInterval.getStart());      assertEquals(new MutableDateTime(2004, 3, 1, 0, 0, 0, 0), febTestInterval.getEnd());      assertEquals(new MutableDateTime(2004, 2, 29, 13, 23, 43, 53), febTest);    }    public void testPropertyToIntervalHourOfDay() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.hourOfDay().toInterval();      assertEquals(new MutableDateTime(2004, 6, 9, 13, 0, 0, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2004, 6, 9, 14, 0, 0, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);      MutableDateTime midnightTest = new MutableDateTime(2004, 6, 9, 23, 23, 43, 53);      Interval midnightTestInterval = midnightTest.hourOfDay().toInterval();      assertEquals(new MutableDateTime(2004, 6, 9, 23, 0, 0, 0), midnightTestInterval.getStart());      assertEquals(new MutableDateTime(2004, 6, 10, 0, 0, 0, 0), midnightTestInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 23, 23, 43, 53), midnightTest);    }    public void testPropertyToIntervalMinuteOfHour() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.minuteOfHour().toInterval();      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 0, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 24, 0, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);    }    public void testPropertyToIntervalSecondOfMinute() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.secondOfMinute().toInterval();      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 0), testInterval.getStart());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 44, 0), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);    }    public void testPropertyToIntervalMillisOfSecond() {      MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);      Interval testInterval = test.millisOfSecond().toInterval();      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), testInterval.getStart());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 54), testInterval.getEnd());      assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestMutableInterval_Updates extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Updates.class);    }    public TestMutableInterval_Updates(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testSetInterval_long_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(TEST_TIME1 - 1, TEST_TIME2 + 1);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_long_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(TEST_TIME1 - 1, TEST_TIME1 - 2);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetInterval_RI_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RI_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME1 - 2));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetInterval_RI_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(null, new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RI_RI4() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Instant(TEST_TIME1 - 1), null);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    public void testSetInterval_RI_RI5() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(null, null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetInterval_RInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setInterval(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetInterval_RInterval2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(new MockBadInterval());            fail();        } catch (IllegalArgumentException ex) {}    }        class MockBadInterval extends AbstractInterval {        public Chronology getChronology() {            return ISOChronology.getInstance();        }        public long getStartMillis() {            return TEST_TIME1 - 1;        }        public long getEndMillis() {            return TEST_TIME1 - 2;        }    }    public void testSetInterval_RInterval3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setInterval(null);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void testSetStartMillis_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStartMillis(TEST_TIME1 - 1);        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSetStartMillis_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setStartMillis(TEST_TIME2 + 1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStart(new Instant(TEST_TIME1 - 1));        assertEquals(TEST_TIME1 - 1, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSetStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setStart(new Instant(TEST_TIME2 + 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setStart(null);        assertEquals(TEST_TIME_NOW, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetEndMillis_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEndMillis(TEST_TIME2 + 1);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetEndMillis_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setEndMillis(TEST_TIME1 - 1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEnd(new Instant(TEST_TIME2 + 1));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME2 + 1, test.getEndMillis());    }    public void testSetEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setEnd(new Instant(TEST_TIME1 - 1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setEnd(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME_NOW, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetDurationAfterStart_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(123L);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSeDurationAfterStart_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationAfterStart(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetDurationAfterStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(new Duration(123L));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSeDurationAfterStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationAfterStart(new Duration(-1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetDurationAfterStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationAfterStart(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetDurationBeforeEnd_long1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(123L);        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSeDurationBeforeEnd_long2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationBeforeEnd(-1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetDurationBeforeEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(new Duration(123L));        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSeDurationBeforeEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setDurationBeforeEnd(new Duration(-1));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetDurationBeforeEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setDurationBeforeEnd(null);        assertEquals(TEST_TIME2, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriodAfterStart_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodAfterStart(new Period(123L));        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1 + 123L, test.getEndMillis());    }    public void testSePeriodAfterStart_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setPeriodAfterStart(new Period(-1L));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetPeriodAfterStart_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodAfterStart(null);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getEndMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriodBeforeEnd_RI1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodBeforeEnd(new Period(123L));        assertEquals(TEST_TIME2 - 123L, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }    public void testSePeriodBeforeEnd_RI2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        try {            test.setPeriodBeforeEnd(new Period(-1L));            fail();        } catch (IllegalArgumentException ex) {}    }    public void testSetPeriodBeforeEnd_RI3() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        test.setPeriodBeforeEnd(null);        assertEquals(TEST_TIME2, test.getStartMillis());        assertEquals(TEST_TIME2, test.getEndMillis());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.CopticChronology;/** * This class is a Junit unit test for DurationFieldType. * * @author Stephen Colebourne */public class TestDurationFieldType extends TestCase {    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDurationFieldType.class);    }    public TestDurationFieldType(String name) {        super(name);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    //-----------------------------------------------------------------------    public void test_eras() throws Exception {        assertEquals(DurationFieldType.eras(), DurationFieldType.eras());        assertEquals("eras", DurationFieldType.eras().getName());        assertEquals(CopticChronology.getInstanceUTC().eras(), DurationFieldType.eras().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().eras().isSupported(), DurationFieldType.eras().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.eras());    }    public void test_centuries() throws Exception {        assertEquals(DurationFieldType.centuries(), DurationFieldType.centuries());        assertEquals("centuries", DurationFieldType.centuries().getName());        assertEquals(CopticChronology.getInstanceUTC().centuries(), DurationFieldType.centuries().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().centuries().isSupported(), DurationFieldType.centuries().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.centuries());    }    public void test_years() throws Exception {        assertEquals(DurationFieldType.years(), DurationFieldType.years());        assertEquals("years", DurationFieldType.years().getName());        assertEquals(CopticChronology.getInstanceUTC().years(), DurationFieldType.years().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().years().isSupported(), DurationFieldType.years().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.years());    }    public void test_months() throws Exception {        assertEquals(DurationFieldType.months(), DurationFieldType.months());        assertEquals("months", DurationFieldType.months().getName());        assertEquals(CopticChronology.getInstanceUTC().months(), DurationFieldType.months().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().months().isSupported(), DurationFieldType.months().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.months());    }    public void test_weekyears() throws Exception {        assertEquals(DurationFieldType.weekyears(), DurationFieldType.weekyears());        assertEquals("weekyears", DurationFieldType.weekyears().getName());        assertEquals(CopticChronology.getInstanceUTC().weekyears(), DurationFieldType.weekyears().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().weekyears().isSupported(), DurationFieldType.weekyears().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.weekyears());    }    public void test_weeks() throws Exception {        assertEquals(DurationFieldType.weeks(), DurationFieldType.weeks());        assertEquals("weeks", DurationFieldType.weeks().getName());        assertEquals(CopticChronology.getInstanceUTC().weeks(), DurationFieldType.weeks().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().weeks().isSupported(), DurationFieldType.weeks().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.weeks());    }    public void test_days() throws Exception {        assertEquals(DurationFieldType.days(), DurationFieldType.days());        assertEquals("days", DurationFieldType.days().getName());        assertEquals(CopticChronology.getInstanceUTC().days(), DurationFieldType.days().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().days().isSupported(), DurationFieldType.days().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.days());    }    public void test_halfdays() throws Exception {        assertEquals(DurationFieldType.halfdays(), DurationFieldType.halfdays());        assertEquals("halfdays", DurationFieldType.halfdays().getName());        assertEquals(CopticChronology.getInstanceUTC().halfdays(), DurationFieldType.halfdays().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().halfdays().isSupported(), DurationFieldType.halfdays().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.halfdays());    }    public void test_hours() throws Exception {        assertEquals(DurationFieldType.hours(), DurationFieldType.hours());        assertEquals("hours", DurationFieldType.hours().getName());        assertEquals(CopticChronology.getInstanceUTC().hours(), DurationFieldType.hours().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().hours().isSupported(), DurationFieldType.hours().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.hours());    }    public void test_minutes() throws Exception {        assertEquals(DurationFieldType.minutes(), DurationFieldType.minutes());        assertEquals("minutes", DurationFieldType.minutes().getName());        assertEquals(CopticChronology.getInstanceUTC().minutes(), DurationFieldType.minutes().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().minutes().isSupported(), DurationFieldType.minutes().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.minutes());    }    public void test_seconds() throws Exception {        assertEquals(DurationFieldType.seconds(), DurationFieldType.seconds());        assertEquals("seconds", DurationFieldType.seconds().getName());        assertEquals(CopticChronology.getInstanceUTC().seconds(), DurationFieldType.seconds().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().seconds().isSupported(), DurationFieldType.seconds().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.seconds());    }    public void test_millis() throws Exception {        assertEquals(DurationFieldType.millis(), DurationFieldType.millis());        assertEquals("millis", DurationFieldType.millis().getName());        assertEquals(CopticChronology.getInstanceUTC().millis(), DurationFieldType.millis().getField(CopticChronology.getInstanceUTC()));        assertEquals(CopticChronology.getInstanceUTC().millis().isSupported(), DurationFieldType.millis().isSupported(CopticChronology.getInstanceUTC()));        assertSerialization(DurationFieldType.millis());    }    public void test_other() throws Exception {        assertEquals(1, DurationFieldType.class.getDeclaredClasses().length);        Class cls = DurationFieldType.class.getDeclaredClasses()[0];        assertEquals(1, cls.getDeclaredConstructors().length);        Constructor con = cls.getDeclaredConstructors()[0];        Object[] params = new Object[] {"other", new Byte((byte) 128)};        DurationFieldType type = (DurationFieldType) con.newInstance(params);                assertEquals("other", type.getName());        try {            type.getField(CopticChronology.getInstanceUTC());            fail();        } catch (InternalError ex) {}        DurationFieldType result = doSerialization(type);        assertEquals(type.getName(), result.getName());        assertNotSame(type, result);    }    //-----------------------------------------------------------------------    private void assertSerialization(DurationFieldType type) throws Exception {        DurationFieldType result = doSerialization(type);        assertSame(type, result);    }    private DurationFieldType doSerialization(DurationFieldType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DurationFieldType result = (DurationFieldType) ois.readObject();        ois.close();        return result;    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */public class TestDateMidnight_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW_UTC =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private long TEST_TIME_NOW_LONDON =            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME_NOW_PARIS =            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;        // 2002-04-05    private long TEST_TIME1_UTC =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME1_LONDON =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME1_PARIS =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - 2*DateTimeConstants.MILLIS_PER_HOUR;        // 2003-05-06    private long TEST_TIME2_UTC =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME2_LONDON =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME2_PARIS =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - 2*DateTimeConstants.MILLIS_PER_HOUR;        private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Constructors.class);    }    public TestDateMidnight_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        DateMidnight test = new DateMidnight();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2_LONDON, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1_PARIS, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2_PARIS, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2_LONDON, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new DateMidnight(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        DateMidnight test = new DateMidnight((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1_PARIS, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new DateMidnight(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new DateMidnight(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1_UTC);        DateMidnight test = new DateMidnight(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1_LONDON, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31);            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31);        try {            new DateMidnight(2002, 7, 32);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_DateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31, PARIS);        try {            new DateMidnight(2002, 7, 32, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_nullDateTimeZone() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 0, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 13, 9, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new DateMidnight(2002, 6, 31, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new DateMidnight(2002, 7, 31, GregorianChronology.getInstance());        try {            new DateMidnight(2002, 7, 32, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.chrono.JulianChronology;/** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */public class TestTimeOfDay_Constructors extends TestCase {    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final ISOChronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final int OFFSET = 1;        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestTimeOfDay_Constructors.class);    }    public TestTimeOfDay_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);        java.util.TimeZone.setDefault(LONDON.toTimeZone());    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        java.util.TimeZone.setDefault(zone.toTimeZone());        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstantMidnight() throws Throwable {        TimeOfDay test = TimeOfDay.MIDNIGHT;        assertEquals(ISO_UTC, test.getChronology());        assertEquals(0, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test factory (long)     */    public void testFactoryMillisOfDay_long1() throws Throwable {        TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test factory (long, Chronology)     */    public void testFactoryMillisOfDay_long1_Chronology() throws Throwable {        TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test factory (long, Chronology=null)     */    public void testFactoryMillisOfDay_long_nullChronology() throws Throwable {        TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        TimeOfDay test = new TimeOfDay();        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10 + OFFSET, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());        // 23:59 in London is 00:59 the following day in Paris                TimeOfDay test = new TimeOfDay(LONDON);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(23, test.getHourOfDay());        assertEquals(59, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());                test = new TimeOfDay(PARIS);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(0, test.getHourOfDay());        assertEquals(59, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());        // 23:59 in London is 00:59 the following day in Paris                TimeOfDay test = new TimeOfDay((DateTimeZone) null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(23, test.getHourOfDay());        assertEquals(59, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(10 + OFFSET, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Chronology) null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10 + OFFSET, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1 + OFFSET, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME2);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(5 + OFFSET, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(1 + OFFSET, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(5 + OFFSET, test.getHourOfDay());        assertEquals(6, test.getMinuteOfHour());        assertEquals(7, test.getSecondOfMinute());        assertEquals(8, test.getMillisOfSecond());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(TEST_TIME1, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1 + OFFSET, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1 + OFFSET, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object)     */    public void testConstructor_Object2() throws Throwable {        Calendar cal = new GregorianCalendar();        cal.setTime(new Date(TEST_TIME1));        TimeOfDay test = new TimeOfDay(cal);        assertEquals(GJChronology.getInstanceUTC(), test.getChronology());        assertEquals(1 + OFFSET, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        TimeOfDay test = new TimeOfDay((Object) null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10 + OFFSET, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object)     */    public void testConstructor_todObject() throws Throwable {        TimeOfDay base = new TimeOfDay(10, 20, 30, 40, CopticChronology.getInstance(PARIS));        TimeOfDay test = new TimeOfDay(base);        assertEquals(CopticChronology.getInstanceUTC(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(1 + OFFSET, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor2_Object_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay("T10:20");        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());                try {            new TimeOfDay("T1020");            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(10 + OFFSET, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        TimeOfDay test = new TimeOfDay(date, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1 + OFFSET, test.getHourOfDay());        assertEquals(2, test.getMinuteOfHour());        assertEquals(3, test.getSecondOfMinute());        assertEquals(4, test.getMillisOfSecond());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay((Object) null, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10 + OFFSET, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int)     */    public void testConstructor_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());    }    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(0, test.getMillisOfSecond());    }    /**     * Test constructor (int, int, int, int)     */    public void testConstructor_int_int_int_int() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, 40);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, 1000);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_Chronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());        assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());        try {            new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_nullChronology() throws Throwable {        TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(10, test.getHourOfDay());        assertEquals(20, test.getMinuteOfHour());        assertEquals(30, test.getSecondOfMinute());        assertEquals(40, test.getMillisOfSecond());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Entry point for all tests in this package. *  * @version $Revision$ $Date$ *  * @author Stephen Colebourne */public class TestAll extends TestCase {    public TestAll(String testName) {        super(testName);    }    public static Test suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestChronology.suite());        suite.addTest(TestDateTimeFieldType.suite());        suite.addTest(TestDurationFieldType.suite());                suite.addTest(TestInstant_Constructors.suite());        suite.addTest(TestInstant_Basics.suite());                suite.addTest(TestDateTime_Constructors.suite());        suite.addTest(TestDateTime_Basics.suite());        suite.addTest(TestDateTime_Properties.suite());                suite.addTest(TestMutableDateTime_Constructors.suite());        suite.addTest(TestMutableDateTime_Basics.suite());        suite.addTest(TestMutableDateTime_Sets.suite());        suite.addTest(TestMutableDateTime_Adds.suite());        suite.addTest(TestMutableDateTime_Properties.suite());                suite.addTest(TestDateMidnight_Constructors.suite());        suite.addTest(TestDateMidnight_Basics.suite());        suite.addTest(TestDateMidnight_Properties.suite());                suite.addTest(TestDuration_Constructors.suite());        suite.addTest(TestDuration_Basics.suite());                suite.addTest(TestInterval_Constructors.suite());        suite.addTest(TestInterval_Basics.suite());                suite.addTest(TestMutableInterval_Constructors.suite());        suite.addTest(TestMutableInterval_Basics.suite());        suite.addTest(TestMutableInterval_Updates.suite());                suite.addTest(TestPeriod_Constructors.suite());        suite.addTest(TestPeriod_Basics.suite());                suite.addTest(TestMutablePeriod_Constructors.suite());        suite.addTest(TestMutablePeriod_Basics.suite());        suite.addTest(TestMutablePeriod_Updates.suite());                suite.addTest(TestTimeOfDay_Basics.suite());        suite.addTest(TestTimeOfDay_Constructors.suite());        suite.addTest(TestTimeOfDay_Properties.suite());                suite.addTest(TestYearMonthDay_Basics.suite());        suite.addTest(TestYearMonthDay_Constructors.suite());        suite.addTest(TestYearMonthDay_Properties.suite());                suite.addTest(TestPartial_Basics.suite());        suite.addTest(TestPartial_Constructors.suite());        suite.addTest(TestPartial_Properties.suite());        suite.addTest(TestPartial_Match.suite());                suite.addTest(TestAbstractPartial.suite());        suite.addTest(TestBasePartial.suite());                suite.addTest(TestDateTimeComparator.suite());        suite.addTest(TestDateTimeConstants.suite());        suite.addTest(TestDateTimeUtils.suite());        suite.addTest(TestDateTimeZone.suite());        suite.addTest(TestPeriodType.suite());//        suite.addTest(TestParseISO.suite());        suite.addTest(TestDurationField.suite());                suite.addTest(TestSerialization.suite());        suite.addTest(TestIllegalFieldValueException.suite());        return suite;    }    public static void main(String args[]) {        String[] testCaseName = {            TestAll.class.getName()        };        junit.textui.TestRunner.main(testCaseName);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */public class TestPartial_Match extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");    private static final int OFFSET = 1;    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);    private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);    private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);    private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);    private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);    private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO);    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();        private long TEST_TIME_NOW =            10L * DateTimeConstants.MILLIS_PER_HOUR            + 20L * DateTimeConstants.MILLIS_PER_MINUTE            + 30L * DateTimeConstants.MILLIS_PER_SECOND            + 40L;                private long TEST_TIME1 =        1L * DateTimeConstants.MILLIS_PER_HOUR        + 2L * DateTimeConstants.MILLIS_PER_MINUTE        + 3L * DateTimeConstants.MILLIS_PER_SECOND        + 4L;            private long TEST_TIME2 =        1L * DateTimeConstants.MILLIS_PER_DAY        + 5L * DateTimeConstants.MILLIS_PER_HOUR        + 6L * DateTimeConstants.MILLIS_PER_MINUTE        + 7L * DateTimeConstants.MILLIS_PER_SECOND        + 8L;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPartial_Match.class);    }    public TestPartial_Match(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    public void testIsMatch() {        // Year=2005, Month=7 (July), DayOfWeek=2 (Tuesday)        Partial test = createYMDwPartial(ISO_UTC, 2005, 7, 2);        DateTime instant = new DateTime(2005, 7, 5, 0, 0, 0, 0);        assertEquals(true, test.isMatch(instant));                instant = new DateTime(2005, 7, 4, 0, 0, 0, 0);        assertEquals(false, test.isMatch(instant));                instant = new DateTime(2005, 7, 6, 0, 0, 0, 0);        assertEquals(false, test.isMatch(instant));                instant = new DateTime(2005, 7, 12, 0, 0, 0, 0);        assertEquals(true, test.isMatch(instant));                instant = new DateTime(2005, 7, 19, 0, 0, 0, 0);        assertEquals(true, test.isMatch(instant));                instant = new DateTime(2005, 7, 26, 0, 0, 0, 0);        assertEquals(true, test.isMatch(instant));                instant = new DateTime(2005, 8, 2, 0, 0, 0, 0);        assertEquals(false, test.isMatch(instant));                instant = new DateTime(2006, 7, 5, 0, 0, 0, 0);        assertEquals(false, test.isMatch(instant));                instant = new DateTime(2005, 6, 5, 0, 0, 0, 0);        assertEquals(false, test.isMatch(instant));    }    //-----------------------------------------------------------------------    private Partial createYMDwPartial(Chronology chrono, int year, int month, int dow) {        return new Partial(            new DateTimeFieldType[] {                    DateTimeFieldType.year(),                    DateTimeFieldType.monthOfYear(),                    DateTimeFieldType.dayOfWeek()},            new int[] {year, month, dow},            chrono);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Date;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */public class TestYearMonthDay_Constructors extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();    private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();    private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS);        private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestYearMonthDay_Constructors.class);    }    public TestYearMonthDay_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        DateTimeZone.setDefault(LONDON);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        YearMonthDay test = new YearMonthDay();        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());        // 23:59 in London is 00:59 the following day in Paris                YearMonthDay test = new YearMonthDay(LONDON);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(2005, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(8, test.getDayOfMonth());                test = new YearMonthDay(PARIS);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(2005, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON);        DateTimeUtils.setCurrentMillisFixed(dt.getMillis());        // 23:59 in London is 00:59 the following day in Paris                YearMonthDay test = new YearMonthDay((DateTimeZone) null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(2005, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(8, test.getDayOfMonth());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Chronology) null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME2);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1971, test.getYear());        assertEquals(5, test.getMonthOfYear());        assertEquals(7, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1, GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME2, GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(1971, test.getYear());        assertEquals(5, test.getMonthOfYear());        assertEquals(7, test.getDayOfMonth());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay(TEST_TIME1, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        YearMonthDay test = new YearMonthDay((Object) null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date, GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Object) null, GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        YearMonthDay test = new YearMonthDay(date, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(4, test.getMonthOfYear());        assertEquals(6, test.getDayOfMonth());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay((Object) null, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new YearMonthDay(Integer.MIN_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(Integer.MAX_VALUE, 6, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 0, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 13, 9);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 31);            fail();        } catch (IllegalArgumentException ex) {}        new YearMonthDay(1970, 7, 31);        try {            new YearMonthDay(1970, 7, 32);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_Chronology() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9, GREGORIAN_PARIS);        assertEquals(GREGORIAN_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        try {            new YearMonthDay(Integer.MIN_VALUE, 6, 9, GREGORIAN_PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(Integer.MAX_VALUE, 6, 9, GREGORIAN_PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 0, 9, GREGORIAN_PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 13, 9, GREGORIAN_PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 0, GREGORIAN_PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new YearMonthDay(1970, 6, 31, GREGORIAN_PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new YearMonthDay(1970, 7, 31, GREGORIAN_PARIS);        try {            new YearMonthDay(1970, 7, 32, GREGORIAN_PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_nullChronology() throws Throwable {        YearMonthDay test = new YearMonthDay(1970, 6, 9, null);        assertEquals(ISO_UTC, test.getChronology());        assertEquals(1970, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Updates extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Updates.class);    }    public TestMutablePeriod_Updates(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testClear() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.clear();        assertEquals(new MutablePeriod(), test);                test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime());        test.clear();        assertEquals(new MutablePeriod(PeriodType.yearMonthDayTime()), test);    }    //-----------------------------------------------------------------------    public void testAddYears() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(10);        assertEquals(11, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(-10);        assertEquals(-9, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addYears(0);        assertEquals(1, test.getYears());    }    //-----------------------------------------------------------------------    public void testAddMonths() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(10);        assertEquals(12, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(-10);        assertEquals(-8, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMonths(0);        assertEquals(2, test.getMonths());    }    //-----------------------------------------------------------------------    public void testAddWeeks() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(10);        assertEquals(13, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(-10);        assertEquals(-7, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addWeeks(0);        assertEquals(3, test.getWeeks());    }    //-----------------------------------------------------------------------    public void testAddDays() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(10);        assertEquals(14, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(-10);        assertEquals(-6, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addDays(0);        assertEquals(4, test.getDays());    }    //-----------------------------------------------------------------------    public void testAddHours() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(10);        assertEquals(15, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(-10);        assertEquals(-5, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addHours(0);        assertEquals(5, test.getHours());    }    //-----------------------------------------------------------------------    public void testAddMinutes() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(10);        assertEquals(16, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(-10);        assertEquals(-4, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMinutes(0);        assertEquals(6, test.getMinutes());    }    //-----------------------------------------------------------------------    public void testAddSeconds() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(10);        assertEquals(17, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(-10);        assertEquals(-3, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addSeconds(0);        assertEquals(7, test.getSeconds());    }    //-----------------------------------------------------------------------    public void testAddMillis() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(10);        assertEquals(18, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(-10);        assertEquals(-2, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.addMillis(0);        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetYears() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(10);        assertEquals(10, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(-10);        assertEquals(-10, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(0);        assertEquals(0, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setYears(1);        assertEquals(1, test.getYears());                test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis());        try {            test.setYears(1);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetMonths() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(10);        assertEquals(10, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(-10);        assertEquals(-10, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(0);        assertEquals(0, test.getMonths());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMonths(2);        assertEquals(2, test.getMonths());    }    //-----------------------------------------------------------------------    public void testSetWeeks() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(10);        assertEquals(10, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(-10);        assertEquals(-10, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(0);        assertEquals(0, test.getWeeks());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setWeeks(3);        assertEquals(3, test.getWeeks());    }    //-----------------------------------------------------------------------    public void testSetDays() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(10);        assertEquals(10, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(-10);        assertEquals(-10, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(0);        assertEquals(0, test.getDays());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setDays(4);        assertEquals(4, test.getDays());    }    //-----------------------------------------------------------------------    public void testSetHours() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(10);        assertEquals(10, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(-10);        assertEquals(-10, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(0);        assertEquals(0, test.getHours());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setHours(5);        assertEquals(5, test.getHours());    }    //-----------------------------------------------------------------------    public void testSetMinutes() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(10);        assertEquals(10, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(-10);        assertEquals(-10, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(0);        assertEquals(0, test.getMinutes());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMinutes(6);        assertEquals(6, test.getMinutes());    }    //-----------------------------------------------------------------------    public void testSetSeconds() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(10);        assertEquals(10, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(-10);        assertEquals(-10, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(0);        assertEquals(0, test.getSeconds());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setSeconds(7);        assertEquals(7, test.getSeconds());    }    //-----------------------------------------------------------------------    public void testSetMillis() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(10);        assertEquals(10, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(-10);        assertEquals(-10, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(0);        assertEquals(0, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setMillis(8);        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSet_Field() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.set(DurationFieldType.years(), 10);        assertEquals(10, test.getYears());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.set(null, 10);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testAdd_Field() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add(DurationFieldType.years(), 10);        assertEquals(11, test.getYears());                test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis());        test.add(DurationFieldType.years(), 0);        assertEquals(0, test.getYears());        assertEquals(1, test.getMillis());                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.add(null, 0);            fail();        } catch (IllegalArgumentException ex) {}                test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        try {            test.add(null, 10);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testSetPeriod_8ints1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_8ints2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        try {            test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_8ints3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        test.setPeriod(0, 0, 0, 0, 0, 0, 0, 18);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_8ints4() {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);        test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RP1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        try {            test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_RP3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        test.setPeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP4() {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);        test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testSetPeriod_RP5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadablePeriod) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_long_long1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt2.getMillis(), dt1.getMillis());        assertEquals(-1, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(-1, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testSetPeriod_long_long3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        test.setPeriod(dt1.getMillis(), dt1.getMillis());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testSetPeriod_long_long_NoYears() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withYearsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(0, test.getYears());        assertEquals(13, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoMonths() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMonthsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(5, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoWeeks() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withWeeksRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(8, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoDays() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withDaysRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(25, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoHours() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withHoursRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(61, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoMinutes() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMinutesRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(61, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_long_long_NoSeconds() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withSecondsRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(1001, test.getMillis());    }    public void testSetPeriod_long_long_NoMillis() {        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMillisRemoved());        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RI_RI1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt1, dt2);        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_RI_RI2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(dt2, dt1);        assertEquals(-1, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(-1, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testSetPeriod_RI_RI3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        test.setPeriod(dt1, dt1);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_RInterval1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);        DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);        test.setPeriod(new Interval(dt1, dt2));        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testSetPeriod_RInterval2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadableInterval) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testSetPeriod_long1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(100L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_long2() {        MutablePeriod test = new MutablePeriod();        test.setPeriod(            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }//    public void testSetPeriod_long3() {//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType());//        test.setPeriod(//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//    }////    public void testSetPeriod_long4() {//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType());//        test.setPeriod(//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);//        assertEquals(1, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(12, test.getWeeks());//        assertEquals(1, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//    }////    public void testSetPeriod_long_NoYears() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());//        test.setPeriod(ms);//        assertEquals(0, test.getYears());//        assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30//        assertEquals(0, test.getWeeks());//        assertEquals(0, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoMonths() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(85, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoWeeks() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(0, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(85, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoDays() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(0, test.getDays());//        assertEquals(5 + 25 * 24, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoHours() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(0, test.getHours());//        assertEquals(6 + 5 * 60, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoMinutes() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(0, test.getMinutes());//        assertEquals(7 + 6 * 60, test.getSeconds());//        assertEquals(8, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoSeconds() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(0, test.getSeconds());//        assertEquals(8 + 7 * 1000, test.getMillis());//        assertEquals(ms, test.toDurationMillis());//    }////    public void testSetPeriod_long_NoMillis() {//        long ms =//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +//            5L * DateTimeConstants.MILLIS_PER_HOUR +//            6L * DateTimeConstants.MILLIS_PER_MINUTE +//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());//        test.setPeriod(ms);//        assertEquals(1, test.getYears());//        assertEquals(2, test.getMonths());//        assertEquals(0, test.getWeeks());//        assertEquals(25, test.getDays());//        assertEquals(5, test.getHours());//        assertEquals(6, test.getMinutes());//        assertEquals(7, test.getSeconds());//        assertEquals(0, test.getMillis());//        assertEquals(ms - 8, test.toDurationMillis());//    }    //-----------------------------------------------------------------------    public void testSetPeriod_RD1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod(new Duration(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testSetPeriod_RD2() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.setPeriod(new Duration(length));        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testSetPeriod_RD3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.setPeriod((ReadableDuration) null);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_8ints1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_8ints2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        try {            test.add(1, 2, 3, 4, 5, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_long1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(100L);        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_long2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(ms);        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_long3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add(2100L);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(9, test.getSeconds());        assertEquals(108, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_long_Chronology1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(100L, ISOChronology.getInstance());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_long_Chronology2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(ms, ISOChronology.getInstance());        // only time fields are precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450 days        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_long_Chronology3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());        long ms =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(ms, ISOChronology.getInstanceUTC());        // UTC, so weeks and day also precise        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450 days        assertEquals(0, test.getMonths());        assertEquals(64, test.getWeeks());        assertEquals(2, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RD1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Duration(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_RD2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        long ms =            (4L + (3L * 7L)) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        test.add(new Duration(ms));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 + (3 * 7)) * 24 + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RD3() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadableDuration) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RP1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Period(100L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_RP2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());  // All type        test.add(new Period(1, 2, 3, 4, 5, 6, 7, 0, PeriodType.standard().withMillisRemoved()));        // add field value, ignore different types        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testAdd_RP3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());        test.add(new Period(0L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testAdd_RP4() {        MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime());        try {            test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testAdd_RP5() {        MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime());        test.add(new Period(1, 2, 0, 4, 5, 6, 7, 8));  // can set weeks as zero        assertEquals(2, test.getYears());        assertEquals(4, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(8, test.getDays());        assertEquals(10, test.getHours());        assertEquals(12, test.getMinutes());        assertEquals(14, test.getSeconds());        assertEquals(16, test.getMillis());    }    public void testAdd_RP6() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadablePeriod) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testAdd_RInterval1() {        MutablePeriod test = new MutablePeriod(100L);        test.add(new Interval(100L, 200L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(200, test.getMillis());    }    public void testAdd_RInterval2() {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 12, 18, 0, 0, 0, 8);        MutablePeriod test = new MutablePeriod(100L);  // All type        test.add(new Interval(dt1, dt2));        assertEquals(1, test.getYears());  // add field value from interval        assertEquals(6, test.getMonths());  // add field value from interval        assertEquals(1, test.getWeeks());  // add field value from interval        assertEquals(2, test.getDays());  // add field value from interval        assertEquals(0, test.getHours());  // time zone OK        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RInterval3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        test.add(new Interval(0L, 0L));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testAdd_RInterval4() {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8);        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());        test.add(new Interval(dt1, dt2));        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());  // no weeks        assertEquals(8, test.getDays());  // week added to days        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(108, test.getMillis());    }    public void testAdd_RInterval5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.add((ReadableInterval) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testMergePeriod_RP1() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.mergePeriod(new MutablePeriod(0, 0, 0, 14, 15, 16, 17, 18, PeriodType.dayTime()));        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testMergePeriod_RP2() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        try {            test.mergePeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(100, test.getMillis());    }    public void testMergePeriod_RP3() {        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());        test.mergePeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18));        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testMergePeriod_RP4() {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);        test.mergePeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));        assertEquals(11, test.getYears());        assertEquals(12, test.getMonths());        assertEquals(13, test.getWeeks());        assertEquals(14, test.getDays());        assertEquals(15, test.getHours());        assertEquals(16, test.getMinutes());        assertEquals(17, test.getSeconds());        assertEquals(18, test.getMillis());    }    public void testMergePeriod_RP5() {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        test.mergePeriod((ReadablePeriod) null);        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */public class TestDuration_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDuration_Constructors.class);    }    public TestDuration_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testZERO() throws Throwable {        Duration test = Duration.ZERO;        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Duration test = new Duration(length);        assertEquals(length, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration test = new Duration(dt1.getMillis(), dt2.getMillis());        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration test = new Duration(dt1, dt2);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        Duration test = new Duration(dt1, dt2);        assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Duration test = new Duration(dt1, dt2);        assertEquals(TEST_TIME_NOW - dt1.getMillis(), test.getMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        Duration test = new Duration(dt1, dt2);        assertEquals(0L, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        Duration test = new Duration("PT72.345S");        assertEquals(72345, test.getMillis());    }    public void testConstructor_Object2() throws Throwable {        Duration test = new Duration((Object) null);        assertEquals(0L, test.getMillis());    }    public void testConstructor_Object3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        Long base = new Long(length);        Duration test = new Duration(base);        assertEquals(length, test.getMillis());    }    public void testConstructor_Object4() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration base = new Duration(dt1, dt2);        Duration test = new Duration(base);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }    public void testConstructor_Object5() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Interval base = new Interval(dt1, dt2);        Duration test = new Duration(base);        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInstant;import org.joda.time.chrono.BuddhistChronology;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.field.UnsupportedDateTimeField;import org.joda.time.field.UnsupportedDurationField;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;/** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */public class TestDateMidnight_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW_UTC =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;    private long TEST_TIME_NOW_LONDON =            TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR;//    private long TEST_TIME_NOW_PARIS =//            TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR;                // 2002-04-05    private long TEST_TIME1_UTC =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME1_LONDON =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME1_PARIS =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            - 2*DateTimeConstants.MILLIS_PER_HOUR;            // 2003-05-06    private long TEST_TIME2_UTC =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;    private long TEST_TIME2_LONDON =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - DateTimeConstants.MILLIS_PER_HOUR;    private long TEST_TIME2_PARIS =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY             - 2*DateTimeConstants.MILLIS_PER_HOUR;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateMidnight_Basics.class);    }    public TestDateMidnight_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString());    }    //-----------------------------------------------------------------------    public void testGet_DateTimeField() {        DateMidnight test = new DateMidnight();        assertEquals(1, test.get(ISOChronology.getInstance().era()));        assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));        assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));        assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));        assertEquals(2002, test.get(ISOChronology.getInstance().year()));        assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));        assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));        assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));        assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));        assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));        assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));        assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().hourOfHalfday()));        assertEquals(24, test.get(ISOChronology.getInstance().clockhourOfDay()));        assertEquals(12, test.get(ISOChronology.getInstance().clockhourOfHalfday()));        assertEquals(0, test.get(ISOChronology.getInstance().hourOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));        assertEquals(0, test.get(ISOChronology.getInstance().minuteOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));        assertEquals(0, test.get(ISOChronology.getInstance().secondOfDay()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));        assertEquals(0, test.get(ISOChronology.getInstance().millisOfDay()));        try {            test.get((DateTimeField) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGet_DateTimeFieldType() {        DateMidnight test = new DateMidnight();        assertEquals(1, test.get(DateTimeFieldType.era()));        assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));        assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));        assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));        assertEquals(2002, test.get(DateTimeFieldType.year()));        assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));        assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));        assertEquals(2002, test.get(DateTimeFieldType.weekyear()));        assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));        assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));        assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));        assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));        assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));        assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay()));        assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));        assertEquals(0, test.get(DateTimeFieldType.hourOfDay()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));        assertEquals(0, test.get(DateTimeFieldType.minuteOfDay()));        assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));        assertEquals(0, test.get(DateTimeFieldType.secondOfDay()));        assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));        assertEquals(0, test.get(DateTimeFieldType.millisOfDay()));        try {            test.get((DateTimeFieldType) null);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testGetMethods() {        DateMidnight test = new DateMidnight();                assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());                assertEquals(1, test.getEra());        assertEquals(20, test.getCenturyOfEra());        assertEquals(2, test.getYearOfCentury());        assertEquals(2002, test.getYearOfEra());        assertEquals(2002, test.getYear());        assertEquals(6, test.getMonthOfYear());        assertEquals(9, test.getDayOfMonth());        assertEquals(2002, test.getWeekyear());        assertEquals(23, test.getWeekOfWeekyear());        assertEquals(7, test.getDayOfWeek());        assertEquals(160, test.getDayOfYear());        assertEquals(0, test.getHourOfDay());        assertEquals(0, test.getMinuteOfHour());        assertEquals(0, test.getMinuteOfDay());        assertEquals(0, test.getSecondOfMinute());        assertEquals(0, test.getSecondOfDay());        assertEquals(0, test.getMillisOfSecond());        assertEquals(0, test.getMillisOfDay());    }    public void testEqualsHashCode() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test2 = new DateMidnight(TEST_TIME1_UTC);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInstant()));        assertEquals(false, test1.equals(new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance())));    }        class MockInstant extends AbstractInstant {        public String toString() {            return null;        }        public long getMillis() {            return TEST_TIME1_LONDON;        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }    }    public void testCompareTo() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(0, test1.compareTo(test1a));        assertEquals(0, test1a.compareTo(test1));        assertEquals(0, test1.compareTo(test1));        assertEquals(0, test1a.compareTo(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(-1, test1.compareTo(test2));        assertEquals(+1, test2.compareTo(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(-1, test1.compareTo(test3));        assertEquals(+1, test3.compareTo(test1));        assertEquals(-1, test3.compareTo(test2));  // midnight paris before london                assertEquals(+1, test2.compareTo(new MockInstant()));        assertEquals(0, test1.compareTo(new MockInstant()));                try {            test1.compareTo(null);            fail();        } catch (NullPointerException ex) {}        try {            test1.compareTo(new Date());            fail();        } catch (ClassCastException ex) {}    }        public void testIsEqual() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(true, test1.isEqual(test1a));        assertEquals(true, test1a.isEqual(test1));        assertEquals(true, test1.isEqual(test1));        assertEquals(true, test1a.isEqual(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.isEqual(test2));        assertEquals(false, test2.isEqual(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isEqual(test3));        assertEquals(false, test3.isEqual(test1));        assertEquals(false, test3.isEqual(test2));  // midnight paris before london                assertEquals(false, test2.isEqual(new MockInstant()));        assertEquals(true, test1.isEqual(new MockInstant()));                assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isEqual(null));        assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isEqual(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isEqual(null));                assertEquals(false, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 8, 23, 59, 59, 999)));        assertEquals(true, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 9, 0, 0, 0, 0)));        assertEquals(false, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 9, 0, 0, 0, 1)));    }        public void testIsBefore() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(false, test1.isBefore(test1a));        assertEquals(false, test1a.isBefore(test1));        assertEquals(false, test1.isBefore(test1));        assertEquals(false, test1a.isBefore(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(true, test1.isBefore(test2));        assertEquals(false, test2.isBefore(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(true, test1.isBefore(test3));        assertEquals(false, test3.isBefore(test1));        assertEquals(true, test3.isBefore(test2));  // midnight paris before london                assertEquals(false, test2.isBefore(new MockInstant()));        assertEquals(false, test1.isBefore(new MockInstant()));                assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isBefore(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isBefore(null));        assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isBefore(null));                assertEquals(false, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 8, 23, 59, 59, 999)));        assertEquals(false, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 9, 0, 0, 0, 0)));        assertEquals(true, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 9, 0, 0, 0, 1)));    }        public void testIsAfter() {        DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);        DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC);        assertEquals(false, test1.isAfter(test1a));        assertEquals(false, test1a.isAfter(test1));        assertEquals(false, test1.isAfter(test1));        assertEquals(false, test1a.isAfter(test1a));                DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC);        assertEquals(false, test1.isAfter(test2));        assertEquals(true, test2.isAfter(test1));                DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance(PARIS));        assertEquals(false, test1.isAfter(test3));        assertEquals(true, test3.isAfter(test1));        assertEquals(false, test3.isAfter(test2));  // midnight paris before london                assertEquals(true, test2.isAfter(new MockInstant()));        assertEquals(false, test1.isAfter(new MockInstant()));                assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isAfter(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isAfter(null));        assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isAfter(null));                assertEquals(true, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 8, 23, 59, 59, 999)));        assertEquals(false, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 9, 0, 0, 0, 0)));        assertEquals(false, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 9, 0, 0, 0, 1)));    }        //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateMidnight result = (DateMidnight) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString());                test = new DateMidnight(TEST_TIME_NOW_UTC, PARIS);        assertEquals("2002-06-09T00:00:00.000+02:00", test.toString());                test = new DateMidnight(TEST_TIME_NOW_UTC, NEWYORK);        assertEquals("2002-06-08T00:00:00.000-04:00", test.toString());  // the 8th    }    public void testToString_String() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("2002 00", test.toString("yyyy HH"));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((String) null));    }    public void testToString_String_String() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH));        assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, Locale.ENGLISH));        assertEquals("Sun 9/6", test.toString("EEE d/M", null));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, null));    }    public void testToString_DTFormatter() {        DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);        assertEquals("2002 00", test.toString(DateTimeFormat.forPattern("yyyy HH")));        assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((DateTimeFormatter) null));    }    //-----------------------------------------------------------------------    public void testToInstant() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Instant result = test.toInstant();        assertEquals(TEST_TIME1_LONDON, result.getMillis());    }    public void testToDateMidnight() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());    }    public void testToDateTimeISO() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTimeISO();        assertSame(DateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDateTime_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(PARIS, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());    }    public void testToDateTime_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateTime result = test.toDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(LONDON, result.getZone());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime();        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTimeISO() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTimeISO();        assertSame(MutableDateTime.class, result.getClass());        assertSame(ISOChronology.class, result.getChronology().getClass());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime(LONDON);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime(PARIS);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime((DateTimeZone) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToMutableDateTime_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance());        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS));        assertEquals(test.getMillis(), result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());        test = new DateMidnight(TEST_TIME1_UTC);        result = test.toMutableDateTime((Chronology) null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());    }    public void testToDate() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Date result = test.toDate();        assertEquals(test.getMillis(), result.getTime());    }    public void testToCalendar_Locale() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        Calendar result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toCalendar(null);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toCalendar(Locale.UK);        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    public void testToGregorianCalendar() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        GregorianCalendar result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone());        test = new DateMidnight(TEST_TIME1_UTC, PARIS);        result = test.toGregorianCalendar();        assertEquals(test.getMillis(), result.getTime().getTime());        assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone());    }    //-----------------------------------------------------------------------    public void testToYearMonthDay() {        DateMidnight base = new DateMidnight(TEST_TIME1_UTC, CopticChronology.getInstance());        YearMonthDay test = base.toYearMonthDay();        assertEquals(new YearMonthDay(TEST_TIME1_UTC, CopticChronology.getInstance()), test);    }    public void testToInterval() {        DateMidnight base = new DateMidnight(TEST_TIME1_UTC, CopticChronology.getInstance());        Interval test = base.toInterval();        DateMidnight end = base.plus(Period.days(1));        assertEquals(new Interval(base, end), test);    }    //-----------------------------------------------------------------------    public void testWithMillis_long() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withMillis(TEST_TIME2_UTC);        assertEquals(TEST_TIME2_LONDON, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withMillis(TEST_TIME2_UTC);        assertEquals(TEST_TIME2_PARIS, result.getMillis());        assertEquals(test.getChronology(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withMillis(TEST_TIME1_UTC);        assertSame(test, result);    }    public void testWithChronology_Chronology() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withChronology(GregorianChronology.getInstance(PARIS));        assertEquals(TEST_TIME1_LONDON, test.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withChronology(null);        assertEquals(TEST_TIME1_PARIS, test.getMillis());        // midnight Paris is previous day in London        assertEquals(TEST_TIME1_LONDON - DateTimeConstants.MILLIS_PER_DAY, result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withChronology(null);        assertEquals(test.getMillis(), result.getMillis());        assertEquals(ISOChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withChronology(ISOChronology.getInstance());        assertSame(test, result);    }    public void testWithZoneRetainFields_DateTimeZone() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC);        DateMidnight result = test.withZoneRetainFields(PARIS);        assertEquals(TEST_TIME1_LONDON, test.getMillis());        assertEquals(TEST_TIME1_PARIS, result.getMillis());        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance(PARIS));        result = test.withZoneRetainFields(null);        assertEquals(TEST_TIME1_PARIS, test.getMillis());        assertEquals(TEST_TIME1_LONDON, result.getMillis());        assertEquals(GregorianChronology.getInstance(), result.getChronology());                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withZoneRetainFields(null);        assertSame(test, result);                test = new DateMidnight(TEST_TIME1_UTC, new MockNullZoneChronology());        result = test.withZoneRetainFields(LONDON);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithFields_RPartial() {        DateMidnight test = new DateMidnight(2004, 5, 6);        DateMidnight result = test.withFields(new YearMonthDay(2003, 4, 5));        DateMidnight expected = new DateMidnight(2003, 4, 5);        assertEquals(expected, result);                test = new DateMidnight(TEST_TIME1_UTC);        result = test.withFields(null);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithField1() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight result = test.withField(DateTimeFieldType.year(), 2006);                assertEquals(new DateMidnight(2004, 6, 9), test);        assertEquals(new DateMidnight(2006, 6, 9), result);    }    public void testWithField2() {        DateMidnight test = new DateMidnight(2004, 6, 9);        try {            test.withField(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testWithFieldAdded1() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight result = test.withFieldAdded(DurationFieldType.years(), 6);                assertEquals(new DateMidnight(2004, 6, 9), test);        assertEquals(new DateMidnight(2010, 6, 9), result);    }    public void testWithFieldAdded2() {        DateMidnight test = new DateMidnight(2004, 6, 9);        try {            test.withFieldAdded(null, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded3() {        DateMidnight test = new DateMidnight(2004, 6, 9);        try {            test.withFieldAdded(null, 6);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testWithFieldAdded4() {        DateMidnight test = new DateMidnight(2004, 6, 9);        DateMidnight result = test.withFieldAdded(DurationFieldType.years(), 0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_long_int() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BuddhistChronology.getInstance());        DateMidnight result = test.withDurationAdded(123456789L, 1);        DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, 0);        assertSame(test, result);                result = test.withDurationAdded(123456789L, 2);        expected = new DateMidnight(test.getMillis() + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(123456789L, -3);        expected = new DateMidnight(test.getMillis() - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }        //-----------------------------------------------------------------------    public void testWithDurationAdded_RD_int() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BuddhistChronology.getInstance());        DateMidnight result = test.withDurationAdded(new Duration(123456789L), 1);        DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(null, 1);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 0);        assertSame(test, result);                result = test.withDurationAdded(new Duration(123456789L), 2);        expected = new DateMidnight(test.getMillis() + (2L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withDurationAdded(new Duration(123456789L), -3);        expected = new DateMidnight(test.getMillis() - (3L * 123456789L), BuddhistChronology.getInstance());        assertEquals(expected, result);    }    //-----------------------------------------------------------------------    public void testWithDurationAdded_RP_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1);        DateMidnight expected = new DateMidnight(2003, 7, 28, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(null, 1);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0);        assertSame(test, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3);        expected = new DateMidnight(2005, 11, 15, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1);        expected = new DateMidnight(2001, 3, 1, BuddhistChronology.getInstance());        assertEquals(expected, result);    }    //-----------------------------------------------------------------------        public void testPlus_long() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BuddhistChronology.getInstance());        DateMidnight result = test.plus(123456789L);        DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);    }        public void testPlus_RD() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BuddhistChronology.getInstance());        DateMidnight result = test.plus(new Duration(123456789L));        DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadableDuration) null);        assertSame(test, result);    }    public void testPlus_RP() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));        DateMidnight expected = new DateMidnight(2003, 7, 28, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plus((ReadablePeriod) null);        assertSame(test, result);    }    public void testPlusYears_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.plusYears(1);        DateMidnight expected = new DateMidnight(2003, 5, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusYears(0);        assertSame(test, result);    }    public void testPlusMonths_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.plusMonths(1);        DateMidnight expected = new DateMidnight(2002, 6, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusMonths(0);        assertSame(test, result);    }    public void testPlusWeeks_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.plusWeeks(1);        DateMidnight expected = new DateMidnight(2002, 5, 10, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusWeeks(0);        assertSame(test, result);    }    public void testPlusDays_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.plusDays(1);        DateMidnight expected = new DateMidnight(2002, 5, 4, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.plusDays(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------        public void testMinus_long() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BuddhistChronology.getInstance());        DateMidnight result = test.minus(123456789L);        DateMidnight expected = new DateMidnight(test.getMillis() - 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);    }    public void testMinus_RD() {        DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BuddhistChronology.getInstance());        DateMidnight result = test.minus(new Duration(123456789L));        DateMidnight expected = new DateMidnight(test.getMillis() - 123456789L, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadableDuration) null);        assertSame(test, result);    }    public void testMinus_RP() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));        DateMidnight expected = new DateMidnight(2001, 3, 25, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minus((ReadablePeriod) null);        assertSame(test, result);    }    public void testMinusYears_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.minusYears(1);        DateMidnight expected = new DateMidnight(2001, 5, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusYears(0);        assertSame(test, result);    }    public void testMinusMonths_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.minusMonths(1);        DateMidnight expected = new DateMidnight(2002, 4, 3, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusMonths(0);        assertSame(test, result);    }    public void testMinusWeeks_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.minusWeeks(1);        DateMidnight expected = new DateMidnight(2002, 4, 26, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusWeeks(0);        assertSame(test, result);    }    public void testMinusDays_int() {        DateMidnight test = new DateMidnight(2002, 5, 3, BuddhistChronology.getInstance());        DateMidnight result = test.minusDays(1);        DateMidnight expected = new DateMidnight(2002, 5, 2, BuddhistChronology.getInstance());        assertEquals(expected, result);                result = test.minusDays(0);        assertSame(test, result);    }    //-----------------------------------------------------------------------    public void testProperty() {        DateMidnight test = new DateMidnight();        assertEquals(test.year(), test.property(DateTimeFieldType.year()));        assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));        assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear()));        assertEquals(test.property(DateTimeFieldType.millisOfSecond()), test.property(DateTimeFieldType.millisOfSecond()));        DateTimeFieldType bad = new DateTimeFieldType("bad") {            public DurationFieldType getDurationType() {                return DurationFieldType.weeks();            }            public DurationFieldType getRangeDurationType() {                return null;            }            public DateTimeField getField(Chronology chronology) {                return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType()));            }        };        try {            test.property(bad);            fail();        } catch (IllegalArgumentException ex) {}        try {            test.property(null);            fail();        } catch (IllegalArgumentException ex) {}    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import org.joda.time.base.AbstractDateTime;import org.joda.time.base.AbstractInstant;/** * This class displays what the ClassLoader is up to. * Run using JVM -verbose:class. * * @author Stephen Colebourne */public class ClassLoadTest {    // run using JVM -verbose:class    public static void main(String[] args) {        System.out.println("-----------------------------------------------");        System.out.println("-----------AbstractInstant---------------------");        Class cls = AbstractInstant.class;        System.out.println("-----------ReadableDateTime--------------------");        cls = ReadableDateTime.class;        System.out.println("-----------AbstractDateTime--------------------");        cls = AbstractDateTime.class;        System.out.println("-----------DateTime----------------------------");        cls = DateTime.class;        System.out.println("-----------DateTimeZone------------------------");        cls = DateTimeZone.class;        System.out.println("-----------new DateTime()----------------------");        DateTime dt = new DateTime();        System.out.println("-----------new DateTime(ReadableInstant)-------");        dt = new DateTime(dt);        System.out.println("-----------new DateTime(Long)------------------");        dt = new DateTime(new Long(0));        System.out.println("-----------------------------------------------");    }    }
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.GregorianChronology;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for MutableDateTime. * * @author Stephen Colebourne */public class TestMutableDateTime_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableDateTime_Constructors.class);    }    public TestMutableDateTime_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        java.util.TimeZone.setDefault(LONDON.toTimeZone());        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        java.util.TimeZone.setDefault(zone.toTimeZone());        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        MutableDateTime test = new MutableDateTime();        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone)     */    public void testConstructor_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (DateTimeZone=null)     */    public void testConstructor_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology)     */    public void testConstructor_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Chronology=null)     */    public void testConstructor_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long1_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone)     */    public void testConstructor_long2_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, DateTimeZone=null)     */    public void testConstructor_long_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long1_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long, Chronology)     */    public void testConstructor_long2_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    /**     * Test constructor (long, Chronology=null)     */    public void testConstructor_long_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime(TEST_TIME1, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new MutableDateTime(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0));            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_Object_DateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_invalidObject_DateTimeZone() throws Throwable {        try {            new MutableDateTime(new Object(), PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, DateTimeZone)     */    public void testConstructor_nullObject_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, PARIS);        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone=null)     */    public void testConstructor_Object_nullDateTimeZone() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, DateTimeZone=null)     */    public void testConstructor_nullObject_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, (DateTimeZone) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, DateTimeZone)     */    public void testConstructor_badconverterObject_DateTimeZone() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_Object_Chronology() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_invalidObject_Chronology() throws Throwable {        try {            new MutableDateTime(new Object(), GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null, Chronology)     */    public void testConstructor_nullObject_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, GregorianChronology.getInstance());        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology=null)     */    public void testConstructor_Object_nullChronology() throws Throwable {        Date date = new Date(TEST_TIME1);        MutableDateTime test = new MutableDateTime(date, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object=null, Chronology=null)     */    public void testConstructor_nullObject_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime((Object) null, (Chronology) null);        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object, Chronology)     */    public void testConstructor_badconverterObject_Chronology() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());            assertEquals(ISOChronology.getInstance(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }    //-----------------------------------------------------------------------    /**     * Test constructor (int, int, int)     */    public void testConstructor_int_int_int_int_int_int_int() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(LONDON, test.getZone());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0);        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone)     */    public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);  // +02:00        assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, DateTimeZone=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (int, int, int, Chronology)     */    public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());  // +01:00        assertEquals(GregorianChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());        try {            new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        try {            new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}        new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());        try {            new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (int, int, int, Chronology=null)     */    public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable {        MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);  // +01:00        assertEquals(ISOChronology.getInstance(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Date;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.ISOChronology;import org.joda.time.convert.ConverterManager;import org.joda.time.convert.MockZeroNullIntegerConverter;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestInstant_Constructors extends TestCase {    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        // 1970-06-09    private long TEST_TIME_NOW =            (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 1970-04-05    private long TEST_TIME1 =        (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 12L * DateTimeConstants.MILLIS_PER_HOUR        + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 1971-05-06    private long TEST_TIME2 =        (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY        + 14L * DateTimeConstants.MILLIS_PER_HOUR        + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone zone = null;    private Locale locale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestInstant_Constructors.class);    }    public TestInstant_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        zone = DateTimeZone.getDefault();        locale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        java.util.TimeZone.setDefault(LONDON.toTimeZone());        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(zone);        java.util.TimeZone.setDefault(zone.toTimeZone());        Locale.setDefault(locale);        zone = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor() throws Throwable {        Instant test = new Instant();        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (long)     */    public void testConstructor_long1() throws Throwable {        Instant test = new Instant(TEST_TIME1);        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (long)     */    public void testConstructor_long2() throws Throwable {        Instant test = new Instant(TEST_TIME2);        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());        assertEquals(TEST_TIME2, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object() throws Throwable {        Date date = new Date(TEST_TIME1);        Instant test = new Instant(date);        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());        assertEquals(TEST_TIME1, test.getMillis());    }    /**     * Test constructor (Object)     */    public void testConstructor_invalidObject() throws Throwable {        try {            new Instant(new Object());            fail();        } catch (IllegalArgumentException ex) {}    }    /**     * Test constructor (Object=null)     */    public void testConstructor_nullObject() throws Throwable {        Instant test = new Instant((Object) null);        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());        assertEquals(TEST_TIME_NOW, test.getMillis());    }    /**     * Test constructor (Object=null)     */    public void testConstructor_badconverterObject() throws Throwable {        try {            ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);            Instant test = new Instant(new Integer(0));            assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());            assertEquals(0L, test.getMillis());        } finally {            ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);        }    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.PrintStream;import java.lang.reflect.Modifier;import java.security.AllPermission;import java.security.CodeSource;import java.security.Permission;import java.security.PermissionCollection;import java.security.Permissions;import java.security.Policy;import java.security.ProtectionDomain;import java.util.Date;import java.util.HashSet;import java.util.Locale;import java.util.Set;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.tz.DefaultNameProvider;import org.joda.time.tz.NameProvider;import org.joda.time.tz.Provider;import org.joda.time.tz.UTCProvider;import org.joda.time.tz.ZoneInfoProvider;/** * This class is a JUnit test for DateTimeZone. * * @author Stephen Colebourne */public class TestDateTimeZone extends TestCase {    private static final boolean OLD_JDK;    static {        String str = System.getProperty("java.version");        boolean old = true;        if (str.length() > 3 &&            str.charAt(0) == '1' &&            str.charAt(1) == '.' &&            (str.charAt(2) == '4' || str.charAt(2) == '5' || str.charAt(2) == '6')) {            old = false;        }        OLD_JDK = old;    }        // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_SUMMER =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-01-09    private long TEST_TIME_WINTER =            (y2002days + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05 Fri    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06 Tue    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private static final Policy RESTRICT;    private static final Policy ALLOW;    static {        // don't call Policy.getPolicy()        RESTRICT = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }            public boolean implies(ProtectionDomain domain, Permission permission) {                if (permission instanceof JodaTimePermission) {                    return false;                }                return true;//                return super.implies(domain, permission);            }        };        ALLOW = new Policy() {            public PermissionCollection getPermissions(CodeSource codesource) {                Permissions p = new Permissions();                p.add(new AllPermission());  // enable everything                return p;            }            public void refresh() {            }        };    }        private DateTimeZone zone;    private Locale locale;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestDateTimeZone.class);    }    public TestDateTimeZone(String name) {        super(name);    }    protected void setUp() throws Exception {        locale = Locale.getDefault();        zone = DateTimeZone.getDefault();        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        Locale.setDefault(locale);        DateTimeZone.setDefault(zone);    }    //-----------------------------------------------------------------------    public void testDefault() {        assertNotNull(DateTimeZone.getDefault());                DateTimeZone.setDefault(PARIS);        assertSame(PARIS, DateTimeZone.getDefault());                try {            DateTimeZone.setDefault(null);            fail();        } catch (IllegalArgumentException ex) {}    }                public void testDefaultSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setDefault(PARIS);            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    //-----------------------------------------------------------------------    public void testForID_String() {        assertEquals(DateTimeZone.getDefault(), DateTimeZone.forID((String) null));                DateTimeZone zone = DateTimeZone.forID("Europe/London");        assertEquals("Europe/London", zone.getID());                zone = DateTimeZone.forID("UTC");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.forID("+00:00");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.forID("+00");        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.forID("+01:23");        assertEquals("+01:23", zone.getID());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),                zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.forID("-02:00");        assertEquals("-02:00", zone.getID());        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR),                zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.forID("-07:05:34.0");        assertEquals("-07:05:34", zone.getID());        assertEquals((-7L * DateTimeConstants.MILLIS_PER_HOUR) +                    (-5L * DateTimeConstants.MILLIS_PER_MINUTE) +                    (-34L * DateTimeConstants.MILLIS_PER_SECOND),                    zone.getOffset(TEST_TIME_SUMMER));                try {            DateTimeZone.forID("SST");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.forID("Europe/UK");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.forID("+");            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.forID("+0");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testForOffsetHours_int() {        assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHours(0));        assertEquals(DateTimeZone.forID("+03:00"), DateTimeZone.forOffsetHours(3));        assertEquals(DateTimeZone.forID("-02:00"), DateTimeZone.forOffsetHours(-2));        try {            DateTimeZone.forOffsetHours(999999);            fail();        } catch (IllegalArgumentException ex) {}    }            //-----------------------------------------------------------------------    public void testForOffsetHoursMinutes_int_int() {        assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));        assertEquals(DateTimeZone.forID("+03:15"), DateTimeZone.forOffsetHoursMinutes(3, 15));        assertEquals(DateTimeZone.forID("-02:00"), DateTimeZone.forOffsetHoursMinutes(-2, 0));        assertEquals(DateTimeZone.forID("-02:30"), DateTimeZone.forOffsetHoursMinutes(-2, 30));        try {            DateTimeZone.forOffsetHoursMinutes(2, 60);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.forOffsetHoursMinutes(-2, 60);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.forOffsetHoursMinutes(2, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.forOffsetHoursMinutes(-2, -1);            fail();        } catch (IllegalArgumentException ex) {}        try {            DateTimeZone.forOffsetHoursMinutes(999999, 0);            fail();        } catch (IllegalArgumentException ex) {}    }            //-----------------------------------------------------------------------    public void testForOffsetMillis_int() {        assertSame(DateTimeZone.UTC, DateTimeZone.forOffsetMillis(0));        assertEquals(DateTimeZone.forID("+03:00"), DateTimeZone.forOffsetMillis(3 * 60 * 60 * 1000));        assertEquals(DateTimeZone.forID("-02:00"), DateTimeZone.forOffsetMillis(-2 * 60 * 60 * 1000));        assertEquals(DateTimeZone.forID("+04:45:17.045"),                DateTimeZone.forOffsetMillis(                        4 * 60 * 60 * 1000 + 45 * 60 * 1000 + 17 * 1000 + 45));    }            //-----------------------------------------------------------------------    public void testForTimeZone_TimeZone() {        assertEquals(DateTimeZone.getDefault(), DateTimeZone.forTimeZone((TimeZone) null));                DateTimeZone zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("Europe/London"));        assertEquals("Europe/London", zone.getID());        assertSame(DateTimeZone.UTC, DateTimeZone.forTimeZone(TimeZone.getTimeZone("UTC")));                zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+00:00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+00"));        assertSame(DateTimeZone.UTC, zone);                zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+01:23"));        assertEquals("+01:23", zone.getID());        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),                zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT-02:00"));        assertEquals("-02:00", zone.getID());        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER));                zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("EST"));        assertEquals("America/New_York", zone.getID());    }    //-----------------------------------------------------------------------    public void testGetAvailableIDs() {        assertTrue(DateTimeZone.getAvailableIDs().contains("UTC"));    }    //-----------------------------------------------------------------------    public void testProvider() {        try {            assertNotNull(DateTimeZone.getProvider());                    Provider provider = DateTimeZone.getProvider();            DateTimeZone.setProvider(null);            assertEquals(provider.getClass(), DateTimeZone.getProvider().getClass());                    try {                DateTimeZone.setProvider(new MockNullIDSProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockEmptyIDSProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockNoUTCProvider());                fail();            } catch (IllegalArgumentException ex) {}            try {                DateTimeZone.setProvider(new MockBadUTCProvider());                fail();            } catch (IllegalArgumentException ex) {}                    Provider prov = new MockOKProvider();            DateTimeZone.setProvider(prov);            assertSame(prov, DateTimeZone.getProvider());            assertEquals(2, DateTimeZone.getAvailableIDs().size());            assertTrue(DateTimeZone.getAvailableIDs().contains("UTC"));            assertTrue(DateTimeZone.getAvailableIDs().contains("Europe/London"));        } finally {            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }                try {            System.setProperty("org.joda.time.DateTimeZone.Provider", "org.joda.time.tz.UTCProvider");            DateTimeZone.setProvider(null);            assertEquals(UTCProvider.class, DateTimeZone.getProvider().getClass());        } finally {            System.getProperties().remove("org.joda.time.DateTimeZone.Provider");            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }                PrintStream syserr = System.err;        try {            System.setProperty("org.joda.time.DateTimeZone.Provider", "xxx");            ByteArrayOutputStream baos = new ByteArrayOutputStream();            System.setErr(new PrintStream(baos));                        DateTimeZone.setProvider(null);                        assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());            String str = new String(baos.toByteArray());            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);        } finally {            System.setErr(syserr);            System.getProperties().remove("org.joda.time.DateTimeZone.Provider");            DateTimeZone.setProvider(null);            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());        }    }        public void testProviderSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setProvider(new MockOKProvider());            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    static class MockNullIDSProvider implements Provider {        public Set getAvailableIDs() {            return null;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockEmptyIDSProvider implements Provider {        public Set getAvailableIDs() {            return new HashSet();        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockNoUTCProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockBadUTCProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("UTC");            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return null;        }    }    static class MockOKProvider implements Provider {        public Set getAvailableIDs() {            Set set = new HashSet();            set.add("UTC");            set.add("Europe/London");            return set;        }        public DateTimeZone getZone(String id) {            return DateTimeZone.UTC;        }    }    //-----------------------------------------------------------------------    public void testNameProvider() {        try {            assertNotNull(DateTimeZone.getNameProvider());                    NameProvider provider = DateTimeZone.getNameProvider();            DateTimeZone.setNameProvider(null);            assertEquals(provider.getClass(), DateTimeZone.getNameProvider().getClass());                    provider = new MockOKButNullNameProvider();            DateTimeZone.setNameProvider(provider);            assertSame(provider, DateTimeZone.getNameProvider());                        assertEquals("+00:00", DateTimeZone.UTC.getShortName(TEST_TIME_SUMMER));            assertEquals("+00:00", DateTimeZone.UTC.getName(TEST_TIME_SUMMER));        } finally {            DateTimeZone.setNameProvider(null);        }                try {            System.setProperty("org.joda.time.DateTimeZone.NameProvider", "org.joda.time.tz.DefaultNameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        } finally {            System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        }                PrintStream syserr = System.err;        try {            System.setProperty("org.joda.time.DateTimeZone.NameProvider", "xxx");            ByteArrayOutputStream baos = new ByteArrayOutputStream();            System.setErr(new PrintStream(baos));                        DateTimeZone.setNameProvider(null);                        assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());            String str = new String(baos.toByteArray());            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);        } finally {            System.setErr(syserr);            System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider");            DateTimeZone.setNameProvider(null);            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());        }    }                public void testNameProviderSecurity() {        if (OLD_JDK) {            return;        }        try {            Policy.setPolicy(RESTRICT);            System.setSecurityManager(new SecurityManager());            DateTimeZone.setNameProvider(new MockOKButNullNameProvider());            fail();        } catch (SecurityException ex) {            // ok        } finally {            System.setSecurityManager(null);            Policy.setPolicy(ALLOW);        }    }    static class MockOKButNullNameProvider implements NameProvider {        public String getShortName(Locale locale, String id, String nameKey) {            return null;        }        public String getName(Locale locale, String id, String nameKey) {            return null;        }    }    //-----------------------------------------------------------------------    public void testConstructor() {        assertEquals(1, DateTimeZone.class.getDeclaredConstructors().length);        assertTrue(Modifier.isProtected(DateTimeZone.class.getDeclaredConstructors()[0].getModifiers()));        try {            new DateTimeZone(null) {                public String getNameKey(long instant) {                    return null;                }                public int getOffset(long instant) {                    return 0;                }                public int getStandardOffset(long instant) {                    return 0;                }                public boolean isFixed() {                    return false;                }                public long nextTransition(long instant) {                    return 0;                }                public long previousTransition(long instant) {                    return 0;                }                public boolean equals(Object object) {                    return false;                }            };        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testGetID() {        DateTimeZone zone = DateTimeZone.forID("Europe/Paris");        assertEquals("Europe/Paris", zone.getID());    }    public void testGetNameKey() {        DateTimeZone zone = DateTimeZone.forID("Europe/London");        assertEquals("BST", zone.getNameKey(TEST_TIME_SUMMER));        assertEquals("GMT", zone.getNameKey(TEST_TIME_WINTER));    }    public void testGetShortName() {        DateTimeZone zone = DateTimeZone.forID("Europe/London");        assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER));        assertEquals("GMT", zone.getShortName(TEST_TIME_WINTER));        assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));    }                public void testGetShortNameProviderName() {        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, "Europe/London", "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, null, "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, "Europe/London", null));        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, null, null));    }        public void testGetShortNameNullKey() {        DateTimeZone zone = new MockDateTimeZone("Europe/London");        assertEquals("Europe/London", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));    }        public void testGetName() {        DateTimeZone zone = DateTimeZone.forID("Europe/London");        assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER));        assertEquals("Greenwich Mean Time", zone.getName(TEST_TIME_WINTER));        assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));            }        public void testGetNameProviderName() {        assertEquals(null, DateTimeZone.getNameProvider().getName(null, "Europe/London", "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, null, "BST"));        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, "Europe/London", null));        assertEquals(null, DateTimeZone.getNameProvider().getName(null, null, null));    }        public void testGetNameNullKey() {        DateTimeZone zone = new MockDateTimeZone("Europe/London");        assertEquals("Europe/London", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));    }        static class MockDateTimeZone extends DateTimeZone {        public MockDateTimeZone(String id) {            super(id);        }        public String getNameKey(long instant) {            return null;  // null        }        public int getOffset(long instant) {            return 0;        }        public int getStandardOffset(long instant) {            return 0;        }        public boolean isFixed() {            return false;        }        public long nextTransition(long instant) {            return 0;        }        public long previousTransition(long instant) {            return 0;        }        public boolean equals(Object object) {            return false;        }    }    //-----------------------------------------------------------------------    public void testGetOffset() {        DateTimeZone zone = DateTimeZone.forID("Europe/Paris");        assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));                assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));                assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));                assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));    }    public void testGetOffsetFixed() {        DateTimeZone zone = DateTimeZone.forID("+01:00");        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));                assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));                assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));    }    //-----------------------------------------------------------------------    public void testGetMillisKeepLocal() {        long millisLondon = TEST_TIME_SUMMER;        long millisParis = TEST_TIME_SUMMER - 1L * DateTimeConstants.MILLIS_PER_HOUR;                assertEquals(millisParis, LONDON.getMillisKeepLocal(PARIS, millisLondon));        assertEquals(millisLondon, PARIS.getMillisKeepLocal(LONDON, millisParis));                DateTimeZone zone = DateTimeZone.getDefault();        try {            DateTimeZone.setDefault(LONDON);            assertEquals(millisLondon, PARIS.getMillisKeepLocal(null, millisParis));        } finally {            DateTimeZone.setDefault(zone);        }    }    //-----------------------------------------------------------------------    public void testGetMillisJDKKeepLocal() {        TimeZone jdkZone = TimeZone.getDefault();        try {            TimeZone.setDefault(TimeZone.getTimeZone("Europe/Paris"));            DateTime dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, PARIS);            Date date = new Date(70, 0, 1, 2, 30, 0);  // same field values                        assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(dt.getMillis()));            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(PARIS.toTimeZone(), dt.getMillis()));            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(null, dt.getMillis()));                        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));            dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, LONDON);            date = new Date(70, 0, 1, 2, 30, 0);  // same field values                        assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(dt.getMillis()));            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(LONDON.toTimeZone(), dt.getMillis()));            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(null, dt.getMillis()));                    } finally {            TimeZone.setDefault(jdkZone);        }    }    //-----------------------------------------------------------------------    public void testIsFixed() {        DateTimeZone zone = DateTimeZone.forID("Europe/Paris");        assertEquals(false, zone.isFixed());        assertEquals(true, DateTimeZone.UTC.isFixed());    }    //-----------------------------------------------------------------------    public void testTransitionFixed() {        DateTimeZone zone = DateTimeZone.forID("+01:00");        assertEquals(TEST_TIME_SUMMER, zone.nextTransition(TEST_TIME_SUMMER));        assertEquals(TEST_TIME_WINTER, zone.nextTransition(TEST_TIME_WINTER));        assertEquals(TEST_TIME_SUMMER, zone.previousTransition(TEST_TIME_SUMMER));        assertEquals(TEST_TIME_WINTER, zone.previousTransition(TEST_TIME_WINTER));    }    //-----------------------------------------------------------------------    public void testToTimeZone() {        DateTimeZone zone = DateTimeZone.forID("Europe/Paris");        TimeZone tz = zone.toTimeZone();        assertEquals("Europe/Paris", tz.getID());    }    //-----------------------------------------------------------------------    public void testEqualsHashCode() {        DateTimeZone zone1 = DateTimeZone.forID("Europe/Paris");        DateTimeZone zone2 = DateTimeZone.forID("Europe/Paris");        assertEquals(true, zone1.equals(zone1));        assertEquals(true, zone1.equals(zone2));        assertEquals(true, zone2.equals(zone1));        assertEquals(true, zone2.equals(zone2));        assertEquals(true, zone1.hashCode() == zone2.hashCode());                DateTimeZone zone3 = DateTimeZone.forID("Europe/London");        assertEquals(true, zone3.equals(zone3));        assertEquals(false, zone1.equals(zone3));        assertEquals(false, zone2.equals(zone3));        assertEquals(false, zone3.equals(zone1));        assertEquals(false, zone3.equals(zone2));        assertEquals(false, zone1.hashCode() == zone3.hashCode());        assertEquals(true, zone3.hashCode() == zone3.hashCode());                DateTimeZone zone4 = DateTimeZone.forID("+01:00");        assertEquals(true, zone4.equals(zone4));        assertEquals(false, zone1.equals(zone4));        assertEquals(false, zone2.equals(zone4));        assertEquals(false, zone3.equals(zone4));        assertEquals(false, zone4.equals(zone1));        assertEquals(false, zone4.equals(zone2));        assertEquals(false, zone4.equals(zone3));        assertEquals(false, zone1.hashCode() == zone4.hashCode());        assertEquals(true, zone4.hashCode() == zone4.hashCode());                DateTimeZone zone5 = DateTimeZone.forID("+02:00");        assertEquals(true, zone5.equals(zone5));        assertEquals(false, zone1.equals(zone5));        assertEquals(false, zone2.equals(zone5));        assertEquals(false, zone3.equals(zone5));        assertEquals(false, zone4.equals(zone5));        assertEquals(false, zone5.equals(zone1));        assertEquals(false, zone5.equals(zone2));        assertEquals(false, zone5.equals(zone3));        assertEquals(false, zone5.equals(zone4));        assertEquals(false, zone1.hashCode() == zone5.hashCode());        assertEquals(true, zone5.hashCode() == zone5.hashCode());    }    //-----------------------------------------------------------------------    public void testToString() {        DateTimeZone zone = DateTimeZone.forID("Europe/Paris");        assertEquals("Europe/Paris", zone.toString());        assertEquals("UTC", DateTimeZone.UTC.toString());    }    //-----------------------------------------------------------------------    public void testSerialization1() throws Exception {        DateTimeZone zone = DateTimeZone.forID("Europe/Paris");                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(zone);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeZone result = (DateTimeZone) ois.readObject();        ois.close();                assertSame(zone, result);    }    //-----------------------------------------------------------------------    public void testSerialization2() throws Exception {        DateTimeZone zone = DateTimeZone.forID("+01:00");                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(zone);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        DateTimeZone result = (DateTimeZone) ois.readObject();        ois.close();                assertSame(zone, result);    }    public void testCommentParse() throws Exception {        // A bug in ZoneInfoCompiler's handling of comments broke Europe/Athens        // after 1980. This test is included to make sure it doesn't break again.        DateTimeZone zone = DateTimeZone.forID("Europe/Athens");        DateTime dt = new DateTime(2005, 5, 5, 20, 10, 15, 0, zone);        assertEquals(1115313015000L, dt.getMillis());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;/** * This class is a JUnit test for PeriodType. * * @author Stephen Colebourne */public class TestPeriodType extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestPeriodType.class);    }    public TestPeriodType(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    private void assertEqualsAfterSerialization(PeriodType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        PeriodType result = (PeriodType) ois.readObject();        ois.close();                assertEquals(type, result);    }    private void assertSameAfterSerialization(PeriodType type) throws Exception {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(type);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        PeriodType result = (PeriodType) ois.readObject();        ois.close();                assertEquals(type, result);    }    //-----------------------------------------------------------------------    public void testStandard() throws Exception {        PeriodType type = PeriodType.standard();        assertEquals(8, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));        assertEquals(DurationFieldType.seconds(), type.getFieldType(6));        assertEquals(DurationFieldType.millis(), type.getFieldType(7));        assertEquals("Standard", type.getName());        assertEquals("PeriodType[Standard]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.standard());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearMonthDayTime() throws Exception {        PeriodType type = PeriodType.yearMonthDayTime();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals("YearMonthDayTime", type.getName());        assertEquals("PeriodType[YearMonthDayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearMonthDayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearMonthDayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearMonthDay() throws Exception {        PeriodType type = PeriodType.yearMonthDay();        assertEquals(3, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals("YearMonthDay", type.getName());        assertEquals("PeriodType[YearMonthDay]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearMonthDay());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearMonthDay().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearWeekDayTime() throws Exception {        PeriodType type = PeriodType.yearWeekDayTime();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals("YearWeekDayTime", type.getName());        assertEquals("PeriodType[YearWeekDayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearWeekDayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearWeekDayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearWeekDay() throws Exception {        PeriodType type = PeriodType.yearWeekDay();        assertEquals(3, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals("YearWeekDay", type.getName());        assertEquals("PeriodType[YearWeekDay]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearWeekDay());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearWeekDay().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearDayTime() throws Exception {        PeriodType type = PeriodType.yearDayTime();        assertEquals(6, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.days(), type.getFieldType(1));        assertEquals(DurationFieldType.hours(), type.getFieldType(2));        assertEquals(DurationFieldType.minutes(), type.getFieldType(3));        assertEquals(DurationFieldType.seconds(), type.getFieldType(4));        assertEquals(DurationFieldType.millis(), type.getFieldType(5));        assertEquals("YearDayTime", type.getName());        assertEquals("PeriodType[YearDayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearDayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearDayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYearDay() throws Exception {        PeriodType type = PeriodType.yearDay();        assertEquals(2, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.days(), type.getFieldType(1));        assertEquals("YearDay", type.getName());        assertEquals("PeriodType[YearDay]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.yearDay());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.yearDay().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testDayTime() throws Exception {        PeriodType type = PeriodType.dayTime();        assertEquals(5, type.size());        assertEquals(DurationFieldType.days(), type.getFieldType(0));        assertEquals(DurationFieldType.hours(), type.getFieldType(1));        assertEquals(DurationFieldType.minutes(), type.getFieldType(2));        assertEquals(DurationFieldType.seconds(), type.getFieldType(3));        assertEquals(DurationFieldType.millis(), type.getFieldType(4));        assertEquals("DayTime", type.getName());        assertEquals("PeriodType[DayTime]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.dayTime());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.dayTime().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testTime() throws Exception {        PeriodType type = PeriodType.time();        assertEquals(4, type.size());        assertEquals(DurationFieldType.hours(), type.getFieldType(0));        assertEquals(DurationFieldType.minutes(), type.getFieldType(1));        assertEquals(DurationFieldType.seconds(), type.getFieldType(2));        assertEquals(DurationFieldType.millis(), type.getFieldType(3));        assertEquals("Time", type.getName());        assertEquals("PeriodType[Time]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.time());        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.time().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testYears() throws Exception {        PeriodType type = PeriodType.years();        assertEquals(1, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals("Years", type.getName());        assertEquals("PeriodType[Years]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.years());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.years().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMonths() throws Exception {        PeriodType type = PeriodType.months();        assertEquals(1, type.size());        assertEquals(DurationFieldType.months(), type.getFieldType(0));        assertEquals("Months", type.getName());        assertEquals("PeriodType[Months]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.months());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.months().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testWeeks() throws Exception {        PeriodType type = PeriodType.weeks();        assertEquals(1, type.size());        assertEquals(DurationFieldType.weeks(), type.getFieldType(0));        assertEquals("Weeks", type.getName());        assertEquals("PeriodType[Weeks]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.weeks());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.weeks().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testDays() throws Exception {        PeriodType type = PeriodType.days();        assertEquals(1, type.size());        assertEquals(DurationFieldType.days(), type.getFieldType(0));        assertEquals("Days", type.getName());        assertEquals("PeriodType[Days]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.days());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.days().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testHours() throws Exception {        PeriodType type = PeriodType.hours();        assertEquals(1, type.size());        assertEquals(DurationFieldType.hours(), type.getFieldType(0));        assertEquals("Hours", type.getName());        assertEquals("PeriodType[Hours]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.hours());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.hours().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMinutes() throws Exception {        PeriodType type = PeriodType.minutes();        assertEquals(1, type.size());        assertEquals(DurationFieldType.minutes(), type.getFieldType(0));        assertEquals("Minutes", type.getName());        assertEquals("PeriodType[Minutes]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.minutes());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.minutes().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testSeconds() throws Exception {        PeriodType type = PeriodType.seconds();        assertEquals(1, type.size());        assertEquals(DurationFieldType.seconds(), type.getFieldType(0));        assertEquals("Seconds", type.getName());        assertEquals("PeriodType[Seconds]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.seconds());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.seconds().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMillis() throws Exception {        PeriodType type = PeriodType.millis();        assertEquals(1, type.size());        assertEquals(DurationFieldType.millis(), type.getFieldType(0));        assertEquals("Millis", type.getName());        assertEquals("PeriodType[Millis]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.millis());        assertEquals(false, type.equals(PeriodType.standard()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.millis().hashCode());        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());        assertSameAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testForFields1() throws Exception {        PeriodType type = PeriodType.forFields(new DurationFieldType[] {            DurationFieldType.years(),        });        assertSame(PeriodType.years(), type);        type = PeriodType.forFields(new DurationFieldType[] {            DurationFieldType.months(),        });        assertSame(PeriodType.months(), type);        type = PeriodType.forFields(new DurationFieldType[] {                DurationFieldType.weeks(),        });        assertSame(PeriodType.weeks(), type);        type = PeriodType.forFields(new DurationFieldType[] {                DurationFieldType.days(),        });        assertSame(PeriodType.days(), type);        type = PeriodType.forFields(new DurationFieldType[] {                DurationFieldType.hours(),        });        assertSame(PeriodType.hours(), type);        type = PeriodType.forFields(new DurationFieldType[] {                DurationFieldType.minutes(),        });        assertSame(PeriodType.minutes(), type);        type = PeriodType.forFields(new DurationFieldType[] {                DurationFieldType.seconds(),        });        assertSame(PeriodType.seconds(), type);        type = PeriodType.forFields(new DurationFieldType[] {                DurationFieldType.millis(),        });        assertSame(PeriodType.millis(), type);    }    public void testForFields2() throws Exception {        DurationFieldType[] types = new DurationFieldType[] {            DurationFieldType.years(),            DurationFieldType.hours(),        };        PeriodType type = PeriodType.forFields(types);        assertEquals(2, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.hours(), type.getFieldType(1));        assertEquals("StandardNoMonthsNoWeeksNoDaysNoMinutesNoSecondsNoMillis", type.getName());        assertEquals("PeriodType[StandardNoMonthsNoWeeksNoDaysNoMinutesNoSecondsNoMillis]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.forFields(types));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.forFields(types).hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    public void testForFields3() throws Exception {        DurationFieldType[] types = new DurationFieldType[] {            DurationFieldType.months(),            DurationFieldType.weeks(),        };        PeriodType type = PeriodType.forFields(types);        assertEquals(2, type.size());        assertEquals(DurationFieldType.months(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals("StandardNoYearsNoDaysNoHoursNoMinutesNoSecondsNoMillis", type.getName());        assertEquals("PeriodType[StandardNoYearsNoDaysNoHoursNoMinutesNoSecondsNoMillis]", type.toString());        assertEquals(true, type.equals(type));        assertEquals(true, type == PeriodType.forFields(types));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.forFields(types).hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertSameAfterSerialization(type);    }    public void testForFields4() throws Exception {        DurationFieldType[] types = new DurationFieldType[] {            DurationFieldType.weeks(),            DurationFieldType.months(),        };        DurationFieldType[] types2 = new DurationFieldType[] {            DurationFieldType.months(),            DurationFieldType.weeks(),        };        PeriodType type = PeriodType.forFields(types);        PeriodType type2 = PeriodType.forFields(types2);        assertEquals(true, type == type2);    }    public void testForFields5() throws Exception {        DurationFieldType[] types = new DurationFieldType[] {            DurationFieldType.centuries(),            DurationFieldType.months(),        };        try {            PeriodType.forFields(types);            fail();        } catch (IllegalArgumentException ex) {            // expected        }        try {            PeriodType.forFields(types);  // repeated for test coverage of cache            fail();        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testForFields6() throws Exception {        DurationFieldType[] types = null;        try {            PeriodType.forFields(types);            fail();        } catch (IllegalArgumentException ex) {            // expected        }                types = new DurationFieldType[0];        try {            PeriodType.forFields(types);            fail();        } catch (IllegalArgumentException ex) {            // expected        }                types = new DurationFieldType[] {            null,            DurationFieldType.months(),        };        try {            PeriodType.forFields(types);            fail();        } catch (IllegalArgumentException ex) {            // expected        }                types = new DurationFieldType[] {            DurationFieldType.months(),            null,        };        try {            PeriodType.forFields(types);            fail();        } catch (IllegalArgumentException ex) {            // expected        }    }    //-----------------------------------------------------------------------    public void testMaskYears() throws Exception {        PeriodType type = PeriodType.standard().withYearsRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.months(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withYearsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withYearsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoYears", type.getName());        assertEquals("PeriodType[StandardNoYears]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMonths() throws Exception {        PeriodType type = PeriodType.standard().withMonthsRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withMonthsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withMonthsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoMonths", type.getName());        assertEquals("PeriodType[StandardNoMonths]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskWeeks() throws Exception {        PeriodType type = PeriodType.standard().withWeeksRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.days(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withWeeksRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withWeeksRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoWeeks", type.getName());        assertEquals("PeriodType[StandardNoWeeks]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskDays() throws Exception {        PeriodType type = PeriodType.standard().withDaysRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.hours(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withDaysRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withDaysRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoDays", type.getName());        assertEquals("PeriodType[StandardNoDays]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskHours() throws Exception {        PeriodType type = PeriodType.standard().withHoursRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoHours", type.getName());        assertEquals("PeriodType[StandardNoHours]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMinutes() throws Exception {        PeriodType type = PeriodType.standard().withMinutesRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withMinutesRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withMinutesRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoMinutes", type.getName());        assertEquals("PeriodType[StandardNoMinutes]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskSeconds() throws Exception {        PeriodType type = PeriodType.standard().withSecondsRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));        assertEquals(DurationFieldType.millis(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withSecondsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withSecondsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoSeconds", type.getName());        assertEquals("PeriodType[StandardNoSeconds]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskMillis() throws Exception {        PeriodType type = PeriodType.standard().withMillisRemoved();        assertEquals(7, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.hours(), type.getFieldType(4));        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));        assertEquals(DurationFieldType.seconds(), type.getFieldType(6));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withMillisRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withMillisRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoMillis", type.getName());        assertEquals("PeriodType[StandardNoMillis]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskHoursMinutesSeconds() throws Exception {        PeriodType type = PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();        assertEquals(5, type.size());        assertEquals(DurationFieldType.years(), type.getFieldType(0));        assertEquals(DurationFieldType.months(), type.getFieldType(1));        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));        assertEquals(DurationFieldType.days(), type.getFieldType(3));        assertEquals(DurationFieldType.millis(), type.getFieldType(4));        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));        assertEquals(false, type.equals(PeriodType.millis()));        assertEquals(true, type.hashCode() == type.hashCode());        assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());        assertEquals("StandardNoHoursNoMinutesNoSeconds", type.getName());        assertEquals("PeriodType[StandardNoHoursNoMinutesNoSeconds]", type.toString());        assertEqualsAfterSerialization(type);    }    //-----------------------------------------------------------------------    public void testMaskTwice1() throws Exception {        PeriodType type = PeriodType.standard().withYearsRemoved();        PeriodType type2 = type.withYearsRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withMonthsRemoved();        type2 = type.withMonthsRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withWeeksRemoved();        type2 = type.withWeeksRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withDaysRemoved();        type2 = type.withDaysRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withHoursRemoved();        type2 = type.withHoursRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withMinutesRemoved();        type2 = type.withMinutesRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withSecondsRemoved();        type2 = type.withSecondsRemoved();        assertEquals(true, type == type2);                type = PeriodType.standard().withMillisRemoved();        type2 = type.withMillisRemoved();        assertEquals(true, type == type2);    }    //-----------------------------------------------------------------------    public void testMaskTwice2() throws Exception {        PeriodType type = PeriodType.dayTime();        PeriodType type2 = type.withYearsRemoved();        assertEquals(true, type == type2);                type = PeriodType.dayTime();        type2 = type.withMonthsRemoved();        assertEquals(true, type == type2);                type = PeriodType.dayTime();        type2 = type.withWeeksRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withDaysRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withHoursRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withMinutesRemoved();        assertEquals(true, type == type2);                type = PeriodType.millis();        type2 = type.withSecondsRemoved();        assertEquals(true, type == type2);    }    //-----------------------------------------------------------------------    public void testEquals() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(true, type.equals(type));        assertEquals(true, type.equals(PeriodType.dayTime().withMillisRemoved()));        assertEquals(false, type.equals(null));        assertEquals(false, type.equals(""));    }    public void testHashCode() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(type.hashCode(), type.hashCode());    }    //-----------------------------------------------------------------------    public void testIsSupported() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(false, type.isSupported(DurationFieldType.years()));        assertEquals(false, type.isSupported(DurationFieldType.months()));        assertEquals(false, type.isSupported(DurationFieldType.weeks()));        assertEquals(true, type.isSupported(DurationFieldType.days()));        assertEquals(true, type.isSupported(DurationFieldType.hours()));        assertEquals(true, type.isSupported(DurationFieldType.minutes()));        assertEquals(true, type.isSupported(DurationFieldType.seconds()));        assertEquals(false, type.isSupported(DurationFieldType.millis()));    }    //-----------------------------------------------------------------------    public void testIndexOf() throws Exception {        PeriodType type = PeriodType.dayTime().withMillisRemoved();        assertEquals(-1, type.indexOf(DurationFieldType.years()));        assertEquals(-1, type.indexOf(DurationFieldType.months()));        assertEquals(-1, type.indexOf(DurationFieldType.weeks()));        assertEquals(0, type.indexOf(DurationFieldType.days()));        assertEquals(1, type.indexOf(DurationFieldType.hours()));        assertEquals(2, type.indexOf(DurationFieldType.minutes()));        assertEquals(3, type.indexOf(DurationFieldType.seconds()));        assertEquals(-1, type.indexOf(DurationFieldType.millis()));    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */public class TestMutablePeriod_Constructors extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;        private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutablePeriod_Constructors.class);    }    public TestMutablePeriod_Constructors(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    /**     * Test constructor ()     */    public void testConstructor1() throws Throwable {        MutablePeriod test = new MutablePeriod();        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (PeriodType)     */    public void testConstructor_PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod(PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod((PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long2() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long3() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(length);        assertEquals(PeriodType.standard(), test.getPeriodType());        // only time fields are precise in AllType        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.millis());        assertEquals(PeriodType.millis(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(length, test.getMillis());    }    public void testConstructor_long_PeriodType3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType4() throws Throwable {        long length =                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, ISOChronology.getInstance());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, ISOChronology.getInstanceUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_PeriodType_Chronology1() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.time().withMillisRemoved(), ISOChronology.getInstance());        assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology2() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), ISOChronology.getInstanceUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology3() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_long_PeriodType_Chronology4() throws Throwable {        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +                5 * DateTimeConstants.MILLIS_PER_HOUR +                6 * DateTimeConstants.MILLIS_PER_MINUTE +                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;        MutablePeriod test = new MutablePeriod(length, (PeriodType) null, (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((4 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (4ints)     */    public void testConstructor_4int1() throws Throwable {        MutablePeriod test = new MutablePeriod(5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int1() throws Throwable {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (8ints)     */    public void testConstructor_8int__PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(3, test.getWeeks());        assertEquals(4, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_8int__PeriodType3() throws Throwable {        try {            new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime());            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void testConstructor_long_long1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), CopticChronology.getInstance());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (Chronology) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_long_long_PeriodType_Chronology1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, CopticChronology.getInstance());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_long_long_PeriodType_Chronology2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI3() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI4() throws Throwable {        DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(-3, test.getYears());        assertEquals(-1, test.getMonths());        assertEquals(-1, test.getWeeks());        assertEquals(-1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(-1, test.getMinutes());        assertEquals(-1, test.getSeconds());        assertEquals(-1, test.getMillis());    }    public void testConstructor_RI_RI5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RI_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.dayTime());        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType3() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard().withMillisRemoved());        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType4() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(3, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(1, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(0, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RI_PeriodType5() throws Throwable {        DateTime dt1 = null;  // 2002-06-09T01:00+01:00        DateTime dt2 = null;  // 2002-06-09T01:00+01:00        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        MutablePeriod test = new MutablePeriod(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        MutablePeriod test = new MutablePeriod(dt1, dur);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_RI_RD_PeriodType1() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);        Duration dur = new Interval(dt1, dt2).toDuration();        MutablePeriod test = new MutablePeriod(dt1, dur, PeriodType.yearDayTime());        assertEquals(PeriodType.yearDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(31, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    public void testConstructor_RI_RD_PeriodType2() throws Throwable {        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);        Duration dur = null;        MutablePeriod test = new MutablePeriod(dt1, dur, (PeriodType) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object)     */    public void testConstructor_Object1() throws Throwable {        MutablePeriod test = new MutablePeriod("P1Y2M3D");        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object2() throws Throwable {        MutablePeriod test = new MutablePeriod((Object) null);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object3() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()));        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object4() throws Throwable {        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard());        MutablePeriod test = new MutablePeriod(base);        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(1, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(1, test.getDays());        assertEquals(1, test.getHours());        assertEquals(1, test.getMinutes());        assertEquals(1, test.getSeconds());        assertEquals(1, test.getMillis());    }    //-----------------------------------------------------------------------    /**     * Test constructor (Object,PeriodType)     */    public void testConstructor_Object_PeriodType1() throws Throwable {        MutablePeriod test = new MutablePeriod("P1Y2M3D", PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(1, test.getYears());        assertEquals(2, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(3, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType2() throws Throwable {        MutablePeriod test = new MutablePeriod((Object) null, PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(0, test.getHours());        assertEquals(0, test.getMinutes());        assertEquals(0, test.getSeconds());        assertEquals(0, test.getMillis());    }    public void testConstructor_Object_PeriodType3() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime());        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    public void testConstructor_Object_PeriodType4() throws Throwable {        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null);        assertEquals(PeriodType.dayTime(), test.getPeriodType());        assertEquals(0, test.getYears());        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals(1, test.getHours());        assertEquals(2, test.getMinutes());        assertEquals(3, test.getSeconds());        assertEquals(4, test.getMillis());    }    //-----------------------------------------------------------------------    public void testConstructor_Object_Chronology1() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(new Duration(length), ISOChronology.getInstance());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(0, test.getWeeks());        assertEquals(0, test.getDays());        assertEquals((450 * 24) + 5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }    public void testConstructor_Object_Chronology2() throws Throwable {        long length =            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +            5L * DateTimeConstants.MILLIS_PER_HOUR +            6L * DateTimeConstants.MILLIS_PER_MINUTE +            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;        MutablePeriod test = new MutablePeriod(new Duration(length), ISOChronology.getInstanceUTC());        assertEquals(PeriodType.standard(), test.getPeriodType());        assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450        assertEquals(0, test.getMonths());        assertEquals(64, test.getWeeks());        assertEquals(2, test.getDays());        assertEquals(5, test.getHours());        assertEquals(6, test.getMinutes());        assertEquals(7, test.getSeconds());        assertEquals(8, test.getMillis());    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test case. * * @author Stephen Colebourne */public class TestDateTimeConstants extends TestCase {    /**     * The main method for this test program.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return new TestSuite(TestDateTimeConstants.class);    }    /**     * TestDateTimeComparator constructor.     * @param name     */    public TestDateTimeConstants(String name) {        super(name);    }    //-----------------------------------------------------------------------    public void testConstructor() {        DateTimeConstants c = new DateTimeConstants() {        };        c.toString();    }    public void testHalfdaysOfDay() {        assertEquals(0, DateTimeConstants.AM);        assertEquals(1, DateTimeConstants.PM);    }    public void testDaysOfWeek() {        assertEquals(1, DateTimeConstants.MONDAY);        assertEquals(2, DateTimeConstants.TUESDAY);        assertEquals(3, DateTimeConstants.WEDNESDAY);        assertEquals(4, DateTimeConstants.THURSDAY);        assertEquals(5, DateTimeConstants.FRIDAY);        assertEquals(6, DateTimeConstants.SATURDAY);        assertEquals(7, DateTimeConstants.SUNDAY);    }    public void testMonthsOfYear() {        assertEquals(1, DateTimeConstants.JANUARY);        assertEquals(2, DateTimeConstants.FEBRUARY);        assertEquals(3, DateTimeConstants.MARCH);        assertEquals(4, DateTimeConstants.APRIL);        assertEquals(5, DateTimeConstants.MAY);        assertEquals(6, DateTimeConstants.JUNE);        assertEquals(7, DateTimeConstants.JULY);        assertEquals(8, DateTimeConstants.AUGUST);        assertEquals(9, DateTimeConstants.SEPTEMBER);        assertEquals(10, DateTimeConstants.OCTOBER);        assertEquals(11, DateTimeConstants.NOVEMBER);        assertEquals(12, DateTimeConstants.DECEMBER);    }    public void testEras() {        assertEquals(0, DateTimeConstants.BC);        assertEquals(0, DateTimeConstants.BCE);        assertEquals(1, DateTimeConstants.AD);        assertEquals(1, DateTimeConstants.CE);    }    public void testMaths() {        assertEquals(1000, DateTimeConstants.MILLIS_PER_SECOND);        assertEquals(60 * 1000, DateTimeConstants.MILLIS_PER_MINUTE);        assertEquals(60 * 60 * 1000, DateTimeConstants.MILLIS_PER_HOUR);        assertEquals(24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_DAY);        assertEquals(7 * 24 * 60 * 60 * 1000, DateTimeConstants.MILLIS_PER_WEEK);                assertEquals(60, DateTimeConstants.SECONDS_PER_MINUTE);        assertEquals(60 * 60, DateTimeConstants.SECONDS_PER_HOUR);        assertEquals(24 * 60 * 60, DateTimeConstants.SECONDS_PER_DAY);        assertEquals(7 * 24 * 60 * 60, DateTimeConstants.SECONDS_PER_WEEK);                assertEquals(60, DateTimeConstants.MINUTES_PER_HOUR);        assertEquals(24 * 60, DateTimeConstants.MINUTES_PER_DAY);        assertEquals(7 * 24 * 60, DateTimeConstants.MINUTES_PER_WEEK);                assertEquals(24, DateTimeConstants.HOURS_PER_DAY);        assertEquals(7 * 24, DateTimeConstants.HOURS_PER_WEEK);                assertEquals(7, DateTimeConstants.DAYS_PER_WEEK);    }}
/* *  Copyright 2001-2005 Stephen Colebourne * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.joda.time;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Locale;import java.util.TimeZone;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.base.AbstractInterval;import org.joda.time.chrono.CopticChronology;import org.joda.time.chrono.GJChronology;import org.joda.time.chrono.ISOChronology;/** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */public class TestMutableInterval_Basics extends TestCase {    // Test in 2002/03 as time zones are more well known    // (before the late 90's they were all over the place)    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");    private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);        long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365;    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 +                      365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +                     366 + 365 + 365;        // 2002-06-09    private long TEST_TIME_NOW =            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;                // 2002-04-05    private long TEST_TIME1 =            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 12L * DateTimeConstants.MILLIS_PER_HOUR            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;            // 2003-05-06    private long TEST_TIME2 =            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY            + 14L * DateTimeConstants.MILLIS_PER_HOUR            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;            private DateTimeZone originalDateTimeZone = null;    private TimeZone originalTimeZone = null;    private Locale originalLocale = null;    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestMutableInterval_Basics.class);    }    public TestMutableInterval_Basics(String name) {        super(name);    }    protected void setUp() throws Exception {        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);        originalDateTimeZone = DateTimeZone.getDefault();        originalTimeZone = TimeZone.getDefault();        originalLocale = Locale.getDefault();        DateTimeZone.setDefault(LONDON);        TimeZone.setDefault(TimeZone.getTimeZone("Europe/London"));        Locale.setDefault(Locale.UK);    }    protected void tearDown() throws Exception {        DateTimeUtils.setCurrentMillisSystem();        DateTimeZone.setDefault(originalDateTimeZone);        TimeZone.setDefault(originalTimeZone);        Locale.setDefault(originalLocale);        originalDateTimeZone = null;        originalTimeZone = null;        originalLocale = null;    }    //-----------------------------------------------------------------------    public void testTest() {        assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString());        assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString());        assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString());    }    //-----------------------------------------------------------------------    public void testGetMillis() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME1, test.getStartMillis());        assertEquals(TEST_TIME1, test.getStart().getMillis());        assertEquals(TEST_TIME2, test.getEndMillis());        assertEquals(TEST_TIME2, test.getEnd().getMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());        assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());    }    public void testGetDuration2() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME1);        assertSame(Duration.ZERO, test.toDuration());    }    public void testEqualsHashCode() {        MutableInterval test1 = new MutableInterval(TEST_TIME1, TEST_TIME2);        MutableInterval test2 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test2));        assertEquals(true, test2.equals(test1));        assertEquals(true, test1.equals(test1));        assertEquals(true, test2.equals(test2));        assertEquals(true, test1.hashCode() == test2.hashCode());        assertEquals(true, test1.hashCode() == test1.hashCode());        assertEquals(true, test2.hashCode() == test2.hashCode());                MutableInterval test3 = new MutableInterval(TEST_TIME_NOW, TEST_TIME2);        assertEquals(false, test1.equals(test3));        assertEquals(false, test2.equals(test3));        assertEquals(false, test3.equals(test1));        assertEquals(false, test3.equals(test2));        assertEquals(false, test1.hashCode() == test3.hashCode());        assertEquals(false, test2.hashCode() == test3.hashCode());                MutableInterval test4 = new MutableInterval(TEST_TIME1, TEST_TIME2, GJChronology.getInstance());        assertEquals(true, test4.equals(test4));        assertEquals(false, test1.equals(test4));        assertEquals(false, test2.equals(test4));        assertEquals(false, test4.equals(test1));        assertEquals(false, test4.equals(test2));        assertEquals(false, test1.hashCode() == test4.hashCode());        assertEquals(false, test2.hashCode() == test4.hashCode());                MutableInterval test5 = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test1.equals(test5));        assertEquals(true, test2.equals(test5));        assertEquals(false, test3.equals(test5));        assertEquals(true, test5.equals(test1));        assertEquals(true, test5.equals(test2));        assertEquals(false, test5.equals(test3));        assertEquals(true, test1.hashCode() == test5.hashCode());        assertEquals(true, test2.hashCode() == test5.hashCode());        assertEquals(false, test3.hashCode() == test5.hashCode());                assertEquals(false, test1.equals("Hello"));        assertEquals(true, test1.equals(new MockInterval()));        assertEquals(false, test1.equals(new DateTime(TEST_TIME1)));    }        class MockInterval extends AbstractInterval {        public MockInterval() {            super();        }        public Chronology getChronology() {            return ISOChronology.getInstance();        }        public long getStartMillis() {            return TEST_TIME1;        }        public long getEndMillis() {            return TEST_TIME2;        }    }    //-----------------------------------------------------------------------    public void testContains_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(TEST_TIME1));        assertEquals(false, test.contains(TEST_TIME1 - 1));        assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2));        assertEquals(false, test.contains(TEST_TIME2));        assertEquals(true, test.contains(TEST_TIME2 - 1));    }    public void testContainsNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2);        assertEquals(true, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(false, test.containsNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(true, test.containsNow());    }    public void testContains_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);        assertEquals(true, test.contains(new Instant(TEST_TIME1)));        assertEquals(false, test.contains(new Instant(TEST_TIME1 - 1)));        assertEquals(true, test.contains(new Instant(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2)));        assertEquals(false, test.contains(new Instant(TEST_TIME2)));        assertEquals(true, test.contains(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.contains((ReadableInstant) null));    }    //-----------------------------------------------------------------------    public void testContains_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1)));        assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1)));                assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));        assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));                assertEquals(true, test.contains((ReadableInterval) null));    }    public void testOverlaps_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2)));                assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2 + 1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));                assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1)));        assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));        assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));                assertEquals(true, test.overlaps((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testIsBefore_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(TEST_TIME1 - 1));        assertEquals(false, test.isBefore(TEST_TIME1));        assertEquals(false, test.isBefore(TEST_TIME1 + 1));                assertEquals(false, test.isBefore(TEST_TIME2 - 1));        assertEquals(true, test.isBefore(TEST_TIME2));        assertEquals(true, test.isBefore(TEST_TIME2 + 1));    }    public void testIsBeforeNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1);        assertEquals(false, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2);        assertEquals(true, test.isBeforeNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 + 1);        assertEquals(true, test.isBeforeNow());    }    public void testIsBefore_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1)));        assertEquals(false, test.isBefore(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Instant(TEST_TIME2 - 1)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2)));        assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isBefore((ReadableInstant) null));    }    public void testIsBefore_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isBefore(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(true, test.isBefore(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isBefore((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testIsAfter_long() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(TEST_TIME1 - 1));        assertEquals(false, test.isAfter(TEST_TIME1));        assertEquals(false, test.isAfter(TEST_TIME1 + 1));                assertEquals(false, test.isAfter(TEST_TIME2 - 1));        assertEquals(false, test.isAfter(TEST_TIME2));        assertEquals(false, test.isAfter(TEST_TIME2 + 1));    }    public void testIsAfterNow() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1);        assertEquals(true, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1);        assertEquals(false, test.isAfterNow());        DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + 1);        assertEquals(false, test.isAfterNow());    }    public void testIsAfter_RI() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Instant(TEST_TIME1 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Instant(TEST_TIME2 - 1)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2)));        assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1)));                assertEquals(false, test.isAfter((ReadableInstant) null));    }    public void testIsAfter_RInterval() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));        assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));                assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2, Long.MAX_VALUE)));        assertEquals(false, test.isAfter(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE)));                assertEquals(false, test.isAfter((ReadableInterval) null));    }    //-----------------------------------------------------------------------    public void testToInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        Interval result = test.toInterval();        assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToMutableInterval1() {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);        MutableInterval result = test.toMutableInterval();        assertEquals(test, result);        assertNotSame(test, result);    }    //-----------------------------------------------------------------------    public void testToPeriod() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);        MutableInterval base = new MutableInterval(dt1, dt2);                Period test = base.toPeriod();        Period expected = new Period(dt1, dt2, PeriodType.standard());        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testToPeriod_PeriodType1() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);        MutableInterval base = new MutableInterval(dt1, dt2);                Period test = base.toPeriod(null);        Period expected = new Period(dt1, dt2, PeriodType.standard());        assertEquals(expected, test);    }    public void testToPeriod_PeriodType2() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);        MutableInterval base = new MutableInterval(dt1, dt2);                Period test = base.toPeriod(PeriodType.yearWeekDayTime());        Period expected = new Period(dt1, dt2, PeriodType.yearWeekDayTime());        assertEquals(expected, test);    }    //-----------------------------------------------------------------------    public void testSerialization() throws Exception {        MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(test);        byte[] bytes = baos.toByteArray();        oos.close();                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        MutableInterval result = (MutableInterval) ois.readObject();        ois.close();                assertEquals(test, result);    }    //-----------------------------------------------------------------------    public void testToString() {        DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);        DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);        MutableInterval test = new MutableInterval(dt1, dt2);        assertEquals("2004-06-09T07:08:09.010/2005-08-13T12:14:16.018", test.toString());    }    //-----------------------------------------------------------------------    public void testCopy() {        MutableInterval test = new MutableInterval(123L, 456L, COPTIC_PARIS);        MutableInterval cloned = test.copy();        assertEquals(test, cloned);        assertNotSame(test, cloned);    }    public void testClone() {        MutableInterval test = new MutableInterval(123L, 456L, COPTIC_PARIS);        MutableInterval cloned = (MutableInterval) test.clone();        assertEquals(test, cloned);        assertNotSame(test, cloned);    }}