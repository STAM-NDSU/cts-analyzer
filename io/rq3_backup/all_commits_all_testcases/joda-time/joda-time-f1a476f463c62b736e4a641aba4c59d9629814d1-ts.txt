/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.buddhist;import java.util.Calendar;import java.util.Locale;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.test.time.BulkTest;import org.joda.time.DateTimeField;import org.joda.time.chrono.buddhist.BuddhistChronology;/** * This class is the Junit unit test for a DateTimeField. * * @author Stephen Colebourne */public class TestBuddhistEraDateTimeField extends AbstractTestDateTimeField {    public TestBuddhistEraDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestBuddhistEraDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "era";    }    protected DateTimeField getField() {        return BuddhistChronology.getInstanceUTC().era();    }    protected int getMinimumValue() {        return BuddhistChronology.BE;    }    protected int getMaximumValue() {        return BuddhistChronology.BE;    }    protected int getCalendarValue(long millis) {        return BuddhistChronology.BE;    }    protected long getUnitSize() {        return Long.MAX_VALUE;    }    public void testGetAsTextLocale() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsText(var[i], Locale.ENGLISH));        }    }    public void testGetAsText() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsText(var[i]));        }    }    public void testGetAsShortTextLocale() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsShortText(var[i], Locale.ENGLISH));        }    }    public void testGetAsShortText() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals("BE", field.getAsShortText(var[i]));        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMinuteOfHourDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMinuteOfHourDateTimeField extends TestGJMinuteOfHourDateTimeField {    public TestISOMinuteOfHourDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMinuteOfHourDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).minuteOfHour();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMinuteOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMinuteOfDayDateTimeField extends TestGJMinuteOfDayDateTimeField {    public TestISOMinuteOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMinuteOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).minuteOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJHourOfHalfdayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOHourOfHalfdayDateTimeField extends TestGJHourOfHalfdayDateTimeField {    public TestISOHourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOHourOfHalfdayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).hourOfHalfday();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJHourOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOHourOfDayDateTimeField extends TestGJHourOfDayDateTimeField {    public TestISOHourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOHourOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).hourOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;/** * This class is a Junit unit test suite. * * @author Stephen Colebourne */public class TestSuiteISO extends TestSuite {    public TestSuiteISO(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }        public static TestSuite suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestISOMillisOfSecondDateTimeField.suite());        suite.addTest(TestISOMillisOfDayDateTimeField.suite());        suite.addTest(TestISOSecondOfMinuteDateTimeField.suite());        suite.addTest(TestISOSecondOfDayDateTimeField.suite());        suite.addTest(TestISOMinuteOfHourDateTimeField.suite());        suite.addTest(TestISOMinuteOfDayDateTimeField.suite());        suite.addTest(TestISOHalfdayOfDayDateTimeField.suite());        suite.addTest(TestISOHourOfDayDateTimeField.suite());        suite.addTest(TestISOHourOfHalfdayDateTimeField.suite());        suite.addTest(TestISOClockhourOfDayDateTimeField.suite());        suite.addTest(TestISOClockhourOfHalfdayDateTimeField.suite());                suite.addTest(TestISODayOfWeekDateTimeField.suite());        suite.addTest(TestISODayOfMonthDateTimeField.suite());        suite.addTest(TestISODayOfYearDateTimeField.suite());                suite.addTest(TestISOMonthOfYearDateTimeField.suite());//        suite.addTest(TestISOYearDateTimeField.suite());//        suite.addTest(TestISOYearOfEraDateTimeField.suite());//        suite.addTest(TestISOYearOfCenturyDateTimeField.suite());        return suite;    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMillisOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMillisOfDayDateTimeField extends TestGJMillisOfDayDateTimeField {    public TestISOMillisOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMillisOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).millisOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJClockhourOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOClockhourOfDayDateTimeField extends TestGJClockhourOfDayDateTimeField {    public TestISOClockhourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOClockhourOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).clockhourOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJDayOfWeekDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISODayOfWeekDateTimeField extends TestGJDayOfWeekDateTimeField {    public TestISODayOfWeekDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODayOfWeekDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).dayOfWeek();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMonthOfYearDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMonthOfYearDateTimeField extends TestGJMonthOfYearDateTimeField {    public TestISOMonthOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMonthOfYearDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).monthOfYear();    }    protected int[] getDMYDS(long millis) {        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJSecondOfMinuteDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOSecondOfMinuteDateTimeField extends TestGJSecondOfMinuteDateTimeField {    public TestISOSecondOfMinuteDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOSecondOfMinuteDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).secondOfMinute();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJClockhourOfHalfdayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOClockhourOfHalfdayDateTimeField extends TestGJClockhourOfHalfdayDateTimeField {    public TestISOClockhourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOClockhourOfHalfdayDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).clockhourOfHalfday();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJMillisOfSecondDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOMillisOfSecondDateTimeField extends TestGJMillisOfSecondDateTimeField {    public TestISOMillisOfSecondDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOMillisOfSecondDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).millisOfSecond();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJHalfdayOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOHalfdayOfDayDateTimeField extends TestGJHalfdayOfDayDateTimeField {    public TestISOHalfdayOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOHalfdayOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).halfdayOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJDayOfMonthDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISODayOfMonthDateTimeField extends TestGJDayOfMonthDateTimeField {    public TestISODayOfMonthDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODayOfMonthDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).dayOfMonth();    }    protected int[] getDMYDS(long millis) {        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJDayOfYearDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISODayOfYearDateTimeField extends TestGJDayOfYearDateTimeField {    public TestISODayOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISODayOfYearDateTimeField.class);    }        protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).dayOfYear();    }    protected int[] getDMYDS(long millis) {        return super.getDMYDS(millis, Long.MIN_VALUE, Integer.MIN_VALUE, 0);    }        }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.iso;import junit.framework.TestSuite;import org.joda.test.time.gj.TestGJSecondOfDayDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestISOSecondOfDayDateTimeField extends TestGJSecondOfDayDateTimeField {    public TestISOSecondOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestISOSecondOfDayDateTimeField.class);    }    protected DateTimeField getField() {        return ISOChronology.getInstance(getZone()).secondOfDay();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJClockhourOfHalfdayDateTimeField extends AbstractTestDateTimeField {    public TestGJClockhourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJClockhourOfHalfdayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }        protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int val = getCalendarValue(millis);        if (val == 12) {            val = 0;        }        int max = 11;        int min = 0;        int add = val + addWrapped;        while (add > max || add < min) {            if (addWrapped >= 0) {                add = add - (max - min) - 1;            } else {                add = add + (max - min) + 1;            }        }        return millis + ((add - val) * getUnitSize());    }        protected String getFieldName() {        return "clockhourOfHalfday";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).clockhourOfHalfday();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 12;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = ((int) ((millis / (60 * 60 * 1000)) % 24)) % 12;        } else {            val = ((int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24)) % 12;        }        return (val == 0 ? 12 : val);    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJSecondOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJSecondOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJSecondOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "secondOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).secondOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 24 * 60 * 60 - 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 1000) % (24 * 60 * 60));        } else {            return (int) (24 * 60 * 60 - 1) + (int) (((millis + 1) / 1000) % (24 * 60 * 60));        }    }    protected long getUnitSize() {        return 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJClockhourOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJClockhourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJClockhourOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }        protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int val = getCalendarValue(millis);        if (val == 24) {            val = 0;        }        int max = 23;        int min = 0;        int add = val + addWrapped;        while (add > max || add < min) {            if (addWrapped >= 0) {                add = add - (max - min) - 1;            } else {                add = add + (max - min) + 1;            }        }        return millis + ((add - val) * getUnitSize());    }        protected String getFieldName() {        return "clockhourOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).clockhourOfDay();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 24;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = (int) ((millis / (60 * 60 * 1000)) % 24);        } else {            val = (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);        }        return (val == 0 ? 24 : val);    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMillisOfSecondDateTimeField extends AbstractTestDateTimeField {    public TestGJMillisOfSecondDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMillisOfSecondDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "millisOfSecond";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).millisOfSecond();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 999;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) (millis % 1000);        } else {            return (int) (999 - ((-millis - 1) % 1000));        }    }    protected long getUnitSize() {        return 1; // 1 milli    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.text.DateFormatSymbols;import java.util.Calendar;import java.util.Locale;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJDayOfWeekDateTimeField extends AbstractTestDateTimeField {    public TestGJDayOfWeekDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJDayOfWeekDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "dayOfWeek";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).dayOfWeek();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 7;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = (int) ((millis / (24 * 60 * 60 * 1000)) % 7);        } else {            val = (int) 6 + (int) (((millis + 1) / (24 * 60 * 60 * 1000)) % 7);        }        val = val + 4;  // shift 1970-01-01 to Thursday        val = val % 7;  // readjust        return (val == 0 ? 7 : val);    }    protected long getUnitSize() {        return 24 * 60 * 60 * 1000; // 1 day    }    protected String getText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        switch (value) {            case DateTimeConstants.MONDAY :            return sym.getWeekdays()[Calendar.MONDAY];            case DateTimeConstants.TUESDAY :            return sym.getWeekdays()[Calendar.TUESDAY];            case DateTimeConstants.WEDNESDAY :            return sym.getWeekdays()[Calendar.WEDNESDAY];            case DateTimeConstants.THURSDAY :            return sym.getWeekdays()[Calendar.THURSDAY];            case DateTimeConstants.FRIDAY :            return sym.getWeekdays()[Calendar.FRIDAY];            case DateTimeConstants.SATURDAY :            return sym.getWeekdays()[Calendar.SATURDAY];            case DateTimeConstants.SUNDAY :            return sym.getWeekdays()[Calendar.SUNDAY];        }        return null;    }    protected String getShortText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        switch (value) {            case DateTimeConstants.MONDAY :            return sym.getShortWeekdays()[Calendar.MONDAY];            case DateTimeConstants.TUESDAY :            return sym.getShortWeekdays()[Calendar.TUESDAY];            case DateTimeConstants.WEDNESDAY :            return sym.getShortWeekdays()[Calendar.WEDNESDAY];            case DateTimeConstants.THURSDAY :            return sym.getShortWeekdays()[Calendar.THURSDAY];            case DateTimeConstants.FRIDAY :            return sym.getShortWeekdays()[Calendar.FRIDAY];            case DateTimeConstants.SATURDAY :            return sym.getShortWeekdays()[Calendar.SATURDAY];            case DateTimeConstants.SUNDAY :            return sym.getShortWeekdays()[Calendar.SUNDAY];        }        return null;    }    protected int getMaximumTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getWeekdays().length; i++) {            max = (max >= sym.getWeekdays()[i].length() ? max : sym.getWeekdays()[i].length());        }        return max;    }    protected int getMaximumShortTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getShortWeekdays().length; i++) {            max = (max >= sym.getShortWeekdays()[i].length() ? max : sym.getShortWeekdays()[i].length());        }        return max;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMillisOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJMillisOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMillisOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "millisOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).millisOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 24 * 60 * 60 * 1000 - 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) (millis % (24 * 60 * 60 * 1000));        } else {            return (int) (24 * 60 * 60 * 1000 - 1) + (int) ((millis + 1) % (24 * 60 * 60 * 1000));        }    }    protected long getUnitSize() {        return 1; // 1 milli    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJDayOfMonthDateTimeField extends AbstractTestGJDateTimeField {    public TestGJDayOfMonthDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJDayOfMonthDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "dayOfMonth";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).dayOfMonth();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 31;    }        protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[0];    }    protected long getAddWrappedResult(long millis, int addWrapped) {        int[] dmyd = getDMYDS(millis + getZone().getOffset(millis));        int day = dmyd[0];        int month = dmyd[1];        int year = dmyd[2];        int monthSize = dmyd[4];        if (millis == -12219469260000L && addWrapped == -13) {            int i = 0;        }                if (addWrapped == 0) {            return millis;        }        int newDay = day + addWrapped;        boolean loop = false;        do {            loop = false;            if (newDay < 1) {                newDay = newDay + monthSize;                loop = true;            } else if (newDay > monthSize) {                newDay = newDay - monthSize;                loop = true;            }        } while (loop);        return millis + ((long) (newDay - day)) * 24 * 60 * 60 * 1000;    }    protected long getUnitSize() {        return 24 * 60 * 60 * 1000; // 1 day    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJHourOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJHourOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJHourOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "hourOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).hourOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 23;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / (60 * 60 * 1000)) % 24);        } else {            return (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);        }    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.util.Calendar;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJYearOfEraDateTimeField extends AbstractTestDateTimeField {    public TestGJYearOfEraDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJYearOfEraDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "yearOfEra";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).yearOfEra();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 292278993;    }    protected int getCalendarValue(long millis) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        int val = iCalendar.get(Calendar.YEAR);        return val;    }    protected long getAddedResult(long millis, int add) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        iCalendar.add(Calendar.YEAR, add);        return iCalendar.getTime().getTime();    }    protected long getAddWrappedResult(long millis, int add) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        iCalendar.add(Calendar.YEAR, add);        return iCalendar.getTime().getTime();    }        protected long getUnitSize() {        return 365 * 24 * 60 * 60 * 1000; // 365 day    }    protected long getIncrementSize() {        return 8 * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 32L * 24 * 60 * 60 * 1000;  // 32 days    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.text.DateFormatSymbols;import java.util.Locale;import junit.framework.TestSuite;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMonthOfYearDateTimeField extends AbstractTestGJDateTimeField {    public TestGJMonthOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMonthOfYearDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "monthOfYear";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).monthOfYear();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 12;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[1];    }    protected long getAddedResult(long millis, int add) {        if (add == 0) {            return millis;        }//        System.out.println(new Instant(millis) + "  " + add);                int[] before = getDMYDS(millis + getZone().getOffset(millis));        int currentDay = before[0];        int currentMonth = before[1];        long newMillis = millis + (add * getUnitSize()) + (((int) (add/2)) * 24 * 60 * 60 * 1000);        int[] after = getDMYDS(newMillis + getZone().getOffset(newMillis));        int newDay = after[0];        int newMonth = after[1];                // calc effective add        int max = 12;        int min = 1;        int added = currentMonth + add;        while (added > max || added < min) {            if (add >= 0) {                added = added - (max - min) - 1;            } else {                added = added + (max - min) + 1;            }        }        int effectiveAdd = added - currentMonth;                // ensure month correct        while (currentMonth + effectiveAdd != newMonth) {            if (currentMonth + effectiveAdd == 1 && newMonth == 12) {                newMillis = newMillis + 24 * 60 * 60 * 1000;            } else if (currentMonth + effectiveAdd == 12 && newMonth == 1) {                newMillis = newMillis - 24 * 60 * 60 * 1000;            } else if (currentMonth + effectiveAdd > newMonth) {                newMillis = newMillis + 24 * 60 * 60 * 1000;            } else {                newMillis = newMillis - 24 * 60 * 60 * 1000;            }            after = getDMYDS(newMillis + getZone().getOffset(newMillis));            newDay = after[0];            newMonth = after[1];        }                // ensure day correct        if (currentDay < newDay) {            while (currentDay < newDay) {                newMillis = newMillis - 24 * 60 * 60 * 1000;                after = getDMYDS(newMillis + getZone().getOffset(newMillis));                newDay = after[0];                newMonth = after[1];                if (currentMonth + effectiveAdd != newMonth) {                    newMillis = newMillis + 24 * 60 * 60 * 1000;                    break;                }            }        } else {            while (currentDay > newDay) {                newMillis = newMillis + 24 * 60 * 60 * 1000;                after = getDMYDS(newMillis + getZone().getOffset(newMillis));                newDay = after[0];                newMonth = after[1];                if (currentMonth + effectiveAdd != newMonth) {                    newMillis = newMillis - 24 * 60 * 60 * 1000;                    break;                }            }        }        //        System.out.println(new Instant(newMillis) + "  " + add);        return newMillis;    }    protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int[] before = getDMYDS(millis + getZone().getOffset(millis));        int val = before[1];        int max = 12;        int min = 1;        int add = val + addWrapped;        while (add > max || add < min) {            if (addWrapped >= 0) {                add = add - (max - min) - 1;            } else {                add = add + (max - min) + 1;            }        }        int amount = add - val;        if (amount == 0) {            return millis;        } else {            return getAddedResult(millis, amount);        }    }        protected long getUnitSize() {        return 30L * 24 * 60 * 60 * 1000; // 30 day    }    protected long getIncrementSize() {        return 8L * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 32L * 24 * 60 * 60 * 1000;  // 32 days    }        protected String getText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getMonths()[value - 1];    }    protected String getShortText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getShortMonths()[value - 1];    }        protected int getMaximumTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getMonths().length; i++) {            max = (max >= sym.getMonths()[i].length() ? max : sym.getMonths()[i].length());        }        return max;    }    protected int getMaximumShortTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getShortMonths().length; i++) {            max = (max >= sym.getShortMonths()[i].length() ? max : sym.getShortMonths()[i].length());        }        return max;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.text.DateFormatSymbols;import java.util.Locale;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJHalfdayOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJHalfdayOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJHalfdayOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "halfdayOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).halfdayOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        int val = 0;        if (millis >= 0) {            val = (int) ((millis / (60 * 60 * 1000)) % 24);        } else {            val = (int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24);        }        return (val < 12 ? 0 : 1);    }    protected long getUnitSize() {        return 12 * 60 * 60 * 1000; // 12 hours    }    protected String getText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getAmPmStrings()[value];    }    protected String getShortText(int value, Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        return sym.getAmPmStrings()[value];    }        protected int getMaximumTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getAmPmStrings().length; i++) {            max = (max >= sym.getAmPmStrings()[i].length() ? max : sym.getAmPmStrings()[i].length());        }        return max;    }    protected int getMaximumShortTextLength(Locale loc) {        if (loc == null) {            loc = Locale.getDefault();        }        DateFormatSymbols sym = new DateFormatSymbols(loc);        int max = 0;        for (int i = 0; i < sym.getAmPmStrings().length; i++) {            max = (max >= sym.getAmPmStrings()[i].length() ? max : sym.getAmPmStrings()[i].length());        }        return max;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJHourOfHalfdayDateTimeField extends AbstractTestDateTimeField {    public TestGJHourOfHalfdayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJHourOfHalfdayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "hourOfHalfday";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).hourOfHalfday();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 11;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return ((int) ((millis / (60 * 60 * 1000)) % 24)) % 12;        } else {            return ((int) 23 + (int) (((millis + 1) / (60 * 60 * 1000)) % 24)) % 12;        }    }    protected long getUnitSize() {        return 60 * 60 * 1000; // 1 hour    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMinuteOfDayDateTimeField extends AbstractTestDateTimeField {    public TestGJMinuteOfDayDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMinuteOfDayDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "minuteOfDay";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).minuteOfDay();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 24 * 60 - 1;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 60000) % (24 * 60));        } else {            return (int) (24 * 60 - 1) + (int) (((millis + 1) / 60000) % (24 * 60));        }    }    protected long getUnitSize() {        return 60 * 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJSecondOfMinuteDateTimeField extends AbstractTestDateTimeField {    public TestGJSecondOfMinuteDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJSecondOfMinuteDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "secondOfMinute";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).secondOfMinute();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 59;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 1000) % 60);        } else {            return (int) 59 + (int) (((millis + 1) / 1000) % 60);        }    }    protected long getUnitSize() {        return 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.util.Date;import junit.framework.AssertionFailedError;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeField;import org.joda.time.Instant;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJYearDateTimeField extends AbstractTestGJDateTimeField {    public TestGJYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJYearDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "year";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).year();    }    protected int getMinimumValue() {        return -292269053;    }    protected int getMaximumValue() {        return 292278993;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[2];    }    protected long getAddedResult(long millis, int add) {        if (add == 0) {            return millis;        }        int[] fields = getDMYDS(millis + getZone().getOffset(millis));        int day = fields[0];        int month = fields[1];        int year = fields[2];        int yearLength = fields[5];        int newYear = year + add;        if (add > 0) {            int addDays = 0;            if (month >= 3) {                for (int i = year + 1; i <= newYear; i++) {                    if (isLeap(i, 1582)) {                        addDays += 366;                    } else {                        addDays += 365;                    }                }            } else {                for (int i = year; i < newYear; i++) {                    if (isLeap(i, 1582)) {                        addDays += 366;                    } else {                        addDays += 365;                    }                }            }            if (day == 29 && month == 2 && isLeap(newYear, 1582) == false) {                addDays = addDays - 1;            }            millis = millis + (addDays * 24 * 60 * 60 * 1000L);        } else {            int addDays = 0;            if (month >= 3) {                for (int i = year; i > newYear; i--) {                    if (isLeap(i, 1582)) {                        addDays -= 366;                    } else {                        addDays -= 365;                    }                }            } else {                for (int i = year - 1; i >= newYear; i--) {                    if (isLeap(i, 1582)) {                        addDays -= 366;                    } else {                        addDays -= 365;                    }                }            }            if (day == 29 && month == 2 && isLeap(newYear, 1582) == false) {                addDays = addDays - 1;            }            millis = millis + (addDays * 24 * 60 * 60 * 1000L);        }        return millis;    }    protected long getAddWrappedResult(long millis, int add) {        return getAddedResult(millis, add);    }        protected long getUnitSize() {        return 365 * 24 * 60 * 60 * 1000; // 365 day    }    protected long getIncrementSize() {        return 8 * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 20L * 24 * 60 * 60 * 1000;  // 20 days    }            public void testIsLeapYear() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            try {                assertEquals(iCalendar.isLeapYear(field.get(var[i])), field.isLeap(var[i]));            } catch (AssertionFailedError ex) {                System.out.println("LEAPYEAR: i: "+i+" cal:"+getCalendarValue(var[i])+" get:"+getField().get(var[i])+                    " time:"+new Instant(var[i])+","+new Date(var[i])+                    " day:"+new DateTime(var[i], GJChronology.getInstance()).getDayOfMonth()+                    " month:"+new DateTime(var[i], GJChronology.getInstance()).getMonthOfYear()+                    " year:"+new DateTime(var[i], GJChronology.getInstance()).getYear());                throw ex;            }        }    }        public void testGetLeapAmount() throws Exception {        DateTimeField field = getField();        long[] var = getAllTestPositions();        for (int i = 0; i < var.length; i++) {            assertEquals(iCalendar.isLeapYear(field.get(var[i])) ? 1 : 0, field.getLeapAmount(var[i]));        }    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJMinuteOfHourDateTimeField extends AbstractTestDateTimeField {    public TestGJMinuteOfHourDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJMinuteOfHourDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "minuteOfHour";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).minuteOfHour();    }    protected int getMinimumValue() {        return 0;    }    protected int getMaximumValue() {        return 59;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        if (millis >= 0) {            return (int) ((millis / 60000) % 60);        } else {            return (int) 59 + (int) (((millis + 1) / 60000) % 60);        }    }    protected long getUnitSize() {        return 60 * 1000; // 1 sec    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;/** * This class is a Junit unit test suite. * * @author Stephen Colebourne */public class TestSuiteGJ extends TestSuite {    public TestSuiteGJ(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }        public static TestSuite suite() {        TestSuite suite = new TestSuite();        suite.addTest(TestGJMillisOfSecondDateTimeField.suite());        suite.addTest(TestGJMillisOfDayDateTimeField.suite());        suite.addTest(TestGJSecondOfMinuteDateTimeField.suite());        suite.addTest(TestGJSecondOfDayDateTimeField.suite());        suite.addTest(TestGJMinuteOfHourDateTimeField.suite());        suite.addTest(TestGJMinuteOfDayDateTimeField.suite());        suite.addTest(TestGJHalfdayOfDayDateTimeField.suite());        suite.addTest(TestGJHourOfDayDateTimeField.suite());        suite.addTest(TestGJHourOfHalfdayDateTimeField.suite());        suite.addTest(TestGJClockhourOfDayDateTimeField.suite());        suite.addTest(TestGJClockhourOfHalfdayDateTimeField.suite());                suite.addTest(TestGJDayOfWeekDateTimeField.suite());        suite.addTest(TestGJDayOfMonthDateTimeField.suite());        suite.addTest(TestGJDayOfYearDateTimeField.suite());                suite.addTest(TestGJMonthOfYearDateTimeField.suite());        suite.addTest(TestGJYearDateTimeField.suite());        suite.addTest(TestGJYearOfEraDateTimeField.suite());        suite.addTest(TestGJYearOfCenturyDateTimeField.suite());        return suite;    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import junit.framework.TestSuite;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJDayOfYearDateTimeField extends AbstractTestGJDateTimeField {    public TestGJDayOfYearDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJDayOfYearDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "dayOfYear";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).dayOfYear();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 366;    }    protected int getCalendarValue(long millis) {        millis = millis + getZone().getOffset(millis);        return getDMYDS(millis)[3];    }    protected long getAddWrappedResult(long millis, int addWrapped) {        if (addWrapped == 0) {            return millis;        }        int[] dmyds = getDMYDS(millis + getZone().getOffset(millis));        int val = dmyds[3];        int max = dmyds[5];        int add = val + addWrapped;        while (add > max || add < 1) {            if (addWrapped >= 0) {                add -= max;            } else {                add += max;            }        }        return millis + ((add - val) * getUnitSize());    }    protected long getUnitSize() {        return 24 * 60 * 60 * 1000; // 1 day    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.gj;import java.util.Calendar;import junit.framework.TestSuite;import org.joda.test.time.AbstractTestDateTimeField;import org.joda.time.DateTimeField;import org.joda.time.chrono.gj.GJChronology;/** * This class is a Junit unit test for the date time field. * * @author Stephen Colebourne */public class TestGJYearOfCenturyDateTimeField extends AbstractTestDateTimeField {    public TestGJYearOfCenturyDateTimeField(String name) {        super(name);    }    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    public static TestSuite suite() {        return new TestSuite(TestGJYearOfCenturyDateTimeField.class);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }            protected String getFieldName() {        return "yearOfCentury";    }    protected DateTimeField getField() {        return GJChronology.getInstance(getZone()).yearOfCentury();    }    protected int getMinimumValue() {        return 1;    }    protected int getMaximumValue() {        return 100;    }    protected int getCalendarValue(long millis) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        int val = iCalendar.get(Calendar.YEAR);        val = val % 100;        return (val == 0 ? 100 : val);    }    protected long getAddedResult(long millis, int add) {        iDate.setTime(millis);        iCalendar.setTime(iDate);        iCalendar.add(Calendar.YEAR, add);        return iCalendar.getTime().getTime();    }        protected long getUnitSize() {        return 365 * 24 * 60 * 60 * 1000; // 365 day    }    protected long getIncrementSize() {        return 8 * 60 * 60 * 1000;  // 8 hours    }    protected long getTestRange() {        return 32L * 24 * 60 * 60 * 1000;  // 32 days    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianMonthOfYearField extends TestGJMonthOfYearField {    public TestJulianMonthOfYearField(TestJulianChronology chrono) {        super(chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long add(long millis, long value) {        int year = iChronology.year().get(millis);        int newYear = year + (int)iChronology.div(value, 12);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        int newMonth = get(millis) + (int)iChronology.mod(value, 12);        if (newMonth > 12) {            if (newYear == -1) {                newYear = 1;            } else {                newYear++;            }            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;import org.joda.time.DurationField;/** * A reference Gregorian/Julian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * <p>In theory, this class can be used to test any other Gregorian/Julian * chronology as long as almost all datetime fields are implemented differently * between the two. Fields that would most likely be implemented the same are * not supported by this class. * * <p>Unsupported features * <ul> * <li>time zones * <li>time of day * <li>year of era * <li>year of century * <li>century of era * <li>era * </ul> * * @author Brian S O'Neill */abstract class TestGJChronology extends Chronology {    static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;    /**     * Divide with round-negative behavior.     *     * @param divisor must be positive     */    static long div(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend / divisor;        } else {            return (dividend + 1) / divisor - 1;        }    }    /**     * Modulus with round-negative behavior, result is always positive.     *     * @param divisor must be positive     */    static long mod(long dividend, long divisor) {        if (divisor < 0) {            throw new IllegalArgumentException("divisor must be positive: " + divisor);        }        if (dividend >= 0) {            return dividend % divisor;        } else {            return (dividend + 1) % divisor - 1 + divisor;        }    }    static long amod(long dividend, long divisor) {        long mod = mod(dividend, divisor);        return (mod == 0) ? divisor : mod;    }    /** Milliseconds from 0001-01-01 to the epoch. */    private final long iEpochMillis;    public TestGJChronology(int epochYear, int epochMonth, int epochDay) {        iEpochMillis = fixedFromGJ(epochYear, epochMonth, epochDay) * MILLIS_PER_DAY;    }    public DateTimeZone getDateTimeZone() {        return null;    }    public Chronology withUTC() {        return this;    }    /**     * Unsupported.     */    public Chronology withDateTimeZone(DateTimeZone zone) {        throw new UnsupportedOperationException();    }    public long getTimeOnlyMillis(long millis) {        return mod(millis, MILLIS_PER_DAY);    }    public long getDateOnlyMillis(long millis) {        return millis - mod(millis, MILLIS_PER_DAY);    }    public DurationField days() {        return dayOfWeek().getDurationField();    }    public DateTimeField dayOfWeek() {        return new TestGJDayOfWeekField(this);    }    public DateTimeField dayOfMonth() {        return new TestGJDayOfMonthField(this);     }    public DateTimeField dayOfYear() {        return new TestGJDayOfYearField(this);    }    public DurationField weeks() {        return weekOfWeekyear().getDurationField();    }    public DateTimeField weekOfWeekyear() {        return new TestGJWeekOfWeekyearField(this);    }    public DurationField weekyears() {        return weekyear().getDurationField();    }    public DateTimeField weekyear() {        return new TestGJWeekyearField(this);    }    public DurationField months() {        return monthOfYear().getDurationField();    }    public DateTimeField monthOfYear() {        return new TestGJMonthOfYearField(this);    }    public DurationField years() {        return year().getDurationField();    }    public DateTimeField year() {        return new TestGJYearField(this);    }    abstract long millisPerYear();    abstract long millisPerMonth();    abstract boolean isLeapYear(int year);    /**     * @return days from 0001-01-01     */    abstract long fixedFromGJ(int year, int monthOfYear, int dayOfMonth);    /**     * @param date days from 0001-01-01     * @return gj year     */    abstract int gjYearFromFixed(long date);    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    abstract int[] gjFromFixed(long date);    abstract long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek);    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    abstract int[] isoFromFixed(long date);    /**     * @param millis milliseconds from epoch     * @return days from 0001-01-01     */    long fixedFromMillis(long millis) {        return div(millis + iEpochMillis, MILLIS_PER_DAY);    }    /**     * @param fixed days from 0001-01-01     * @return milliseconds from epoch     */    long millisFromFixed(long fixed) {        return fixed * MILLIS_PER_DAY - iEpochMillis;    }    /**     * @return milliseconds from epoch     */    long millisFromGJ(int year, int monthOfYear, int dayOfMonth) {        return millisFromFixed(fixedFromGJ(year, monthOfYear, dayOfMonth));    }    /**     * @param millis milliseconds from epoch     * @return gj year     */    int gjYearFromMillis(long millis) {        return gjYearFromFixed(fixedFromMillis(millis));    }    /**     * @param millis milliseconds from epoch     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromMillis(long millis) {        return gjFromFixed(fixedFromMillis(millis));    }    /**     * @return milliseconds from epoch     */    long millisFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return millisFromFixed(fixedFromISO(weekyear, weekOfWeekyear, dayOfWeek));    }    /**     * @param millis milliseconds from epoch     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromMillis(long millis) {        return isoFromFixed(fixedFromMillis(millis));    }    /**     * @param date days from 0001-01-01     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday     * @param date days from 0001-01-01, on or before weekday     */    long weekdayOnOrBefore(long date, int weekday) {        return date - mod(date - mod(weekday, 7), 7);    }    long weekdayOnOrAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 6, weekday);    }    long weekdayNearest(long date, int weekday) {        return weekdayOnOrBefore(date + 3, weekday);    }    long weekdayBefore(long date, int weekday) {        return weekdayOnOrBefore(date - 1, weekday);    }    long weekdayAfter(long date, int weekday) {        return weekdayOnOrBefore(date + 7, weekday);    }    long nthWeekday(int n, int weekday,                    int year, int monthOfYear, int dayOfMonth)    {        if (n > 0) {            return 7 * n + weekdayBefore                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        } else {            return 7 * n + weekdayAfter                (fixedFromGJ(year, monthOfYear, dayOfMonth), weekday);        }    }    long firstWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(1, weekday, year, monthOfYear, dayOfMonth);    }    long lastWeekday(int weekday, int year, int monthOfYear, int dayOfMonth) {        return nthWeekday(-1, weekday, year, monthOfYear, dayOfMonth);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfMonthField extends TestGJDateTimeField {    public TestGJDayOfMonthField(TestGJChronology chrono) {        super("dayOfMonth", "days", chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[2];    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(ymd[0], ymd[1], value);    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.months();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 31;    }    public int getMaximumValue(long millis) {        int[] lengths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};        if (iChronology.year().isLeap(millis)) {            lengths[2] = 29;        }        return lengths[iChronology.monthOfYear().get(millis)];    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import java.util.Random;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;import org.joda.time.chrono.gj.GJChronology;/** * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj * against the implementations in this package. It tests all the date fields * against their principal methods. * <p> * Randomly generated values are fed into the DateTimeField methods and the * results are compared between the two chronologies. If any result doesn't * match, an error report is generated and the program exits. Each time this * test program is run, the pseudo random number generator is seeded with the * same value. This ensures consistent results between test runs. * <p> * The main method accepts three optional arguments: iterations, mode, seed. By * default, iterations is set to 1,000,000. The test will take several minutes * to run, depending on the computer's performance. Every 5 seconds a progress * message is printed. * <p> * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for * proleptic julian. To override the default random number generator seed, pass * in a thrid argument which accepts a long signed integer. * * @author Brian S O'Neill */public class Test {    public static final int GREGORIAN_MODE = 0;    public static final int JULIAN_MODE = 1;    private static final long MILLIS_PER_YEAR = (long)365.2425 * 24 * 60 * 60 * 1000;    private static final long _1000_YEARS = 1000 * MILLIS_PER_YEAR;    private static final long _500_YEARS = 500 * MILLIS_PER_YEAR;    private static final long MAX_MILLIS = (10000 - 1970) * MILLIS_PER_YEAR;    private static final long MIN_MILLIS = (-10000 - 1970) * MILLIS_PER_YEAR;    // Show progess reports every 5 seconds.    private static final long UPDATE_INTERVAL = 5000;    /**     * Arguments: iterations [mode [seed]]     */    public static void main(String[] args) throws Exception {        int iterations = 1000000;        int mode = GREGORIAN_MODE;        long seed = 1345435247779935L;        if (args.length > 0) {            iterations = Integer.parseInt(args[0]);            if (args.length > 1) {                if (args[1].startsWith("g")) {                    mode = GREGORIAN_MODE;                } else if (args[1].startsWith("j")) {                    mode = JULIAN_MODE;                } else {                    throw new IllegalArgumentException                        ("Unknown mode: " + args[1]);                }                if (args.length > 2) {                    seed = Long.parseLong(args[2]);                }            }        }        test(iterations, mode, seed);    }    /**     * @param iterations number of test iterations to perform     * @param mode GREGORIAN_MODE or JULIAN_MODE     * @param seed seed for random number generator     */    public static void test(final int iterations, int mode, long seed) {        String modeStr;        if (mode == GREGORIAN_MODE) {            modeStr = "Gregorian";        } else {            modeStr = "Julian";        }        System.out.println("Testing " + modeStr + " chronology over " + iterations + " iterations");        Test t = new Test(mode);        Random rnd = new Random(seed);        long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;        for (int i=0; i<iterations; i++) {            long now = System.currentTimeMillis();            if (now >= updateMillis) {                updateMillis = now + UPDATE_INTERVAL;                double complete = ((int)((double)i / iterations * 1000.0)) / 10d;                if (complete < 100) {                    System.out.println("" + complete + "% complete (i=" + i + ")");                }            }            long millis = randomMillis(rnd);            int value = rnd.nextInt(200) - 100;            // millis2 is used for difference tests.            long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;            try {                t.testFields(millis, value, millis2);            } catch (RuntimeException e) {                System.out.println("Failure index: " + i);                System.out.println("Test millis: " + millis);                System.out.println("Test value: " + value);                System.out.println("Test millis2: " + millis2);                throw e;            }        }        System.out.println("100% complete (i=" + iterations + ")");    }    private static long randomMillis(Random rnd) {        long millis = rnd.nextLong();        if (millis >= 0) {            millis = millis % MAX_MILLIS;        } else {            millis = millis % -MIN_MILLIS;        }        return millis;    }    private static void dump(Chronology chrono, long millis) {        System.out.println("year:           " + chrono.year().get(millis));        System.out.println("monthOfYear:    " + chrono.monthOfYear().get(millis));        System.out.println("dayOfMonth:     " + chrono.dayOfMonth().get(millis));        System.out.println("weekyear:       " + chrono.weekyear().get(millis));        System.out.println("weekOfWeekyear: " + chrono.weekOfWeekyear().get(millis));        System.out.println("dayOfWeek:      " + chrono.dayOfWeek().get(millis));        System.out.println("dayOfYear:      " + chrono.dayOfYear().get(millis));    }    private final int iMode;    private final Chronology iTest;    private final Chronology iActual;    /**     * @param mode 0=Gregorian, 1=Julian     */    public Test(int mode) {        iMode = mode;        if (mode == GREGORIAN_MODE) {            iTest = new TestGregorianChronology();            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true);        } else {            iTest = new TestJulianChronology();            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MAX_VALUE, true);        }    }    public void testFields(long millis, int value, long millis2) {        testField(iTest.year(), iActual.year(), millis, value, millis2);        testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);        testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);        testField(iTest.weekyear(), iActual.weekyear(), millis, value, millis2);        testField(iTest.weekOfWeekyear(),                  iActual.weekOfWeekyear(), millis, value, millis2);        testField(iTest.dayOfWeek(), iActual.dayOfWeek(), millis, value, millis2);        testField(iTest.dayOfYear(), iActual.dayOfYear(), millis, value, millis2);    }    private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,                           int value, long millis2)    {        int a, b;        long x, y;        boolean m, n;        // get test        a = fieldA.get(millis);        b = fieldB.get(millis);        testValue(fieldA, fieldB, "get", millis, a, b);        // getMaximumValue test        // Restrict this test to the fields that matter.        Class fieldClass = fieldA.getClass();        if (fieldClass == TestGJDayOfYearField.class ||            fieldClass == TestGJDayOfMonthField.class ||            fieldClass == TestGJWeekOfWeekyearField.class) {                        a = fieldA.getMaximumValue(millis);            b = fieldB.getMaximumValue(millis);            testValue(fieldA, fieldB, "getMaximumValue", millis, a, b);        }        // set test        a = getWrappedValue            (value, fieldA.getMinimumValue(millis), fieldA.getMaximumValue(millis));        b = getWrappedValue            (value, fieldB.getMinimumValue(millis), fieldB.getMaximumValue(millis));        if (iMode == JULIAN_MODE && a == 0            && (fieldA.getName().equals("year") || fieldA.getName().equals("weekyear"))) {            // Exclude setting Julian year of zero.        } else {            x = fieldA.set(millis, a);            y = fieldB.set(millis, b);            testMillis(fieldA, fieldB, "set", millis, x, y, a, b);        }        // roundFloor test        x = fieldA.roundFloor(millis);        y = fieldB.roundFloor(millis);        testMillis(fieldA, fieldB, "roundFloor", millis, x, y);        // roundCeiling test        x = fieldA.roundCeiling(millis);        y = fieldB.roundCeiling(millis);        testMillis(fieldA, fieldB, "roundCeiling", millis, x, y);        // roundHalfFloor test        x = fieldA.roundHalfFloor(millis);        y = fieldB.roundHalfFloor(millis);        testMillis(fieldA, fieldB, "roundHalfFloor", millis, x, y);        // roundHalfEven test        x = fieldA.roundHalfEven(millis);        y = fieldB.roundHalfEven(millis);        testMillis(fieldA, fieldB, "roundHalfEven", millis, x, y);        // remainder test        x = fieldA.remainder(millis);        y = fieldB.remainder(millis);        testMillis(fieldA, fieldB, "remainder", millis, x, y);        // add test        x = fieldA.add(millis, value);        y = fieldB.add(millis, value);        testMillis(fieldA, fieldB, "add", millis, x, y);        // addWrapped test        x = fieldA.addWrapped(millis, value);        y = fieldB.addWrapped(millis, value);        testMillis(fieldA, fieldB, "addWrapped", millis, x, y);        // getDifference test        x = fieldA.getDifference(millis, millis2);        y = fieldB.getDifference(millis, millis2);        try {            testValue(fieldA, fieldB, "getDifference", millis, x, y);        } catch (RuntimeException e) {            System.out.println("Test datetime 2: " + makeDatetime(millis2));            throw e;        }        // isLeap test        m = fieldA.isLeap(millis);        n = fieldB.isLeap(millis);        testBoolean(fieldA, fieldB, "isLeap", millis, m, n);        // getLeapAmount test        a = fieldA.getLeapAmount(millis);        b = fieldB.getLeapAmount(millis);        testValue(fieldA, fieldB, "getLeapAmount", millis, a, b);    }    private int getWrappedValue(int value, int minValue, int maxValue) {        if (minValue >= maxValue) {            throw new IllegalArgumentException("MIN > MAX");        }        int wrapRange = maxValue - minValue + 1;        value -= minValue;        if (value >= 0) {            return (value % wrapRange) + minValue;        }        int remByRange = (-value) % wrapRange;        if (remByRange == 0) {            return 0 + minValue;        }        return (wrapRange - remByRange) + minValue;    }    private void testValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        if (valueA != valueB) {            failValue(fieldA, fieldB, method, millis, valueA, valueB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB);        }    }    private void testMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        if (millisA != millisB) {            failMillis(fieldA, fieldB, method, millis, millisA, millisB, valueA, valueB);        }    }    private void testBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        if (boolA != boolB) {            failBoolean(fieldA, fieldB, method, millis, boolA, boolB);        }    }    private void failValue(DateTimeField fieldA, DateTimeField fieldB,                           String method, long millis, long valueA, long valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(valueA + " != " + valueB);        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        throw new RuntimeException();    }    private void failMillis(DateTimeField fieldA, DateTimeField fieldB,                            String method, long millis, long millisA, long millisB,                            int valueA, int valueB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(makeDatetime(millisA) + " != " + makeDatetime(millisB));        System.out.println(millisA + " != " + millisB);        System.out.println("Original value as reported by first field: " +                           fieldA.get(millis));        System.out.println("Original value as reported by second field: " +                           fieldB.get(millis));        System.out.println("First new value as reported by first field: " +                           fieldA.get(millisA));        System.out.println("First new value as reported by second field: " +                           fieldB.get(millisA));        System.out.println("Second new value as reported by first field: " +                           fieldA.get(millisB));        System.out.println("Second new value as reported by second field: " +                           fieldB.get(millisB));        System.out.println("Value to set for first field: " + valueA);        System.out.println("Value to set for second field: " + valueB);        throw new RuntimeException();    }    private void failBoolean(DateTimeField fieldA, DateTimeField fieldB,                             String method, long millis, boolean boolA, boolean boolB) {        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);        System.out.println(fieldA.getClass().getName() + "\n\tvs. "                           + fieldB.getClass().getName());        System.out.println("Datetime: " + makeDatetime(millis));        System.out.println("Millis from 1970: " + millis);        System.out.println(boolA + " != " + boolB);        throw new RuntimeException();    }    private String makeName(DateTimeField fieldA, DateTimeField fieldB) {        if (fieldA.getName().equals(fieldB.getName())) {            return fieldA.getName();        } else {            return fieldA.getName() + "/" + fieldB.getName();        }    }    private String makeDatetime(long millis) {        return makeDatetime(millis, iActual);    }    private String makeDatetime(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString() + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }    private String makeDate(long millis) {        return makeDate(millis, iActual);    }    private String makeDate(long millis, Chronology chrono) {        return chrono.dayOfWeek().getAsShortText(millis) + " "            + new DateTime(millis, chrono).toString("yyyy-MM-dd") + " / " +            chrono.weekyear().get(millis) + "-W" + chrono.weekOfWeekyear().get(millis) +            "-" + chrono.dayOfWeek().get(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.chrono.Utils;/** *  * @author Brian S O'Neill */class TestJulianWeekyearField extends TestGJWeekyearField {    public TestJulianWeekyearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapped(long millis, int value) {        int weekyear = get(millis);        int wrapped = Utils.getWrappedValue            (weekyear, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - weekyear);    }    public long add(long millis, long value) {        int weekyear = get(millis);        int newWeekyear = weekyear + Utils.safeToInt(value);        if (weekyear < 0) {            if (newWeekyear >= 0) {                newWeekyear++;            }        } else {            if (newWeekyear <= 0) {                newWeekyear--;            }        }        return set(millis, newWeekyear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekOfWeekyearField extends TestGJDateTimeField {    public TestGJWeekOfWeekyearField(TestGJChronology chrono) {        super("weekOfWeekyear", "weeks",              (long)(chrono.MILLIS_PER_DAY * 7), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[1];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(wwd[0], value, wwd[2]);    }    public long add(long millis, long value) {        return iChronology.dayOfYear().add(millis, value * 7);    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 53;    }    public int getMaximumValue(long millis) {        // Move millis to end of weekyear.        millis = iChronology.weekyear().roundFloor(millis);        millis = iChronology.weekyear().add(millis, 1);        millis = iChronology.dayOfYear().add(millis, -1);        return get(millis);    }    public long roundFloor(long millis) {        int[] wwd = iChronology.isoFromMillis(millis);        return iChronology.millisFromISO(wwd[0], wwd[1], 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfYearField extends TestGJDateTimeField {    public TestGJDayOfYearField(TestGJChronology chrono) {        super("dayOfYear", "days", chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int year = iChronology.gjYearFromMillis(millis);        return (int)(iChronology.fixedFromMillis(millis)                     - iChronology.fixedFromGJ(year, 1, 1)) + 1;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 366;    }    public int getMaximumValue(long millis) {        return iChronology.year().isLeap(millis) ? 366 : 365;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.chrono.Utils;/** *  * @author Brian S O'Neill */class TestJulianYearField extends TestGJYearField {    public TestJulianYearField(TestJulianChronology chrono) {        super(chrono);    }    public long addWrapped(long millis, int value) {        int year = get(millis);        int wrapped = Utils.getWrappedValue            (year, value, getMinimumValue(), getMaximumValue());        return add(millis, (long) wrapped - year);    }    public long add(long millis, long value) {        int year = get(millis);        int newYear = year + Utils.safeToInt(value);        if (year < 0) {            if (newYear >= 0) {                newYear++;            }        } else {            if (newYear <= 0) {                newYear--;            }        }        return set(millis, newYear);    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJMonthOfYearField extends TestGJDateTimeField {    public TestGJMonthOfYearField(TestGJChronology chrono) {        super("monthOfYear", "months", chrono.millisPerMonth(), chrono);    }    public int get(long millis) {        return iChronology.gjFromMillis(millis)[1];    }    public long set(long millis, int value) {        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);        int[] ymd = iChronology.gjFromMillis(millis);        // First set to start of month...        millis = iChronology.millisFromGJ(ymd[0], value, 1);        // ...and use dayOfMonth field to check range.        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);        if (ymd[2] > maxDay) {            ymd[2] = maxDay;        }        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);    }    public long add(long millis, long value) {        int newYear = iChronology.year().get(millis)            + (int)iChronology.div(value, 12);        int newMonth = get(millis) + (int)iChronology.mod(value, 12);        if (newMonth > 12) {            newYear++;            newMonth -= 12;        }        int newDay = iChronology.dayOfMonth().get(millis);        millis = iChronology.getTimeOnlyMillis(millis)             + iChronology.millisFromGJ(newYear, newMonth, newDay);        while (get(millis) != newMonth) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public boolean isLeap(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return ymd[1] == 2 && iChronology.isLeapYear(ymd[0]);    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return iChronology.years();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 12;    }    public long roundFloor(long millis) {        int[] ymd = iChronology.gjFromMillis(millis);        return iChronology.millisFromGJ(ymd[0], ymd[1], 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJDayOfWeekField extends TestGJDateTimeField {    public TestGJDayOfWeekField(TestGJChronology chrono) {        super("dayOfWeek", "days", chrono.MILLIS_PER_DAY, chrono);    }    public int get(long millis) {        int dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);        if (dayOfWeek == 0) {            dayOfWeek = 7;        }        return dayOfWeek;    }    public long set(long millis, int value) {        return add(millis, (long) value - get(millis));    }    public long add(long millis, long value) {        return millis + value * iChronology.MILLIS_PER_DAY;    }    public DurationField getRangeDurationField() {        return iChronology.weeks();    }    public int getMinimumValue() {        return 1;    }    public int getMaximumValue() {        return 7;    }    public long roundFloor(long millis) {        return iChronology.getDateOnlyMillis(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;/** *  * @author Brian S O'Neill */class TestJulianDayOfMonthField extends TestGJDayOfMonthField {    public TestJulianDayOfMonthField(TestJulianChronology chrono) {        super(chrono);    }    public long getRangeMillis() {        return iChronology.millisPerMonth();    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJYearField extends TestGJDateTimeField {    public TestGJYearField(TestGJChronology chrono) {        super("year", "years", chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.gjYearFromMillis(millis);    }    public long set(long millis, int value) {        int[] ymd = iChronology.gjFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromGJ(value, ymd[1], ymd[2]);        if (ymd[1] == 2 && ymd[2] == 29 && !iChronology.isLeapYear(value)) {            millis = iChronology.dayOfYear().add(millis, -1);        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public boolean isLeap(long millis) {        return iChronology.isLeapYear(get(millis));    }    public int getLeapAmount(long millis) {        return isLeap(millis) ? 1 : 0;    }    public DurationField getLeapDurationField() {        return iChronology.days();    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromGJ(get(millis), 1, 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;/** * A reference Julian chronology implementation, intended for testing purposes * only. Correctness is favored over performance. The key functions for date * calculations are based on ones provided in "Calendrical Calculations", ISBN * 0-521-77752-6. * * @author Brian S O'Neill */public final class TestJulianChronology extends TestGJChronology {    private static final long JULIAN_EPOCH;    static {        // Constant as defined in book.        JULIAN_EPOCH = new TestGregorianChronology().fixedFromGJ(0, 12, 30);    }    /**     * Constructs with an epoch of 1969-12-19.     */    public TestJulianChronology() {        super(1969, 12, 19);    }    public TestJulianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public DateTimeField dayOfMonth() {        return new TestJulianDayOfMonthField(this);     }    public DateTimeField weekyear() {        return new TestJulianWeekyearField(this);    }    public DateTimeField monthOfYear() {        return new TestJulianMonthOfYearField(this);    }    public DateTimeField year() {        return new TestJulianYearField(this);    }    public String toString() {        return "TestJulianChronology";    }    long millisPerYear() {        return (long)(365.25 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.25 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        return mod(year, 4) == (year > 0 ? 0 : 3);    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        if (year == 0) {            throw new IllegalArgumentException("Illegal year: " + year);        }        int y = (year < 0) ? year + 1 : year;        long y_m1 = y - 1;        long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4)            + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        return gjFromFixed(date)[0];    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);        long year = (approx <= 0) ? approx - 1 : approx;        int year_i = (int)year;        if (year_i != year) {            throw new RuntimeException("year cannot be cast to an int: " + year);        }        long priorDays = date - fixedFromGJ(year_i, 1, 1);        long correction;        if (date < fixedFromGJ(year_i, 3, 1)) {            correction = 0;        } else if (isLeapYear(year_i)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year_i, monthOfYear, 1) + 1);        return new int[]{year_i, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        if (weekyear == 0) {            throw new IllegalArgumentException("Illegal weekyear: " + weekyear);        }        if (weekyear == 1) {            weekyear = -1;        } else {            weekyear--;        }        return nthWeekday(weekOfWeekyear, 0, weekyear, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        int nextWeekyear;        if (weekyear == -1) {            nextWeekyear = 1;        } else {            nextWeekyear = weekyear + 1;        }        if (date >= fixedFromISO(nextWeekyear, 1, 1)) {            weekyear = nextWeekyear;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.chrono.ImpreciseDateTimeField;import org.joda.time.chrono.Utils;/** *  * @author Brian S O'Neill */abstract class TestGJDateTimeField extends ImpreciseDateTimeField {    protected final TestGJChronology iChronology;    public TestGJDateTimeField(String name, String duratioName,                               long unitMillis, TestGJChronology chrono) {        super(name, duratioName, unitMillis);        iChronology = chrono;    }    public boolean isLenient() {        return false;    }    public long add(long instant, int value) {        return add(instant, (long)value);    }    public abstract long add(long instant, long value);}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.DurationField;/** *  * @author Brian S O'Neill */class TestGJWeekyearField extends TestGJDateTimeField {    public TestGJWeekyearField(TestGJChronology chrono) {        super("weekyear", "weekyears", chrono.millisPerYear(), chrono);    }    public int get(long millis) {        return iChronology.isoFromMillis(millis)[0];    }    public long set(long millis, int value) {        int[] wwd = iChronology.isoFromMillis(millis);        millis = iChronology.getTimeOnlyMillis(millis)            + iChronology.millisFromISO(value, wwd[1], wwd[2]);        if (wwd[1] == 53) {            int[] wwd2 = iChronology.isoFromMillis(millis);            if (wwd2[0] != value) {                // Set year doesn't have 53 weeks, so back off a week.                millis = iChronology.dayOfYear().add(millis, -7);            }        }        return millis;    }    public long add(long millis, long value) {        return set(millis, (int)(get(millis) + value));    }    public DurationField getRangeDurationField() {        return null;    }    public int getMinimumValue() {        return -100000000;    }    public int getMaximumValue() {        return 100000000;    }    public long roundFloor(long millis) {        return iChronology.millisFromISO(get(millis), 1, 1);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time.chrono.gj;import org.joda.time.Chronology;import org.joda.time.DateTimeField;import org.joda.time.DateTimeZone;/** * A reference Gregorian chronology implementation, intended for testing * purposes only. Correctness is favored over performance. The key functions * for date calculations are based on ones provided in "Calendrical * Calculations", ISBN 0-521-77752-6. * * @author Brian S O'Neill */public final class TestGregorianChronology extends TestGJChronology {    /**     * Constructs with an epoch of 1970-01-01.     */    public TestGregorianChronology() {        super(1970, 1, 1);    }    public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {        super(epochYear, epochMonth, epochDay);    }    public String toString() {        return "TestGregorianChronology";    }    long millisPerYear() {        return (long)(365.2425 * MILLIS_PER_DAY);    }    long millisPerMonth() {        return (long)(365.2425 * MILLIS_PER_DAY / 12);    }    boolean isLeapYear(int year) {        if (mod(year, 4) == 0) {            int t = (int)mod(year, 400);            if (t != 100 && t != 200 & t != 300) {                return true;            }        }        return false;    }    /**     * @return days from 0001-01-01     */    long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) {        long year_m1 = year - 1;        long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100)            + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;        if (monthOfYear > 2) {            f += isLeapYear(year) ? -1 : -2;        }        return f;    }    /**     * @param date days from 0001-01-01     * @return gj year     */    int gjYearFromFixed(long date) {        long d0 = date - 1;        long n400 = div(d0, 146097);        long d1 = mod(d0, 146097);        long n100 = div(d1, 36524);        long d2 = mod(d1, 36524);        long n4 = div(d2, 1461);        long d3 = mod(d2, 1461);        long n1 = div(d3, 365);        long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;        if (!(n100 == 4 || n1 == 4)) {            year += 1;        }        int year_i = (int)year;        if (year_i == year) {            return year_i;        } else {            throw new RuntimeException("year cannot be cast to an int: " + year);        }    }    /**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */    int[] gjFromFixed(long date) {        int year = gjYearFromFixed(date);        long priorDays = date - fixedFromGJ(year, 1, 1);        long correction;        if (date < fixedFromGJ(year, 3, 1)) {            correction = 0;        } else if (isLeapYear(year)) {            correction = 1;        } else {            correction = 2;        }        int monthOfYear = (int)div(12 * (priorDays + correction) + 373, 367);        int day = (int)(date - fixedFromGJ(year, monthOfYear, 1) + 1);        return new int[]{year, monthOfYear, day};    }    long fixedFromISO(int weekyear, int weekOfWeekyear, int dayOfWeek) {        return nthWeekday(weekOfWeekyear, 0, weekyear - 1, 12, 28) + dayOfWeek;    }    /**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */    int[] isoFromFixed(long date) {        int weekyear = gjYearFromFixed(date - 3);        if (date >= fixedFromISO(weekyear + 1, 1, 1)) {            weekyear += 1;        }        int weekOfWeekyear = (int)(div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);        int dayOfWeek = (int)amod(date, 7);        return new int[]{weekyear, weekOfWeekyear, dayOfWeek};    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;//import java.util.*;//import java.text.* ;import junit.framework.TestSuite;//import org.joda.time.*;//import org.joda.time.gj.*;//import org.joda.time.iso.*;/** * This class is a Junit unit test for the * GJDateTimeParserBucket date time class. * * @author Stephen Colebourne * @author Guy Allard */public class TestDateTimeParserBucket extends BulkTest {/** * This is the main class for this test suite. * @param args command line arguments. */public static void main(String[] args) {junit.textui.TestRunner.run(suite());}/** * TestSuite is a junit required method. */public static TestSuite suite() {return BulkTest.makeSuite(TestDateTimeParserBucket.class);}/** * TestDateTimeField constructor. * @param name */public TestDateTimeParserBucket(String name) {super(name);}// Class Name: org.joda.time.format.DateTimeParserBucket/** * Junit <code>setUp()</code> method. */protected void setUp() /* throws Exception */ {// super.setUp();}/** * Junit <code>tearDown()</code> method. */protected void tearDown() /* throws Exception */ {// super.tearDown();}/** * Test the <code>setMillis(long)</code> method. * @see org.joda.time.format.DateTimeParserBucket#setMillis(long) */public void testSetMillis() {fail("TBD");}/** * Test the <code>saveField(org.joda.time.DateTimeField, int, int)</code> method. * @see org.joda.time.format.DateTimeParserBucket#saveField(org.joda.time.DateTimeField, int, int) */public void testSaveField() {fail("TBD");}/** * Test the <code>setTimeZone(java.util.TimeZone)</code> method. * @see org.joda.time.format.DateTimeParserBucket#setTimeZone(java.util.TimeZone) */public void testSetTimeZone() {fail("TBD");}/** * Test the <code>setTimeZoneOffset(int)</code> method. * @see org.joda.time.format.DateTimeParserBucket#setTimeZoneOffset(int) */public void testSetTimeZoneOffset() {fail("TBD");}/** * Test the <code>getTimeZone()</code> method. * @see org.joda.time.format.DateTimeParserBucket#getTimeZone() */public void testGetTimeZone() {fail("TBD");}/** * Test the <code>getTimeZoneOffset()</code> method. * @see org.joda.time.format.DateTimeParserBucket#getTimeZoneOffset() */public void testGetTimeZoneOffset() {fail("TBD");}/** * Test the <code>computeMillis()</code> method. * @see org.joda.time.format.DateTimeParserBucket#computeMillis() */public void testComputeMillis() {fail("TBD");}}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.io.PrintStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.SimpleTimeZone;import java.util.TimeZone;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.Instant;import org.joda.time.MutableDateTime;import org.joda.time.ReadableInstant;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.MutableDateTime class. * This currently forces tests using GMT only. * * @author Guy Allard */public class TestMDTAddWrapped extends BulkTest {    /**     * main     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestMDTAddWrapped.class);    }    /**     * TestMDTAddWrapped constructor.     * @param name     */    public TestMDTAddWrapped(String name) {        super(name);    }    // Class Name: org.joda.time.MutableDateTime    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() /* throws Exception */ {        // super.setUp();        ++testNum;        TimeZone.setDefault( new SimpleTimeZone(0, "UTC") );        // gcals = gcalsMiscBunch;    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();    }    private boolean debug = true;    private static int testNum = 0;    private PrintStream ewtr = System.err;    GregorianCalendar[] gcals0 = {        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),    };    /**     *     */    ReadableInstant rica = null;    /**     *     */    Chronology cronca = null;    /**     *     */    Date jdtca = null;    /**     *     */    Calendar calca = null;    /**     *     */    GregorianCalendar[] gcals = null;    /**     *     */    final int bumpValue = 385;    // final int bumpValue = 0;    /**     *     */    // GregorianCalendar gcal = null;    /**     *     */    String isoString = null;    /**     *     */    MutableDateTime mdt = null;    /**     *     */    Chronology chrona = null;    /**     *     */    long setMillis = -1L;    /**     *     */    int setYear = -1;    int setMonth = -1;    int setDay = -1;    int setHour = -1;    int setMinute = -1;    int setSecond = -1;    int setMillisecond = -1;    String setString = null;    String yearStr = null;    String monthStr = null;    String dayStr = null;    String hourStr = null;    String minuteStr = null;    String secondStr = null;    String millisecondStr = null;    /**     *     */    Long longVal = null;    /**     *     */    boolean failed;    /**     *     */    public void testFailure() {        fail("TBD - all MDT Add tests");    }    public void testLast() {        ewtr.println("TestMDTAddWrapped completes");        ewtr.flush();    }    //-----------------------------------------------------------------    //    // Private methods.    //    //    private  void prepTest(int item) {        GregorianCalendar wrkgcal = new GregorianCalendar(            gcals[item].get( Calendar.YEAR ),            gcals[item].get( Calendar.MONTH ),            gcals[item].get( Calendar.DATE ),            gcals[item].get( Calendar.HOUR ),            gcals[item].get( Calendar.MINUTE ),            gcals[item].get( Calendar.SECOND )        );        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));        //        wrkgcal.add(Calendar.MILLISECOND, bumpValue);        wrkgcal.setMinimalDaysInFirstWeek(4);        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);        //        // Force the GregorianCalendar to recalculate all internal        // values.        //        wrkgcal.setTime( wrkgcal.getTime() );        if ( debug ) {            ewtr.println("====Test Number: " + testNum);            ewtr.println("  ==Item Number: " + item);            ewtr.flush();        }        isoString = getDateTimeString( wrkgcal );        mdt = null;        try        {            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );        }        catch(IllegalArgumentException pe)        {            ewtr.println("IllegalArgumentException Detected: " + isoString);            ewtr.println( pe.getMessage() );            ewtr.flush();        }        if ( debug ) {            ewtr.println("    =ISO String: " + isoString);            ewtr.flush();        }        setMillis = System.currentTimeMillis();        GregorianCalendar gx = new GregorianCalendar();        gx.setTime( new Date( setMillis ) );        //        setYear = gx.get(Calendar.YEAR);        setMonth = gx.get(Calendar.MONTH) + 1;        setDay = gx.get(Calendar.DATE);        setHour = gx.get(Calendar.HOUR_OF_DAY);        setMinute = gx.get(Calendar.MINUTE);        setSecond = gx.get(Calendar.SECOND);        setMillisecond = gx.get(Calendar.MILLISECOND);        //        rica = new Instant( setMillis );        jdtca = new Date( setMillis );        calca = Calendar.getInstance();        calca.setTime( jdtca );        longVal = new Long( setMillis );        //        MutableDateTime temp = new MutableDateTime( setMillis,            ISOChronology.getInstanceUTC() );        setString = "" + temp;    }} // end of class TestMDTAddWrapped
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.io.PrintStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.SimpleTimeZone;import java.util.TimeZone;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.Instant;import org.joda.time.MutableDateTime;import org.joda.time.ReadableInstant;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.MutableDateTime class. * This currently forces tests using GMT only. * * @author Guy Allard */public class TestMDTAdd extends BulkTest {    /**     * main     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestMDTAdd.class);    }    /**     * TestMDTAdd constructor.     * @param name     */    public TestMDTAdd(String name) {        super(name);    }    // Class Name: org.joda.time.MutableDateTime    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() /* throws Exception */ {        // super.setUp();        ++testNum;        TimeZone.setDefault( new SimpleTimeZone(0, "UTC") );        // gcals = gcalsMiscBunch;    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();    }    private boolean debug = true;    private static int testNum = 0;    private PrintStream ewtr = System.err;    GregorianCalendar[] gcals0 = {        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),    };    /**     *     */    ReadableInstant rica = null;    /**     *     */    Chronology cronca = null;    /**     *     */    Date jdtca = null;    /**     *     */    Calendar calca = null;    /**     *     */    GregorianCalendar[] gcals = null;    /**     *     */    final int bumpValue = 385;    // final int bumpValue = 0;    /**     *     */    // GregorianCalendar gcal = null;    /**     *     */    String isoString = null;    /**     *     */    MutableDateTime mdt = null;    /**     *     */    Chronology chrona = null;    /**     *     */    long setMillis = -1L;    /**     *     */    int setYear = -1;    int setMonth = -1;    int setDay = -1;    int setHour = -1;    int setMinute = -1;    int setSecond = -1;    int setMillisecond = -1;    String setString = null;    String yearStr = null;    String monthStr = null;    String dayStr = null;    String hourStr = null;    String minuteStr = null;    String secondStr = null;    String millisecondStr = null;    /**     *     */    Long longVal = null;    /**     *     */    boolean failed;    /**     * Test the <code>addMillis(long)</code> method.     * @see org.joda.time.MutableDateTime#add(long)     */    public void testAddMillis() {        fail("TBD");    }    public void testLast() {        ewtr.println("TestMDTAdd completes");        ewtr.flush();    }    //-----------------------------------------------------------------    //    // Private methods.    //    //    private  void prepTest(int item) {        GregorianCalendar wrkgcal = new GregorianCalendar(            gcals[item].get( Calendar.YEAR ),            gcals[item].get( Calendar.MONTH ),            gcals[item].get( Calendar.DATE ),            gcals[item].get( Calendar.HOUR ),            gcals[item].get( Calendar.MINUTE ),            gcals[item].get( Calendar.SECOND )        );        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));        //        wrkgcal.add(Calendar.MILLISECOND, bumpValue);        wrkgcal.setMinimalDaysInFirstWeek(4);        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);        //        // Force the GregorianCalendar to recalculate all internal        // values.        //        wrkgcal.setTime( wrkgcal.getTime() );        if ( debug ) {            ewtr.println("====Test Number: " + testNum);            ewtr.println("  ==Item Number: " + item);            ewtr.flush();        }        isoString = getDateTimeString( wrkgcal );        mdt = null;        try        {            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );        }        catch(IllegalArgumentException pe)        {            ewtr.println("IllegalArgumentException Detected: " + isoString);            ewtr.println( pe.getMessage() );            ewtr.flush();        }        if ( debug ) {            ewtr.println("    =ISO String: " + isoString);            ewtr.flush();        }        setMillis = System.currentTimeMillis();        GregorianCalendar gx = new GregorianCalendar();        gx.setTime( new Date( setMillis ) );        //        setYear = gx.get(Calendar.YEAR);        setMonth = gx.get(Calendar.MONTH) + 1;        setDay = gx.get(Calendar.DATE);        setHour = gx.get(Calendar.HOUR_OF_DAY);        setMinute = gx.get(Calendar.MINUTE);        setSecond = gx.get(Calendar.SECOND);        setMillisecond = gx.get(Calendar.MILLISECOND);        //        rica = new Instant( setMillis );        jdtca = new Date( setMillis );        calca = Calendar.getInstance();        calca.setTime( jdtca );        longVal = new Long( setMillis );        //        MutableDateTime temp = new MutableDateTime( setMillis,            ISOChronology.getInstanceUTC() );        setString = "" + temp;    }} // end of class TestMDTAdd
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.io.PrintStream;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.SimpleTimeZone;import java.util.TimeZone;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.Instant;import org.joda.time.MutableDateTime;import org.joda.time.ReadableInstant;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.MutableDateTime class. * This currently forces tests using GMT only. * * @author Guy Allard */public class TestMDTSet extends BulkTest {    /**     * main     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestMDTSet.class);    }    /**     * TestMDTSet constructor.     * @param name     */    public TestMDTSet(String name) {        super(name);    }    // Class Name: org.joda.time.MutableDateTime    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() /* throws Exception */ {        // super.setUp();        ++testNum;        TimeZone.setDefault( new SimpleTimeZone(0, "UTC") );        gcals = gcals0;        // gcals = gcalsMiscBunch;    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();    }    private boolean debug = true;    private static int testNum = 0;    private PrintStream ewtr = System.err;    /**     *     */    Long longVal = null;    /**     *     */    boolean failed;    // Developers/Testers Note:    //    // 1) Construct any valid array of Gregorian calendar objects,    //    e.g. 'gcals1' below.    // 2) Change the assignment statement in the setUp() method.    // 3) Recompile+jar.    //    // The new array will be used in all the tests.    //    /**     *     */    GregorianCalendar[] gcals0 = {        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),    };    GregorianCalendar[] gcals1 = {        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(1999, 1, 1, 0, 0, 0),        new GregorianCalendar(1999, 2, 1, 0, 0, 0),        new GregorianCalendar(2000, 0, 1, 0, 0, 0),        new GregorianCalendar(2000, 1, 1, 0, 0, 0),        new GregorianCalendar(2000, 2, 1, 0, 0, 0),    };    GregorianCalendar[] gcalsGJCutOver = {        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),    };    GregorianCalendar[] gcalsPreCut = {        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),    };    GregorianCalendar[] gcalsYear0 = {        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),    };    GregorianCalendar[] gcalsYearM1 = {        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),    };    GregorianCalendar[] gcalsEndPoints = {        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),    };    // This don't work.  ParseException from the CTOR.    GregorianCalendar[] gcalsOutSide = {        new GregorianCalendar(+76542, Calendar.DECEMBER, 31, 23, 59, 59),        new GregorianCalendar(-12345, Calendar.JANUARY, 1, 0, 0, 0),    };    //    GregorianCalendar[] gcalsMiscBunch = {        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(1999, 1, 1, 0, 0, 0),        new GregorianCalendar(1999, 2, 1, 0, 0, 0),        new GregorianCalendar(2000, 0, 1, 0, 0, 0),        new GregorianCalendar(2000, 1, 1, 0, 0, 0),        new GregorianCalendar(2000, 2, 1, 0, 0, 0),    };    /**     *     */    ReadableInstant rica = null;    /**     *     */    Chronology cronca = null;    /**     *     */    Date jdtca = null;    /**     *     */    Calendar calca = null;    /**     *     */    GregorianCalendar[] gcals = null;    /**     *     */    final int bumpValue = 385;    // final int bumpValue = 0;    /**     *     */    // GregorianCalendar gcal = null;    /**     *     */    String isoString = null;    /**     *     */    MutableDateTime mdt = null;    /**     *     */    Chronology chrona = null;    /**     *     */    long setMillis = -1L;    /**     *     */    int setYear = -1;    int setMonth = -1;    int setDay = -1;    int setHour = -1;    int setMinute = -1;    int setSecond = -1;    int setMillisecond = -1;    String setString = null;    String yearStr = null;    String monthStr = null;    String dayStr = null;    String hourStr = null;    String minuteStr = null;    String secondStr = null;    String millisecondStr = null;    //    // Long longVal = null;    //    boolean getsDone = true;    //    // Test 'set' methods - 2nd.    //    //----------------------------------------------------------------    //    // Sets of Millis value.    //    /**     * Test the <code>setMillis(long)</code> method.     * @see org.joda.time.MutableDateTime#setMillis(long)     */    public void testSetMillisL() {        getsDone = true;        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            mdt.setMillis( setMillis );            assertEquals("SML1:"+isoString+":"+setString,                mdt.getMillis(), setMillis);        }    }    /**     * Test the <code>setMillis(java.lang.Object)</code> method.     * @see org.joda.time.MutableDateTime#setMillis(java.lang.Object)     */    public void testSetMillisO() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            //ewtr.println("getsDone: " + getsDone);            //ewtr.println("rica: " + rica);            //ewtr.flush();            mdt.setMillis( rica );            assertEquals("SMO1:"+isoString+":"+setString,                setString, ""+mdt);            //            mdt.setMillis( jdtca );            assertEquals("SMO2:"+isoString+":"+setString,                setString, ""+mdt);            //            mdt.setMillis( calca );            assertEquals("SMO3:"+isoString+":"+setString,                setString, ""+mdt);            //            mdt.setMillis( longVal );            assertEquals("SMO4:"+isoString+":"+setString,                setString, ""+mdt);            //            mdt.setMillis( setString );            assertEquals("SMO5:"+isoString+":"+setString,                setString, ""+mdt);            //            failed = false;            rica = null;            try            {                mdt.setMillis( rica );            }            catch(IllegalArgumentException iae)            {                failed = true;            }            if ( !failed ) {                fail("SMO6:null");            }        }    }    //    // Set of individual fields through individual DateTe=imeFields.    //    /**     * Test the <code>set(org.joda.time.DateTimeField, int)</code> method.     * @see org.joda.time.MutableDateTime#set(org.joda.time.DateTimeField, int)     */    public void testSetDTFI() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            mdt.set( mdt.year().getField(), setYear );            mdt.set( mdt.monthOfYear().getField(), setMonth );            mdt.set( mdt.dayOfMonth().getField(), setDay );            mdt.set( mdt.hourOfDay().getField(), setHour );            mdt.set( mdt.minuteOfHour().getField(), setMinute );            mdt.set( mdt.secondOfMinute().getField(), setSecond );            mdt.set( mdt.millisOfSecond().getField(), setMillisecond );            //ewtr.println("setString: " + setString);            //ewtr.println("mdt: " + mdt);            assertEquals("DTFI1:"+isoString+":"+setString,                setString, ""+mdt);        }    }    //    // Sets of the date portion.    //    /**     * Test the <code>setDate(long)</code> method.     * @see org.joda.time.MutableDateTime#setDate(long)     */    public void testSetDateL() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            String before = "" + mdt;            mdt.setDate( setMillis );            String after = "" + mdt;            assertEquals("SDL1:",                rhsDT(before), rhsDT(after) );            assertEquals("SDL2:",                lhsDT(setString), lhsDT(after) );        }    }    /**     * Test the <code>setDate(java.lang.Object)</code> method.     * @see org.joda.time.MutableDateTime#setDate(java.lang.Object)     */    public void testSetDateO() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            //            String before = "" + mdt;            String rhsBefore = rhsDT( before );            //            mdt.setDate( rica );            String after = "" + mdt;            String rhsAfter = rhsDT( after );            assertEquals("SDO1:",                rhsBefore, rhsAfter);            assertEquals("SDO1A:",                lhsDT(setString), lhsDT(after));            //            mdt.setDate( jdtca );            after = "" + mdt;            rhsAfter = rhsDT( after );            assertEquals("SDO2:",                rhsBefore, rhsAfter);            assertEquals("SDO2A:",                lhsDT(setString), lhsDT(after));            //            mdt.setDate( calca );            after = "" + mdt;            rhsAfter = rhsDT( after );            assertEquals("SDO3:",                rhsBefore, rhsAfter);            assertEquals("SDO3A:",                lhsDT(setString), lhsDT(after));            //            mdt.setDate( longVal );            after = "" + mdt;            rhsAfter = rhsDT( after );            assertEquals("SDO4:",                rhsBefore, rhsAfter);            assertEquals("SDO4A:",                lhsDT(setString), lhsDT(after));            //            mdt.setDate( setString );            after = "" + mdt;            rhsAfter = rhsDT( after );            assertEquals("SDO5:",                rhsBefore, rhsAfter);            assertEquals("SDO5A:",                lhsDT(setString), lhsDT(after));            //            failed = false;            rica = null;            try            {                mdt.setDate( rica );            }            catch(IllegalArgumentException iae)            {                failed = true;            }            if ( !failed ) {                fail("SDO6:null");            }        }    }    /**     * Test the <code>setDate(int, int, int)</code> method.     * @see org.joda.time.MutableDateTime#setDate(int, int, int)     */    public void testSetDateIII() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            //            String before = "" + mdt;            String rhsBefore = rhsDT( before );            //            mdt.setDate( setYear, setMonth, setDay );            //            String after = "" + mdt;            String rhsAfter = rhsDT( after );            assertEquals("DIII1:",                rhsBefore, rhsAfter);            assertEquals("DIII1A:",                lhsDT(setString), lhsDT(after));        }    }    //    // Sets of the time portion of the DT.    //    /**     * Test the <code>setTime(long)</code> method.     * @see org.joda.time.MutableDateTime#setTime(long)     */    public void testSetTimeL() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            String before = "" + mdt;            mdt.setTime( setMillis );            String after = "" + mdt;            assertEquals("SDL1:",                lhsDT(before), lhsDT(after) );            assertEquals("SDL2:",                rhsDT(setString), rhsDT(after) );        }    }    /**     * Test the <code>setTime(java.lang.Object)</code> method.     * @see org.joda.time.MutableDateTime#setTime(java.lang.Object)     */    public void testSetTimeO() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            String before = "" + mdt;            String lhsBefore = lhsDT( before );            //            mdt.setTime( rica );            String after = "" + mdt;            String lhsAfter = lhsDT( after );            // ewtr.println("before: " + before);            // ewtr.println("after: " + after);            // ewtr.println("setString: " + setString);            // ewtr.flush();            assertEquals("STO1:",                lhsBefore, lhsAfter);            assertEquals("STO1A:",                rhsDT(setString), rhsDT(after));            //            mdt.setTime( jdtca );            after = "" + mdt;            lhsAfter = lhsDT( after );            assertEquals("STO2:",                lhsBefore, lhsAfter);            assertEquals("STO2A:",                rhsDT(setString), rhsDT(after));            //            mdt.setTime( calca );            after = "" + mdt;            lhsAfter = lhsDT( after );            assertEquals("STO3:",                lhsBefore, lhsAfter);            assertEquals("STO3A:",                rhsDT(setString), rhsDT(after));            //            mdt.setTime( longVal );            after = "" + mdt;            lhsAfter = lhsDT( after );            assertEquals("STO4:",                lhsBefore, lhsAfter);            assertEquals("STO4A:",                rhsDT(setString), rhsDT(after));            //            mdt.setTime( setString );            after = "" + mdt;            lhsAfter = lhsDT( after );            assertEquals("STO5:",                lhsBefore, lhsAfter);            assertEquals("STO5A:",                rhsDT(setString), rhsDT(after));            //            failed = false;            rica = null;            try            {                mdt.setTime( rica );            }            catch(IllegalArgumentException iae)            {                failed = true;            }            if ( !failed ) {                fail("STO6:null");            }        }    }    /**     * Test the <code>setTime(int, int, int, int)</code> method.     * @see org.joda.time.MutableDateTime#setTime(int, int, int, int)     */    public void testSetTimeIIII() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            String before = "" + mdt;            mdt.setTime( setHour, setMinute, setSecond, setMillisecond );            String after = "" + mdt;            assertEquals("TIII1:",                lhsDT(before), lhsDT(after) );            assertEquals("TIII2:",                rhsDT(setString), rhsDT(after) );        }    }    //    // Sets of both the Date and Time portions.    //    /**     * Test the <code>setDateTime(long)</code> method.     * @see org.joda.time.MutableDateTime#setDateTime(long)     */    public void testSetDateTimeL() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            mdt.setDateTime( setMillis );            assertEquals("SDT1:",                setString, ""+mdt );        }    }    /**     * Test the <code>setDateTime(java.lang.Object)</code> method.     * @see org.joda.time.MutableDateTime#setDateTime(java.lang.Object)     */    public void testSetDateTimeO() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            //            mdt.setDateTime( rica );            assertEquals("SDTO1:",                setString, ""+mdt );            //            mdt.setDateTime( jdtca );            assertEquals("SDTO2:",                setString, ""+mdt );            //            mdt.setDateTime( calca );            assertEquals("SDTO3:",                setString, ""+mdt );            //            mdt.setDateTime( longVal );            assertEquals("SDTO4:",                setString, ""+mdt );            //            mdt.setDateTime( setString );            assertEquals("SDTO5:",                setString, ""+mdt );            //            failed = false;            rica = null;            try            {                mdt.setDateTime( rica );            }            catch(IllegalArgumentException iae)            {                failed = true;            }            if ( !failed ) {                fail("SDTO6:null");            }        }    }    /**     * Test the <code>setDateTime(int, int, int, int, int, int, int)</code> method.     * @see org.joda.time.MutableDateTime#setDateTime(int, int, int, int, int, int, int)     */    public void testSetDateTimeIs() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            mdt.setDateTime( setYear, setMonth, setDay,                setHour, setMinute, setSecond, setMillisecond );            assertEquals("SDTIIs",                setString, ""+mdt );        }    }    //    // Individual field sets.    //    /**     * Test the <code>setYear(int)</code> method.     * @see org.joda.time.MutableDateTime#setYear(int)     */    public void testSetYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.setYear( setYear );            ArrayList after = getDTA( ""+mdt );            int[] mc = {3,5,7,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSYR1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(1);            assertEquals("TSYR2",                e, padNumberToLen(setYear,e.length())            );        }        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.year().set( setYear );            ArrayList after = getDTA( ""+mdt );            int[] mc = {3,5,7,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSYR1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(1);            assertEquals("TSYR2",                e, padNumberToLen(setYear,e.length())            );        }    }    /**     * Test the <code>setMonthOfYear(int)</code> method.     * @see org.joda.time.MutableDateTime#setMonthOfYear(int)     */    public void testSetMonthOfYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.setMonthOfYear( setMonth );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,5,7,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSMO1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(3);            assertEquals("TSMO2",                e, padNumberToLen(setMonth,e.length())            );        }        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.monthOfYear().set( setMonth );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,5,7,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSMO1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(3);            assertEquals("TSMO2",                e, padNumberToLen(setMonth,e.length())            );        }    }    /**     * Test the <code>setDayOfMonth(int)</code> method.     * @see org.joda.time.MutableDateTime#setDayOfMonth(int)     */    public void testSetDayOfMonth() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.setDayOfMonth( setDay );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,7,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSDA1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(5);            assertEquals("TSDA2",                e, padNumberToLen(setDay,e.length())            );        }        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.dayOfMonth().set( setDay );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,7,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSDA1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(5);            assertEquals("TSDA2",                e, padNumberToLen(setDay,e.length())            );        }    }    /**     * Test the <code>setHourOfDay(int)</code> method.     * @see org.joda.time.MutableDateTime#setHourOfDay(int)     */    public void testSetHourOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.setHourOfDay( setHour );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSHD1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(7);            assertEquals("TSHD2",                e, padNumberToLen(setHour,e.length())            );        }        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.hourOfDay().set( setHour );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,9,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSHD1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(7);            assertEquals("TSHD2",                e, padNumberToLen(setHour,e.length())            );        }    }    /**     * Test the <code>setMinuteOfHour(int)</code> method.     * @see org.joda.time.MutableDateTime#setMinuteOfHour(int)     */    public void testSetMinuteOfHour() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.setMinuteOfHour( setHour );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,7,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSMH1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(9);            assertEquals("TSMH2",                e, padNumberToLen(setHour,e.length())            );        }        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.minuteOfHour().set( setHour );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,7,11,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSMH1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(9);            assertEquals("TSMH2",                e, padNumberToLen(setHour,e.length())            );        }    }    /**     * Test the <code>setSecondOfMinute(int)</code> method.     * @see org.joda.time.MutableDateTime#setSecondOfMinute(int)     */    public void testSetSecondOfMinute() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.setSecondOfMinute( setSecond );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,7,9,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSSM1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(11);            assertEquals("TSSM2",                e, padNumberToLen(setSecond,e.length())            );        }        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.secondOfMinute().set( setSecond );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,7,9,13};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSSM1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(11);            assertEquals("TSSM2",                e, padNumberToLen(setSecond,e.length())            );        }    }    /**     * Test the <code>setMillisOfSecond(int)</code> method.     * @see org.joda.time.MutableDateTime#setMillisOfSecond(int)     */    public void testSetMillisOfSecond() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.setMillisOfSecond( setMillisecond );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,7,9,11};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSMS1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(13);            assertEquals("TSMS2",                e, padNumberToLen(setMillisecond,e.length())            );        }        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            ArrayList before = getDTA( ""+mdt );            mdt.millisOfSecond().set( setMillisecond );            ArrayList after = getDTA( ""+mdt );            int[] mc = {1,3,5,7,9,11};            for (int i = 0; i < mc.length; ++i) {                assertEquals("TSMS1",                    ""+(String)before.get(mc[i]),                    ""+(String)after.get(mc[i])                );            }            String e = (String)after.get(13);            assertEquals("TSMS2",                e, padNumberToLen(setMillisecond,e.length())            );        }    }    /**     * Test the <code>setDayOfYear(int)</code> method.     * @see org.joda.time.MutableDateTime#setDayOfYear(int)     */    public void testSetDayOfYear() {        //        ewtr.println("testSetDayOfYear needs enhancement");        ewtr.flush();        //        String ts = "1776-07-04T11:22:33.000Z";        //        mdt = getMDTFromString( ts );        mdt.setDayOfYear( 8 );        assertEquals("SDOY1",            "1776-01-08T11:22:33.000Z",            mdt.toString() );        mdt = getMDTFromString( ts );        mdt.setDayOfYear( 60 );        assertEquals("SDOY2",            "1776-02-29T11:22:33.000Z",            mdt.toString() );        mdt = getMDTFromString( ts );        mdt.setDayOfYear( 366 );        assertEquals("SDOY3",            "1776-12-31T11:22:33.000Z",            mdt.toString() );        mdt = getMDTFromString( ts );        failed = false;        try        {            mdt.setDayOfYear( 367 );        }        catch(IllegalArgumentException iae)        {            failed = true;        }        if ( !failed ) {            fail("SDOY4");        }        mdt = getMDTFromString( "1777-12-31T11:22:33.000Z" );        failed = false;        try        {            mdt.setDayOfYear( 366 );        }        catch(IllegalArgumentException iae)        {            failed = true;        }        if ( !failed ) {            fail("SDOY4");        }    }    /**     * Test the <code>setDayOfWeek(int)</code> method.     * @see org.joda.time.MutableDateTime#setDayOfWeek(int)     */    public void testSetDayOfWeek() {        //        ewtr.println("testSetDayOfWeek needs enhancement");        ewtr.flush();        String ts = "1776-07-04T11:22:33.000Z";        //        mdt = getMDTFromString( ts );        mdt.setDayOfWeek( DateTimeConstants.MONDAY );        assertEquals("SDOW1",            "1776-07-01T11:22:33.000Z",            mdt.toString() );        mdt.setDayOfWeek( DateTimeConstants.SUNDAY );        assertEquals("SDOW2",            "1776-07-07T11:22:33.000Z",            mdt.toString() );        //        failed = false;        try        {            mdt.setDayOfWeek( 8 );        }        catch(IllegalArgumentException iae)        {            failed = true;        }        if ( !failed ) {            fail("SWOY4");        }    }    /**     * Test the <code>setWeekOfYear(int, int)</code> method.     * @see org.joda.time.MutableDateTime#setWeekOfWeekyear(int)     */    public void testSetWeekOfYear() {        ewtr.println("testSetWeekOfYear needs enhancement");        ewtr.flush();        String ts = "1776-07-04T11:22:33.000Z";        //        mdt = getMDTFromString( ts );        mdt.setWeekyear( 1944 );        mdt.setWeekOfWeekyear( 2 );        assertEquals("SWOY1", 2, mdt.getWeekOfWeekyear());        assertEquals("SWOY2", 1944, mdt.getWeekyear());        assertEquals("SWOY3",            "1944-01-13T11:22:33.000Z",            mdt.toString() );        //        failed = false;        try        {            mdt.setWeekyear( 2003 );            mdt.setWeekOfWeekyear( 53 ); // 03 has 52 weeks        }        catch(IllegalArgumentException iae)        {            failed = true;        }        if ( !failed ) {            fail("SWOY4");        }        //        failed = false;        try        {            mdt.setWeekyear( 2004 );            mdt.setWeekOfWeekyear( 53 ); // 03 has 52 weeks        }        catch(IllegalArgumentException iae)        {            failed = true;        }        if ( failed ) {            fail("SWOY5");        }    }    public void testLast() {        ewtr.println("TestMDTSet completes");        ewtr.flush();    }    //-----------------------------------------------------------------    //    // Private methods.    //    //    private  void prepTest(int item) {        GregorianCalendar wrkgcal = new GregorianCalendar(            gcals[item].get( Calendar.YEAR ),            gcals[item].get( Calendar.MONTH ),            gcals[item].get( Calendar.DATE ),            gcals[item].get( Calendar.HOUR ),            gcals[item].get( Calendar.MINUTE ),            gcals[item].get( Calendar.SECOND )        );        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));        //        wrkgcal.add(Calendar.MILLISECOND, bumpValue);        wrkgcal.setMinimalDaysInFirstWeek(4);        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);        //        // Force the GregorianCalendar to recalculate all internal        // values.        //        wrkgcal.setTime( wrkgcal.getTime() );        if ( debug ) {            ewtr.println("====Test Number: " + testNum);            ewtr.println("  ==Item Number: " + item);            ewtr.flush();        }        isoString = getDateTimeString( wrkgcal );        mdt = null;        try        {            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );        }        catch(IllegalArgumentException pe)        {            ewtr.println("IllegalArgumentException Detected: " + isoString);            ewtr.println( pe.getMessage() );            ewtr.flush();        }        if ( debug ) {            ewtr.println("    =ISO String: " + isoString);            ewtr.flush();        }        setMillis = System.currentTimeMillis();        GregorianCalendar gx = new GregorianCalendar();        gx.setTime( new Date( setMillis ) );        //        setYear = gx.get(Calendar.YEAR);        setMonth = gx.get(Calendar.MONTH) + 1;        setDay = gx.get(Calendar.DATE);        setHour = gx.get(Calendar.HOUR_OF_DAY);        setMinute = gx.get(Calendar.MINUTE);        setSecond = gx.get(Calendar.SECOND);        setMillisecond = gx.get(Calendar.MILLISECOND);        //        rica = new Instant( setMillis );        jdtca = new Date( setMillis );        calca = Calendar.getInstance();        calca.setTime( jdtca );        longVal = new Long( setMillis );        //        MutableDateTime temp = new MutableDateTime( setMillis,            ISOChronology.getInstanceUTC() );        setString = "" + temp;    }} // end of class TestMDTSet
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.io.PrintStream;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.SimpleTimeZone;import java.util.TimeZone;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTimeConstants;import org.joda.time.MutableDateTime;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.MutableDateTime class. * This currently forces tests using GMT only. * * @author Guy Allard */public class TestMDTGet extends BulkTest {    /**     * main     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestMDTGet.class);    }    /**     * TestMDTGet constructor.     * @param name     */    public TestMDTGet(String name) {        super(name);    }    // Class Name: org.joda.time.MutableDateTime    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() /* throws Exception */ {        // super.setUp();        ++testNum;        TimeZone.setDefault( new SimpleTimeZone(0, "UTC") );        gcals = gcals0;        // gcals = gcalsMiscBunch;    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();    }    private boolean debug = true;    private static int testNum = 0;    private PrintStream ewtr = System.err;    /**     *     */    boolean failed;    // Developers/Testers Note:    //    // 1) Construct any valid array of Gregorian calendar objects,    //    e.g. 'gcals1' below.    // 2) Change the assignment statement in the setUp() method.    // 3) Recompile+jar.    //    // The new array will be used in all the tests.    //    /**     *     */    GregorianCalendar[] gcals0 = {        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),    };    GregorianCalendar[] gcals1 = {        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(1999, 1, 1, 0, 0, 0),        new GregorianCalendar(1999, 2, 1, 0, 0, 0),        new GregorianCalendar(2000, 0, 1, 0, 0, 0),        new GregorianCalendar(2000, 1, 1, 0, 0, 0),        new GregorianCalendar(2000, 2, 1, 0, 0, 0),    };    GregorianCalendar[] gcalsGJCutOver = {        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),    };    GregorianCalendar[] gcalsPreCut = {        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),    };    GregorianCalendar[] gcalsYear0 = {        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),    };    GregorianCalendar[] gcalsYearM1 = {        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),    };    GregorianCalendar[] gcalsEndPoints = {        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),    };    // This don't work.  ParseException from the CTOR.    GregorianCalendar[] gcalsOutSide = {        new GregorianCalendar(+76542, Calendar.DECEMBER, 31, 23, 59, 59),        new GregorianCalendar(-12345, Calendar.JANUARY, 1, 0, 0, 0),    };    //    GregorianCalendar[] gcalsMiscBunch = {        new GregorianCalendar(-9999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(+9999, Calendar.DECEMBER, 31, 23, 59, 59),        new GregorianCalendar(-1, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(0, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(0, Calendar.DECEMBER, 31, 23, 59, 59),        new GregorianCalendar(1, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(400, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(403, Calendar.FEBRUARY, 28, 0, 0, 0),        new GregorianCalendar(404, Calendar.FEBRUARY, 29, 0, 0, 0),        new GregorianCalendar(1066, Calendar.DECEMBER, 25, 0, 0, 0),        new GregorianCalendar(1492, Calendar.MAY, 5, 0, 0, 0),        new GregorianCalendar(1385, Calendar.MARCH, 23, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 4, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 5, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 6, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 7, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 8, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 9, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 10, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 11, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 12, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 13, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 14, 0, 0, 0),        new GregorianCalendar(1582, Calendar.OCTOBER, 15, 0, 0, 0),        new GregorianCalendar(1999, Calendar.JANUARY, 1, 0, 0, 0),        new GregorianCalendar(1999, 1, 1, 0, 0, 0),        new GregorianCalendar(1999, 2, 1, 0, 0, 0),        new GregorianCalendar(2000, 0, 1, 0, 0, 0),        new GregorianCalendar(2000, 1, 1, 0, 0, 0),        new GregorianCalendar(2000, 2, 1, 0, 0, 0),    };    //    /**     *     */    GregorianCalendar[] gcals = null;    /**     *     */    final int bumpValue = 385;    // final int bumpValue = 0;    /**     *     */    // GregorianCalendar gcal = null;    /**     *     */    String isoString = null;    /**     *     */    MutableDateTime mdt = null;    /**     *     */    int expected_year = -1;         // Calculated in setup    /**     *     */    int expected_mon = -1;    /**     *     */    int expected_day = -1;    /**     *     */    int expected_hour = -1;    /**     *     */    int expected_minute = -1;    /**     *     */    int expected_second = -1;    /**     *     */    int expected_doy = -1;    /**     *     */    int expected_woyw = -1;    /**     *     */    int expected_woyy = -1;    /**     *     */    int expected_dow = -1;    /**     *     */    long expected_gcmillis = -1L;    /**     *     */    long expected_millisofday = -1L;    /**     *     */    long expected_secondofday = -1L;    /**     *     */    long expected_minuteofday = -1L;    /**     *     */    Chronology chrona = null;    //    // Test 'get' methods - 1st.    //    /**     * Test the <code>getChronology()</code> method.     * @see org.joda.time.MutableDateTime#getChronology()     */    public void testGetChronology() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            chrona = mdt.getChronology();            assertNotNull("GC1:"+isoString, chrona);            // Commented out until ?            // assertTrue("GC2:"+isoString, chrona instanceof ISOChronology);        }    }    /**     * Test the <code>getMillis()</code> method.     * @see org.joda.time.MutableDateTime#getMillis()     */    public void testGetMillis() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GM1:"+isoString, expected_gcmillis, mdt.getMillis());        }    }    /**     * Test the <code>getDayOfWeek()</code> method.     * @see org.joda.time.MutableDateTime#getDayOfWeek()     */    public void testGetDayOfWeek() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GDOW1:"+isoString, expected_dow, mdt.getDayOfWeek() );        }    }    /**     * Test the <code>getDayOfMonth()</code> method.     * @see org.joda.time.MutableDateTime#getDayOfMonth()     */    public void testGetDayOfMonth() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GDOM1:"+isoString, expected_day, mdt.getDayOfMonth());        }    }    /**     * Test the <code>getDayOfYear()</code> method.     * @see org.joda.time.MutableDateTime#getDayOfYear()     */    public void testGetDayOfYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GDOY1:"+isoString, expected_doy, mdt.getDayOfYear());        }    }    /**     * Test the <code>getWeekOfYearWeek()</code> method.     * @see org.joda.time.MutableDateTime#getWeekOfWeekyear()     */    public void testGetWeekOfWeekyear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GWOYW1:"+isoString, expected_woyw, mdt.getWeekOfWeekyear());        }    }    /**     * Test the <code>getWeekOfYearYear()</code> method.     * @see org.joda.time.MutableDateTime#getWeekOfWeekyear()     */    public void testGetYearOfWeekyear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GWOYY1:"+isoString, expected_woyy, mdt.getWeekyear());        }    }    /**     * Test the <code>getMonthOfYear()</code> method.     * @see org.joda.time.MutableDateTime#getMonthOfYear()     */    public void testGetMonthOfYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GMOY1:"+isoString, expected_mon, mdt.getMonthOfYear());        }    }    /**     * Test the <code>getYear()</code> method.     * @see org.joda.time.MutableDateTime#getYear()     */    public void testGetYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GY1:"+isoString, expected_year, mdt.getYear());        }    }    /**     * Test the <code>getYearOfEra()</code> method.     * @see org.joda.time.MutableDateTime#getYearOfEra()     */    /*    public void testGetYearOfEra() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GYOE1:"+isoString, Math.abs(expected_year), mdt.getYearOfEra());        }    }    */    /**     * Test the <code>getEra()</code> method.     * @see org.joda.time.MutableDateTime#getEra()     */    /*    public void testGetEra() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            if ( gcals[ngc].get(Calendar.ERA) == GregorianCalendar.AD) {                assertEquals("GERA1:"+isoString,                    DateTimeConstants.AD, mdt.getEra());            } else {                assertEquals("GERA1:"+isoString,                    DateTimeConstants.BC, mdt.getEra());            }        }    }    */    /**     * Test the <code>getMillisOfSecond()</code> method.     * @see org.joda.time.MutableDateTime#getMillisOfSecond()     */    public void testGetMillisOfSecond() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GMOS1:"+isoString, bumpValue, mdt.getMillisOfSecond());        }    }    /**     * Test the <code>getMillisOfDay()</code> method.     * @see org.joda.time.MutableDateTime#getMillisOfDay()     */    public void testGetMillisOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GMLSOD1:"+isoString, expected_millisofday, mdt.getMillisOfDay());        }    }    /**     * Test the <code>getSecondOfMinute()</code> method.     * @see org.joda.time.MutableDateTime#getSecondOfMinute()     */    public void testGetSecondOfMinute() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GSOM1:"+isoString, expected_second, mdt.getSecondOfMinute());        }    }    /**     * Test the <code>getSecondOfDay()</code> method.     * @see org.joda.time.MutableDateTime#getSecondOfDay()     */    public void testGetSecondOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GSOD1:"+isoString, expected_secondofday, mdt.getSecondOfDay());        }    }    /**     * Test the <code>getMinuteOfHour()</code> method.     * @see org.joda.time.MutableDateTime#getMinuteOfHour()     */    public void testGetMinuteOfHour() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GMOH1:"+isoString, expected_minute, mdt.getMinuteOfHour());        }    }    /**     * Test the <code>getMinuteOfDay()</code> method.     * @see org.joda.time.MutableDateTime#getMinuteOfDay()     */    public void testGetMinuteOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GMINOD1:"+isoString,                expected_minuteofday, mdt.getMinuteOfDay());        }    }    /**     * Test the <code>getHourOfDay()</code> method.     * @see org.joda.time.MutableDateTime#getHourOfDay()     */    public void testGetHourOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("GHOD1:"+isoString, expected_hour,                mdt.getHourOfDay());        }    }    /**     * Test the <code>dayOfWeek()</code> method.     * @see org.joda.time.MutableDateTime#dayOfWeek()     */    public void testDayOfWeek() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("DOW1:"+isoString, expected_dow,                mdt.dayOfWeek().get() );            assertEquals("DOW2:"+isoString, expected_dow,                mdt.dayOfWeek().getField().get(mdt.getMillis()));            //            assertEquals("DOW3:"+isoString,                dowShort[mdt.dayOfWeek().get()],                mdt.dayOfWeek().getAsShortText() );            assertEquals("DOW4:"+isoString,                dowLong[mdt.dayOfWeek().get()],                mdt.dayOfWeek().getAsText() );        }    }    /**     * Test the <code>dayOfMonth()</code> method.     * @see org.joda.time.MutableDateTime#dayOfMonth()     */    public void testDayOfMonth() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("DOM1:"+isoString, expected_day,                mdt.dayOfMonth().getField().get(mdt.getMillis()));            assertEquals("DOM2:"+isoString, expected_day,                mdt.dayOfMonth().getField().get(mdt.getMillis()));            assertEquals("DOM3:"+isoString,                ""+expected_day, mdt.dayOfMonth().getAsShortText() );            assertEquals("DOM4:"+isoString,                ""+expected_day, mdt.dayOfMonth().getAsText() );        }    }    /**     * Test the <code>dayOfYear()</code> method.     * @see org.joda.time.MutableDateTime#dayOfYear()     */    public void testDayOfYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("DOY1:"+isoString, expected_doy,                mdt.dayOfYear().getField().get(mdt.getMillis()));            assertEquals("DOY2:"+isoString, expected_doy,                mdt.dayOfYear().getField().get(mdt.getMillis()));            assertEquals("DOY3:"+isoString,                ""+expected_doy, mdt.dayOfYear().getAsShortText() );            assertEquals("DOY4:"+isoString,                ""+expected_doy, mdt.dayOfYear().getAsText() );        }    }    /**     * Test the <code>weekOfYearWeek()</code> method.     * @see org.joda.time.MutableDateTime#weekOfWeekyear()     */    public void testWeekOfWeekyear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("DWOYW1:"+isoString, expected_woyw,                mdt.weekOfWeekyear().getField().get(mdt.getMillis()));            assertEquals("DWOYW2:"+isoString, expected_woyw,                mdt.weekOfWeekyear().getField().get(mdt.getMillis()));            assertEquals("DWOYW3:"+isoString,                ""+expected_woyw, mdt.weekOfWeekyear().getAsShortText() );            assertEquals("DWOYW4:"+isoString,                ""+expected_woyw, mdt.weekOfWeekyear().getAsText() );        }    }    /**     * Test the <code>weekOfYearYear()</code> method.     * @see org.joda.time.MutableDateTime#weekyear()     */    public void testWeekyear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("DWOYY1:"+isoString, expected_woyy,                mdt.weekyear().getField().get(mdt.getMillis()));            assertEquals("DWOYY2:"+isoString, expected_woyy,                mdt.weekyear().getField().get(mdt.getMillis()));            assertEquals("DWOYY3:"+isoString,                ""+expected_woyy, mdt.weekyear().getAsShortText() );            assertEquals("DWOYY4:"+isoString,                ""+expected_woyy, mdt.weekyear().getAsText() );        }    }    /**     * Test the <code>monthOfYear()</code> method.     * @see org.joda.time.MutableDateTime#monthOfYear()     */    public void testMonthOfYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("MOY1:"+isoString, expected_mon,                mdt.monthOfYear().getField().get(mdt.getMillis()));            assertEquals("MOY2:"+isoString, expected_mon,                mdt.monthOfYear().getField().get(mdt.getMillis()));            assertEquals("MOY3:"+isoString,                moyShort[mdt.monthOfYear().getField().get(mdt.getMillis())],                mdt.monthOfYear().getAsShortText() );            assertEquals("MOY4:"+isoString,                moyLong[mdt.monthOfYear().getField().get(mdt.getMillis())],                mdt.monthOfYear().getAsText() );        }    }    /**     * Test the <code>year()</code> method.     * @see org.joda.time.MutableDateTime#year()     */    public void testYear() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("Y1:"+isoString, expected_year,                mdt.year().getField().get(mdt.getMillis()));            assertEquals("Y2:"+isoString, expected_year,                mdt.year().getField().get(mdt.getMillis()));            assertEquals("Y3:"+isoString, ""+expected_year, mdt.year().getAsShortText() );            assertEquals("Y4:"+isoString, ""+expected_year, mdt.year().getAsText() );        }    }    /**     * Test the <code>yearOfEra()</code> method.     * @see org.joda.time.MutableDateTime#yearOfEra()     */    /*    public void testYearOfEra() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            int lty = Math.abs( expected_year );            assertEquals("YOE1:"+isoString, lty,                mdt.yearOfEra().getField().get(mdt.getMillis()));            assertEquals("YOE2:"+isoString, lty,                mdt.yearOfEra().getField().get(mdt.getMillis()));            assertEquals("YOE3:"+isoString, ""+lty, mdt.yearOfEra().getAsShortText() );            assertEquals("YOE4:"+isoString, ""+lty, mdt.yearOfEra().getAsText() );        }    }    */    /**     * Test the <code>era()</code> method.     * @see org.joda.time.MutableDateTime#era()     */    /*    public void testEra() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            if ( gcals[ngc].get(Calendar.ERA) == GregorianCalendar.AD) {                assertEquals("ERA1:"+isoString, DateTimeConstants.AD,                    mdt.era().getField().get(mdt.getMillis()));                assertEquals("ERA2:"+isoString, DateTimeConstants.AD,                    mdt.era().getField().get(mdt.getMillis()));                assertEquals("ERA3:"+isoString, "AD", mdt.era().getAsShortText() );                assertEquals("ERA4:"+isoString, "AD", mdt.era().getAsText() );            } else {                assertEquals("ERA1:"+isoString, DateTimeConstants.BC,                    mdt.era().getField().get(mdt.getMillis()));                assertEquals("ERA2:"+isoString, DateTimeConstants.BC,                    mdt.era().getField().get(mdt.getMillis()));                assertEquals("ERA3:"+isoString, "BC", mdt.era().getAsShortText() );                assertEquals("ERA4:"+isoString, "BC", mdt.era().getAsText() );            }        }    }    */    /**     * Test the <code>millisOfSecond()</code> method.     * @see org.joda.time.MutableDateTime#millisOfSecond()     */    public void testMillisOfSecond() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("MOS1:"+isoString,                bumpValue, mdt.millisOfSecond().getField().get(mdt.getMillis()));            assertEquals("MOS2:"+isoString,                bumpValue, mdt.millisOfSecond().getField().get(mdt.getMillis()));            assertEquals("MOS3:"+isoString,                ""+bumpValue, mdt.millisOfSecond().getAsShortText() );            assertEquals("MOS4:"+isoString,                ""+bumpValue, mdt.millisOfSecond().getAsText() );        }    }    /**     * Test the <code>millisOfDay()</code> method.     * @see org.joda.time.MutableDateTime#millisOfDay()     */    public void testMillisOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("MLSOD1:"+isoString,                expected_millisofday,                mdt.millisOfDay().getField().get(mdt.getMillis()));            assertEquals("MLSOD2:"+isoString,                expected_millisofday,                mdt.millisOfDay().getField().get(mdt.getMillis()));            assertEquals("MLSOD3:"+isoString,                ""+expected_millisofday, mdt.millisOfDay().getAsShortText() );            assertEquals("MLSOD4:"+isoString,                ""+expected_millisofday, mdt.millisOfDay().getAsText() );        }    }    /**     * Test the <code>secondOfMinute()</code> method.     * @see org.joda.time.MutableDateTime#secondOfMinute()     */    public void testSecondOfMinute() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("SOM1:"+isoString, expected_second,                mdt.secondOfMinute().getField().get(mdt.getMillis()));            assertEquals("SOM2:"+isoString, expected_second,                mdt.secondOfMinute().getField().get(mdt.getMillis()));            assertEquals("SOM3:"+isoString,                ""+expected_second, mdt.secondOfMinute().getAsShortText() );            assertEquals("SOM4:"+isoString,                ""+expected_second, mdt.secondOfMinute().getAsText() );        }    }    /**     * Test the <code>secondOfDay()</code> method.     * @see org.joda.time.MutableDateTime#secondOfDay()     */    public void testSecondOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("SOD1:"+isoString, expected_secondofday,                mdt.secondOfDay().getField().get(mdt.getMillis()));            assertEquals("SOD2:"+isoString, expected_secondofday,                mdt.secondOfDay().getField().get(mdt.getMillis()));            assertEquals("SOD3:"+isoString, ""+expected_secondofday,                mdt.secondOfDay().getAsShortText() );            assertEquals("SOD4:"+isoString, ""+expected_secondofday,                mdt.secondOfDay().getAsText() );        }    }    /**     * Test the <code>minuteOfHour()</code> method.     * @see org.joda.time.MutableDateTime#minuteOfHour()     */    public void testMinuteOfHour() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("MOH1:"+isoString, expected_minute,                mdt.minuteOfHour().getField().get(mdt.getMillis()));            assertEquals("MOH2:"+isoString, expected_minute,                mdt.minuteOfHour().getField().get(mdt.getMillis()));            assertEquals("MOH3:"+isoString,                ""+expected_minute, mdt.minuteOfHour().getAsShortText() );            assertEquals("MOH4:"+isoString,                ""+expected_minute, mdt.minuteOfHour().getAsText() );        }    }    /**     * Test the <code>minuteOfDay()</code> method.     * @see org.joda.time.MutableDateTime#minuteOfDay()     */    public void testMinuteOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("MOD1:"+isoString, expected_minuteofday,                mdt.minuteOfDay().getField().get(mdt.getMillis()));            assertEquals("MOD2:"+isoString, expected_minuteofday,                mdt.minuteOfDay().getField().get(mdt.getMillis()));            assertEquals("MOD3:"+isoString, ""+expected_minuteofday,                mdt.minuteOfDay().getAsShortText() );            assertEquals("MOD4:"+isoString, ""+expected_minuteofday,                mdt.minuteOfDay().getAsText() );        }    }    /**     * Test the <code>hourOfDay()</code> method.     * @see org.joda.time.MutableDateTime#hourOfDay()     */    public void testHourOfDay() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("HOD1:"+isoString, expected_hour,                mdt.hourOfDay().getField().get(mdt.getMillis()));            assertEquals("HOD2:"+isoString, expected_hour,                mdt.hourOfDay().getField().get(mdt.getMillis()));            assertEquals("HOD3:"+isoString,                ""+expected_hour, mdt.hourOfDay().getAsShortText() );            assertEquals("HOD4:"+isoString,                ""+expected_hour, mdt.hourOfDay().getAsText() );        }    }    private static boolean getsDone = false;    /**     * Test the <code>toString()</code> method.     * @see org.joda.time.MutableDateTime#toString()     */    public void testToString() {        for (int ngc = 0; ngc < gcals.length; ++ngc) {            prepTest( ngc );            assertEquals("TOS1:"+isoString,                // isoString + "." + bumpValue + "Z",                isoString,                mdt.toString());            /*            assertEquals("TOS1:"+isoString,                isoString + "." + "000" + "Z",                mdt.toString());            */        }    }    public void testLast() {        ewtr.println("TestMDTGet completes");        ewtr.flush();    }    //-----------------------------------------------------------------    //    // Private methods.    //    //    private  void prepTest(int item) {        GregorianCalendar wrkgcal = new GregorianCalendar(            gcals[item].get( Calendar.YEAR ),            gcals[item].get( Calendar.MONTH ),            gcals[item].get( Calendar.DATE ),            gcals[item].get( Calendar.HOUR ),            gcals[item].get( Calendar.MINUTE ),            gcals[item].get( Calendar.SECOND )        );        wrkgcal.setGregorianChange(new Date(Long.MIN_VALUE));        wrkgcal.set(Calendar.ERA, gcals[item].get(Calendar.ERA));        //        wrkgcal.add(Calendar.MILLISECOND, bumpValue);        wrkgcal.setMinimalDaysInFirstWeek(4);        wrkgcal.setFirstDayOfWeek(Calendar.MONDAY);        //        // Force the GregorianCalendar to recalculate all internal        // values.        //        wrkgcal.setTime( wrkgcal.getTime() );        if ( debug ) {            ewtr.println("====Test Number: " + testNum);            ewtr.println("  ==Item Number: " + item);            ewtr.flush();        }        isoString = getDateTimeString( wrkgcal );        mdt = null;        try        {            mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );        }        catch(IllegalArgumentException pe)        {            ewtr.println("IllegalArgumentException Detected: " + isoString);            ewtr.println( pe.getMessage() );            ewtr.flush();        }        if ( debug ) {            ewtr.println("    =ISO String: " + isoString);            ewtr.flush();        }        //        // When it is easy to do, we locally calculate test comparison        // values rather than depend on Java Calendar's.        // If it is not fairly convenient, we call the Calendar's        // get method.        //        // However, the following is very ugly code and needs to be        // cleaned up.        //        int pb = 0;        if ( isoString.substring(0,1).equals("-") ) {            pb = 1;        }        //        // Calculate expected values.        //        expected_gcmillis = wrkgcal.getTime().getTime();        //        expected_year = getPartValue( isoString.substring(0+pb,4+pb) );        if ( pb == 1 ) {            expected_year = -expected_year;        }        //        expected_mon = getPartValue( isoString.substring(5+pb,7+pb) );        expected_day = getPartValue( isoString.substring(8+pb,10+pb) );        expected_hour = getPartValue( isoString.substring(11+pb,13+pb) );        expected_minute = getPartValue( isoString.substring(14+pb,16+pb) );        expected_second = getPartValue( isoString.substring(17+pb,19+pb) );        //        expected_doy = wrkgcal.get(Calendar.DAY_OF_YEAR);        expected_dow = wrkgcal.get(Calendar.DAY_OF_WEEK) - 1;        expected_dow = (expected_dow <= 0 ? 7 : expected_dow);        //        expected_woyw = wrkgcal.get(Calendar.WEEK_OF_YEAR);        if (expected_woyw == 1) {            wrkgcal.add(Calendar.DATE, +7);        } else if (expected_woyw > 51) {            wrkgcal.add(Calendar.DATE, -14);        }        expected_woyy = wrkgcal.get(Calendar.YEAR);        if ( wrkgcal.get(Calendar.ERA) == GregorianCalendar.BC ) {            expected_woyy = -(expected_woyy-1);        }        //        expected_millisofday = expected_hour * DateTimeConstants.MILLIS_PER_HOUR            + expected_minute * DateTimeConstants.MILLIS_PER_MINUTE            + expected_second * DateTimeConstants.MILLIS_PER_SECOND            + bumpValue;        expected_secondofday = expected_hour * DateTimeConstants.SECONDS_PER_HOUR            + expected_minute * DateTimeConstants.SECONDS_PER_MINUTE            + expected_second;        expected_minuteofday = expected_hour * DateTimeConstants.MINUTES_PER_HOUR            + expected_minute;        return;    }} // end of class TestMDTGet
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;//import java.io.PrintStream;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.ReadableInstant;///** * This class is a Junit unit test for the * constructors of various DateTime, DateOnly, and * TimeOnly objects. * * @author Guy Allard * */public class TestConstructors extends BulkTest {    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite suite() is a junit required method.     * @see org.joda.test.time.BulkTest     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestConstructors.class);    }    /**     * TestConstructors constructor.     * @param name     */    public TestConstructors(String name) {        super(name);    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    /**     * Test the <code>DateOnly</code> constructors.     * @see org.joda.time.DateOnly     */    public void testDateOnlyConstructors() {        dateOnly = true;        //        // Tests for Spec Section 5.2.1        //        new SectionRunner( new SpecSection( "5.2.1.1", dates5211 ),            "", "" ).run();        //        new SectionRunner( new SpecSection( "5.2.1.2", dates5212 ),            "", "" ).run();        //        new SectionRunner( new SpecSection( "5.2.1.3", dates5213 ),            "", "" ).run();        //        new SectionRunner( new SpecSection( "5.2.1.4", dates5214 ),            "", "" ).run();        //        // Tests for Spec Section 5.2.2.1        //        new SectionRunner( new SpecSection( "5.2.2.1", dates5221 ),            "", "" ).run();        //        // Tests for Spec Section 5.2.2.2        //        new SectionRunner( new SpecSection( "5.2.2.2", dates5222 ),            "", "" ).run();        //        // Tests for Spec Section 5.2.2.3        //        new SectionRunner( new SpecSection( "5.2.2.3", dates5223 ),            "", "" ).run();        //        // Tests for Spec Section 5.2.3.1        //        new SectionRunner( new SpecSection( "5.2.3.1", dates5231 ),            "", "" ).run();        //        // Tests for Spec Section 5.2.3.2        //        new SectionRunner( new SpecSection( "5.2.3.2", dates5232 ),            "", "" ).run();        //        // Tests for Spec Section 5.2.3.3        //        new SectionRunner( new SpecSection( "5.2.3.3", dates5233 ),            "", "" ).run();        //        // Tests for Spec Section 5.2.3.4        //        new SectionRunner( new SpecSection( "5.2.3.4", dates5234 ),            "", "" ).run();        //        wtr.println("Running Totals:");        tt.showResults();    }    /**     * Test the <code>TimeOnly</code> constructors.     * @see org.joda.time.TimeOnly     */    public void testTimeOnlyConstructors() {        dateOnly = false;        //        // Tests for Spec Section 5.3.1 - No Leading 'T', no 'Z' suffix        //        new SectionRunner( new SpecSection( "5.3.1.1", times5311 ),            "", "" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.2", times5312 ),            "", "" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.3", times5313 ),            "", "" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.4", times5314 ),            "", "" ).run();        //        // Tests for Spec Section 5.3.1 - Leading 'T', no 'Z' suffix        //        new SectionRunner( new SpecSection( "5.3.1.1", times5311 ),            "T", "" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.2", times5312 ),            "T", "" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.3", times5313 ),            "T", "" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.4", times5314 ),            "T", "" ).run();        //        // Tests for Spec Section 5.3.1 - No leading 'T", 'Z' suffix        //        new SectionRunner( new SpecSection( "5.3.1.1", times5311 ),            "", "Z" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.2", times5312 ),            "", "Z" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.3", times5313 ),            "", "Z" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.4", times5314 ),            "", "Z" ).run();        //        // Tests for Spec Section 5.3.1 - Leading 'T" and 'Z' suffix        //        new SectionRunner( new SpecSection( "5.3.1.1", times5311 ),            "T", "Z" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.2", times5312 ),            "T", "Z" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.3", times5313 ),            "T", "Z" ).run();        //        new SectionRunner( new SpecSection( "5.3.1.4", times5314 ),            "T", "Z" ).run();        //        // Tests for Spec Section 5.3.2        //        new SectionRunner( new SpecSection( "5.3.2", times532 ),            "", "" ).run();        //        // Tests for Spec Section 5.3.4.2        //        new SectionRunner( new SpecSection( "5.3.4.2", times5342 ),            "", "" ).run();        //        wtr.println("Running Totals:");        tt.showResults();    }    /**     * Test the <code>DateTime</code> constructors.     * @see org.joda.time.DateTime     */    public void testDateTimeConstructors() {        dateTimes = true;        //        // Tests for Spec Section 5.4.1        //        new SectionRunner( new SpecSection( "5.4.1", datetimes541 ),            "", "" ).run();        new SectionRunner( new SpecSection( "5.4.1", datetimes541 ),            "", "Z" ).run();        //        // Tests for Spec Section 5.4.2        //        new SectionRunner( new SpecSection( "5.4.2", datetimes542 ),            "", "" ).run();        //        wtr.println("Running Totals:");        tt.showResults();    }//// ------------------------------------------------------------// Private data and methods// ------------------------------------------------------------//    private final TotalsTracker tt = new TotalsTracker();//    private boolean dateOnly = true;    private boolean dateTimes = false;    protected  PrintStream wtr = System.err;    //    // Spec Section 5.2 - Dates    //    // Spec Section 5.2.1 - Calendar Dates    //    // Spec Section 5.2.1.1 - Complete Representation    //    private final String[][] dates5211 = {            {"19990101",                "Complete~Basic~YYYYMMDD~Spec 5.2.1.1"},            {"1999-01-01",                "Complete~Extended~YYYY-MM-DD~Spec 5.2.1.1"},    };    //    // Spec Section 5.2.1.2 - Representations with reduced precision    //    private final String[][] dates5212 = {            // A specific month            {"1999-01",                "Reduced~Basic~YYYY-MM~Spec 5.2.1.2(a)"},            // A specific year            {"1999",                "Reduced~Basic~YYYY~Spec 5.2.1.2(b)"},            // A specific century            {"19",                "Reduced~Basic~YY~Spec 5.2.1.2(c)"},        };    //    // Spec Section 5.2.1.3 - Truncated representations    //    private final String[][] dates5213 = {            // A specific date in the implied century            {"990101",                "Truncated~Basic~YYMMDD~Spec 5.2.1.3(a)"},            {"99-01-01",                "Truncated~Extended~YY-MM-DD~Spec 5.2.1.3(a)"},            // A specific year and month in the implied century            {"-9901",                "Truncated~Basic~-YYMM~Spec 5.2.1.3(b)"},            {"-99-01",                "Truncated~Extended~YYMMDD~Spec 5.2.1.3(b)"},            // A specific year in the implied century            {"-99",                "Truncated~Basic~-YY~Spec 5.2.1.3(c)"},            // A specific day of a month in the implied year            {"--0101",                "Truncated~Basic~--MMDD~Spec 5.2.1.3(d)"},            {"--01-01",                "Truncated~Basic~--MM-DD~Spec 5.2.1.3(d)"},            // A specific month in the implied year            {"--01",                "Truncated~Basic~--MM~Spec 5.2.1.3(e)"},            // A specific day in the implied month            {"---01",                "Truncated~Basic~---DD~Spec 5.2.1.3(f)"},    };    //    // Spec Section 5.2.1.4 - Expanded Representations    //    private final String[][] dates5214 = {            // A specific day            {"-19990101",                "Expanded~Basic~-YYYYMMDD~Spec 5.2.1.4(a)"},            {"+19990101",                "Expanded~Basic~+YYYYMMDD~Spec 5.2.1.4(a)"},            {"-1999-01-01",                "Expanded~Extended~-YYYY-MM-DD~Spec 5.2.1.4(a)"},            {"+1999-01-01",                "Expanded~Extended~+YYYY-MM-DD~Spec 5.2.1.4(a)"},            // A specific month            {"-1999-01",                "Expanded~Basic~-YYYY-MM~Spec 5.2.1.4(b)"},            {"+1999-01",                "Expanded~Basic~+YYYY-MM~Spec 5.2.1.4(b)"},            // A specific year            {"-1999",                "Expanded~Basic~-YYYY~Spec 5.2.1.4(c)"},            {"+1999",                "Expanded~Basic~+YYYY~Spec 5.2.1.4(c)"},            // A specific century            {"-19",                "Expanded~Basic~-YY~Spec 5.2.1.4(d)"},            {"+19",                "Expanded~Basic~+YY~Spec 5.2.1.4(d)"},    };    //    // Spec Section 5.2.2 - Ordinal Dates    //    // Spec Section 5.2.2.1 - Complete Representation    //    private final String[][] dates5221 = {            {"1999123",                "Complete~Basic~YYYYDDD~Spec 5.2.2.1"},            {"1999-123",                "Complete~Extended~YYYY-DDD~Spec 5.2.2.1"},    };    //    // Spec Section 5.2.2.2 - Truncated Representation    //    private final String[][] dates5222 = {            // A specific year and day in the implied century            {"99123",                "Truncated~Basic~YYDDD~Spec 5.2.2.2(a)"},            {"99-123",                "Truncated~Extended~YY-DDD~Spec 5.2.2.2(a)"},            // Day only in the implied year            {"-123",                "Truncated~Basic~-DDD~Spec 5.2.2.2(b)"},    };    //    // Spec Section 5.2.2.3 - Expanded Representation    //    private final String[][] dates5223 = {        // A specific day            {"-1999123",                "Expanded~Basic~-YYYYDDD~Spec 5.2.2.3(a)"},            {"-1999-123",                "Expanded~Extended~-YYYY-DDD~Spec 5.2.2.3(a)"},    };    //    // Spec Section 5.2.3 - Week Date    //    // Spec Section 5.2.3.1 - Complete representation    //    private final String[][] dates5231 = {            {"1999W236",                "Complete~Basic~YYYYWwwD~Spec 5.2.3.1"},            {"1999-W23-6",                "Complete~Extended~YYYY-Www-D~Spec 5.2.3.1"},    };    //    // Spec Section 5.2.3.2 - Representations with reduced precision    //    private final String[][] dates5232 = {        // A specific week            {"1999W23",                "Reduced~Basic~YYYYWww~Spec 5.2.3.2(a)"},            {"1999-W23",                "Reduced~Extended~YYYY-Www~Spec 5.2.3.2(a)"},    };    //    // Spec Section 5.2.3.3 - Truncated representations    //    private final String[][] dates5233 = {        // Year, week, and day in the implied century            {"99W236",                "Truncated~Basic~YYWwwD~Spec 5.2.3.3(a)"},            {"99-W23-6",                "Truncated~Extended~YYWwwD~Spec 5.2.3.3(a)"},        // Year and week only in the implied century            {"99W23",                "Truncated~Basic~YYWww~Spec 5.2.3.3(b)"},            {"99-W23",                "Truncated~Extended~YY-Www~Spec 5.2.3.3(b)"},        // Year of the implied decade, week and day only            {"-5W236",                "Truncated~Basic~-YWwwD~Spec 5.2.3.3(c)"},            {"-5-W23-6",                "Truncated~Extended~-Y-Www-D~Spec 5.2.3.3(c)"},        // Year of the implied decade and week only            {"-5W23",                "Truncated~Basic~-YWww~Spec 5.2.3.3(d)"},            {"-5-W23",                "Truncated~Extended~-Y-Www~Spec 5.2.3.3(d)"},        // Week and day only of the implied year            {"-W236",                "Truncated~Basic~-WwwD~Spec 5.2.3.3(e)"},            {"-W23-6",                "Truncated~Extended~-Www-D~Spec 5.2.3.3(e)"},        // Week only of the implied year            {"-W23",                "Truncated~Basic~-Www~Spec 5.2.3.3(f)"},        // Day only of the implied week            {"-W-6",                "Truncated~Basic~-W-D~Spec 5.2.3.3(g)"},    };    //    // Spec Section 5.2.3.4 - Expanded representations    //    private final String[][] dates5234 = {        // A specific day            {"-1999W236",                "Truncated~Basic~-YYYYWwwd~Spec 5.2.3.4(a)"},            {"+1999W236",                "Truncated~Basic~+YYYYWwwd~Spec 5.2.3.4(a)"},            {"-1999-W23-6",                "Truncated~Extended~-YYYY-Www-d~Spec 5.2.3.4(a)"},            {"+1999-W23-6",                "Truncated~Extended~+YYYY-Www-d~Spec 5.2.3.4(a)"},        // A specific week            {"-1999W23",                "Truncated~Basic~-YYYYWww~Spec 5.2.3.4(b)"},            {"+1999W23",                "Truncated~Basic~+YYYYWww~Spec 5.2.3.4(b)"},            {"-1999-W23",                "Truncated~Extended~-YYYY-Www~Spec 5.2.3.4(b)"},            {"+1999-W23",                "Truncated~Extended~+YYYY-Www~Spec 5.2.3.4(b)"},    };    //    // Spec Section 5.3 - Time of day    //    // Spec Section 5.3.1.1 - Complete representation    //    private final String[][] times5311 = {            {"232050",                "Complete~Basic~hhmmss~Spec 5.3.1.1"},            {"23:20:50",                "Complete~Extended~hh:mm:ss~Spec 5.3.1.1"},    };    //    // Spec Section 5.3.1.2 - Representations with reduced precision    //    private final String[][] times5312 = {            // A specific hour and minute            {"2320",                "Reduced~Basic~hhmm~Spec 5.3.1.2(a)"},            {"23:20",                "Reduced~Extended~hh:mm~Spec 5.3.1.2(a)"},            // A specific hour            {"23",                "Reduced~Basic~hh~Spec 5.3.1.2(b)"},    };    //    // Spec Section 5.3.1.3 - Representation of decimal fractions    //    private final String[][] times5313 = {            // A specific hour, minute, second, and decimal fraction of            // a second            {"232050,5",                "Decimal~Basic~hhmmss,ss~Spec 5.3.1.3(a)"},            {"23:20:50,5",                "Decimal~Extended~hh:mm:ss,ss~Spec 5.3.1.3(a)"},            // A specific hour, minute, and decimal fraction of a minute            {"2320,8",                "Decimal~Basic~hhmm,mm~Spec 5.3.1.3(b)"},            {"23:20,8",                "Decimal~Extended~hh:mm,mm~Spec 5.3.1.3(b)"},            // A specific hour and decimal fraction of an hour            {"23,8",                "Decimal~Basic~hh,hh~Spec 5.3.1.3(c)"},    };    //    // Spec Section 5.3.1.4 - Truncated representations    //    private final String[][] times5314 = {        // A specific minute and second of the implied hour            {"-2050",                "Truncated~Basic~-mmss~Spec 5.3.1.4(a)"},            {"-20:50",                "Truncated~Extended~-mm:ss~Spec 5.3.1.4(a)"},        // A specific minute of the implied hour            {"-20",                "Truncated~Basic~-mm~Spec 5.3.1.4(b)"},        // A specific second of the implied minute            {"--50",                "Truncated~Basic~--ss~Spec 5.3.1.4(c)"},        // A specific minute and second of the implied hour and        // a decimal fraction of a second            {"-2050,5",                "Truncated~Basic~-mmss,s~Spec 5.3.1.4(d)"},            {"-20:50,5",                "Truncated~Extended~-mm:ss,s~Spec 5.3.1.4(d)"},        // A specific minute of the implied hour and a decimal fraction        // of the minute            {"-20,8",                "Truncated~Basic~-mm,m~Spec 5.3.1.4(e)"},        // A specific second of the implied minute and a decimal fraction        // of the second            {"--50,5",                "Truncated~Basic~--ss,s~Spec 5.3.1.4(f)"},    };    //    // Spec Section 5.3.2 - Midnight    //    private final String[][] times532 = {            {"000000",                "Midnight~Basic~000000~Spec 5.3.2"},            {"00:00:00",                "Midnight~Extended~00:00:00~Spec 5.3.2"},            {"240000",                "Midnight~Basic~240000~Spec 5.3.2"},            {"24:00:00",                "Midnight~Extended~24:00:00~Spec 5.3.2"},            {"0000",                "Midnight~Basic~0000~Spec 5.3.2 Note 1"},            {"2400",                "Midnight~Basic~2400~Spec 5.3.2 Note 1"},    };    //    // Spec Section 5.3.4.2 - Local time and the difference with UTC    //    private final String[][] times5342 = {            {"152746+0100",                "Difference~Basic~hhmmss(+/-)hhmm~Spec 5.3.4.2"},            {"15:27:46+01:00",                "Difference~Extended~hh:mm:ss(+/-)hh:mm~Spec 5.3.4.2"},            {"152746-0500",                "Difference~Basic~hhmmss(+/-)hhmm~Spec 5.3.4.2"},            {"15:27:46-05:00",                "Difference~Extended~hh:mm:ss(+/-)hh:mm~Spec 5.3.4.2"},    };    //    // Spec Section 5.4 - Combinations of date and time of day    //    // Spec Section 5.4.1 - Complete representation    //    private final String[][] datetimes541 = {            {"19990101T112233",                "Combination~Basic~YYYYMMDDThhmmss~Spec 5.4.1(a)"},            {"1999-01-01T11:22:33",                "Combination~Extended~YYYY-MM-DDThh:mm:ss~Spec 5.4.1(a)"},            {"1999123T112233",                "Combination~Basic~YYYYDDDThhmmss~Spec 5.4.1(b)"},            {"1999-123T11:22:33",                "Combination~Extended~YYYY-DDDThh:mm:ss~Spec 5.4.1(b)"},            {"1999W176T112233",                "Combination~Basic~YYYYWwwDThhmmss~Spec 5.4.1(c)"},            {"1999-W17-6T11:22:33",                "Combination~Extended~YYYY-Www-DThh:mm:ss~Spec 5.4.1(c)"},    };    //    // Spec Section 5.4.2 - Representations other than complete    //    private final String[][] datetimes542 = {            {"19990101T1516",                "Reduced-Combo~Basic~YYYYMMDDThhmm~Spec 5.4.2(a)"},            {"1999-01-01T15:16",                "Reduced-Combo~Extended~YYYY-MM-DDThh:mm~Spec 5.4.2(a)"},            {"1999123T1516",                "Reduced-Combo~Basic~YYYYDDDThhmm~Spec 5.4.2(b)"},            {"1999-123T15:16",                "Reduced-Combo~Extended~YYYY-DDDThh:mm~Spec 5.4.2(b)"},            {"1985W155T1015+0400",                "Reduced-Combo~Basic~YYYYWwwDThhmm+hhmm~Spec 5.4.2(b)"},            {"1985W155T1015-0400",                "Reduced-Combo~Basic~YYYYWwwDThhmm-hhmm~Spec 5.4.2(b)"},            {"1985-W15-5T10:15+04:00",                "Reduced-Combo~Extended~YYYY-Www-DThh:mm+hh:mm~Spec 5.4.2(b)"},            {"1985-W15-5T10:15-04:00",                "Reduced-Combo~Extended~YYYY-Www-DThh:mm-hh:mm~Spec 5.4.2(b)"},    };    //    // A Specification Section    //    private class SpecSection {        private final String name;        private final String[][] testData;        private final int numTests;        private int failedTests = 0;        SpecSection(final String name, final String[][] testData) {            this.name = name;            this.testData = testData;            this.numTests = this.testData.length;        }        public String getName() {            return name;        }        public String[][] getTestData() {            return testData;        }        public int getNumTests() {            return numTests;        }        public int getFailedTests() {            return failedTests;        }        public void bumpFailedTests() {            ++failedTests;        }        public void showResults() {            wtr.println("Section Results For: " + name );            wtr.println("\tSection Number of CTOR tests: " + numTests );            wtr.println("\tSection Failed CTOR tests: " + failedTests );        }    }    //    // A Specification Section Test Runner    //    private class SectionRunner {        private final SpecSection ss;        private final String prepend;        private final String append;        private ReadableInstant ri = null;        SectionRunner(final SpecSection ss, final String prepend,                      final String append) {            this.ss = ss;            this.prepend = prepend;            this.append = append;        }        public final void run() {            wtr.println(" ");            wtr.println("-> Start Section: " + ss.getName());            String[][] testData = ss.getTestData();            String sDT = null;            boolean raised = false;            for(int nextDate = 0; nextDate < testData.length; ++nextDate) {                sDT = prepend + testData[nextDate][0] + append;                wtr.println(" ");                wtr.println( "The Next String Is: " + sDT );                wtr.println( "The Spec Reference Is: "                    + testData[nextDate][1] );                tt.bumpNumTests();                try                {                    if ( dateTimes ) {                        ri = new DateTime( sDT );                    }                    /*                    else                    {                        if ( dateOnly ) {                            ri = new DateOnly( sDT );                        }                        else                        {                            ri = new TimeOnly( sDT );                        }                    }                    */                }                catch(IllegalArgumentException pe)                {                    ss.bumpFailedTests();                    tt.bumpFailedTests();                    wtr.println("Parse Exception Detected");                    pe.printStackTrace( wtr );                    raised = true;                }                if ( !raised ) {                    wtr.print("Construction Complete, ");                    wtr.println("As String: " + this.ri);                }                raised = false;            } // end of the for            ss.showResults();            tt.showResults();        } // end of run    }    //    // Running Totals Tracker    //    private class TotalsTracker {        private int numTests = 0;        private int failedTests = 0;        public final int getNumTests() { return numTests; }        public final int getFailedTests() { return failedTests; }        public final void bumpNumTests() { ++numTests; }        public final void bumpFailedTests() { ++failedTests; }        public final void showResults() {            // wtr.println(" ");            wtr.println("\tCurrent Total of CTOR tests: " + numTests );            wtr.println("\tCurrent # of Failed CTOR tests: " + failedTests );        }    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import junit.framework.TestSuite;import org.joda.time.DateTimeZone;import org.joda.time.DateTime;import org.joda.time.MutableDateTime;import org.joda.time.ReadableInstant;import org.joda.time.chrono.gj.GJChronology;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the CTORs of the * MutableDateTime date time class.  The MutableDateTime class is passed * to the base class, which actually invokes the proper * constructors. * * @author Stephen Colebourne * @author Guy Allard */public class TestMutableDateTimeCtors       extends AbstractTestDateTimeCommon {    // The class to be tested.    private static Class cls = MutableDateTime.class;    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestMutableDateTimeCtors.class);    }    /**     * Constructor.     * @param name     */    public TestMutableDateTimeCtors(String name) {        super(name, cls);    }    /**     * Constructor     * @param name The class name.     * @param cls The class to be tested.     */    public TestMutableDateTimeCtors(String name, Class cls) {        super(name, cls);        TestMutableDateTimeCtors.cls = cls;    }    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() /* throws Exception */ {        super.setUp();    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        super.tearDown();    }        protected ReadableInstant createSmall(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(-1L * 1000, GJChronology.getInstance());        }        return new MutableDateTime(-1L * 1000);    }        protected ReadableInstant createMid(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(2L * 1000, GJChronology.getInstance());        }        return new MutableDateTime((2L * 1000));    }        protected ReadableInstant createLarge(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(3L * 1000, GJChronology.getInstance());        }        return new MutableDateTime((3L * 1000));    }    protected ReadableInstant createUTC(long millis) {        return new MutableDateTime(millis, ISOChronology.getInstance(DateTimeZone.UTC));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.util.ArrayList;import java.util.Calendar;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.List;import junit.framework.TestSuite;import org.joda.time.Chronology;import org.joda.time.DateTime;import org.joda.time.DateTimeComparator;import org.joda.time.DateTimeZone;import org.joda.time.ReadableInstant;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.DateTimeComparator class. * * @author Guy Allard */public class TestDateTimeComparator extends BulkTest {    /**     * The main method for this test program.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestDateTimeComparator.class);    }    /**     * TestDateTimeComparator constructor.     * @param name     */    public TestDateTimeComparator(String name) {        super(name);    }    /**     * A reference to a DateTime object.     */    DateTime aDateTime = null;    /**     * A reference to a DateTime object.     */    DateTime bDateTime = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for millis of seconds.     */    Comparator cMillis = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for seconds.     */    Comparator cSecond = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for minutes.     */    Comparator cMinute = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for hours.     */    Comparator cHour = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the week.     */    Comparator cDayOfWeek = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the month.     */    Comparator cDayOfMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for day of the year.     */    Comparator cDayOfYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for week of the weekyear.     */    Comparator cWeekOfWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year given a week of the year.     */    Comparator cWeekyear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for months.     */    Comparator cMonth = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for year.     */    Comparator cYear = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the date portion of an     * object.     */    Comparator cDate = null;    /**     * A reference to a DateTimeComparator object     * (a Comparator) for the time portion of an     * object.     */    Comparator cTime = null;    /**     * Junit <code>setUp()</code> method.     */    public void setUp() /* throws Exception */ {        Chronology chrono = ISOChronology.getInstanceUTC();        // super.setUp();        // Obtain comparator's        cMillis = DateTimeComparator.getInstance(null, chrono.secondOfMinute());        cSecond = DateTimeComparator.getInstance(chrono.secondOfMinute(), chrono.minuteOfHour());        cMinute = DateTimeComparator.getInstance(chrono.minuteOfHour(), chrono.hourOfDay());        cHour = DateTimeComparator.getInstance(chrono.hourOfDay(), chrono.dayOfYear());        cDayOfWeek = DateTimeComparator.getInstance(chrono.dayOfWeek(), chrono.weekOfWeekyear());        cDayOfMonth = DateTimeComparator.getInstance(chrono.dayOfMonth(), chrono.monthOfYear());        cDayOfYear = DateTimeComparator.getInstance(chrono.dayOfYear(), chrono.year());        cWeekOfWeekyear = DateTimeComparator.getInstance(chrono.weekOfWeekyear(), chrono.weekyear());        cWeekyear = DateTimeComparator.getInstance(chrono.weekyear());        cMonth = DateTimeComparator.getInstance(chrono.monthOfYear(), chrono.year());        cYear = DateTimeComparator.getInstance(chrono.year());        cDate = DateTimeComparator.getDateOnlyInstance(chrono);        cTime = DateTimeComparator.getTimeOnlyInstance(chrono);    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();        aDateTime = null;        bDateTime = null;        //        cMillis = null;        cSecond = null;        cMinute = null;        cHour = null;        cDayOfWeek = null;        cDayOfMonth = null;        cDayOfYear = null;        cWeekOfWeekyear = null;        cWeekyear = null;        cMonth = null;        cYear = null;        cDate = null;        cTime = null;    }    /**     * Test all basic comparator operation with DateTime objects.     */    public void testBasicComps1() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with ReadableInstant objects.     */    public void testBasicComps2() {        ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC );        assertEquals( "getMillis", aDateTime.getMillis(),            bDateTime.getMillis() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with java Date objects.     */    public void testBasicComps3() {        Date aDateTime            = new Date( System.currentTimeMillis() );        Date bDateTime            = new Date( aDateTime.getTime() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Long objects.     */    public void testBasicComps4() {        Long aDateTime            = new Long( System.currentTimeMillis() );        Long bDateTime            = new Long( aDateTime.longValue() );        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test all basic comparator operation with Calendar objects.     */    public void testBasicComps5() {        Calendar aDateTime            = Calendar.getInstance();   // right now        Calendar bDateTime = aDateTime;        assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) );        assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) );    }   // end of testBasicComps    /**     * Test unequal comparisons with millis of second comparators.     */    public void testMillis() {        aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC );        bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC );        assertEquals( "MillisM1", -1, cMillis.compare( aDateTime, bDateTime ) );        assertEquals( "MillisP1", 1, cMillis.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with second comparators.     */    public void testSecond() {        aDateTime = getADate( "1969-12-31T23:59:58" );        bDateTime = getADate( "1969-12-31T23:50:59" );        assertEquals( "SecondM1a", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1a", 1, cSecond.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:00:01" );        assertEquals( "SecondM1b", -1, cSecond.compare( aDateTime, bDateTime ) );        assertEquals( "SecondP1b", 1, cSecond.compare( bDateTime, aDateTime ) );    }   // end of testSecond    /**     * Test unequal comparisons with minute comparators.     */    public void testMinute() {        aDateTime = getADate( "1969-12-31T23:58:00" );        bDateTime = getADate( "1969-12-31T23:59:00" );        assertEquals( "MinuteM1a", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1a", 1, cMinute.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T00:01:00" );        assertEquals( "MinuteM1b", -1, cMinute.compare( aDateTime, bDateTime ) );        assertEquals( "MinuteP1b", 1, cMinute.compare( bDateTime, aDateTime ) );    }   // end of testMinute    /**     * Test unequal comparisons with hour comparators.     */    public void testHour() {        aDateTime = getADate( "1969-12-31T22:00:00" );        bDateTime = getADate( "1969-12-31T23:00:00" );        assertEquals( "HourM1a", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1a", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1970-01-01T00:00:00" );        bDateTime = getADate( "1970-01-01T01:00:00" );        assertEquals( "HourM1b", -1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourP1b", 1, cHour.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "HourP1c", 1, cHour.compare( aDateTime, bDateTime ) );        assertEquals( "HourM1c", -1, cHour.compare( bDateTime, aDateTime ) );    }   // end of testHour    /**     * Test unequal comparisons with day of week comparators.     */    public void testDOW() {        /*         * Dates chosen when I wrote the code, so I know what day of         * the week it is.         */        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOWM1a", -1, cDayOfWeek.compare( aDateTime, bDateTime ) );        assertEquals( "DOWP1a", 1, cDayOfWeek.compare( bDateTime, aDateTime ) );    }   // end of testDOW    /**     * Test unequal comparisons with day of month comparators.     */    public void testDOM() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOMM1a", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1a", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-12-01T00:00:00" );        bDateTime = getADate( "1814-04-30T00:00:00" );        assertEquals( "DOMM1b", -1, cDayOfMonth.compare( aDateTime, bDateTime ) );        assertEquals( "DOMP1b", 1, cDayOfMonth.compare( bDateTime, aDateTime ) );    }   // end of testDOM    /**     * Test unequal comparisons with day of year comparators.     */    public void testDOY() {        aDateTime = getADate( "2002-04-12T00:00:00" );        bDateTime = getADate( "2002-04-13T00:00:00" );        assertEquals( "DOYM1a", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1a", 1, cDayOfYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-02-29T00:00:00" );        bDateTime = getADate( "1814-11-30T00:00:00" );        assertEquals( "DOYM1b", -1, cDayOfYear.compare( aDateTime, bDateTime ) );        assertEquals( "DOYP1b", 1, cDayOfYear.compare( bDateTime, aDateTime ) );    }   // end of testDOY    /**     * Test unequal comparisons with week of weekyear comparators.     */    public void testWOW() {        // 1st week of year contains Jan 04.        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "2000-01-11T00:00:00" );        assertEquals( "WOWM1a", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1a", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "2000-01-04T00:00:00" );        bDateTime = getADate( "1999-12-31T00:00:00" );        assertEquals( "WOWM1b", -1,            cWeekOfWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "WOWP1b", 1,            cWeekOfWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testMillis    /**     * Test unequal comparisons with year given the week comparators.     */    public void testWOYY() {        // How do I test the end conditions of this?        // Don't understand ......        aDateTime = getADate( "1998-12-31T23:59:59" );        bDateTime = getADate( "1999-01-01T00:00:00" );        assertEquals( "YOYYZ", 0, cWeekyear.compare( aDateTime, bDateTime ) );        bDateTime = getADate( "1999-01-04T00:00:00" );        assertEquals( "YOYYM1", -1, cWeekyear.compare( aDateTime, bDateTime ) );        assertEquals( "YOYYP1", 1, cWeekyear.compare( bDateTime, aDateTime ) );    }   // end of testWOYY    /**     * Test unequal comparisons with month comparators.     */    public void testMonth() {        aDateTime = getADate( "2002-04-30T00:00:00" );        bDateTime = getADate( "2002-05-01T00:00:00" );        assertEquals( "MONTHM1a", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1a", 1, cMonth.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1900-01-01T00:00:00" );        bDateTime = getADate( "1899-12-31T00:00:00" );        assertEquals( "MONTHM1b", -1, cMonth.compare( aDateTime, bDateTime ) );        assertEquals( "MONTHP1b", 1, cMonth.compare( bDateTime, aDateTime ) );    }   // end of testMonth    /**     * Test unequal comparisons with year comparators.     */    public void testYear() {        aDateTime = getADate( "2000-01-01T00:00:00" );        bDateTime = getADate( "2001-01-01T00:00:00" );        assertEquals( "YEARM1a", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1a", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1968-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1b", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1b", 1, cYear.compare( bDateTime, aDateTime ) );        aDateTime = getADate( "1969-12-31T23:59:59" );        bDateTime = getADate( "1970-01-01T00:00:00" );        assertEquals( "YEARM1c", -1, cYear.compare( aDateTime, bDateTime ) );        assertEquals( "YEARP1c", 1, cYear.compare( bDateTime, aDateTime ) );    }   // end of testYear    /*     * 'List' processing tests follow.     */     /**      * Test sorting with full default comparator.      */     public void testListBasic() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-01-20T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListBasic", !isSorted1, isSorted2);     } // end of testListBasic     /**      * Test sorting with millis of second comparator.      */    public void testListMillis() {        //        List sl = new ArrayList();        long base = 12345L * 1000L;        sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) );        sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) );        //        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMillis );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListLillis", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with second comparator.      */    public void testListSecond() {        String[] dtStrs = {            "1999-02-01T00:00:10",            "1999-02-01T00:00:30",            "1999-02-01T00:00:25",            "1999-02-01T00:00:18",            "1999-02-01T00:00:01",            "1999-02-01T00:00:59",            "1999-02-01T00:00:22"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cSecond );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListSecond", !isSorted1, isSorted2);    } // end of testListSecond     /**      * Test sorting with minute comparator.      */    public void testListMinute() {        String[] dtStrs = {            "1999-02-01T00:10:00",            "1999-02-01T00:30:00",            "1999-02-01T00:25:00",            "1999-02-01T00:18:00",            "1999-02-01T00:01:00",            "1999-02-01T00:59:00",            "1999-02-01T00:22:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMinute );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMinute", !isSorted1, isSorted2);    } // end of testListMinute     /**      * Test sorting with hour comparator.      */    public void testListHour() {        String[] dtStrs = {            "1999-02-01T10:00:00",            "1999-02-01T23:00:00",            "1999-02-01T01:00:00",            "1999-02-01T15:00:00",            "1999-02-01T05:00:00",            "1999-02-01T20:00:00",            "1999-02-01T17:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cHour );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListHour", !isSorted1, isSorted2);    } // end of testListHour     /**      * Test sorting with day of week comparator.      */    public void testListDOW() {        String[] dtStrs = {            /* 2002-04-15 = Monday */            "2002-04-21T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-20T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfWeek );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOW", !isSorted1, isSorted2);    } // end of testListDOW     /**      * Test sorting with day of month comparator.      */    public void testListDOM() {        String[] dtStrs = {            /* 2002-04-14 = Sunday */            "2002-04-20T10:00:00",            "2002-04-16T10:00:00",            "2002-04-15T10:00:00",            "2002-04-17T10:00:00",            "2002-04-19T10:00:00",            "2002-04-18T10:00:00",            "2002-04-14T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOM", !isSorted1, isSorted2);    } // end of testListDOM     /**      * Test sorting with day of year comparator.      */    public void testListDOY() {        String[] dtStrs = {            "2002-04-20T10:00:00",            "2002-01-16T10:00:00",            "2002-12-31T10:00:00",            "2002-09-14T10:00:00",            "2002-09-19T10:00:00",            "2002-02-14T10:00:00",            "2002-10-30T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDayOfYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDOY", !isSorted1, isSorted2);    } // end of testListDOY     /**      * Test sorting with week of weekyear comparator.      */    public void testListWOW() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekOfWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListWOW", !isSorted1, isSorted2);    } // end of testListWOW     /**      * Test sorting with year (given week) comparator.      */    public void testListYOYY() {        // ?? How to catch end conditions ??        String[] dtStrs = {            "2010-04-01T10:00:00",            "2002-01-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cWeekyear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYOYY", !isSorted1, isSorted2);    } // end of testListYOYY     /**      * Test sorting with month comparator.      */    public void testListMonth() {        String[] dtStrs = {            "2002-04-01T10:00:00",            "2002-01-01T10:00:00",            "2002-12-01T10:00:00",            "2002-09-01T10:00:00",            "2002-09-01T10:00:00",            "2002-02-01T10:00:00",            "2002-10-01T10:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cMonth );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListMonth", !isSorted1, isSorted2);    } // end of testListMonth     /**      * Test sorting with year comparator.      */     public void testListYear() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-02-01T00:00:00",            "2525-02-01T00:00:00",            "1776-02-01T00:00:00",            "1863-02-01T00:00:00",            "1066-02-01T00:00:00",            "2100-02-01T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cYear );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListYear", !isSorted1, isSorted2);     } // end of testListYear     /**      * Test sorting with date only comparator.      */    public void testListDate() {        String[] dtStrs = {            "1999-02-01T00:00:00",            "1998-10-03T00:00:00",            "2525-05-20T00:00:00",            "1776-12-25T00:00:00",            "1863-01-31T00:00:00",            "1066-09-22T00:00:00",            "2100-07-04T00:00:00"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cDate );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListDate", !isSorted1, isSorted2);    } // end of testListDate     /**      * Test sorting with time only comparator.      */    public void testListTime() {        String[] dtStrs = {            "1999-02-01T01:02:05",            "1999-02-01T22:22:22",            "1999-02-01T05:30:45",            "1999-02-01T09:17:59",            "1999-02-01T09:17:58",            "1999-02-01T15:30:00",            "1999-02-01T17:00:44"        };        //        List sl = loadAList( dtStrs );        boolean isSorted1 = isListSorted( sl );        Collections.sort( sl, cTime );        boolean isSorted2 = isListSorted( sl );        assertEquals("ListTime", !isSorted1, isSorted2);    } // end of testListTime    /**     * Test comparator operation with null object(s).     */    public void testNullDT() {        try        {            aDateTime = getADate( "2000-01-01T00:00:00" );            assertEquals("NULLDT Expected Fail", 0,     // should not matter                    cYear.compare( null, aDateTime ) );        }        catch(IllegalArgumentException iae)        {            return;        }        fail("null object failed");    } // end of testNullDT    /**     * Test comparator operation with an invalid object type.     */    public void testInvalidObj() {        try        {            aDateTime = getADate( "2000-01-01T00:00:00" );            assertEquals("INVLO Expected Fail", 0,  // should not matter                    cYear.compare( "FreeBird" , aDateTime ) );        }        catch(ClassCastException cce)        {            return;        }        catch(IllegalArgumentException iae)        {            return;        }        fail("Invalid object failed");    } // end of testInvalidObj    /*     * -----------------------------------------     * private convenience methods     * -----------------------------------------     */    /*     * getADate     */    private DateTime getADate(String s) {        DateTime retDT = null;        try        {            retDT = new DateTime( s, DateTimeZone.UTC );        }        catch(IllegalArgumentException pe)        {            pe.printStackTrace();        }        return retDT;    } // end of getADate    /*     * loadAList     */    private List loadAList(String[] someStrs) {        List newList = new ArrayList();        try        {            for (int i = 0; i < someStrs.length; ++i) {                newList.add( new DateTime( someStrs[i], DateTimeZone.UTC ) );            } // end of the for        }        catch(IllegalArgumentException pe)        {            pe.printStackTrace();        }        return newList;    } // end of loadAList    /*     * isListSorted     */    private boolean isListSorted( List tl ) {        // tl must be populated with DateTime objects.        DateTime lhDT = (DateTime)tl.get(0);        DateTime rhDT = null;        Long lhVal = new Long( lhDT.getMillis() );        Long rhVal = null;        for (int i = 1; i < tl.size(); ++i) {            rhDT = (DateTime)tl.get(i);            rhVal = new Long( rhDT.getMillis() );            if ( lhVal.compareTo( rhVal) > 0 ) return false;            //            lhVal = rhVal;  // swap for next iteration            lhDT = rhDT;    // swap for next iteration        } // end of the for        return true;    } // end of isListSorted} // end of class TestDateTimeComparator
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import junit.framework.TestSuite;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.ReadableInstant;import org.joda.time.chrono.gj.GJChronology;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the CTORs of the * DateTime date time class.  The DateTime class is passed * to the base class, which actually invokes the proper * constructors. * * @author Stephen Colebourne * @author Guy Allard */public class TestDateTimeCtors    extends AbstractTestDateTimeCommon {    // The class to be tested.    private static Class cls = DateTime.class;    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestDateTimeCtors.class);    }    /**     * Constructor.     * @param name     */    public TestDateTimeCtors(String name) {        super(name, cls);    }    /**     * Constructor     * @param name The class name.     * @param cls The class to be tested.     */    public TestDateTimeCtors(String name, Class cls) {        super(name, cls);        TestDateTimeCtors.cls = cls;    }    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() /* throws Exception */ {        super.setUp();    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        super.tearDown();    }        protected ReadableInstant createSmall(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(-1L * 1000, GJChronology.getInstance());        }        return new DateTime(-1L * 1000);    }        protected ReadableInstant createMid(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(2L * 1000, GJChronology.getInstance());        }        return new DateTime(2L * 1000);    }        protected ReadableInstant createLarge(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(3L * 1000, GJChronology.getInstance());        }        return new DateTime(3L * 1000);    }    protected ReadableInstant createUTC(long millis) {        return new DateTime(millis, ISOChronology.getInstance(DateTimeZone.UTC));    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.Calendar;import java.util.Date;import junit.framework.TestSuite;import org.joda.time.AbstractInstant;import org.joda.time.DateTimeZone;import org.joda.time.DateTime;import org.joda.time.Instant;import org.joda.time.ReadableInstant;/** * This class is a Junit unit test for the * Instant date time class. * * @author Stephen Colebourne * @author Guy Allard */public class TestInstant extends AbstractTestAbstractInstant {    private static Class cls = Instant.class;        /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestInstant.class);    }    /**     * TestDateTimeField constructor.     * @param name     */    public TestInstant(String name) {        super(name, Instant.class);    }        /**     * Test the CTOR with signature: ().     */    public void testCurrentTimeConstructor() throws Throwable {        long currentMillis = System.currentTimeMillis();        ReadableInstant ri = create(cls, null, null);        assertTrue(ri.getMillis() - currentMillis < 100);    }    /**     * Test the CTOR with signature: (long).     */    public void testMillisConstructor() throws Throwable {        long currentMillis = System.currentTimeMillis() + 1000;        ReadableInstant ri = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(currentMillis)});        assertEquals(currentMillis, ri.getMillis());    }    /**     * Test the CTOR with signature: (ReadableInstant).     */    public void testReadableInstantConstructor() throws Throwable {        ReadableInstant instant = create(Instant.class, null, null);        ReadableInstant ri = create(cls, new Class[] {ReadableInstant.class}, new Object[] {instant});        assertEquals(instant.getMillis(), ri.getMillis());    }    /**     * Test the CTOR with signature: (ReadableInstant), null RI.     */    public void testReadableInstantConstructorEx() throws Throwable {        try {            create(cls, new Class[] {ReadableInstant.class}, new Object[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    /**     * Test the CTOR with signature: (Date).     */    public void testDateConstructor() throws Throwable {        Date date = new Date();        ReadableInstant ri = create(cls, new Class[] {Date.class}, new Object[] {date});        assertEquals(date.getTime(), ri.getMillis());    }    /**     * Test the CTOR with signature: (Date), null date.     */    public void testDateConstructorEx() throws Throwable {        try {            create(cls, new Class[] {Date.class}, new Object[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    /**     * Test the CTOR with signature: (Calendar).     */    public void testCalendarConstructor() throws Throwable {        Calendar cal = Calendar.getInstance();        ReadableInstant ri = create(cls, new Class[] {Calendar.class}, new Object[] {cal});        assertEquals(cal.getTime().getTime(), ri.getMillis());    }    /**     * Test the CTOR with signature: (Calendar), null calendar.     */    public void testCalendarConstructorEx() throws Throwable {        try {            create(cls, new Class[] {Calendar.class}, new Object[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    /**     * Test the CTOR with signature: (String).     */    public void testStringConstructor() throws Throwable {        ReadableInstant ri = create(cls, new Class[] {String.class}, new Object[] {"1970-01-01T13:02:03.004Z"});        assertEquals(4 + 3*1000 + 2*1000*60 + 13*1000*60*60, ri.getMillis());        // TODO: Merge in proper ISO testing from TestConstructors    }    /**     * Test the CTOR with signature: (String), null string.     */    public void testStringConstructorEx() throws Throwable {        try {            create(cls, new Class[] {String.class}, new Object[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        //----------------------------------------------------------------------------    /**     * Test getChronology     */    public void testGetChronology() throws Throwable {        ReadableInstant ri1 = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(-300)});        assertNull(ri1.getChronology());    }    //----------------------------------------------------------------------------    /**     * Test toInstant     */    public void testToInstant() throws Throwable {        ReadableInstant ri = create(cls, null, null);        Instant instant = ri.toInstant();        assertSame(instant, ri);    }    /**     * Test toString     */    public void testToString() throws Throwable {        ReadableInstant ri = create(cls, new Class[] {Long.TYPE}, new Object[] {new Long(4 + 3*1000 + 2*1000*60 + 13*1000*60*60)});        assertEquals("1970-01-01T13:02:03.004Z", ri.toString());    }    /**     * @see org.joda.test.time.AbstractTestReadableInstant#createLarge(boolean)     */    protected ReadableInstant createLarge(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(400, DateTimeZone.UTC);        }        return new Instant(400);    }    /**     * @see org.joda.test.time.AbstractTestReadableInstant#createMid(boolean)     */    protected ReadableInstant createMid(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(100, DateTimeZone.UTC);        }        return new Instant(100);    }    /**     * @see org.joda.test.time.AbstractTestReadableInstant#createSmall(boolean)     */    protected ReadableInstant createSmall(boolean ofAnotherClass) {        if (ofAnotherClass) {            return new DateTime(-300, DateTimeZone.UTC);        }        return new Instant(-300);    }    protected ReadableInstant createUTC(long millis) {        return new Instant(millis);    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time ;//import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.Arrays;import java.util.Calendar;import java.util.GregorianCalendar;import java.util.List;import junit.framework.TestCase;import junit.framework.TestSuite;import org.joda.time.MutableDateTime;import org.joda.time.chrono.iso.ISOChronology;/** *  A {@link TestCase} that can define both simple and bulk test methods.<P> * *  A <I>simple test method</I> is the type of test traditionally *  supplied by by {@link TestCase}.  To define a simple test, create a public *  no-argument method whose name starts with "test".  You can specify the *  the name of simple test in the constructor of <Code>BulkTest</Code>; *  a subsequent call to {@link TestCase#run} will run that simple test.<P> * *  A <I>bulk test method</I>, on the other hand, returns a new instance *  of <Code>BulkTest</Code>, which can itself define new simple and bulk *  test methods.  By using the {@link #makeSuite} method, you can *  automatically create a hierarchal suite of tests and child bulk tests.<P> * *  For instance, consider the following two classes: * *  <Pre> *  public class TestSet extends BulkTest { * *      private Set set; * *      public TestSet(Set set) { *          this.set = set; *      } * *      public void testContains() { *          boolean r = set.contains(set.iterator().next())); *          assertTrue("Set should contain first element, r); *      } * *      public void testClear() { *          set.clear(); *          assertTrue("Set should be empty after clear", set.isEmpty()); *      } *  } * * *  public class TestHashMap extends BulkTest { * *      private Map makeFullMap() { *          HashMap result = new HashMap(); *          result.put("1", "One"); *          result.put("2", "Two"); *          return result; *      } * *      public void testClear() { *          Map map = makeFullMap(); *          map.clear(); *          assertTrue("Map empty after clear", map.isEmpty()); *      } * *      public BulkTest bulkTestKeySet() { *          return new TestSet(makeFullMap().keySet()); *      } * *      public BulkTest bulkTestEntrySet() { *          return new TestSet(makeFullMap().entrySet()); *      } *  } *  </Pre> * *  In the above examples, <Code>TestSet</Code> defines two *  simple test methods and no bulk test methods; <Code>TestHashMap</Code> *  defines one simple test method and two bulk test methods.  When *  <Code>makeSuite(TestHashMap.class).run</Code> is executed, *  <I>five</I> simple test methods will be run, in this order:<P> * *  <Ol> *  <Li>TestHashMap.testClear() *  <Li>TestHashMap.bulkTestKeySet().testContains(); *  <Li>TestHashMap.bulkTestKeySet().testClear(); *  <Li>TestHashMap.bulkTestEntrySet().testContains(); *  <Li>TestHashMap.bulkTestEntrySet().testClear(); *  </Ol> * *  In the graphical junit test runners, the tests would be displayed in *  the following tree:<P> * *  <UL> *  <LI>TestHashMap</LI> *      <UL> *      <LI>testClear *      <LI>bulkTestKeySet *          <UL> *          <LI>testContains *          <LI>testClear *          </UL> *      <LI>bulkTestEntrySet *          <UL> *          <LI>testContains *          <LI>testClear *          </UL> *      </UL> *  </UL> * *  A subclass can override a superclass's bulk test by *  returning <Code>null</Code> from the bulk test method.  If you only *  want to override specific simple tests within a bulk test, use the *  {@link #ignoredSimpleTests} method.<P> * *  Note that if you want to use the bulk test methods, you <I>must</I> *  define your <Code>suite()</Code> method to use {@link #makeSuite}. *  The ordinary {@link TestSuite} constructor doesn't know how to *  interpret bulk test methods. * *  Original implementation modified slightly for use with Joda ISO Time *  testing. * *  @author Paul Jack *  @author Guy Allard * */public class BulkTest extends TestCase implements Cloneable {    // Note:  BulkTest is Cloneable to make it easier to construct    // BulkTest instances for simple test methods that are defined in    // anonymous inner classes.  Basically we don't have to worry about    // finding wierd constructors.  (And even if we found them, techinically    // it'd be illegal for anyone but the outer class to invoke them).    // Given one BulkTest instance, we can just clone it and reset the    // method name for every simple test it defines.    /**     *  The full name of this bulk test instance.  This is the full name     *  that is compared to {@link #ignoredSimpleTests} to see if this     *  test should be ignored.  It's also displayed in the text runner     *  to ease debugging.     */    String verboseName;    /**     *  Constructs a new <Code>BulkTest</Code> instance that will run the     *  specified simple test.     *     *  @param name  the name of the simple test method to run     */    public BulkTest(String name) {        super(name);        this.verboseName = getClass().getName();    }    /**     *  Creates a clone of this <Code>BulkTest</Code>.<P>     *     *  @return  a clone of this <Code>BulkTest</Code>     */    public Object clone() {        try {            return super.clone();        } catch (CloneNotSupportedException e) {            throw new Error(); // should never happen        }    }    /**     *  Returns an array of simple test names to ignore.<P>     *     *  If a simple test that's defined by this <Code>BulkTest</Code> or     *  by one of its bulk test methods has a name that's in the returned     *  array, then that simple test will not be executed.<P>     *     *  A simple test's name is formed by taking the class name of the     *  root <Code>BulkTest</Code>, eliminating the package name, then     *  appending the names of any bulk test methods that were invoked     *  to get to the simple test, and then appending the simple test     *  method name.  The method names are delimited by periods:     *     *  <Pre>     *  TestHashMap.bulkTestEntrySet.testClear     *  </Pre>     *     *  is the name of one of the simple tests defined in the sample classes     *  described above.  If the sample <Code>TestHashMap</Code> class     *  included this method:     *     *  <Pre>     *  public String[] ignoredSimpleTests() {     *      return new String[] { "TestHashMap.bulkTestEntrySet.testClear" };     *  }     *  </Pre>     *     *  then the entry set's clear method wouldn't be tested, but the key     *  set's clear method would.     *     *  @return an array of the names of simple tests to ignore, or null if     *   no tests should be ignored     */    public String[] ignoredSimpleTests() {        return null;    }    /**     *  Returns the display name of this <Code>BulkTest</Code>.     *     *  @return the display name of this <Code>BulkTest</Code>     */    public String toString() {        return getName() + "(" + verboseName + ") ";    }    /**     *  Returns a {@link TestSuite} for testing all of the simple tests     *  <I>and</I> all the bulk tests defined by the given class.<P>     *     *  The class is examined for simple and bulk test methods; any child     *  bulk tests are also examined recursively; and the results are stored     *  in a hierarchal {@link TestSuite}.<P>     *     *  The given class must be a subclass of <Code>BulkTest</Code> and must     *  not be abstract.<P>     *     *  @param c  the class to examine for simple and bulk tests     *  @return  a {@link TestSuite} containing all the simple and bulk tests     *    defined by that class     */    public static TestSuite makeSuite(Class c) {        if (Modifier.isAbstract(c.getModifiers())) {            throw new IllegalArgumentException("Class must not be abstract.");        }        if (!BulkTest.class.isAssignableFrom(c)) {            throw new IllegalArgumentException("Class must extend BulkTest.");        }        return new BulkTestSuiteMaker(c).make();    }    //    // Methods added by the Joda project for testing of the    // org.joda.time package and it's subpackages.    //    /**     * Build an ISODateTime string from a Gregorian calendar.     * @param gc a Gregorian Calendar instance.     * @return a String suitable for ISODateTime instantiation.     */    protected String getDateTimeString(GregorianCalendar gc) {        int year = gc.get(Calendar.YEAR);        StringBuffer retVal = new StringBuffer();        if ( gc.get(Calendar.ERA) == GregorianCalendar.BC ) {            if ( year > 1 ) retVal.append("-");            year = year - 1;        }        //        retVal.append( padNumberToLen( Math.abs(year), 4 ) );        retVal.append("-");        retVal.append( padNumberToLen(gc.get(Calendar.MONTH)+1, 2) );        retVal.append("-");        retVal.append( padNumberToLen(gc.get(Calendar.DATE), 2) );        retVal.append("T");        retVal.append(  padNumberToLen(gc.get(Calendar.HOUR), 2) );        retVal.append(":");        retVal.append( padNumberToLen(gc.get(Calendar.MINUTE), 2) );        retVal.append(":");        retVal.append( padNumberToLen(gc.get(Calendar.SECOND), 2) );        retVal.append(".");        retVal.append( padNumberToLen(gc.get(Calendar.MILLISECOND), 3) );        retVal.append("Z");        return retVal.toString();    }    /**     * Create a string from an integer, pad it on the left with     * '0's to the length specified.     * @param num The number to use.     * @param len The length to pad to.     * @return The created string.     */    protected String padNumberToLen(int num, int len) {        StringBuffer retVal = new StringBuffer( len );        retVal.insert(0, "" + num);        if ( retVal.length() >= len ) return retVal.toString();        retVal.insert(0, copiesOf("0", len - retVal.length()));        if (num < 0) {            retVal.insert(0,"-");        }        return retVal.toString();    }    /**     * Generate the specified number of copies of a String and     * return it.     * @param s The String to copy.     * @param c The number of copies.     * @return The generated String.     */    protected String copiesOf(String s, int c) {        if ( c == 0 ) return s;        StringBuffer retBuff = new StringBuffer( s.length() * c );        for (int i = 1; i <= c; ++i) {            retBuff.insert( retBuff.length(), s );        }        return retBuff.toString();    }    /**     * Convert a String to an Integer, and return the int     * value.     * @param s The string to convert.     * @return The int to return.     * @throws A NullPointerException if the string fails conversion.     */    protected int getPartValue(String s) {        Integer iVal = null;        try        {            iVal = new Integer( s );        }        catch(NumberFormatException nfe)        {        }        return iVal.intValue();    }    /**     *     * @param s An ISO format Date/Time string.     * @return The left hand side of the string.     */    protected String lhsDT(String s) {        return s.substring(0,s.indexOf('T'));    }    /**     *     * @param s An ISO format Date/Time string.     * @return The right hand side of the string.     */    protected String rhsDT(String s) {        return s.substring(s.indexOf('T')+1);    }    /**     *     * @param s An ISO format Date/Time string.     * @return An array list containing all the subelements     * of the input string.     */    protected ArrayList getDTA(String s) {        ArrayList al = new ArrayList();        String dateSide = lhsDT( s );        String timeSide = rhsDT( s );        // Date Side        if ( dateSide.substring(0,1).equals("-") )        {            al.add("-");            dateSide = dateSide.substring(1);        }        else        {            al.add("");        }        int pos = dateSide.indexOf('-');        al.add( dateSide.substring(0, pos) );        al.add("-");        pos += 1;        dateSide = dateSide.substring( pos );        //        pos = dateSide.indexOf('-');        al.add( dateSide.substring(0, pos) );        al.add("-");        al.add( dateSide.substring( ++pos ) );        al.add("T");        //        // Time Side        //        pos = timeSide.indexOf(':');        al.add( timeSide.substring(0, pos) );        al.add(":");        pos += 1;        timeSide = timeSide.substring( pos );        //        pos = timeSide.indexOf(':');        al.add( timeSide.substring(0, pos) );        al.add(":");        pos += 1;        timeSide = timeSide.substring( pos );        //        pos = timeSide.indexOf('.');        if ( pos == -1 ) {            al.add( timeSide );            return al;        }        al.add( timeSide.substring(0,pos) );        al.add(".");        pos += 1;        timeSide = timeSide.substring(pos);        pos = timeSide.indexOf('Z');        al.add( timeSide.substring(0,pos) );        al.add("Z");        //        return al;    }    /**     * An array of the short names of the days of the week.     */    protected final String[] dowShort = {        "N/A","Mon","Tue","Wed","Thu","Fri","Sat","Sun"    };    /**     * An array of the long names of the days of the week.     */    protected final String[] dowLong = {        "N/A","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"    };    /**     * An array of the short names of the month.     */    protected final String[] moyShort = {        "N/A","Jan","Feb","Mar","Apr","May","Jun",            "Jul","Aug","Sep","Oct","Nov","Dec"    };    /**     * An array of the long names of the month.     */    protected final String[] moyLong = {        "N/A","January","February","March","April","May","June",            "July","August","September","October","November","December"    };    /**     *     * @param s An ISO format Date/Time string.     * @return A Joda MutableDateTime object, or null if     * parsing fails.     */    MutableDateTime getMDTFromString(String s) {        MutableDateTime retVal = null;        try        {            retVal = new MutableDateTime( s,                ISOChronology.getInstanceUTC() );        }        catch(IllegalArgumentException pe)        {            System.err.println("IllegalArgumentException Detected");            pe.printStackTrace();        }        return retVal;    }} // End of BulkTest class// It was easier to use a separate class to do all the reflection stuff// for making the TestSuite instances.  Having permanent state around makes// it easier to handle the recursion.class BulkTestSuiteMaker {    /** The class that defines simple and bulk tests methods. */    private Class startingClass;    /** List of ignored simple test names. */    private List ignored;    /** The TestSuite we're currently populating.  Can change over time. */    private TestSuite result;    /**     *  The prefix for simple test methods.  Used to check if a test is in     *  the ignored list.     */    private String prefix;    /**     *  Constructor.     *     *  @param startingClass  the starting class     */    public BulkTestSuiteMaker(Class startingClass) {        this.startingClass = startingClass;    }    /**     *  Makes a hierarchal TestSuite based on the starting class.     *     *  @return  the hierarchal TestSuite for startingClass     */    public TestSuite make() {         this.result = new TestSuite();         this.prefix = getBaseName(startingClass);         result.setName(prefix);         BulkTest bulk = makeFirstTestCase(startingClass);         ignored = new ArrayList();         String[] s = bulk.ignoredSimpleTests();         if (s != null) {             ignored.addAll(Arrays.asList(s));         }         make(bulk);         return result;    }    /**     *  Appends all the simple tests and bulk tests defined by the given     *  instance's class to the current TestSuite.     *     *  @param bulk  An instance of the class that defines simple and bulk     *    tests for us to append     */    void make(BulkTest bulk) {        Class c = bulk.getClass();        Method[] all = c.getMethods();        for (int i = 0; i < all.length; i++) {            if (isTest(all[i])) addTest(bulk, all[i]);            if (isBulk(all[i])) addBulk(bulk, all[i]);        }    }    /**     *  Adds the simple test defined by the given method to the TestSuite.     *     *  @param bulk  The instance of the class that defined the method     *   (I know it's wierd.  But the point is, we can clone the instance     *   and not have to worry about constructors.)     *  @param m  The simple test method     */    void addTest(BulkTest bulk, Method m) {        BulkTest bulk2 = (BulkTest)bulk.clone();        bulk2.setName(m.getName());        bulk2.verboseName = prefix + "." + m.getName();        if (ignored.contains(bulk2.verboseName)) return;        result.addTest(bulk2);    }    /**     *  Adds a whole new suite of tests that are defined by the result of     *  the given bulk test method.  In other words, the given bulk test     *  method is invoked, and the resulting BulkTest instance is examined     *  for yet more simple and bulk tests.     *     *  @param bulk  The instance of the class that defined the method     *  @param m  The bulk test method     */    void addBulk(BulkTest bulk, Method m) {        BulkTest bulk2;        try {            bulk2 = (BulkTest)m.invoke(bulk, null);            if (bulk2 == null) return;        } catch (InvocationTargetException e) {            throw new Error(); // FIXME;        } catch (IllegalAccessException e) {            throw new Error(); // FIXME;        }        // Save current state on the stack.        String oldPrefix = prefix;        TestSuite oldResult = result;        prefix = prefix + "." + m.getName();        result = new TestSuite();        result.setName(m.getName());        make(bulk2);        oldResult.addTest(result);        // Restore the old state        prefix = oldPrefix;        result = oldResult;    }    /**     *  Returns the base name of the given class.     *     *  @param c  the class     *  @return the name of that class, minus any package names     */    private static String getBaseName(Class c) {        String name = c.getName();        int p = name.lastIndexOf('.');        if (p > 0) {            name = name.substring(p + 1);        }        return name;    }    // These three methods are used to create a valid BulkTest instance    // from a class.    private static Constructor getTestCaseConstructor(Class c) {        try {            return c.getConstructor(new Class[] { String.class });        } catch (NoSuchMethodException e) {            throw new IllegalArgumentException(c + " must provide " +             "a (String) constructor");        }    }    private static BulkTest makeTestCase(Class c, Method m) {        Constructor con = getTestCaseConstructor(c);        try {            return (BulkTest)con.newInstance(new String[] { m.getName() });        } catch (InvocationTargetException e) {            e.printStackTrace();            throw new RuntimeException(); // FIXME;        } catch (IllegalAccessException e) {            throw new Error(); // should never occur        } catch (InstantiationException e) {            throw new RuntimeException(); // FIXME;        }    }    private static BulkTest makeFirstTestCase(Class c) {        Method[] all = c.getMethods();        for (int i = 0; i < all.length; i++) {            if (isTest(all[i])) return makeTestCase(c, all[i]);        }        throw new IllegalArgumentException(c.getName() + " must provide "          + " at least one test method.");    }    /**     *  Returns true if the given method is a simple test method.     */    private static boolean isTest(Method m) {        if (!m.getName().startsWith("test")) return false;        if (m.getReturnType() != Void.TYPE) return false;        if (m.getParameterTypes().length != 0) return false;        int mods = m.getModifiers();        if (Modifier.isStatic(mods)) return false;        if (Modifier.isAbstract(mods)) return false;        return true;    }    /**     *  Returns true if the given method is a bulk test method.     */    private static boolean isBulk(Method m) {        if (!m.getName().startsWith("bulkTest")) return false;        if (m.getReturnType() != BulkTest.class) return false;        if (m.getParameterTypes().length != 0) return false;        int mods = m.getModifiers();        if (Modifier.isStatic(mods)) return false;        if (Modifier.isAbstract(mods)) return false;        return true;    }} // end of BulkTestSuiteMaker class
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;//import java.util.*;//import java.text.* ;import junit.framework.TestSuite;//import org.joda.time.*;//import org.joda.time.gj.*;//import org.joda.time.iso.*;/** * This class is a Junit unit test for the * GJTimePeriod date time class. * * @author Stephen Colebourne * @author Guy Allard */public class TestTimePeriod extends BulkTest {/** * This is the main class for this test suite. * @param args command line arguments. */public static void main(String[] args) {junit.textui.TestRunner.run(suite());}/** * TestSuite is a junit required method. */public static TestSuite suite() {return BulkTest.makeSuite(TestTimePeriod.class);}/** * TestDateTimeField constructor. * @param name */public TestTimePeriod(String name) {super(name);}// Class Name: org.joda.time.TimePeriod/** * Junit <code>setUp()</code> method. */protected void setUp() /* throws Exception */ {// super.setUp();}/** * Junit <code>tearDown()</code> method. */protected void tearDown() /* throws Exception */ {// super.tearDown();}/** * Test the <code>clone()</code> method. * @see org.joda.time.TimePeriod#clone() */public void testClone() {fail("TBD");}/** * Test the <code>format(java.text.Format)</code> method. * @see org.joda.time.TimePeriod#format(java.text.Format) */public void testFormat() {fail("TBD");}/** * Test the <code>getMillis()</code> method. * @see org.joda.time.TimePeriod#getMillis() */public void testGetMillis() {fail("TBD");}/** * Test the <code>getStartInstant()</code> method. * @see org.joda.time.TimePeriod#getStartInstant() */public void testGetStartInstant() {fail("TBD");}/** * Test the <code>getEndInstant()</code> method. * @see org.joda.time.TimePeriod#getEndInstant() */public void testGetEndInstant() {fail("TBD");}/** * Test the <code>toTimePeriod()</code> method. * @see org.joda.time.TimePeriod#toTimePeriod() */public void testToTimePeriod() {fail("TBD");}/** * Test the <code>getTotalSeconds()</code> method. * @see org.joda.time.TimePeriod#getTotalSeconds() */public void testGetTotalSeconds() {fail("TBD");}/** * Test the <code>getTotalMinutes()</code> method. * @see org.joda.time.TimePeriod#getTotalMinutes() */public void testGetTotalMinutes() {fail("TBD");}/** * Test the <code>getTotalHours()</code> method. * @see org.joda.time.TimePeriod#getTotalHours() */public void testGetTotalHours() {fail("TBD");}/** * Test the <code>getTotalDays()</code> method. * @see org.joda.time.TimePeriod#getTotalDays() */public void testGetTotalDays() {fail("TBD");}/** * Test the <code>getTotalMonths()</code> method. * @see org.joda.time.TimePeriod#getTotalMonths() */public void testGetTotalMonths() {fail("TBD");}/** * Test the <code>getTotalWeeks()</code> method. * @see org.joda.time.TimePeriod#getTotalWeeks() */public void testGetTotalWeeks() {fail("TBD");}/** * Test the <code>getSeconds()</code> method. * @see org.joda.time.TimePeriod#getSeconds() */public void testGetSeconds() {fail("TBD");}/** * Test the <code>getMinutes()</code> method. * @see org.joda.time.TimePeriod#getMinutes() */public void testGetMinutes() {fail("TBD");}/** * Test the <code>getHours()</code> method. * @see org.joda.time.TimePeriod#getHours() */public void testGetHours() {fail("TBD");}/** * Test the <code>getDays()</code> method. * @see org.joda.time.TimePeriod#getDays() */public void testGetDays() {fail("TBD");}/** * Test the <code>getMonths()</code> method. * @see org.joda.time.TimePeriod#getMonths() */public void testGetMonths() {fail("TBD");}/** * Test the <code>getYears()</code> method. * @see org.joda.time.TimePeriod#getYears() */public void testGetYears() {fail("TBD");}/** * Test the <code>equals(java.lang.Object)</code> method. * @see org.joda.time.TimePeriod#equals(java.lang.Object) */public void testEquals() {fail("TBD");}/** * Test the <code>hashCode()</code> method. * @see org.joda.time.TimePeriod#hashCode() */public void testHashCode() {fail("TBD");}/** * Test the <code>compareTo(java.lang.Object)</code> method. * @see org.joda.time.TimePeriod#compareTo(java.lang.Object) */public void testCompareTo() {fail("TBD");}/** * Test the <code>isLongerThan(java.lang.Object)</code> method. * @see org.joda.time.TimePeriod#isLongerThan(java.lang.Object) */public void testIsLongerThan() {fail("TBD");}/** * Test the <code>isShorterThan(java.lang.Object)</code> method. * @see org.joda.time.TimePeriod#isShorterThan(java.lang.Object) */public void testIsShorterThan() {fail("TBD");}/** * Test the <code>toString()</code> method. * @see org.joda.time.TimePeriod#toString() */public void testToString() {fail("TBD");}}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;//import java.util.*;//import java.text.* ;import junit.framework.TestSuite;//import org.joda.time.*;//import org.joda.time.gj.*;//import org.joda.time.iso.*;/** * This class is a Junit unit test for the * GJDateTimeFormat date time class. * * @author Stephen Colebourne * @author Guy Allard */public class TestDateTimeFormat extends BulkTest {    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestDateTimeFormat.class);    }    /**     * TestDateTimeField constructor.     * @param name     */    public TestDateTimeFormat(String name) {        super(name);    }    // Class Name: org.joda.time.format.DateTimeFormat    /**     * Junit <code>setUp()</code> method.     */    public void setUp() /* throws Exception */ {        // super.setUp();    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();    }    /**     * Test the <code>getInstanceUTC()</code> method.     * @see org.joda.time.format.DateTimeFormat#getInstanceUTC()     */    protected void testGetInstanceUTC() {        fail("TBD");    }    /**     * Test the <code>getInstance()</code> method.     * @see org.joda.time.format.DateTimeFormat#getInstance()     */    protected void testGetInstance() {        fail("TBD");    }    /**     * Test the <code>getInstance(org.joda.time.DateTimeZone)</code> method.     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone)     */    public void testGetInstanceTZ() {        fail("TBD");    }    /**     * Test the <code>getInstance(org.joda.time.DateTimeZone, java.util.Locale)</code> method.     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone, java.util.Locale)     */    public void testGetInstanceTZL() {        fail("TBD");    }    /**     * Test the <code>getInstance(org.joda.time.Chronology)</code> method.     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology)     */    public void testGetInstanceC() {        fail("TBD");    }    /**     * Test the <code>getInstance(org.joda.time.Chronology, java.util.Locale)</code> method.     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology, java.util.Locale)     */    public void testGetInstanceCL() {        fail("TBD");    }    /**     * Test the <code>forPattern(String)</code> method.     * @see org.joda.time.format.DateTimeFormat#forPattern(String)     */    public void testForPattern() {        fail("TBD");    }    /**     * Test the <code>forStyle(String)</code> method.     * @see org.joda.time.format.DateTimeFormat#forStyle(String)     */    public void testForStyle() {        fail("TBD");    }    /**     * Test the <code>getPatternForStyle()</code> method.     * @see org.joda.time.format.DateTimeFormat#getPatternForStyle(String)     */    public void testGetPatternForStyle() {        fail("TBD");    }}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;//import java.util.*;//import java.text.* ;import junit.framework.TestSuite;//import org.joda.time.*;//import org.joda.time.gj.*;//import org.joda.time.iso.*;/** * This class is a Junit unit test for the * GJDateTimeFormatterBuilder date time class. * * @author Stephen Colebourne * @author Guy Allard */public class TestDateTimeFormatterBuilder extends BulkTest {/** * This is the main class for this test suite. * @param args command line arguments. */public static void main(String[] args) {junit.textui.TestRunner.run(suite());}/** * TestSuite is a junit required method. */public static TestSuite suite() {return BulkTest.makeSuite(TestDateTimeFormatterBuilder.class);}/** * TestDateTimeField constructor. * @param name */public TestDateTimeFormatterBuilder(String name) {super(name);}// Class Name: org.joda.time.format.DateTimeFormatterBuilder/** * Junit <code>setUp()</code> method. */protected void setUp() /* throws Exception */ {// super.setUp();}/** * Junit <code>tearDown()</code> method. */protected void tearDown() /* throws Exception */ {// super.tearDown();}/** * Test the <code>toPrinter()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#toPrinter() */public void testToPrinter() {fail("TBD");}/** * Test the <code>toParser()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#toParser() */public void testToParser() {fail("TBD");}/** * Test the <code>toFormatter()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#toFormatter() */public void testToFormatter() {fail("TBD");}/** * Test the <code>canBuildPrinter()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#canBuildPrinter() */public void testCanBuildPrinter() {fail("TBD");}/** * Test the <code>canBuildParser()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#canBuildParser() */public void testCanBuildParser() {fail("TBD");}/** * Test the <code>canBuilderFormatter()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#canBuilderFormatter() */public void testCanBuilderFormatter() {fail("TBD");}/** * Test the <code>clear()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#clear() */public void testClear() {fail("TBD");}/** * Test the <code>append(org.joda.time.format.DateTimeFormatter)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#append(org.joda.time.format.DateTimeFormatter) */public void testAppendDTF() {fail("TBD");}/** * Test the <code>append(org.joda.time.format.DateTimePrinterElement, org.joda.time.format.DateTimeParserElement)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#append(org.joda.time.format.DateTimePrinterElement, org.joda.time.format.DateTimeParserElement) */public void testAppendDTPE() {fail("TBD");}/** * Test the <code>appendLiteral(char)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendLiteral(char) */public void testAppendLiteralC() {fail("TBD");}/** * Test the <code>appendLiteral(java.lang.String)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendLiteral(java.lang.String) */public void testAppendLiteralS() {fail("TBD");}/** * Test the <code>appendNumeric(org.joda.time.DateTimeField, int, int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendNumeric(org.joda.time.DateTimeField, int, int, int) */public void testAppendNumeric() {fail("TBD");}/** * Test the <code>appendSignedNumeric(org.joda.time.DateTimeField, int, int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendSignedNumeric(org.joda.time.DateTimeField, int, int, int) */public void testAppendSignedNumeric() {fail("TBD");}/** * Test the <code>appendFraction(int, int, int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendFraction(int, int, int, int) */public void testAppendFraction() {fail("TBD");}/** * Test the <code>appendFractionOfSecond(int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfSecond(int, int) */public void testAppendFractionOfSecond() {fail("TBD");}/** * Test the <code>appendFractionOfMinute(int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfMinute(int, int) */public void testAppendFractionOfMinute() {fail("TBD");}/** * Test the <code>appendFractionOfHour(int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfHour(int, int) */public void testAppendFractionOfHour() {fail("TBD");}/** * Test the <code>appendFractionOfDay(int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfDay(int, int) */public void testAppendFractionOfDay() {fail("TBD");}/** * Test the <code>appendMillisOfSecond(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendMillisOfSecond(int) */public void testAppendMillisOfSecond() {fail("TBD");}/** * Test the <code>appendMillisOfDay(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendMillisOfDay(int) */public void testAppendMillisOfDay() {fail("TBD");}/** * Test the <code>appendSecondOfMinute(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendSecondOfMinute(int) */public void testAppendSecondOfMinute() {fail("TBD");}/** * Test the <code>appendSecondOfDay(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendSecondOfDay(int) */public void testAppendSecondOfDay() {fail("TBD");}/** * Test the <code>appendMinuteOfHour(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendMinuteOfHour(int) */public void testAppendMinuteOfHour() {fail("TBD");}/** * Test the <code>appendMinuteOfDay(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendMinuteOfDay(int) */public void testAppendMinuteOfDay() {fail("TBD");}/** * Test the <code>appendHourOfDay(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendHourOfDay(int) */public void testAppendHourOfDay() {fail("TBD");}/** * Test the <code>appendClockhourOfDay(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendClockhourOfDay(int) */public void testAppendClockhourOfDay() {fail("TBD");}/** * Test the <code>appendHourOfHalfday(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendHourOfHalfday(int) */public void testAppendHourOfHalfday() {fail("TBD");}/** * Test the <code>appendClockhourOfHalfday(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendClockhourOfHalfday(int) */public void testAppendClockhourOfHalfday() {fail("TBD");}/** * Test the <code>appendDayOfWeek(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeek(int) */public void testAppendDayOfWeek() {fail("TBD");}/** * Test the <code>appendDayOfMonth(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfMonth(int) */public void testAppendDayOfMonth() {fail("TBD");}/** * Test the <code>appendDayOfYear(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfYear(int) */public void testAppendDayOfYear() {fail("TBD");}/** * Test the <code>appendWeekOfYearWeek(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendWeekOfYearWeek(int) */public void testAppendWeekOfYearWeek() {fail("TBD");}/** * Test the <code>appendWeekOfYearYear(int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendWeekOfYearYear(int, int) */public void testAppendWeekOfYearYear() {fail("TBD");}/** * Test the <code>appendMonthOfYear(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYear(int) */public void testAppendMonthOfYear() {fail("TBD");}/** * Test the <code>appendYear(int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendYear(int, int) */public void testAppendYear() {fail("TBD");}/** * Test the <code>appendYearOfEra(int, int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendYearOfEra(int, int) */public void testAppendYearOfEra() {fail("TBD");}/** * Test the <code>appendYearOfCentury()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendYearOfCentury() */public void testAppendYearOfCentury() {fail("TBD");}/** * Test the <code>appendCentury(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendCentury(int) */public void testAppendCentury() {fail("TBD");}/** * Test the <code>appendCenturyOfEra(int)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendCenturyOfEra(int) */public void testAppendCenturyOfEra() {fail("TBD");}/** * Test the <code>appendAmPmSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendAmPmSymbol() */public void testAppendAmPmSymbol() {fail("TBD");}/** * Test the <code>appendDayOfWeekSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeekSymbol() */public void testAppendDayOfWeekSymbol() {fail("TBD");}/** * Test the <code>appendDayOfWeekShortSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeekShortSymbol() */public void testAppendDayOfWeekShortSymbol() {fail("TBD");}/** * Test the <code>appendMonthOfYearSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYearSymbol() */public void testAppendMonthOfYearSymbol() {fail("TBD");}/** * Test the <code>appendMonthOfYearShortSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYearShortSymbol() */public void testAppendMonthOfYearShortSymbol() {fail("TBD");}/** * Test the <code>appendEraSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendEraSymbol() */public void testAppendEraSymbol() {fail("TBD");}/** * Test the <code>appendTimeZoneSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneSymbol() */public void testAppendTimeZoneSymbol() {fail("TBD");}/** * Test the <code>appendTimeZoneShortSymbol()</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneShortSymbol() */public void testAppendTimeZoneShortSymbol() {fail("TBD");}/** * Test the <code>appendTimeZoneOffset(java.lang.String, java.lang.String, boolean)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneOffset(java.lang.String, java.lang.String, boolean) */public void testAppendTimeZoneOffset() {fail("TBD");}/** * Test the <code>appendPattern(java.lang.String)</code> method. * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String) */public void testAppendPattern() {fail("TBD");}}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.*;import java.text.* ;import java.io.*;import junit.framework.TestSuite;import org.joda.time.MutableDateTime;import org.joda.time.chrono.iso.ISOChronology;/** * This class is a Junit unit test for the * org.joda.time.MutableDateTime class. * * @author Stephen Colebourne * @author Guy Allard */public class TestMutableDateTime    extends BulkTest {    private static Class cls = MutableDateTime.class;    /**     * main     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestMutableDateTime.class);    }    /**     * TestMutableDateTime constructor.  A constructor with this signature     * is required for Junit testing.     * @param name The human readable name of the class.     */    public TestMutableDateTime(String name) {        super(name);    }    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() /* throws Exception */ {        // TimeZone.setDefault( new SimpleTimeZone(0, "UTC") );    }        /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() /* throws Exception */ {        // super.tearDown();    }    //    // No CTOR test methods are provided here!    // All MutableDateTime CTORs map directly to AbstractDateTime    // CTORS, and all each MDT CTOR does is call super.    //    // New CTOR tests are required only for:    // 1) CTORs which do *NOT* call super(...) at all.    // 1) CTORs which do *NOT* call super(...) with a matching signature.    // 2) CTORs with differing method signatures (new at this level).    //    // Add Other BulkTests    //    public BulkTest bulkTestGet() {        return new TestMDTGet("Mutable Date Time get Method Tests");    }    public BulkTest bulkTestSet() {        return new TestMDTSet("Mutable Date Time set Method Tests");    }} // end of class TestMutableDateTime
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import org.joda.time.AbstractDateTime;import org.joda.time.AbstractInstant;import org.joda.time.DateTime;import org.joda.time.DateTimeZone;import org.joda.time.ReadableDateTime;/** * This class is a Junit unit test base class for * Instant implementations. * * @author Stephen Colebourne */public class ClassLoadTest {    // run using JVM -verbose:class    public static void main(String[] args) {        System.out.println("-----------------------------------------------");        System.out.println("-----------AbstractInstant---------------------");        Class cls = AbstractInstant.class;        System.out.println("-----------ReadableDateTime--------------------");        cls = ReadableDateTime.class;        System.out.println("-----------AbstractDateTime--------------------");        cls = AbstractDateTime.class;        System.out.println("-----------DateTime----------------------------");        cls = DateTime.class;        System.out.println("-----------DateTimeZone------------------------");        cls = DateTimeZone.class;        System.out.println("-----------new DateTime()----------------------");        DateTime dt = new DateTime();        System.out.println("-----------new DateTime(ReadableInstant)-------");        dt = new DateTime(dt);        System.out.println("-----------new DateTime(Long)------------------");        dt = new DateTime(new Long(0));        System.out.println("-----------------------------------------------");    }    }
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;//import java.util.*;//import java.text.* ;import junit.framework.TestSuite;//import org.joda.time.*;//import org.joda.time.gj.*;//import org.joda.time.iso.*;/** * This class is a Junit unit test for the * GJTimePeriodFormat date time class. * * @author Stephen Colebourne * @author Guy Allard */public class TestTimePeriodFormat extends BulkTest {/** * This is the main class for this test suite. * @param args command line arguments. */public static void main(String[] args) {junit.textui.TestRunner.run(suite());}/** * TestSuite is a junit required method. */public static TestSuite suite() {return BulkTest.makeSuite(TestTimePeriodFormat.class);}/** * TestDateTimeField constructor. * @param name */public TestTimePeriodFormat(String name) {super(name);}// Class Name: org.joda.time.TimePeriodFormat/** * Junit <code>setUp()</code> method. */protected void setUp() /* throws Exception */ {// super.setUp();}/** * Junit <code>tearDown()</code> method. */protected void tearDown() /* throws Exception */ {// super.tearDown();}/** * Test the <code>format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)</code> method. * @see org.joda.time.TimePeriodFormat#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition) */public void testFormat() {fail("TBD");}/** * Test the <code>parseObject(java.lang.String, java.text.ParsePosition)</code> method. * @see org.joda.time.TimePeriodFormat#parseObject(java.lang.String, java.text.ParsePosition) */public void testParseObject() {fail("TBD");}}
/* * Joda Software License, Version 1.0 * * * Copyright (c) 2001-03 Stephen Colebourne. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Joda project (http://www.joda.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The name "Joda" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact licence@joda.org. * * 5. Products derived from this software may not be called "Joda", *    nor may "Joda" appear in their name, without prior written *    permission of the Joda project. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Joda project and was originally * created by Stephen Colebourne <scolebourne@joda.org>. For more * information on the Joda project, please see <http://www.joda.org/>. */package org.joda.test.time;import java.util.GregorianCalendar;import org.joda.time.DateTimeConstants;import org.joda.time.DateTimeZone;import org.joda.time.chrono.buddhist.BuddhistChronology;import junit.framework.TestSuite;/** * This class is a Junit unit test for the * BuddhistChronology date time class. * * @author Stephen Colebourne */public class TestBuddhistChronology extends BulkTest {    // TODO: These are not TimeZone safe    private static final long SMALL_MILLIS = new GregorianCalendar(-20000, 0, 1).getTime().getTime();    private static final long LARGE_MILLIS = new GregorianCalendar(20000, 0, 1).getTime().getTime();    private static final long MILLIS_1971 = new GregorianCalendar(1971, 0, 1).getTime().getTime();    private static final long MILLIS_1970 = new GregorianCalendar(1970, 0, 1).getTime().getTime();    private static final long MILLIS_1969 = new GregorianCalendar(1969, 0, 1).getTime().getTime();        private BuddhistChronology iChrono = null;    /**     * This is the main class for this test suite.     * @param args command line arguments.     */    public static void main(String[] args) {        junit.textui.TestRunner.run(suite());    }    /**     * TestSuite is a junit required method.     */    public static TestSuite suite() {        return BulkTest.makeSuite(TestBuddhistChronology.class);    }    /**     * TestDateTimeField constructor.     * @param name     */    public TestBuddhistChronology(String name) {        super(name);    }    /**     * Junit <code>setUp()</code> method.     */    protected void setUp() throws Exception {        super.setUp();        iChrono = BuddhistChronology.getInstanceUTC();    }    /**     * Junit <code>tearDown()</code> method.     */    protected void tearDown() throws Exception {        super.tearDown();    }    public void testEraConstant() throws Exception {        assertEquals(DateTimeConstants.CE, BuddhistChronology.BE);    }    public void testGetInstanceUTC() throws Exception {        assertNotNull(BuddhistChronology.getInstanceUTC());        assertTrue(BuddhistChronology.getInstanceUTC() instanceof BuddhistChronology);        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC());    }    public void testGetInstanceNull() throws Exception {        DateTimeZone zone = DateTimeZone.getDefault();        assertNotNull(BuddhistChronology.getInstance());        assertTrue(BuddhistChronology.getInstance() instanceof BuddhistChronology);        assertSame(zone, BuddhistChronology.getInstance().getDateTimeZone());    }    public void testGetInstanceZone() throws Exception {        DateTimeZone zone = DateTimeZone.getInstance("+01:00");        assertNotNull(BuddhistChronology.getInstance(zone));        assertTrue(BuddhistChronology.getInstance(zone) instanceof BuddhistChronology);        assertSame(zone, BuddhistChronology.getInstance(zone).getDateTimeZone());    }    public void testGetInstanceZoneUTC() throws Exception {        assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(DateTimeZone.UTC));    }        public void testMillisOfSecond() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMillisOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testSecondOfMinute() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testSecondOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMinuteOfHour() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMinuteOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testHourOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testClockhourOfDay() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testHourOfHalfday() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testClockhourOfHalfday() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testAmPm() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testDayOfWeek() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testDayOfMonth() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testDayOfYear() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testWeekOfYearWeek() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testMonthOfYear() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }    public void testLeapYear() {        // TODO: Its the same as GJChronology, so checking it isn't that important    }        public void testWeekOfYearYear() {        fail("TBD");    }    public void testYear() {        assertEquals("year", iChrono.year().getName());        assertSame(iChrono.year(), iChrono.year());                assertEquals(1970 + 543, iChrono.year().get(MILLIS_1970));        assertEquals(20000 + 543, iChrono.year().get(LARGE_MILLIS));                assertEquals(MILLIS_1970, iChrono.year().set(LARGE_MILLIS, 1970 + 543));                assertEquals(MILLIS_1971, iChrono.year().add(MILLIS_1970, 1));        assertEquals(MILLIS_1969, iChrono.year().add(MILLIS_1970, -1));                assertEquals(MILLIS_1971, iChrono.year().addWrapped(MILLIS_1970, 1));        assertEquals(MILLIS_1969, iChrono.year().addWrapped(MILLIS_1970, -1));                assertEquals("2513", iChrono.year().getAsShortText(MILLIS_1970));        assertEquals(9, iChrono.year().getMaximumShortTextLength(null));        assertEquals("2513", iChrono.year().getAsText(MILLIS_1970));        assertEquals(9, iChrono.year().getMaximumTextLength(null));                assertEquals(1, iChrono.year().getMinimumValue());        assertEquals(250000000 + 543, iChrono.year().getMaximumValue());                assertEquals(MILLIS_1970, iChrono.year().set(MILLIS_1970, "2513"));        assertEquals(MILLIS_1971, iChrono.year().set(MILLIS_1970, "2514"));        assertEquals(LARGE_MILLIS, iChrono.year().set(MILLIS_1970, "20543"));        try {            iChrono.year().set(MILLIS_1970, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            iChrono.year().set(MILLIS_1970, "AD");            fail();        } catch (IllegalArgumentException ex) {}    }    public void testYearOfCentury() {        try {            iChrono.yearOfCentury();            fail();        } catch (UnsupportedOperationException ex) {}    }    public void testCenturyOfEra() {        try {            iChrono.centuryOfEra();            fail();        } catch (UnsupportedOperationException ex) {}    }    public void testEra() {        assertEquals("era", iChrono.era().getName());        assertSame(iChrono.era(), iChrono.era());                assertEquals(BuddhistChronology.BE, iChrono.era().get(SMALL_MILLIS));        assertEquals(BuddhistChronology.BE, iChrono.era().get(MILLIS_1970));        assertEquals(BuddhistChronology.BE, iChrono.era().get(LARGE_MILLIS));                assertEquals(SMALL_MILLIS, iChrono.era().set(SMALL_MILLIS, BuddhistChronology.BE));        try {            iChrono.era().set(SMALL_MILLIS, DateTimeConstants.BCE);            fail();        } catch (IllegalArgumentException ex) {}                try {            iChrono.era().add(SMALL_MILLIS, 1);            fail();        } catch (UnsupportedOperationException ex) {}                try {            iChrono.era().addWrapped(SMALL_MILLIS, 1);            fail();        } catch (UnsupportedOperationException ex) {}                assertEquals("BE", iChrono.era().getAsShortText(MILLIS_1970));        assertEquals(2, iChrono.era().getMaximumShortTextLength(null));        assertEquals("BE", iChrono.era().getAsText(MILLIS_1970));        assertEquals(2, iChrono.era().getMaximumTextLength(null));                assertEquals(BuddhistChronology.BE, iChrono.era().getMinimumValue());        assertEquals(BuddhistChronology.BE, iChrono.era().getMaximumValue());                assertEquals(MILLIS_1970, iChrono.era().set(MILLIS_1970, "BE"));        try {            iChrono.era().set(SMALL_MILLIS, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            iChrono.era().set(SMALL_MILLIS, "AD");            fail();        } catch (IllegalArgumentException ex) {}    }}